
==================== Output Cmm ====================
2018-03-16 15:54:42.713422965 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:54:42.714478386 UTC

[section ""data" . GHC.Base.$p1Monad_closure" {
     GHC.Base.$p1Monad_closure:
         const GHC.Base.$p1Monad_info;
 },
 GHC.Base.$p1Monad_entry() //  [R2]
         { info_tbl: [(c8rG,
                       label: GHC.Base.$p1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8rH; else goto c8rI;
       c8rH: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8rI: // global
           I64[Sp - 8] = block_c8rD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8rM; else goto c8rE;
       u8rM: // global
           call _c8rD(R1) args: 0, res: 0, upd: 0;
       c8rE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8rD() //  [R1]
         { info_tbl: [(c8rD,
                       label: block_c8rD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rD: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.716459445 UTC

[section ""data" . GHC.Base.>>=_closure" {
     GHC.Base.>>=_closure:
         const GHC.Base.>>=_info;
 },
 GHC.Base.>>=_entry() //  [R2]
         { info_tbl: [(c8rU,
                       label: GHC.Base.>>=_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8rV; else goto c8rW;
       c8rV: // global
           R2 = R2;
           R1 = GHC.Base.>>=_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8rW: // global
           I64[Sp - 8] = block_c8rR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8s0; else goto c8rS;
       u8s0: // global
           call _c8rR(R1) args: 0, res: 0, upd: 0;
       c8rS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8rR() //  [R1]
         { info_tbl: [(c8rR,
                       label: block_c8rR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8rR: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.717617975 UTC

[section ""data" . GHC.Base.>>_closure" {
     GHC.Base.>>_closure:
         const GHC.Base.>>_info;
 },
 GHC.Base.>>_entry() //  [R2]
         { info_tbl: [(c8s8,
                       label: GHC.Base.>>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8s9; else goto c8sa;
       c8s9: // global
           R2 = R2;
           R1 = GHC.Base.>>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sa: // global
           I64[Sp - 8] = block_c8s5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8se; else goto c8s6;
       u8se: // global
           call _c8s5(R1) args: 0, res: 0, upd: 0;
       c8s6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8s5() //  [R1]
         { info_tbl: [(c8s5,
                       label: block_c8s5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8s5: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.718704437 UTC

[section ""data" . GHC.Base.return_closure" {
     GHC.Base.return_closure:
         const GHC.Base.return_info;
 },
 GHC.Base.return_entry() //  [R2]
         { info_tbl: [(c8sm,
                       label: GHC.Base.return_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8sn; else goto c8so;
       c8sn: // global
           R2 = R2;
           R1 = GHC.Base.return_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8so: // global
           I64[Sp - 8] = block_c8sj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ss; else goto c8sk;
       u8ss: // global
           call _c8sj(R1) args: 0, res: 0, upd: 0;
       c8sk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sj() //  [R1]
         { info_tbl: [(c8sj,
                       label: block_c8sj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sj: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.719987014 UTC

[section ""data" . GHC.Base.fail_closure" {
     GHC.Base.fail_closure:
         const GHC.Base.fail_info;
 },
 GHC.Base.fail_entry() //  [R2]
         { info_tbl: [(c8sA,
                       label: GHC.Base.fail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8sB; else goto c8sC;
       c8sB: // global
           R2 = R2;
           R1 = GHC.Base.fail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sC: // global
           I64[Sp - 8] = block_c8sx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8sG; else goto c8sy;
       u8sG: // global
           call _c8sx(R1) args: 0, res: 0, upd: 0;
       c8sy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sx() //  [R1]
         { info_tbl: [(c8sx,
                       label: block_c8sx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sx: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.721033444 UTC

[section ""data" . GHC.Base.fmap_closure" {
     GHC.Base.fmap_closure:
         const GHC.Base.fmap_info;
 },
 GHC.Base.fmap_entry() //  [R2]
         { info_tbl: [(c8sO,
                       label: GHC.Base.fmap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8sP; else goto c8sQ;
       c8sP: // global
           R2 = R2;
           R1 = GHC.Base.fmap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8sQ: // global
           I64[Sp - 8] = block_c8sL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8sU; else goto c8sM;
       u8sU: // global
           call _c8sL(R1) args: 0, res: 0, upd: 0;
       c8sM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sL() //  [R1]
         { info_tbl: [(c8sL,
                       label: block_c8sL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sL: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.722150629 UTC

[section ""data" . GHC.Base.<$_closure" {
     GHC.Base.<$_closure:
         const GHC.Base.<$_info;
 },
 GHC.Base.<$_entry() //  [R2]
         { info_tbl: [(c8t2,
                       label: GHC.Base.<$_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8t2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8t3; else goto c8t4;
       c8t3: // global
           R2 = R2;
           R1 = GHC.Base.<$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8t4: // global
           I64[Sp - 8] = block_c8sZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8t8; else goto c8t0;
       u8t8: // global
           call _c8sZ(R1) args: 0, res: 0, upd: 0;
       c8t0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8sZ() //  [R1]
         { info_tbl: [(c8sZ,
                       label: block_c8sZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8sZ: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.723842891 UTC

[section ""data" . GHC.Base.$p1Applicative_closure" {
     GHC.Base.$p1Applicative_closure:
         const GHC.Base.$p1Applicative_info;
 },
 GHC.Base.$p1Applicative_entry() //  [R2]
         { info_tbl: [(c8tg,
                       label: GHC.Base.$p1Applicative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8tg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8th; else goto c8ti;
       c8th: // global
           R2 = R2;
           R1 = GHC.Base.$p1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ti: // global
           I64[Sp - 8] = block_c8td_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8tm; else goto c8te;
       u8tm: // global
           call _c8td(R1) args: 0, res: 0, upd: 0;
       c8te: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8td() //  [R1]
         { info_tbl: [(c8td,
                       label: block_c8td_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8td: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.725141843 UTC

[section ""data" . GHC.Base.pure_closure" {
     GHC.Base.pure_closure:
         const GHC.Base.pure_info;
 },
 GHC.Base.pure_entry() //  [R2]
         { info_tbl: [(c8tu,
                       label: GHC.Base.pure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8tu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8tv; else goto c8tw;
       c8tv: // global
           R2 = R2;
           R1 = GHC.Base.pure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8tw: // global
           I64[Sp - 8] = block_c8tr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8tA; else goto c8ts;
       u8tA: // global
           call _c8tr(R1) args: 0, res: 0, upd: 0;
       c8ts: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8tr() //  [R1]
         { info_tbl: [(c8tr,
                       label: block_c8tr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8tr: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.726732726 UTC

[section ""data" . GHC.Base.<*>_closure" {
     GHC.Base.<*>_closure:
         const GHC.Base.<*>_info;
 },
 GHC.Base.<*>_entry() //  [R2]
         { info_tbl: [(c8tI,
                       label: GHC.Base.<*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8tI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8tJ; else goto c8tK;
       c8tJ: // global
           R2 = R2;
           R1 = GHC.Base.<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8tK: // global
           I64[Sp - 8] = block_c8tF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8tO; else goto c8tG;
       u8tO: // global
           call _c8tF(R1) args: 0, res: 0, upd: 0;
       c8tG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8tF() //  [R1]
         { info_tbl: [(c8tF,
                       label: block_c8tF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8tF: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.72780278 UTC

[section ""data" . GHC.Base.liftA2_closure" {
     GHC.Base.liftA2_closure:
         const GHC.Base.liftA2_info;
 },
 GHC.Base.liftA2_entry() //  [R2]
         { info_tbl: [(c8tW,
                       label: GHC.Base.liftA2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8tW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8tX; else goto c8tY;
       c8tX: // global
           R2 = R2;
           R1 = GHC.Base.liftA2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8tY: // global
           I64[Sp - 8] = block_c8tT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8u2; else goto c8tU;
       u8u2: // global
           call _c8tT(R1) args: 0, res: 0, upd: 0;
       c8tU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8tT() //  [R1]
         { info_tbl: [(c8tT,
                       label: block_c8tT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8tT: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.728823418 UTC

[section ""data" . GHC.Base.*>_closure" {
     GHC.Base.*>_closure:
         const GHC.Base.*>_info;
 },
 GHC.Base.*>_entry() //  [R2]
         { info_tbl: [(c8ua,
                       label: GHC.Base.*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ua: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ub; else goto c8uc;
       c8ub: // global
           R2 = R2;
           R1 = GHC.Base.*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8uc: // global
           I64[Sp - 8] = block_c8u7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ug; else goto c8u8;
       u8ug: // global
           call _c8u7(R1) args: 0, res: 0, upd: 0;
       c8u8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8u7() //  [R1]
         { info_tbl: [(c8u7,
                       label: block_c8u7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8u7: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.730081215 UTC

[section ""data" . GHC.Base.<*_closure" {
     GHC.Base.<*_closure:
         const GHC.Base.<*_info;
 },
 GHC.Base.<*_entry() //  [R2]
         { info_tbl: [(c8uo,
                       label: GHC.Base.<*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8up; else goto c8uq;
       c8up: // global
           R2 = R2;
           R1 = GHC.Base.<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8uq: // global
           I64[Sp - 8] = block_c8ul_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8uu; else goto c8um;
       u8uu: // global
           call _c8ul(R1) args: 0, res: 0, upd: 0;
       c8um: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ul() //  [R1]
         { info_tbl: [(c8ul,
                       label: block_c8ul_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ul: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.731147716 UTC

[section ""data" . GHC.Base.<>_closure" {
     GHC.Base.<>_closure:
         const GHC.Base.<>_info;
 },
 GHC.Base.<>_entry() //  [R2]
         { info_tbl: [(c8uC,
                       label: GHC.Base.<>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8uD; else goto c8uE;
       c8uD: // global
           R2 = R2;
           R1 = GHC.Base.<>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8uE: // global
           I64[Sp - 8] = block_c8uz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8uI; else goto c8uA;
       u8uI: // global
           call _c8uz(R1) args: 0, res: 0, upd: 0;
       c8uA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8uz() //  [R1]
         { info_tbl: [(c8uz,
                       label: block_c8uz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uz: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.732206619 UTC

[section ""data" . GHC.Base.sconcat_closure" {
     GHC.Base.sconcat_closure:
         const GHC.Base.sconcat_info;
 },
 GHC.Base.sconcat_entry() //  [R2]
         { info_tbl: [(c8uQ,
                       label: GHC.Base.sconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8uR; else goto c8uS;
       c8uR: // global
           R2 = R2;
           R1 = GHC.Base.sconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8uS: // global
           I64[Sp - 8] = block_c8uN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8uW; else goto c8uO;
       u8uW: // global
           call _c8uN(R1) args: 0, res: 0, upd: 0;
       c8uO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8uN() //  [R1]
         { info_tbl: [(c8uN,
                       label: block_c8uN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8uN: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.733512924 UTC

[section ""data" . GHC.Base.stimes_closure" {
     GHC.Base.stimes_closure:
         const GHC.Base.stimes_info;
 },
 GHC.Base.stimes_entry() //  [R2]
         { info_tbl: [(c8v4,
                       label: GHC.Base.stimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8v4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8v5; else goto c8v6;
       c8v5: // global
           R2 = R2;
           R1 = GHC.Base.stimes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8v6: // global
           I64[Sp - 8] = block_c8v1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8va; else goto c8v2;
       u8va: // global
           call _c8v1(R1) args: 0, res: 0, upd: 0;
       c8v2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8v1() //  [R1]
         { info_tbl: [(c8v1,
                       label: block_c8v1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8v1: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.734559845 UTC

[section ""data" . GHC.Base.$p1Monoid_closure" {
     GHC.Base.$p1Monoid_closure:
         const GHC.Base.$p1Monoid_info;
 },
 GHC.Base.$p1Monoid_entry() //  [R2]
         { info_tbl: [(c8vi,
                       label: GHC.Base.$p1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8vj; else goto c8vk;
       c8vj: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8vk: // global
           I64[Sp - 8] = block_c8vf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8vo; else goto c8vg;
       u8vo: // global
           call _c8vf(R1) args: 0, res: 0, upd: 0;
       c8vg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vf() //  [R1]
         { info_tbl: [(c8vf,
                       label: block_c8vf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vf: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.735639248 UTC

[section ""data" . GHC.Base.mempty_closure" {
     GHC.Base.mempty_closure:
         const GHC.Base.mempty_info;
 },
 GHC.Base.mempty_entry() //  [R2]
         { info_tbl: [(c8vw,
                       label: GHC.Base.mempty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8vx; else goto c8vy;
       c8vx: // global
           R2 = R2;
           R1 = GHC.Base.mempty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8vy: // global
           I64[Sp - 8] = block_c8vt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8vC; else goto c8vu;
       u8vC: // global
           call _c8vt(R1) args: 0, res: 0, upd: 0;
       c8vu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vt() //  [R1]
         { info_tbl: [(c8vt,
                       label: block_c8vt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vt: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.737197805 UTC

[section ""data" . GHC.Base.mappend_closure" {
     GHC.Base.mappend_closure:
         const GHC.Base.mappend_info;
 },
 GHC.Base.mappend_entry() //  [R2]
         { info_tbl: [(c8vK,
                       label: GHC.Base.mappend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8vL; else goto c8vM;
       c8vL: // global
           R2 = R2;
           R1 = GHC.Base.mappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8vM: // global
           I64[Sp - 8] = block_c8vH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8vQ; else goto c8vI;
       u8vQ: // global
           call _c8vH(R1) args: 0, res: 0, upd: 0;
       c8vI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vH() //  [R1]
         { info_tbl: [(c8vH,
                       label: block_c8vH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vH: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.738363875 UTC

[section ""data" . GHC.Base.mconcat_closure" {
     GHC.Base.mconcat_closure:
         const GHC.Base.mconcat_info;
 },
 GHC.Base.mconcat_entry() //  [R2]
         { info_tbl: [(c8vY,
                       label: GHC.Base.mconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8vZ; else goto c8w0;
       c8vZ: // global
           R2 = R2;
           R1 = GHC.Base.mconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8w0: // global
           I64[Sp - 8] = block_c8vV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8w4; else goto c8vW;
       u8w4: // global
           call _c8vV(R1) args: 0, res: 0, upd: 0;
       c8vW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8vV() //  [R1]
         { info_tbl: [(c8vV,
                       label: block_c8vV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8vV: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.73968229 UTC

[section ""data" . GHC.Base.$p1MonadPlus_closure" {
     GHC.Base.$p1MonadPlus_closure:
         const GHC.Base.$p1MonadPlus_info;
 },
 GHC.Base.$p1MonadPlus_entry() //  [R2]
         { info_tbl: [(c8wc,
                       label: GHC.Base.$p1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8wd; else goto c8we;
       c8wd: // global
           R2 = R2;
           R1 = GHC.Base.$p1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8we: // global
           I64[Sp - 8] = block_c8w9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8wi; else goto c8wa;
       u8wi: // global
           call _c8w9(R1) args: 0, res: 0, upd: 0;
       c8wa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8w9() //  [R1]
         { info_tbl: [(c8w9,
                       label: block_c8w9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8w9: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.740742138 UTC

[section ""data" . GHC.Base.$p2MonadPlus_closure" {
     GHC.Base.$p2MonadPlus_closure:
         const GHC.Base.$p2MonadPlus_info;
 },
 GHC.Base.$p2MonadPlus_entry() //  [R2]
         { info_tbl: [(c8wq,
                       label: GHC.Base.$p2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8wr; else goto c8ws;
       c8wr: // global
           R2 = R2;
           R1 = GHC.Base.$p2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ws: // global
           I64[Sp - 8] = block_c8wn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ww; else goto c8wo;
       u8ww: // global
           call _c8wn(R1) args: 0, res: 0, upd: 0;
       c8wo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wn() //  [R1]
         { info_tbl: [(c8wn,
                       label: block_c8wn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wn: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.741808827 UTC

[section ""data" . GHC.Base.mzero_closure" {
     GHC.Base.mzero_closure:
         const GHC.Base.mzero_info;
 },
 GHC.Base.mzero_entry() //  [R2]
         { info_tbl: [(c8wE,
                       label: GHC.Base.mzero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8wF; else goto c8wG;
       c8wF: // global
           R2 = R2;
           R1 = GHC.Base.mzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8wG: // global
           I64[Sp - 8] = block_c8wB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8wK; else goto c8wC;
       u8wK: // global
           call _c8wB(R1) args: 0, res: 0, upd: 0;
       c8wC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wB() //  [R1]
         { info_tbl: [(c8wB,
                       label: block_c8wB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wB: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.743105239 UTC

[section ""data" . GHC.Base.mplus_closure" {
     GHC.Base.mplus_closure:
         const GHC.Base.mplus_info;
 },
 GHC.Base.mplus_entry() //  [R2]
         { info_tbl: [(c8wS,
                       label: GHC.Base.mplus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8wT; else goto c8wU;
       c8wT: // global
           R2 = R2;
           R1 = GHC.Base.mplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8wU: // global
           I64[Sp - 8] = block_c8wP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8wY; else goto c8wQ;
       u8wY: // global
           call _c8wP(R1) args: 0, res: 0, upd: 0;
       c8wQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8wP() //  [R1]
         { info_tbl: [(c8wP,
                       label: block_c8wP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8wP: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.744321757 UTC

[section ""data" . GHC.Base.$p1Alternative_closure" {
     GHC.Base.$p1Alternative_closure:
         const GHC.Base.$p1Alternative_info;
 },
 GHC.Base.$p1Alternative_entry() //  [R2]
         { info_tbl: [(c8x6,
                       label: GHC.Base.$p1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8x7; else goto c8x8;
       c8x7: // global
           R2 = R2;
           R1 = GHC.Base.$p1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8x8: // global
           I64[Sp - 8] = block_c8x3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8xc; else goto c8x4;
       u8xc: // global
           call _c8x3(R1) args: 0, res: 0, upd: 0;
       c8x4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8x3() //  [R1]
         { info_tbl: [(c8x3,
                       label: block_c8x3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8x3: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.745588539 UTC

[section ""data" . GHC.Base.empty_closure" {
     GHC.Base.empty_closure:
         const GHC.Base.empty_info;
 },
 GHC.Base.empty_entry() //  [R2]
         { info_tbl: [(c8xk,
                       label: GHC.Base.empty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8xl; else goto c8xm;
       c8xl: // global
           R2 = R2;
           R1 = GHC.Base.empty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8xm: // global
           I64[Sp - 8] = block_c8xh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8xq; else goto c8xi;
       u8xq: // global
           call _c8xh(R1) args: 0, res: 0, upd: 0;
       c8xi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xh() //  [R1]
         { info_tbl: [(c8xh,
                       label: block_c8xh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xh: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.747017669 UTC

[section ""data" . GHC.Base.<|>_closure" {
     GHC.Base.<|>_closure:
         const GHC.Base.<|>_info;
 },
 GHC.Base.<|>_entry() //  [R2]
         { info_tbl: [(c8xy,
                       label: GHC.Base.<|>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8xz; else goto c8xA;
       c8xz: // global
           R2 = R2;
           R1 = GHC.Base.<|>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8xA: // global
           I64[Sp - 8] = block_c8xv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8xE; else goto c8xw;
       u8xE: // global
           call _c8xv(R1) args: 0, res: 0, upd: 0;
       c8xw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xv() //  [R1]
         { info_tbl: [(c8xv,
                       label: block_c8xv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xv: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.748097581 UTC

[section ""data" . GHC.Base.some_closure" {
     GHC.Base.some_closure:
         const GHC.Base.some_info;
 },
 GHC.Base.some_entry() //  [R2]
         { info_tbl: [(c8xM,
                       label: GHC.Base.some_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8xN; else goto c8xO;
       c8xN: // global
           R2 = R2;
           R1 = GHC.Base.some_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8xO: // global
           I64[Sp - 8] = block_c8xJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8xS; else goto c8xK;
       u8xS: // global
           call _c8xJ(R1) args: 0, res: 0, upd: 0;
       c8xK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xJ() //  [R1]
         { info_tbl: [(c8xJ,
                       label: block_c8xJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xJ: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.749188969 UTC

[section ""data" . GHC.Base.many_closure" {
     GHC.Base.many_closure:
         const GHC.Base.many_info;
 },
 GHC.Base.many_entry() //  [R2]
         { info_tbl: [(c8y0,
                       label: GHC.Base.many_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8y1; else goto c8y2;
       c8y1: // global
           R2 = R2;
           R1 = GHC.Base.many_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8y2: // global
           I64[Sp - 8] = block_c8xX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8y6; else goto c8xY;
       u8y6: // global
           call _c8xX(R1) args: 0, res: 0, upd: 0;
       c8xY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8xX() //  [R1]
         { info_tbl: [(c8xX,
                       label: block_c8xX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8xX: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.751237471 UTC

[section ""data" . GHC.Base.eqString_closure" {
     GHC.Base.eqString_closure:
         const GHC.Base.eqString_info;
 },
 GHC.Base.eqString_entry() //  [R2, R3]
         { info_tbl: [(c8yi,
                       label: GHC.Base.eqString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8yj; else goto u8z8;
       c8yj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.eqString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u8z8: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c8y8() args: 0, res: 0, upd: 0;
     }
 },
 _c8y8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8y8: // global
           _s7SQ::P64 = P64[Sp];
           I64[Sp] = block_c8yb_info;
           R1 = _s7SQ::P64;
           if (R1 & 7 != 0) goto u8zd; else goto c8yc;
       u8zd: // global
           call _c8yb(R1) args: 0, res: 0, upd: 0;
       c8yc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8yb() //  [R1]
         { info_tbl: [(c8yb,
                       label: block_c8yb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yb: // global
           _s7SR::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8yf; else goto c8yg;
       c8yf: // global
           I64[Sp + 8] = block_c8yn_info;
           R1 = _s7SR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ze; else goto c8yp;
       u8ze: // global
           call _c8yn(R1) args: 0, res: 0, upd: 0;
       c8yp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8yg: // global
           I64[Sp - 8] = block_c8yC_info;
           _s7SW::P64 = P64[R1 + 6];
           _s7SX::P64 = P64[R1 + 14];
           R1 = _s7SR::P64;
           P64[Sp] = _s7SX::P64;
           P64[Sp + 8] = _s7SW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8zf; else goto c8yE;
       u8zf: // global
           call _c8yC(R1) args: 0, res: 0, upd: 0;
       c8yE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8yn() //  [R1]
         { info_tbl: [(c8yn,
                       label: block_c8yn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yn: // global
           if (R1 & 7 == 1) goto c8yv; else goto u8zc;
       c8yv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8zc: // global
           Sp = Sp + 8;
           call _c8z4() args: 0, res: 0, upd: 0;
     }
 },
 _c8yC() //  [R1]
         { info_tbl: [(c8yC,
                       label: block_c8yC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yC: // global
           if (R1 & 7 == 1) goto u8z9; else goto c8yU;
       u8z9: // global
           Sp = Sp + 24;
           call _c8z4() args: 0, res: 0, upd: 0;
       c8yU: // global
           I64[Sp - 8] = block_c8yN_info;
           _s7SZ::P64 = P64[R1 + 6];
           _s7T0::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _s7T0::P64;
           P64[Sp + 16] = _s7SZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8zi; else goto c8yO;
       u8zi: // global
           call _c8yN(R1) args: 0, res: 0, upd: 0;
       c8yO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8yN() //  [R1]
         { info_tbl: [(c8yN,
                       label: block_c8yN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yN: // global
           I64[Sp] = block_c8yS_info;
           _s7T2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7T2::I64;
           if (R1 & 7 != 0) goto u8zk; else goto c8yW;
       u8zk: // global
           call _c8yS(R1) args: 0, res: 0, upd: 0;
       c8yW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8yS() //  [R1]
         { info_tbl: [(c8yS,
                       label: block_c8yS_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8yS: // global
           if (I64[Sp + 24] == I64[R1 + 7]) goto c8z5; else goto u8za;
       c8z5: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c8y8() args: 0, res: 0, upd: 0;
       u8za: // global
           Sp = Sp + 32;
           call _c8z4() args: 0, res: 0, upd: 0;
     }
 },
 _c8z4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8z4: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.754293398 UTC

[section ""data" . GHC.Base.when2_closure" {
     GHC.Base.when2_closure:
         const GHC.Base.when2_info;
 },
 GHC.Base.when2_entry() //  [R2, R3]
         { info_tbl: [(c8zy,
                       label: GHC.Base.when2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zz; else goto c8zA;
       c8zz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8zA: // global
           I64[Sp - 16] = block_c8zr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8zH; else goto c8zs;
       u8zH: // global
           call _c8zr(R1) args: 0, res: 0, upd: 0;
       c8zs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8zr() //  [R1]
         { info_tbl: [(c8zr,
                       label: block_c8zr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zr: // global
           if (R1 & 7 == 1) goto c8zv; else goto c8zw;
       c8zv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8zw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.755470311 UTC

[section ""data" . GHC.Base.when_$swhen1_closure" {
     GHC.Base.when_$swhen1_closure:
         const GHC.Base.when_$swhen1_info;
 },
 GHC.Base.when_$swhen1_entry() //  [R2, R3]
         { info_tbl: [(c8zM,
                       label: GHC.Base.when_$swhen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zM: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.when2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.756488701 UTC

[section ""data" . GHC.Base.$fFunctorIO2_closure" {
     GHC.Base.$fFunctorIO2_closure:
         const GHC.Base.$fFunctorIO2_info;
 },
 GHC.Base.$fFunctorIO2_entry() //  [R2, R3]
         { info_tbl: [(c8zW,
                       label: GHC.Base.$fFunctorIO2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8zX; else goto c8zY;
       c8zX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8zY: // global
           I64[Sp - 16] = block_c8zT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8zT() //  [R1]
         { info_tbl: [(c8zT,
                       label: block_c8zT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8zT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8A1; else goto c8A0;
       c8A1: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8A0: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.757965127 UTC

[section ""data" . GHC.Base.$fFunctorIO1_closure" {
     GHC.Base.$fFunctorIO1_closure:
         const GHC.Base.$fFunctorIO1_info;
 },
 GHC.Base.$fFunctorIO1_entry() //  [R2, R3]
         { info_tbl: [(c8A8,
                       label: GHC.Base.$fFunctorIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8A8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8A9; else goto c8Aa;
       c8A9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Aa: // global
           I64[Sp - 16] = block_c8A6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8A6() //  []
         { info_tbl: [(c8A6,
                       label: block_c8A6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8A6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.758860274 UTC

[section ""data" . GHC.Base.$fFunctorIO_closure" {
     GHC.Base.$fFunctorIO_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorIO2_closure+3;
         const GHC.Base.$fFunctorIO1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.759376796 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe1_closure" {
     GHC.Base.$fAlternativeMaybe1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.760737533 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$cmany_closure" {
     GHC.Base.$fAlternativeMaybe_$cmany_closure:
         const GHC.Base.$fAlternativeMaybe_$cmany_info;
 },
 many_v_s7To_entry() //  [R1]
         { info_tbl: [(c8Ar,
                       label: many_v_s7To_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ar: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8As; else goto c8At;
       c8As: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8At: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8Ak_info;
           _s7To::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s7To::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8AV; else goto c8Al;
       u8AV: // global
           call _c8Ak(R1) args: 0, res: 0, upd: 0;
       c8Al: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Ak() //  [R1]
         { info_tbl: [(c8Ak,
                       label: block_c8Ak_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ak: // global
           if (R1 & 7 == 1) goto u8AR; else goto c8Ap;
       u8AR: // global
           Sp = Sp + 16;
           call _c8AH() args: 0, res: 0, upd: 0;
       c8Ap: // global
           I64[Sp] = block_c8Az_info;
           _s7Tq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Tq::P64;
           if (R1 & 7 != 0) goto u8AT; else goto c8AB;
       u8AT: // global
           call _c8Az(R1) args: 0, res: 0, upd: 0;
       c8AB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Az() //  [R1]
         { info_tbl: [(c8Az,
                       label: block_c8Az_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Az: // global
           if (R1 & 7 == 1) goto u8AS; else goto c8AM;
       u8AS: // global
           Sp = Sp + 16;
           call _c8AH() args: 0, res: 0, upd: 0;
       c8AM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8AP; else goto c8AO;
       c8AP: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8AO: // global
           _s7Ts::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7Ts::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c8AH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8AH: // global
           R1 = GHC.Base.$fAlternativeMaybe1_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$cmany_entry() //  [R2]
         { info_tbl: [(c8AX,
                       label: GHC.Base.$fAlternativeMaybe_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8AX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8B1; else goto c8B0;
       c8B1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8B0: // global
           I64[Hp - 16] = many_v_s7To_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.763076612 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$csome_closure" {
     GHC.Base.$fAlternativeMaybe_$csome_closure:
         const GHC.Base.$fAlternativeMaybe_$csome_info;
 },
 some_v_s7Tv_entry() //  [R1]
         { info_tbl: [(c8Bh,
                       label: some_v_s7Tv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Bi; else goto c8Bj;
       c8Bi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Bj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c8Ba_info;
           _s7Tv::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s7Tv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8BM; else goto c8Bb;
       u8BM: // global
           call _c8Ba(R1) args: 0, res: 0, upd: 0;
       c8Bb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Ba() //  [R1]
         { info_tbl: [(c8Ba,
                       label: block_c8Ba_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ba: // global
           if (R1 & 7 == 1) goto c8Be; else goto c8Bf;
       c8Be: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8Bf: // global
           I64[Sp] = block_c8Bp_info;
           _s7Tx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Tx::P64;
           if (R1 & 7 != 0) goto u8BL; else goto c8Br;
       u8BL: // global
           call _c8Bp(R1) args: 0, res: 0, upd: 0;
       c8Br: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Bp() //  [R1]
         { info_tbl: [(c8Bp,
                       label: block_c8Bp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Bp: // global
           _s7Tx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8By; else goto c8BG;
       c8By: // global
           Hp = Hp + 40;
           _s7Ty::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8BJ; else goto c8BA;
       c8BA: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _s7Tx::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c8BG: // global
           Hp = Hp + 40;
           _s7Ty::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8BJ; else goto c8BI;
       c8BJ: // global
           HpAlloc = 40;
           R1 = _s7Ty::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8BI: // global
           _s7TA::P64 = P64[_s7Ty::P64 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _s7Tx::P64;
           P64[Hp - 16] = _s7TA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$csome_entry() //  [R2]
         { info_tbl: [(c8BN,
                       label: GHC.Base.$fAlternativeMaybe_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8BR; else goto c8BQ;
       c8BR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8BQ: // global
           I64[Hp - 16] = some_v_s7Tv_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.765536976 UTC

[section ""data" . GHC.Base.ap_$sap_closure" {
     GHC.Base.ap_$sap_closure:
         const GHC.Base.ap_$sap_info;
 },
 GHC.Base.ap_$sap_entry() //  [R2, R3]
         { info_tbl: [(c8C3,
                       label: GHC.Base.ap_$sap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8C3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8C4; else goto c8C5;
       c8C4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap_$sap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8C5: // global
           I64[Sp - 16] = block_c8BW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Cx; else goto c8BX;
       u8Cx: // global
           call _c8BW(R1) args: 0, res: 0, upd: 0;
       c8BX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8BW() //  [R1]
         { info_tbl: [(c8BW,
                       label: block_c8BW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8BW: // global
           if (R1 & 7 == 1) goto u8Ct; else goto c8C1;
       u8Ct: // global
           Sp = Sp + 16;
           call _c8Cj() args: 0, res: 0, upd: 0;
       c8C1: // global
           I64[Sp] = block_c8Cb_info;
           _s7TF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7TF::P64;
           if (R1 & 7 != 0) goto u8Cv; else goto c8Cd;
       u8Cv: // global
           call _c8Cb(R1) args: 0, res: 0, upd: 0;
       c8Cd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Cb() //  [R1]
         { info_tbl: [(c8Cb,
                       label: block_c8Cb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cb: // global
           if (R1 & 7 == 1) goto u8Cu; else goto c8Co;
       u8Cu: // global
           Sp = Sp + 16;
           call _c8Cj() args: 0, res: 0, upd: 0;
       c8Co: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Cr; else goto c8Cq;
       c8Cr: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Cq: // global
           _s7TH::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7TH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Cj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Cj: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.768007707 UTC

[section ""data" . GHC.Base.liftM5_$sliftM5_closure" {
     GHC.Base.liftM5_$sliftM5_closure:
         const GHC.Base.liftM5_$sliftM5_info;
 },
 GHC.Base.liftM5_$sliftM5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8CK,
                       label: GHC.Base.liftM5_$sliftM5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8CL; else goto c8CM;
       c8CL: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM5_$sliftM5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8CM: // global
           I64[Sp - 40] = block_c8CD_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8DU; else goto c8CE;
       u8DU: // global
           call _c8CD(R1) args: 0, res: 0, upd: 0;
       c8CE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CD() //  [R1]
         { info_tbl: [(c8CD,
                       label: block_c8CD_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CD: // global
           if (R1 & 7 == 1) goto u8DN; else goto c8CI;
       u8DN: // global
           Sp = Sp + 48;
           call _c8DA() args: 0, res: 0, upd: 0;
       c8CI: // global
           I64[Sp] = block_c8CS_info;
           _s7TQ::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7TQ::P64;
           if (R1 & 7 != 0) goto u8DS; else goto c8CU;
       u8DS: // global
           call _c8CS(R1) args: 0, res: 0, upd: 0;
       c8CU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8CS() //  [R1]
         { info_tbl: [(c8CS,
                       label: block_c8CS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8CS: // global
           if (R1 & 7 == 1) goto u8DO; else goto c8D5;
       u8DO: // global
           Sp = Sp + 48;
           call _c8DA() args: 0, res: 0, upd: 0;
       c8D5: // global
           I64[Sp] = block_c8D3_info;
           _s7TS::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7TS::P64;
           if (R1 & 7 != 0) goto u8DV; else goto c8D6;
       u8DV: // global
           call _c8D3(R1) args: 0, res: 0, upd: 0;
       c8D6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8D3() //  [R1]
         { info_tbl: [(c8D3,
                       label: block_c8D3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8D3: // global
           if (R1 & 7 == 1) goto u8DP; else goto c8Dh;
       u8DP: // global
           Sp = Sp + 48;
           call _c8DA() args: 0, res: 0, upd: 0;
       c8Dh: // global
           I64[Sp] = block_c8Df_info;
           _s7TU::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7TU::P64;
           if (R1 & 7 != 0) goto u8DX; else goto c8Di;
       u8DX: // global
           call _c8Df(R1) args: 0, res: 0, upd: 0;
       c8Di: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Df() //  [R1]
         { info_tbl: [(c8Df,
                       label: block_c8Df_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Df: // global
           if (R1 & 7 == 1) goto u8DQ; else goto c8Dt;
       u8DQ: // global
           Sp = Sp + 48;
           call _c8DA() args: 0, res: 0, upd: 0;
       c8Dt: // global
           I64[Sp] = block_c8Dr_info;
           _s7TW::P64 = P64[R1 + 6];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s7TW::P64;
           if (R1 & 7 != 0) goto u8DZ; else goto c8Du;
       u8DZ: // global
           call _c8Dr(R1) args: 0, res: 0, upd: 0;
       c8Du: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Dr() //  [R1]
         { info_tbl: [(c8Dr,
                       label: block_c8Dr_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Dr: // global
           if (R1 & 7 == 1) goto u8DR; else goto c8DF;
       u8DR: // global
           Sp = Sp + 48;
           call _c8DA() args: 0, res: 0, upd: 0;
       c8DF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8DI; else goto c8DH;
       c8DI: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8DH: // global
           _s7TY::P64 = P64[R1 + 6];
           I64[Hp - 72] = stg_ap_6_upd_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = _s7TY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 72;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8DA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8DA: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.771196222 UTC

[section ""data" . GHC.Base.liftM4_$sliftM4_closure" {
     GHC.Base.liftM4_$sliftM4_closure:
         const GHC.Base.liftM4_$sliftM4_info;
 },
 GHC.Base.liftM4_$sliftM4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8Ed,
                       label: GHC.Base.liftM4_$sliftM4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ed: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Ee; else goto c8Ef;
       c8Ee: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM4_$sliftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ef: // global
           I64[Sp - 40] = block_c8E6_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8F9; else goto c8E7;
       u8F9: // global
           call _c8E6(R1) args: 0, res: 0, upd: 0;
       c8E7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8E6() //  [R1]
         { info_tbl: [(c8E6,
                       label: block_c8E6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8E6: // global
           if (R1 & 7 == 1) goto u8F3; else goto c8Eb;
       u8F3: // global
           Sp = Sp + 40;
           call _c8ER() args: 0, res: 0, upd: 0;
       c8Eb: // global
           I64[Sp] = block_c8El_info;
           _s7U6::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7U6::P64;
           if (R1 & 7 != 0) goto u8F7; else goto c8En;
       u8F7: // global
           call _c8El(R1) args: 0, res: 0, upd: 0;
       c8En: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8El() //  [R1]
         { info_tbl: [(c8El,
                       label: block_c8El_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8El: // global
           if (R1 & 7 == 1) goto u8F4; else goto c8Ey;
       u8F4: // global
           Sp = Sp + 40;
           call _c8ER() args: 0, res: 0, upd: 0;
       c8Ey: // global
           I64[Sp] = block_c8Ew_info;
           _s7U8::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7U8::P64;
           if (R1 & 7 != 0) goto u8Fa; else goto c8Ez;
       u8Fa: // global
           call _c8Ew(R1) args: 0, res: 0, upd: 0;
       c8Ez: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ew() //  [R1]
         { info_tbl: [(c8Ew,
                       label: block_c8Ew_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ew: // global
           if (R1 & 7 == 1) goto u8F5; else goto c8EK;
       u8F5: // global
           Sp = Sp + 40;
           call _c8ER() args: 0, res: 0, upd: 0;
       c8EK: // global
           I64[Sp] = block_c8EI_info;
           _s7Ua::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Ua::P64;
           if (R1 & 7 != 0) goto u8Fc; else goto c8EL;
       u8Fc: // global
           call _c8EI(R1) args: 0, res: 0, upd: 0;
       c8EL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8EI() //  [R1]
         { info_tbl: [(c8EI,
                       label: block_c8EI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8EI: // global
           if (R1 & 7 == 1) goto u8F6; else goto c8EW;
       u8F6: // global
           Sp = Sp + 40;
           call _c8ER() args: 0, res: 0, upd: 0;
       c8EW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8EZ; else goto c8EY;
       c8EZ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8EY: // global
           _s7Uc::P64 = P64[R1 + 6];
           I64[Hp - 64] = stg_ap_5_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = _s7Uc::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ER() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ER: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.774149239 UTC

[section ""data" . GHC.Base.liftM3_$sliftM3_closure" {
     GHC.Base.liftM3_$sliftM3_closure:
         const GHC.Base.liftM3_$sliftM3_info;
 },
 GHC.Base.liftM3_$sliftM3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Fq,
                       label: GHC.Base.liftM3_$sliftM3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Fq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Fr; else goto c8Fs;
       c8Fr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM3_$sliftM3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Fs: // global
           I64[Sp - 32] = block_c8Fj_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8G8; else goto c8Fk;
       u8G8: // global
           call _c8Fj(R1) args: 0, res: 0, upd: 0;
       c8Fk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Fj() //  [R1]
         { info_tbl: [(c8Fj,
                       label: block_c8Fj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Fj: // global
           if (R1 & 7 == 1) goto u8G3; else goto c8Fo;
       u8G3: // global
           Sp = Sp + 32;
           call _c8FS() args: 0, res: 0, upd: 0;
       c8Fo: // global
           I64[Sp] = block_c8Fy_info;
           _s7Uj::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Uj::P64;
           if (R1 & 7 != 0) goto u8G6; else goto c8FA;
       u8G6: // global
           call _c8Fy(R1) args: 0, res: 0, upd: 0;
       c8FA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Fy() //  [R1]
         { info_tbl: [(c8Fy,
                       label: block_c8Fy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Fy: // global
           if (R1 & 7 == 1) goto u8G4; else goto c8FL;
       u8G4: // global
           Sp = Sp + 32;
           call _c8FS() args: 0, res: 0, upd: 0;
       c8FL: // global
           I64[Sp] = block_c8FJ_info;
           _s7Ul::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Ul::P64;
           if (R1 & 7 != 0) goto u8G9; else goto c8FM;
       u8G9: // global
           call _c8FJ(R1) args: 0, res: 0, upd: 0;
       c8FM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8FJ() //  [R1]
         { info_tbl: [(c8FJ,
                       label: block_c8FJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8FJ: // global
           if (R1 & 7 == 1) goto u8G5; else goto c8FX;
       u8G5: // global
           Sp = Sp + 32;
           call _c8FS() args: 0, res: 0, upd: 0;
       c8FX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8G0; else goto c8FZ;
       c8G0: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8FZ: // global
           _s7Un::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s7Un::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8FS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8FS: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.776570596 UTC

[section ""data" . GHC.Base.liftM2_$sliftM2_closure" {
     GHC.Base.liftM2_$sliftM2_closure:
         const GHC.Base.liftM2_$sliftM2_info;
 },
 GHC.Base.liftM2_$sliftM2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Gn,
                       label: GHC.Base.liftM2_$sliftM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Go; else goto c8Gp;
       c8Go: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM2_$sliftM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Gp: // global
           I64[Sp - 24] = block_c8Gg_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8GR; else goto c8Gh;
       u8GR: // global
           call _c8Gg(R1) args: 0, res: 0, upd: 0;
       c8Gh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Gg() //  [R1]
         { info_tbl: [(c8Gg,
                       label: block_c8Gg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gg: // global
           if (R1 & 7 == 1) goto u8GN; else goto c8Gl;
       u8GN: // global
           Sp = Sp + 24;
           call _c8GD() args: 0, res: 0, upd: 0;
       c8Gl: // global
           I64[Sp] = block_c8Gv_info;
           _s7Ut::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Ut::P64;
           if (R1 & 7 != 0) goto u8GP; else goto c8Gx;
       u8GP: // global
           call _c8Gv(R1) args: 0, res: 0, upd: 0;
       c8Gx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Gv() //  [R1]
         { info_tbl: [(c8Gv,
                       label: block_c8Gv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Gv: // global
           if (R1 & 7 == 1) goto u8GO; else goto c8GI;
       u8GO: // global
           Sp = Sp + 24;
           call _c8GD() args: 0, res: 0, upd: 0;
       c8GI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8GL; else goto c8GK;
       c8GL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8GK: // global
           _s7Uv::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _s7Uv::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8GD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GD: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.778348213 UTC

[section ""data" . GHC.Base.liftM_$sliftM_closure" {
     GHC.Base.liftM_$sliftM_closure:
         const GHC.Base.liftM_$sliftM_info;
 },
 GHC.Base.liftM_$sliftM_entry() //  [R2, R3]
         { info_tbl: [(c8H4,
                       label: GHC.Base.liftM_$sliftM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8H4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8H5; else goto c8H6;
       c8H5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM_$sliftM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8H6: // global
           I64[Sp - 16] = block_c8GX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Hh; else goto c8GY;
       u8Hh: // global
           call _c8GX(R1) args: 0, res: 0, upd: 0;
       c8GY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8GX() //  [R1]
         { info_tbl: [(c8GX,
                       label: block_c8GX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8GX: // global
           if (R1 & 7 == 1) goto c8H1; else goto c8H2;
       c8H1: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8H2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Hg; else goto c8Hf;
       c8Hg: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Hf: // global
           _s7UA::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7UA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.779647664 UTC

[section ""data" . GHC.Base.when1_closure" {
     GHC.Base.when1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.780436046 UTC

[section ""data" . GHC.Base.when_$swhen_closure" {
     GHC.Base.when_$swhen_closure:
         const GHC.Base.when_$swhen_info;
 },
 GHC.Base.when_$swhen_entry() //  [R2, R3]
         { info_tbl: [(c8Ht,
                       label: GHC.Base.when_$swhen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Hu; else goto c8Hv;
       c8Hu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_$swhen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Hv: // global
           I64[Sp - 16] = block_c8Hm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8HC; else goto c8Hn;
       u8HC: // global
           call _c8Hm(R1) args: 0, res: 0, upd: 0;
       c8Hn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Hm() //  [R1]
         { info_tbl: [(c8Hm,
                       label: block_c8Hm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Hm: // global
           if (R1 & 7 == 1) goto c8Hq; else goto c8Hr;
       c8Hq: // global
           R1 = GHC.Base.when1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Hr: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.781831779 UTC

[section ""data" . GHC.Base.when_closure" {
     GHC.Base.when_closure:
         const GHC.Base.when_info;
 },
 GHC.Base.when_entry() //  [R2, R3, R4]
         { info_tbl: [(c8HO,
                       label: GHC.Base.when_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8HP; else goto c8HQ;
       c8HP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8HQ: // global
           I64[Sp - 24] = block_c8HH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8HX; else goto c8HI;
       u8HX: // global
           call _c8HH(R1) args: 0, res: 0, upd: 0;
       c8HI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8HH() //  [R1]
         { info_tbl: [(c8HH,
                       label: block_c8HH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8HH: // global
           if (R1 & 7 == 1) goto c8HL; else goto c8HM;
       c8HL: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       c8HM: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.783471109 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*_entry() //  [R2, R3]
         { info_tbl: [(c8I9,
                       label: GHC.Base.$fApplicativeMaybe_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ia; else goto c8Ib;
       c8Ia: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ib: // global
           I64[Sp - 16] = block_c8I2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Iz; else goto c8I3;
       u8Iz: // global
           call _c8I2(R1) args: 0, res: 0, upd: 0;
       c8I3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8I2() //  [R1]
         { info_tbl: [(c8I2,
                       label: block_c8I2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8I2: // global
           if (R1 & 7 == 1) goto u8Iv; else goto c8I7;
       u8Iv: // global
           Sp = Sp + 16;
           call _c8Ip() args: 0, res: 0, upd: 0;
       c8I7: // global
           I64[Sp] = block_c8Ih_info;
           _s7UL::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7UL::P64;
           if (R1 & 7 != 0) goto u8Ix; else goto c8Ij;
       u8Ix: // global
           call _c8Ih(R1) args: 0, res: 0, upd: 0;
       c8Ij: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ih() //  [R1]
         { info_tbl: [(c8Ih,
                       label: block_c8Ih_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ih: // global
           if (R1 & 7 == 1) goto u8Iw; else goto c8It;
       u8Iw: // global
           Sp = Sp + 16;
           call _c8Ip() args: 0, res: 0, upd: 0;
       c8It: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ip() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ip: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.784694552 UTC

[section ""cstring" . GHC.Base.$tc'O3_bytes" {
     GHC.Base.$tc'O3_bytes:
         I8[] [39,79]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.785425456 UTC

[section ""data" . GHC.Base.$tc'O2_closure" {
     GHC.Base.$tc'O2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'O3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.785911615 UTC

[section ""cstring" . GHC.Base.$tcOpaque2_bytes" {
     GHC.Base.$tcOpaque2_bytes:
         I8[] [79,112,97,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.786367241 UTC

[section ""data" . GHC.Base.$tcOpaque1_closure" {
     GHC.Base.$tcOpaque1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcOpaque2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.786879574 UTC

[section ""cstring" . GHC.Base.$tcMonadPlus2_bytes" {
     GHC.Base.$tcMonadPlus2_bytes:
         I8[] [77,111,110,97,100,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.787400564 UTC

[section ""data" . GHC.Base.$tcMonadPlus1_closure" {
     GHC.Base.$tcMonadPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonadPlus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.788035483 UTC

[section ""cstring" . GHC.Base.$tcMonad2_bytes" {
     GHC.Base.$tcMonad2_bytes:
         I8[] [77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.788544545 UTC

[section ""data" . GHC.Base.$tcMonad1_closure" {
     GHC.Base.$tcMonad1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonad2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.789060401 UTC

[section ""cstring" . GHC.Base.$tc'C:Monoid3_bytes" {
     GHC.Base.$tc'C:Monoid3_bytes:
         I8[] [39,67,58,77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.789598513 UTC

[section ""data" . GHC.Base.$tc'C:Monoid2_closure" {
     GHC.Base.$tc'C:Monoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'C:Monoid3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.790236858 UTC

[section ""cstring" . GHC.Base.$tcMonoid3_bytes" {
     GHC.Base.$tcMonoid3_bytes:
         I8[] [77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.790739422 UTC

[section ""data" . GHC.Base.$tcMonoid2_closure" {
     GHC.Base.$tcMonoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonoid3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.791223274 UTC

[section ""cstring" . GHC.Base.$tcSemigroup2_bytes" {
     GHC.Base.$tcSemigroup2_bytes:
         I8[] [83,101,109,105,103,114,111,117,112]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.791711251 UTC

[section ""data" . GHC.Base.$tcSemigroup1_closure" {
     GHC.Base.$tcSemigroup1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcSemigroup2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.79221325 UTC

[section ""cstring" . GHC.Base.$tc':|3_bytes" {
     GHC.Base.$tc':|3_bytes:
         I8[] [39,58,124]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.792816827 UTC

[section ""data" . GHC.Base.$tc':|2_closure" {
     GHC.Base.$tc':|2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc':|3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.793349705 UTC

[section ""cstring" . GHC.Base.$tcNonEmpty2_bytes" {
     GHC.Base.$tcNonEmpty2_bytes:
         I8[] [78,111,110,69,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.793822599 UTC

[section ""data" . GHC.Base.$tcNonEmpty1_closure" {
     GHC.Base.$tcNonEmpty1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcNonEmpty2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.794315552 UTC

[section ""cstring" . GHC.Base.$tcAlternative3_bytes" {
     GHC.Base.$tcAlternative3_bytes:
         I8[] [65,108,116,101,114,110,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.794802127 UTC

[section ""data" . GHC.Base.$tcAlternative2_closure" {
     GHC.Base.$tcAlternative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcAlternative3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.795429878 UTC

[section ""cstring" . GHC.Base.$tcApplicative2_bytes" {
     GHC.Base.$tcApplicative2_bytes:
         I8[] [65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.795921611 UTC

[section ""data" . GHC.Base.$tcApplicative1_closure" {
     GHC.Base.$tcApplicative1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcApplicative2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.796395674 UTC

[section ""cstring" . GHC.Base.$tcFunctor2_bytes" {
     GHC.Base.$tcFunctor2_bytes:
         I8[] [70,117,110,99,116,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.796913526 UTC

[section ""data" . GHC.Base.$tcFunctor1_closure" {
     GHC.Base.$tcFunctor1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcFunctor2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.797791522 UTC

[section ""cstring" . GHC.Base.$tc'Just3_bytes" {
     GHC.Base.$tc'Just3_bytes:
         I8[] [39,74,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.798381882 UTC

[section ""data" . GHC.Base.$tc'Just2_closure" {
     GHC.Base.$tc'Just2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Just3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.798931053 UTC

[section ""cstring" . GHC.Base.$tc'Nothing3_bytes" {
     GHC.Base.$tc'Nothing3_bytes:
         I8[] [39,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.79953353 UTC

[section ""data" . GHC.Base.$tc'Nothing2_closure" {
     GHC.Base.$tc'Nothing2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Nothing3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.800331172 UTC

[section ""cstring" . GHC.Base.$tcMaybe2_bytes" {
     GHC.Base.$tcMaybe2_bytes:
         I8[] [77,97,121,98,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.800821759 UTC

[section ""data" . GHC.Base.$tcMaybe1_closure" {
     GHC.Base.$tcMaybe1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMaybe2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.801347001 UTC

[section ""data" . $krep_r7Pr_closure" {
     $krep_r7Pr_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.801858367 UTC

[section ""data" . $krep1_r7Ps_closure" {
     $krep1_r7Ps_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.802417584 UTC

[section ""data" . $krep2_r7Pt_closure" {
     $krep2_r7Pt_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep1_r7Ps_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.803067755 UTC

[section ""data" . $krep3_r7Pu_closure" {
     $krep3_r7Pu_closure:
         const :_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.803588675 UTC

[section ""data" . $krep4_r7Pv_closure" {
     $krep4_r7Pv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.804087519 UTC

[section ""data" . $krep5_r7Pw_closure" {
     $krep5_r7Pw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.804634877 UTC

[section ""data" . $krep6_r7Px_closure" {
     $krep6_r7Px_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.805362044 UTC

[section ""data" . GHC.Base.$tcMonoid1_closure" {
     GHC.Base.$tcMonoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.805888955 UTC

[section ""data" . GHC.Base.$tcAlternative1_closure" {
     GHC.Base.$tcAlternative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.806404066 UTC

[section ""cstring" . GHC.Base.$trModule2_bytes" {
     GHC.Base.$trModule2_bytes:
         I8[] [71,72,67,46,66,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.806927282 UTC

[section ""data" . GHC.Base.$trModule1_closure" {
     GHC.Base.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.80744544 UTC

[section ""cstring" . GHC.Base.$trModule4_bytes" {
     GHC.Base.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.808051745 UTC

[section ""data" . GHC.Base.$trModule3_closure" {
     GHC.Base.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.808562712 UTC

[section ""data" . GHC.Base.$trModule_closure" {
     GHC.Base.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Base.$trModule3_closure+1;
         const GHC.Base.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.809078978 UTC

[section ""data" . GHC.Base.$tcMaybe_closure" {
     GHC.Base.$tcMaybe_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMaybe1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 625655543500963593;
         const 6391758309165051762;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.809674012 UTC

[section ""data" . GHC.Base.$tc'Nothing1_closure" {
     GHC.Base.$tc'Nothing1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.810328456 UTC

[section ""data" . GHC.Base.$tc'Just1_closure" {
     GHC.Base.$tc'Just1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.810876119 UTC

[section ""data" . GHC.Base.$tc'Nothing_closure" {
     GHC.Base.$tc'Nothing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Nothing2_closure+1;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 14633289528184412192;
         const 12773126156421542470;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.811428835 UTC

[section ""data" . GHC.Base.$tc'Just_closure" {
     GHC.Base.$tc'Just_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Just2_closure+1;
         const GHC.Base.$tc'Just1_closure+4;
         const 5794512144280699493;
         const 9434423460978218117;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.811972101 UTC

[section ""data" . GHC.Base.$tcFunctor_closure" {
     GHC.Base.$tcFunctor_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcFunctor1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 211182333006544237;
         const 5556320544348084514;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.812659946 UTC

[section ""data" . GHC.Base.$tcApplicative_closure" {
     GHC.Base.$tcApplicative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcApplicative1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 12705055220831243597;
         const 2963353171490466073;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.81327219 UTC

[section ""data" . GHC.Base.$tcAlternative_closure" {
     GHC.Base.$tcAlternative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcAlternative2_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 1073491102990665358;
         const 14320772755704808948;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.813817978 UTC

[section ""data" . GHC.Base.$tcNonEmpty_closure" {
     GHC.Base.$tcNonEmpty_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcNonEmpty1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13207016872645468285;
         const 3455542966739695982;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.814382102 UTC

[section ""data" . $krep7_r7Py_closure" {
     $krep7_r7Py_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcNonEmpty_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.814972533 UTC

[section ""data" . $krep8_r7Pz_closure" {
     $krep8_r7Pz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep7_r7Py_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.815676096 UTC

[section ""data" . GHC.Base.$tc':|1_closure" {
     GHC.Base.$tc':|1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep8_r7Pz_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.816171943 UTC

[section ""data" . GHC.Base.$tc':|_closure" {
     GHC.Base.$tc':|_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc':|2_closure+1;
         const GHC.Base.$tc':|1_closure+4;
         const 9440832435183810765;
         const 3053237465234607583;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.816705164 UTC

[section ""data" . GHC.Base.$tcSemigroup_closure" {
     GHC.Base.$tcSemigroup_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcSemigroup1_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 16195352186364298277;
         const 3285685594139281062;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.817302372 UTC

[section ""data" . $krep9_r7PA_closure" {
     $krep9_r7PA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcSemigroup_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.818002867 UTC

[section ""data" . GHC.Base.$tcMonoid_closure" {
     GHC.Base.$tcMonoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonoid2_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 13838560045895743776;
         const 1291018260833769143;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.8185631 UTC

[section ""data" . $krep10_r7PB_closure" {
     $krep10_r7PB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMonoid_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.819064421 UTC

[section ""data" . $krep11_r7PC_closure" {
     $krep11_r7PC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r7Pw_closure+4;
         const $krep10_r7PB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.819608367 UTC

[section ""data" . $krep12_r7PD_closure" {
     $krep12_r7PD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r7Pt_closure+4;
         const $krep11_r7PC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.820288521 UTC

[section ""data" . $krep13_r7PE_closure" {
     $krep13_r7PE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep12_r7PD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.820846611 UTC

[section ""data" . GHC.Base.$tc'C:Monoid1_closure" {
     GHC.Base.$tc'C:Monoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r7PA_closure+1;
         const $krep13_r7PE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.821401625 UTC

[section ""data" . GHC.Base.$tc'C:Monoid_closure" {
     GHC.Base.$tc'C:Monoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'C:Monoid2_closure+1;
         const GHC.Base.$tc'C:Monoid1_closure+4;
         const 16099296089107510343;
         const 5895832073319104984;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.821924336 UTC

[section ""data" . GHC.Base.$tcMonad_closure" {
     GHC.Base.$tcMonad_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonad1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 3168880480603756299;
         const 8398240611646296094;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.822502585 UTC

[section ""data" . GHC.Base.$tcMonadPlus_closure" {
     GHC.Base.$tcMonadPlus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonadPlus1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 14115673251620372550;
         const 14155357326069389390;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.823245816 UTC

[section ""data" . GHC.Base.$tcOpaque_closure" {
     GHC.Base.$tcOpaque_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcOpaque1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9339725405829241186;
         const 15550233501624900571;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.823793451 UTC

[section ""data" . $krep14_r7PF_closure" {
     $krep14_r7PF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcOpaque_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.824310531 UTC

[section ""data" . GHC.Base.$tc'O1_closure" {
     GHC.Base.$tc'O1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep14_r7PF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.82483675 UTC

[section ""data" . GHC.Base.$tc'O_closure" {
     GHC.Base.$tc'O_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'O2_closure+1;
         const GHC.Base.$tc'O1_closure+4;
         const 12551274612394834805;
         const 13000664474148134329;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.826106069 UTC

[section ""data" . GHC.Base.quotRemInt_closure" {
     GHC.Base.quotRemInt_closure:
         const GHC.Base.quotRemInt_info;
 },
 GHC.Base.quotRemInt_entry() //  [R2, R3]
         { info_tbl: [(c8II,
                       label: GHC.Base.quotRemInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8II: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8IT; else goto c8IU;
       c8IT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotRemInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8IU: // global
           I64[Sp - 16] = block_c8IF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8J0; else goto c8IG;
       u8J0: // global
           call _c8IF(R1) args: 0, res: 0, upd: 0;
       c8IG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8IF() //  [R1]
         { info_tbl: [(c8IF,
                       label: block_c8IF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IF: // global
           I64[Sp] = block_c8IL_info;
           _s7US::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7US::I64;
           if (R1 & 7 != 0) goto u8IZ; else goto c8IM;
       u8IZ: // global
           call _c8IL(R1) args: 0, res: 0, upd: 0;
       c8IM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8IL() //  [R1]
         { info_tbl: [(c8IL,
                       label: block_c8IL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8IL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8IY; else goto c8IX;
       c8IY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8IX: // global
           (_s7UW::I64, _s7UX::I64) = call MO_S_QuotRem W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7UX::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s7UW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.827752689 UTC

[section ""data" . GHC.Base.modInt_closure" {
     GHC.Base.modInt_closure:
         const GHC.Base.modInt_info;
 },
 GHC.Base.modInt_entry() //  [R2, R3]
         { info_tbl: [(c8J8,
                       label: GHC.Base.modInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Jl; else goto c8Jm;
       c8Jl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.modInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Jm: // global
           I64[Sp - 16] = block_c8J5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Jt; else goto c8J6;
       u8Jt: // global
           call _c8J5(R1) args: 0, res: 0, upd: 0;
       c8J6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8J5() //  [R1]
         { info_tbl: [(c8J5,
                       label: block_c8J5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8J5: // global
           I64[Sp] = block_c8Jb_info;
           _s7V3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7V3::I64;
           if (R1 & 7 != 0) goto u8Js; else goto c8Jc;
       u8Js: // global
           call _c8Jb(R1) args: 0, res: 0, upd: 0;
       c8Jc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jb() //  [R1]
         { info_tbl: [(c8Jb,
                       label: block_c8Jb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jb: // global
           _s7V3::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8Jg_info;
           R3 = I64[R1 + 7];
           R2 = _s7V3::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jg() //  [R1]
         { info_tbl: [(c8Jg,
                       label: block_c8Jg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Jr; else goto c8Jq;
       c8Jr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Jq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.829619109 UTC

[section ""data" . GHC.Base.divInt_closure" {
     GHC.Base.divInt_closure:
         const GHC.Base.divInt_info;
 },
 GHC.Base.divInt_entry() //  [R2, R3]
         { info_tbl: [(c8JB,
                       label: GHC.Base.divInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8JO; else goto c8JP;
       c8JO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8JP: // global
           I64[Sp - 16] = block_c8Jy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8JW; else goto c8Jz;
       u8JW: // global
           call _c8Jy(R1) args: 0, res: 0, upd: 0;
       c8Jz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Jy() //  [R1]
         { info_tbl: [(c8Jy,
                       label: block_c8Jy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Jy: // global
           I64[Sp] = block_c8JE_info;
           _s7Va::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Va::I64;
           if (R1 & 7 != 0) goto u8JV; else goto c8JF;
       u8JV: // global
           call _c8JE(R1) args: 0, res: 0, upd: 0;
       c8JF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8JE() //  [R1]
         { info_tbl: [(c8JE,
                       label: block_c8JE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JE: // global
           _s7Va::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8JJ_info;
           R3 = I64[R1 + 7];
           R2 = _s7Va::I64;
           Sp = Sp + 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8JJ() //  [R1]
         { info_tbl: [(c8JJ,
                       label: block_c8JJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8JJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8JU; else goto c8JT;
       c8JU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8JT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.831239104 UTC

[section ""data" . GHC.Base.remInt_closure" {
     GHC.Base.remInt_closure:
         const GHC.Base.remInt_info;
 },
 GHC.Base.remInt_entry() //  [R2, R3]
         { info_tbl: [(c8K4,
                       label: GHC.Base.remInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8K4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Kg; else goto c8Kh;
       c8Kg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.remInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Kh: // global
           I64[Sp - 16] = block_c8K1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Kn; else goto c8K2;
       u8Kn: // global
           call _c8K1(R1) args: 0, res: 0, upd: 0;
       c8K2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8K1() //  [R1]
         { info_tbl: [(c8K1,
                       label: block_c8K1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8K1: // global
           I64[Sp] = block_c8K7_info;
           _s7Vh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Vh::I64;
           if (R1 & 7 != 0) goto u8Km; else goto c8K8;
       u8Km: // global
           call _c8K7(R1) args: 0, res: 0, upd: 0;
       c8K8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8K7() //  [R1]
         { info_tbl: [(c8K7,
                       label: block_c8K7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8K7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Kl; else goto c8Kk;
       c8Kl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Kk: // global
           _s7Vk::I64 = %MO_S_Rem_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Vk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.832933729 UTC

[section ""data" . GHC.Base.quotInt_closure" {
     GHC.Base.quotInt_closure:
         const GHC.Base.quotInt_info;
 },
 GHC.Base.quotInt_entry() //  [R2, R3]
         { info_tbl: [(c8Kv,
                       label: GHC.Base.quotInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Kv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8KH; else goto c8KI;
       c8KH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8KI: // global
           I64[Sp - 16] = block_c8Ks_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8KO; else goto c8Kt;
       u8KO: // global
           call _c8Ks(R1) args: 0, res: 0, upd: 0;
       c8Kt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ks() //  [R1]
         { info_tbl: [(c8Ks,
                       label: block_c8Ks_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ks: // global
           I64[Sp] = block_c8Ky_info;
           _s7Vo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Vo::I64;
           if (R1 & 7 != 0) goto u8KN; else goto c8Kz;
       u8KN: // global
           call _c8Ky(R1) args: 0, res: 0, upd: 0;
       c8Kz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ky() //  [R1]
         { info_tbl: [(c8Ky,
                       label: block_c8Ky_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ky: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8KM; else goto c8KL;
       c8KM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8KL: // global
           _s7Vr::I64 = %MO_S_Quot_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Vr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.834516049 UTC

[section ""data" . GHC.Base.getTag_closure" {
     GHC.Base.getTag_closure:
         const GHC.Base.getTag_info;
 },
 GHC.Base.getTag_entry() //  [R2]
         { info_tbl: [(c8KW,
                       label: GHC.Base.getTag_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8KX; else goto c8KY;
       c8KX: // global
           R2 = R2;
           R1 = GHC.Base.getTag_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8KY: // global
           I64[Sp - 8] = block_c8KT_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8KT() //  [R1]
         { info_tbl: [(c8KT,
                       label: block_c8KT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8KT: // global
           R1 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.835766984 UTC

[section ""data" . GHC.Base.$fMonadIO1_closure" {
     GHC.Base.$fMonadIO1_closure:
         const GHC.Base.$fMonadIO1_info;
 },
 GHC.Base.$fMonadIO1_entry() //  [R2, R3]
         { info_tbl: [(c8L6,
                       label: GHC.Base.$fMonadIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8L7; else goto c8L8;
       c8L7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8L8: // global
           I64[Sp - 16] = block_c8L4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8L4() //  [R1]
         { info_tbl: [(c8L4,
                       label: block_c8L4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8L4: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.836723609 UTC

[section ""data" . GHC.Base.bindIO_closure" {
     GHC.Base.bindIO_closure:
         const GHC.Base.bindIO_info;
 },
 GHC.Base.bindIO_entry() //  [R2, R3]
         { info_tbl: [(c8Le,
                       label: GHC.Base.bindIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Le: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fMonadIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.837620644 UTC

[section ""data" . GHC.Base.$fApplicativeIO2_closure" {
     GHC.Base.$fApplicativeIO2_closure:
         const GHC.Base.$fApplicativeIO2_info;
 },
 GHC.Base.$fApplicativeIO2_entry() //  [R2, R3]
         { info_tbl: [(c8Ln,
                       label: GHC.Base.$fApplicativeIO2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ln: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Lo; else goto c8Lp;
       c8Lo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Lp: // global
           I64[Sp - 16] = block_c8Ll_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ll() //  []
         { info_tbl: [(c8Ll,
                       label: block_c8Ll_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ll: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.83875003 UTC

[section ""data" . GHC.Base.thenIO_closure" {
     GHC.Base.thenIO_closure:
         const GHC.Base.thenIO_info;
 },
 GHC.Base.thenIO_entry() //  [R2, R3]
         { info_tbl: [(c8Lv,
                       label: GHC.Base.thenIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Lv: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeIO2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.839466494 UTC

[section ""data" . GHC.Base.unIO1_closure" {
     GHC.Base.unIO1_closure:
         const GHC.Base.unIO1_info;
 },
 GHC.Base.unIO1_entry() //  [R2]
         { info_tbl: [(c8LC,
                       label: GHC.Base.unIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LC: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.840200089 UTC

[section ""data" . GHC.Base.unIO_closure" {
     GHC.Base.unIO_closure:
         const GHC.Base.unIO_info;
 },
 GHC.Base.unIO_entry() //  [R2]
         { info_tbl: [(c8LJ,
                       label: GHC.Base.unIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LJ: // global
           R2 = R2;
           call GHC.Base.unIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.841112611 UTC

[section ""data" . GHC.Base.$fApplicativeIO4_closure" {
     GHC.Base.$fApplicativeIO4_closure:
         const GHC.Base.$fApplicativeIO4_info;
 },
 GHC.Base.$fApplicativeIO4_entry() //  [R2]
         { info_tbl: [(c8LQ,
                       label: GHC.Base.$fApplicativeIO4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LQ: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.841908908 UTC

[section ""data" . GHC.Base.returnIO_closure" {
     GHC.Base.returnIO_closure:
         const GHC.Base.returnIO_info;
 },
 GHC.Base.returnIO_entry() //  [R2]
         { info_tbl: [(c8LX,
                       label: GHC.Base.returnIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8LX: // global
           R2 = R2;
           call GHC.Base.$fApplicativeIO4_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.842854461 UTC

[section ""data" . GHC.Base.$fApplicativeIO3_closure" {
     GHC.Base.$fApplicativeIO3_closure:
         const GHC.Base.$fApplicativeIO3_info;
 },
 GHC.Base.$fApplicativeIO3_entry() //  [R2, R3]
         { info_tbl: [(c8M9,
                       label: GHC.Base.$fApplicativeIO3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ma; else goto c8Mb;
       c8Ma: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mb: // global
           I64[Sp - 16] = block_c8M4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8M4() //  [R1]
         { info_tbl: [(c8M4,
                       label: block_c8M4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M4: // global
           I64[Sp] = block_c8M6_info;
           _s7VN::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7VN::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8M6() //  [R1]
         { info_tbl: [(c8M6,
                       label: block_c8M6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8M6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Mf; else goto c8Me;
       c8Mf: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Me: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.844218112 UTC

[section ""data" . GHC.Base.liftA_$sliftA1_closure" {
     GHC.Base.liftA_$sliftA1_closure:
         const GHC.Base.liftA_$sliftA1_info;
 },
 GHC.Base.liftA_$sliftA1_entry() //  [R2, R3]
         { info_tbl: [(c8Mk,
                       label: GHC.Base.liftA_$sliftA1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mk: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.845099142 UTC

[section ""data" . GHC.Base.ap1_closure" {
     GHC.Base.ap1_closure:
         const GHC.Base.ap1_info;
 },
 GHC.Base.ap1_entry() //  [R2, R3]
         { info_tbl: [(c8Mw,
                       label: GHC.Base.ap1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Mx; else goto c8My;
       c8Mx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8My: // global
           I64[Sp - 16] = block_c8Mr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mr() //  [R1]
         { info_tbl: [(c8Mr,
                       label: block_c8Mr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mr: // global
           I64[Sp] = block_c8Mt_info;
           _s7VX::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7VX::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mt() //  [R1]
         { info_tbl: [(c8Mt,
                       label: block_c8Mt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8MC; else goto c8MB;
       c8MC: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8MB: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.846308256 UTC

[section ""data" . GHC.Base.ap_$sap1_closure" {
     GHC.Base.ap_$sap1_closure:
         const GHC.Base.ap_$sap1_info;
 },
 GHC.Base.ap_$sap1_entry() //  [R2, R3]
         { info_tbl: [(c8MH,
                       label: GHC.Base.ap_$sap1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MH: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.ap1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.847582724 UTC

[section ""data" . GHC.Base.ap_closure" {
     GHC.Base.ap_closure:
         const GHC.Base.ap_info;
 },
 sat_s7W8_entry() //  [R1, R2]
         { info_tbl: [(c8MZ,
                       label: sat_s7W8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MZ: // global
           _s7W6::P64 = R2;
           _s7W8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8N0; else goto c8N1;
       c8N1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8N3; else goto c8N2;
       c8N3: // global
           HpAlloc = 32;
           goto c8N0;
       c8N0: // global
           R2 = _s7W6::P64;
           R1 = _s7W8::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8N2: // global
           _s7W2::P64 = P64[_s7W8::P64 + 7];
           _s7W5::P64 = P64[_s7W8::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s7W5::P64;
           P64[Hp] = _s7W6::P64;
           R2 = _s7W2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7W9_entry() //  [R1, R2]
         { info_tbl: [(c8N4,
                       label: sat_s7W9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N4: // global
           _s7W5::P64 = R2;
           _s7W9::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8N5; else goto c8N6;
       c8N6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8N8; else goto c8N7;
       c8N8: // global
           HpAlloc = 24;
           goto c8N5;
       c8N5: // global
           R2 = _s7W5::P64;
           R1 = _s7W9::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8N7: // global
           _s7W2::P64 = P64[_s7W9::P64 + 7];
           _s7W4::P64 = P64[_s7W9::P64 + 15];
           I64[Hp - 16] = sat_s7W8_info;
           P64[Hp - 8] = _s7W2::P64;
           P64[Hp] = _s7W5::P64;
           R2 = _s7W2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7W4::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.ap_entry() //  [R2, R3, R4]
         { info_tbl: [(c8N9,
                       label: GHC.Base.ap_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N9: // global
           _s7W4::P64 = R4;
           _s7W3::P64 = R3;
           _s7W2::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Na; else goto c8Nb;
       c8Nb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Nd; else goto c8Nc;
       c8Nd: // global
           HpAlloc = 24;
           goto c8Na;
       c8Na: // global
           R4 = _s7W4::P64;
           R3 = _s7W3::P64;
           R2 = _s7W2::P64;
           R1 = GHC.Base.ap_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Nc: // global
           I64[Hp - 16] = sat_s7W9_info;
           P64[Hp - 8] = _s7W2::P64;
           P64[Hp] = _s7W4::P64;
           R2 = _s7W2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7W3::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.849454398 UTC

[section ""data" . GHC.Base.liftM1_closure" {
     GHC.Base.liftM1_closure:
         const GHC.Base.liftM1_info;
 },
 GHC.Base.liftM1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Nn,
                       label: GHC.Base.liftM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8No; else goto c8Np;
       c8No: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Np: // global
           I64[Sp - 24] = block_c8Ni_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ni() //  [R1]
         { info_tbl: [(c8Ni,
                       label: block_c8Ni_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ni: // global
           I64[Sp] = block_c8Nk_info;
           _s7Wg::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Wg::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nk() //  [R1]
         { info_tbl: [(c8Nk,
                       label: block_c8Nk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Nt; else goto c8Ns;
       c8Nt: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ns: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.850864818 UTC

[section ""data" . GHC.Base.liftM2_$sliftM1_closure" {
     GHC.Base.liftM2_$sliftM1_closure:
         const GHC.Base.liftM2_$sliftM1_info;
 },
 GHC.Base.liftM2_$sliftM1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Ny,
                       label: GHC.Base.liftM2_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ny: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.852067745 UTC

[section ""data" . GHC.Base.liftM2_closure" {
     GHC.Base.liftM2_closure:
         const GHC.Base.liftM2_info;
 },
 sat_s7Ws_entry() //  [R1, R2]
         { info_tbl: [(c8NQ,
                       label: sat_s7Ws_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NQ: // global
           _s7Wq::P64 = R2;
           _s7Ws::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8NR; else goto c8NS;
       c8NS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8NU; else goto c8NT;
       c8NU: // global
           HpAlloc = 40;
           goto c8NR;
       c8NR: // global
           R2 = _s7Wq::P64;
           R1 = _s7Ws::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NT: // global
           _s7Wl::P64 = P64[_s7Ws::P64 + 7];
           _s7Wm::P64 = P64[_s7Ws::P64 + 15];
           _s7Wp::P64 = P64[_s7Ws::P64 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _s7Wm::P64;
           P64[Hp - 8] = _s7Wp::P64;
           P64[Hp] = _s7Wq::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7Wt_entry() //  [R1, R2]
         { info_tbl: [(c8NV,
                       label: sat_s7Wt_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NV: // global
           _s7Wp::P64 = R2;
           _s7Wt::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8NW; else goto c8NX;
       c8NX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8NZ; else goto c8NY;
       c8NZ: // global
           HpAlloc = 32;
           goto c8NW;
       c8NW: // global
           R2 = _s7Wp::P64;
           R1 = _s7Wt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NY: // global
           _s7Wl::P64 = P64[_s7Wt::P64 + 7];
           _s7Wm::P64 = P64[_s7Wt::P64 + 15];
           _s7Wo::P64 = P64[_s7Wt::P64 + 23];
           I64[Hp - 24] = sat_s7Ws_info;
           P64[Hp - 16] = _s7Wl::P64;
           P64[Hp - 8] = _s7Wm::P64;
           P64[Hp] = _s7Wp::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Wo::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8O0,
                       label: GHC.Base.liftM2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8O0: // global
           _s7Wo::P64 = R5;
           _s7Wn::P64 = R4;
           _s7Wm::P64 = R3;
           _s7Wl::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8O1; else goto c8O2;
       c8O2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8O4; else goto c8O3;
       c8O4: // global
           HpAlloc = 32;
           goto c8O1;
       c8O1: // global
           R5 = _s7Wo::P64;
           R4 = _s7Wn::P64;
           R3 = _s7Wm::P64;
           R2 = _s7Wl::P64;
           R1 = GHC.Base.liftM2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8O3: // global
           I64[Hp - 24] = sat_s7Wt_info;
           P64[Hp - 16] = _s7Wl::P64;
           P64[Hp - 8] = _s7Wm::P64;
           P64[Hp] = _s7Wo::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Wn::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.854278279 UTC

[section ""data" . $cliftA2_r7PG_closure" {
     $cliftA2_r7PG_closure:
         const $cliftA2_r7PG_info;
 },
 $cliftA2_r7PG_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Oe,
                       label: $cliftA2_r7PG_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Of; else goto c8Og;
       c8Of: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Og: // global
           I64[Sp - 24] = block_c8O9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8O9() //  [R1]
         { info_tbl: [(c8O9,
                       label: block_c8O9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8O9: // global
           I64[Sp] = block_c8Ob_info;
           _s7WA::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WA::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ob() //  [R1]
         { info_tbl: [(c8Ob,
                       label: block_c8Ob_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ob: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Ok; else goto c8Oj;
       c8Ok: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Oj: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.855520104 UTC

[section ""data" . GHC.Base.$fApplicativeIO_$cliftA2_closure" {
     GHC.Base.$fApplicativeIO_$cliftA2_closure:
         const GHC.Base.$fApplicativeIO_$cliftA2_info;
 },
 GHC.Base.$fApplicativeIO_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Op,
                       label: GHC.Base.$fApplicativeIO_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Op: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.856814007 UTC

[section ""data" . GHC.Base.liftA1_closure" {
     GHC.Base.liftA1_closure:
         const GHC.Base.liftA1_info;
 },
 GHC.Base.liftA1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8OD,
                       label: GHC.Base.liftA1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8OE; else goto c8OF;
       c8OE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OF: // global
           I64[Sp - 32] = block_c8Ow_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ow() //  [R1]
         { info_tbl: [(c8Ow,
                       label: block_c8Ow_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ow: // global
           I64[Sp] = block_c8Oy_info;
           _s7WM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WM::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oy() //  [R1]
         { info_tbl: [(c8Oy,
                       label: block_c8Oy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oy: // global
           I64[Sp] = block_c8OA_info;
           _s7WP::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7WP::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OA() //  [R1]
         { info_tbl: [(c8OA,
                       label: block_c8OA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8OK; else goto c8OJ;
       c8OK: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OJ: // global
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.858283295 UTC

[section ""data" . GHC.Base.liftA3_$sliftA1_closure" {
     GHC.Base.liftA3_$sliftA1_closure:
         const GHC.Base.liftA3_$sliftA1_info;
 },
 GHC.Base.liftA3_$sliftA1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8OP,
                       label: GHC.Base.liftA3_$sliftA1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OP: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.859698218 UTC

[section ""data" . GHC.Base.$fSemigroupIO2_closure" {
     GHC.Base.$fSemigroupIO2_closure:
         const GHC.Base.$fSemigroupIO2_info;
 },
 sat_s7X4_entry() //  [R1]
         { info_tbl: [(c8P4,
                       label: sat_s7X4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8P4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8P5; else goto c8P6;
       c8P5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8P6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupIO2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8P7,
                       label: GHC.Base.$fSemigroupIO2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8P7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8P8; else goto c8P9;
       c8P8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8P9: // global
           I64[Sp - 24] = block_c8OW_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OW() //  [R1]
         { info_tbl: [(c8OW,
                       label: block_c8OW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OW: // global
           I64[Sp] = block_c8OY_info;
           _s7X0::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7X0::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OY() //  [R1]
         { info_tbl: [(c8OY,
                       label: block_c8OY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Pd; else goto c8Pc;
       c8Pd: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Pc: // global
           I64[Hp - 32] = sat_s7X4_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.861931783 UTC

[section ""data" . GHC.Base.$w$csconcat4_closure" {
     GHC.Base.$w$csconcat4_closure:
         const GHC.Base.$w$csconcat4_info;
 },
 sat_s7Xm_entry() //  [R1]
         { info_tbl: [(c8PB,
                       label: sat_s7Xm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8PC; else goto c8PD;
       c8PC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8PD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s7X9_entry() //  [R1, R2, R3]
         { info_tbl: [(c8PI,
                       label: go_s7X9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8PJ; else goto c8PK;
       c8PJ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8PK: // global
           I64[Sp - 32] = block_c8Pn_info;
           _s7X9::P64 = R1;
           _s7X5::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 24] = _s7X5::P64;
           P64[Sp - 16] = _s7X9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8PS; else goto c8Po;
       u8PS: // global
           call _c8Pn(R1) args: 0, res: 0, upd: 0;
       c8Po: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Pn() //  [R1]
         { info_tbl: [(c8Pn,
                       label: block_c8Pn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Pn: // global
           _s7Xa::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c8PF; else goto c8PG;
       c8PF: // global
           R1 = _s7Xa::P64;
           Sp = Sp + 32;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       c8PG: // global
           I64[Sp - 8] = block_c8Pt_info;
           _s7Xe::P64 = P64[R1 + 6];
           _s7Xf::P64 = P64[R1 + 14];
           R1 = _s7Xa::P64;
           P64[Sp] = _s7Xf::P64;
           P64[Sp + 24] = _s7Xe::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Pt() //  [R1]
         { info_tbl: [(c8Pt,
                       label: block_c8Pt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Pt: // global
           _s7Xf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Pv_info;
           R3 = _s7Xf::P64;
           R2 = P64[Sp + 32];
           _s7Xi::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 32] = _s7Xi::P64;
           Sp = Sp + 8;
           call go_s7X9_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Pv() //  [R1]
         { info_tbl: [(c8Pv,
                       label: block_c8Pv_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Pv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8PR; else goto c8PQ;
       c8PR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8PQ: // global
           I64[Hp - 32] = sat_s7Xm_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat4_entry() //  [R2, R3, R4]
         { info_tbl: [(c8PT,
                       label: GHC.Base.$w$csconcat4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8PX; else goto c8PW;
       c8PX: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8PW: // global
           I64[Hp - 8] = go_s7X9_info;
           P64[Hp] = R2;
           _s7X6::P64 = R3;
           R3 = R4;
           R2 = _s7X6::P64;
           R1 = Hp - 5;
           call go_s7X9_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.86442021 UTC

[section ""data" . GHC.Base.$fSemigroupIO1_closure" {
     GHC.Base.$fSemigroupIO1_closure:
         const GHC.Base.$fSemigroupIO1_info;
 },
 GHC.Base.$fSemigroupIO1_entry() //  [R2, R3]
         { info_tbl: [(c8Q5,
                       label: GHC.Base.$fSemigroupIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Q6; else goto c8Q7;
       c8Q6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q7: // global
           I64[Sp - 16] = block_c8Q2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Qb; else goto c8Q3;
       u8Qb: // global
           call _c8Q2(R1) args: 0, res: 0, upd: 0;
       c8Q3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q2() //  [R1]
         { info_tbl: [(c8Q2,
                       label: block_c8Q2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q2: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat4_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.866431569 UTC

[section ""data" . GHC.Base.$fSemigroupIO_closure" {
     GHC.Base.$fSemigroupIO_closure:
         const GHC.Base.$fSemigroupIO_info;
         const 0;
 },
 sat_s7Xw_entry() //  [R1, R2]
         { info_tbl: [(c8Ql,
                       label: sat_s7Xw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ql: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupIO_$cstimes_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Xv_entry() //  [R1, R2]
         { info_tbl: [(c8Qt,
                       label: sat_s7Xv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qt: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroupIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Xu_entry() //  [R1, R2, R3]
         { info_tbl: [(c8QB,
                       label: sat_s7Xu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroupIO2_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroupIO_entry() //  [R2]
         { info_tbl: [(c8QF,
                       label: GHC.Base.$fSemigroupIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8QJ; else goto c8QI;
       c8QJ: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QI: // global
           I64[Hp - 72] = sat_s7Xw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s7Xv_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s7Xu_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 54;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.$fSemigroupIO_$cstimes_closure" {
     GHC.Base.$fSemigroupIO_$cstimes_closure:
         const GHC.Base.$fSemigroupIO_$cstimes_info;
         const 0;
 },
 sat_s7Xz_entry() //  [R1]
         { info_tbl: [(c8QS,
                       label: sat_s7Xz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QT; else goto c8QU;
       c8QT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupIO_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(c8QV,
                       label: GHC.Base.$fSemigroupIO_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8QZ; else goto c8QY;
       c8QZ: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QY: // global
           I64[Hp - 16] = sat_s7Xz_info;
           P64[Hp] = R2;
           _s7Xy::P64 = R3;
           R3 = Hp - 16;
           R2 = _s7Xy::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.868465662 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cp1Monoid_closure" {
     GHC.Base.$fMonoidIO_$cp1Monoid_closure:
         const GHC.Base.$fMonoidIO_$cp1Monoid_info;
         const 0;
 },
 sat_s7XB_entry() //  [R1]
         { info_tbl: [(c8R9,
                       label: sat_s7XB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ra; else goto c8Rb;
       c8Ra: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidIO_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(c8Rc,
                       label: GHC.Base.$fMonoidIO_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Rg; else goto c8Rf;
       c8Rg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Rf: // global
           I64[Hp - 16] = sat_s7XB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.870146762 UTC

[section ""data" . $cmappend_r7PH_closure" {
     $cmappend_r7PH_closure:
         const $cmappend_r7PH_info;
 },
 sat_s7XN_entry() //  [R1]
         { info_tbl: [(c8Rv,
                       label: sat_s7XN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Rw; else goto c8Rx;
       c8Rw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8Rt_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Rt() //  [R1]
         { info_tbl: [(c8Rt,
                       label: block_c8Rt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rt: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $cmappend_r7PH_entry() //  [R2, R3, R4]
         { info_tbl: [(c8RB,
                       label: $cmappend_r7PH_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RC; else goto c8RD;
       c8RC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RD: // global
           I64[Sp - 24] = block_c8Rl_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rl() //  [R1]
         { info_tbl: [(c8Rl,
                       label: block_c8Rl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rl: // global
           I64[Sp] = block_c8Rn_info;
           _s7XI::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7XI::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rn() //  [R1]
         { info_tbl: [(c8Rn,
                       label: block_c8Rn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8RH; else goto c8RG;
       c8RH: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RG: // global
           I64[Hp - 32] = sat_s7XN_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.871724846 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cmappend_closure" {
     GHC.Base.$fMonoidIO_$cmappend_closure:
         const GHC.Base.$fMonoidIO_$cmappend_info;
 },
 GHC.Base.$fMonoidIO_$cmappend_entry() //  [R2, R3, R4]
         { info_tbl: [(c8RM,
                       label: GHC.Base.$fMonoidIO_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.872643726 UTC

[section ""data" . GHC.Base.$fAlternativeIO1_closure" {
     GHC.Base.$fAlternativeIO1_closure:
         const GHC.Base.$fAlternativeIO1_info;
 },
 GHC.Base.$fAlternativeIO1_entry() //  []
         { info_tbl: [(c8RT,
                       label: GHC.Base.$fAlternativeIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RT: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.873770992 UTC

[section ""data" . GHC.Base.$fAlternativeIO2_closure" {
     GHC.Base.$fAlternativeIO2_closure:
         const GHC.Base.$fAlternativeIO2_info;
         const 0;
 },
 some_v_s7XR_entry() //  [R1]
         { info_tbl: [(c8Sa,
                       label: some_v_s7XR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Sa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Sb; else goto c8Sc;
       c8Sb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8Sc: // global
           I64[Sp - 16] = block_c8S5_info;
           _s7XR::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s7XR::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8S5() //  [R1]
         { info_tbl: [(c8S5,
                       label: block_c8S5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8S5: // global
           I64[Sp] = block_c8S7_info;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = P64[Sp + 8];
           _s7XV::P64 = R1;
           R1 = GHC.IO.mplusIO_closure;
           P64[Sp + 8] = _s7XV::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8S7() //  [R1]
         { info_tbl: [(c8S7,
                       label: block_c8S7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8S7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Sg; else goto c8Sf;
       c8Sg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Sf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fAlternativeIO2_entry() //  [R2]
         { info_tbl: [(c8Sh,
                       label: GHC.Base.$fAlternativeIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Sh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Sl; else goto c8Sk;
       c8Sl: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Sk: // global
           I64[Hp - 8] = some_v_s7XR_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_s7XR_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.875891372 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cmany_closure" {
     GHC.Base.$fAlternativeIO_$cmany_closure:
         const GHC.Base.$fAlternativeIO_$cmany_info;
         const 0;
 },
 sat_s7Ya_entry() //  [R1]
         { info_tbl: [(c8SE,
                       label: sat_s7Ya_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8SE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8SF; else goto c8SG;
       c8SF: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c8SG: // global
           I64[Sp - 16] = block_c8Sz_info;
           _s7Y1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s7Y1::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Sz() //  [R1]
         { info_tbl: [(c8Sz,
                       label: block_c8Sz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Sz: // global
           I64[Sp] = block_c8SB_info;
           _s7Y5::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Y5::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8SB() //  [R1]
         { info_tbl: [(c8SB,
                       label: block_c8SB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8SB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8SK; else goto c8SJ;
       c8SK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8SJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v_s7Y1_entry() //  [R1]
         { info_tbl: [(c8SL,
                       label: many_v_s7Y1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8SL: // global
           _s7Y1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8SM; else goto c8SN;
       c8SN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8SP; else goto c8SO;
       c8SP: // global
           HpAlloc = 24;
           goto c8SM;
       c8SM: // global
           R1 = _s7Y1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8SO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Y1::P64;
           _s7Y0::P64 = P64[_s7Y1::P64 + 16];
           I64[Hp - 16] = sat_s7Ya_info;
           P64[Hp - 8] = _s7Y0::P64;
           P64[Hp] = _s7Y1::P64;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = Hp - 15;
           R1 = GHC.IO.mplusIO_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeIO_$cmany_entry() //  [R2]
         { info_tbl: [(c8SQ,
                       label: GHC.Base.$fAlternativeIO_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8SQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8SU; else goto c8ST;
       c8SU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ST: // global
           I64[Hp - 16] = many_v_s7Y1_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.877991317 UTC

[section ""data" . GHC.Base.liftM9_closure" {
     GHC.Base.liftM9_closure:
         const GHC.Base.liftM9_info;
 },
 GHC.Base.liftM9_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8Ta,
                       label: GHC.Base.liftM9_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ta: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Tb; else goto c8Tc;
       c8Tb: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM9_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8Tc: // global
           I64[Sp - 40] = block_c8SZ_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8SZ() //  [R1]
         { info_tbl: [(c8SZ,
                       label: block_c8SZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8SZ: // global
           I64[Sp] = block_c8T1_info;
           _s7Yk::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Yk::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8T1() //  [R1]
         { info_tbl: [(c8T1,
                       label: block_c8T1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8T1: // global
           I64[Sp] = block_c8T3_info;
           _s7Yn::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Yn::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8T3() //  [R1]
         { info_tbl: [(c8T3,
                       label: block_c8T3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8T3: // global
           I64[Sp] = block_c8T5_info;
           _s7Yq::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Yq::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8T5() //  [R1]
         { info_tbl: [(c8T5,
                       label: block_c8T5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8T5: // global
           I64[Sp] = block_c8T7_info;
           _s7Yt::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s7Yt::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8T7() //  [R1]
         { info_tbl: [(c8T7,
                       label: block_c8T7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8T7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Tj; else goto c8Ti;
       c8Tj: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ti: // global
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R1 = Hp - 56;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.879930315 UTC

[section ""data" . GHC.Base.liftM5_$sliftM1_closure" {
     GHC.Base.liftM5_$sliftM1_closure:
         const GHC.Base.liftM5_$sliftM1_info;
 },
 GHC.Base.liftM5_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8To,
                       label: GHC.Base.liftM5_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8To: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM9_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.882138661 UTC

[section ""data" . GHC.Base.liftM5_closure" {
     GHC.Base.liftM5_closure:
         const GHC.Base.liftM5_info;
 },
 GHC.Base.liftM5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ts: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.liftM5_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2,
                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7YL_entry() //  [R1, R2]
         { info_tbl: [(c8TW,
                       label: sat_s7YL_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8TW: // global
           _s7YJ::P64 = R2;
           _s7YL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8TX; else goto c8TY;
       c8TY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8U0; else goto c8TZ;
       c8U0: // global
           HpAlloc = 64;
           goto c8TX;
       c8TX: // global
           R2 = _s7YJ::P64;
           R1 = _s7YL::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8TZ: // global
           _s7Yy::P64 = P64[_s7YL::P64 + 7];
           _s7Yz::P64 = P64[_s7YL::P64 + 15];
           _s7YF::P64 = P64[_s7YL::P64 + 23];
           _s7YG::P64 = P64[_s7YL::P64 + 31];
           _s7YH::P64 = P64[_s7YL::P64 + 39];
           _s7YI::P64 = P64[_s7YL::P64 + 47];
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = _s7Yz::P64;
           P64[Hp - 32] = _s7YF::P64;
           P64[Hp - 24] = _s7YG::P64;
           P64[Hp - 16] = _s7YH::P64;
           P64[Hp - 8] = _s7YI::P64;
           P64[Hp] = _s7YJ::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7YM_entry() //  [R1, R2]
         { info_tbl: [(c8U1,
                       label: sat_s7YM_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U1: // global
           _s7YI::P64 = R2;
           _s7YM::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8U2; else goto c8U3;
       c8U3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8U5; else goto c8U4;
       c8U5: // global
           HpAlloc = 56;
           goto c8U2;
       c8U2: // global
           R2 = _s7YI::P64;
           R1 = _s7YM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8U4: // global
           _s7Yy::P64 = P64[_s7YM::P64 + 7];
           _s7Yz::P64 = P64[_s7YM::P64 + 15];
           _s7YE::P64 = P64[_s7YM::P64 + 23];
           _s7YF::P64 = P64[_s7YM::P64 + 31];
           _s7YG::P64 = P64[_s7YM::P64 + 39];
           _s7YH::P64 = P64[_s7YM::P64 + 47];
           I64[Hp - 48] = sat_s7YL_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YF::P64;
           P64[Hp - 16] = _s7YG::P64;
           P64[Hp - 8] = _s7YH::P64;
           P64[Hp] = _s7YI::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YE::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7YN_entry() //  [R1, R2]
         { info_tbl: [(c8U6,
                       label: sat_s7YN_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U6: // global
           _s7YH::P64 = R2;
           _s7YN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8U7; else goto c8U8;
       c8U8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Ua; else goto c8U9;
       c8Ua: // global
           HpAlloc = 56;
           goto c8U7;
       c8U7: // global
           R2 = _s7YH::P64;
           R1 = _s7YN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8U9: // global
           _s7Yy::P64 = P64[_s7YN::P64 + 7];
           _s7Yz::P64 = P64[_s7YN::P64 + 15];
           _s7YD::P64 = P64[_s7YN::P64 + 23];
           _s7YE::P64 = P64[_s7YN::P64 + 31];
           _s7YF::P64 = P64[_s7YN::P64 + 39];
           _s7YG::P64 = P64[_s7YN::P64 + 47];
           I64[Hp - 48] = sat_s7YM_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YE::P64;
           P64[Hp - 16] = _s7YF::P64;
           P64[Hp - 8] = _s7YG::P64;
           P64[Hp] = _s7YH::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YD::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7YO_entry() //  [R1, R2]
         { info_tbl: [(c8Ub,
                       label: sat_s7YO_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ub: // global
           _s7YG::P64 = R2;
           _s7YO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Uc; else goto c8Ud;
       c8Ud: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Uf; else goto c8Ue;
       c8Uf: // global
           HpAlloc = 56;
           goto c8Uc;
       c8Uc: // global
           R2 = _s7YG::P64;
           R1 = _s7YO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Ue: // global
           _s7Yy::P64 = P64[_s7YO::P64 + 7];
           _s7Yz::P64 = P64[_s7YO::P64 + 15];
           _s7YC::P64 = P64[_s7YO::P64 + 23];
           _s7YD::P64 = P64[_s7YO::P64 + 31];
           _s7YE::P64 = P64[_s7YO::P64 + 39];
           _s7YF::P64 = P64[_s7YO::P64 + 47];
           I64[Hp - 48] = sat_s7YN_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YD::P64;
           P64[Hp - 16] = _s7YE::P64;
           P64[Hp - 8] = _s7YF::P64;
           P64[Hp] = _s7YG::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YC::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7YP_entry() //  [R1, R2]
         { info_tbl: [(c8Ug,
                       label: sat_s7YP_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ug: // global
           _s7YF::P64 = R2;
           _s7YP::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Uh; else goto c8Ui;
       c8Ui: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Uk; else goto c8Uj;
       c8Uk: // global
           HpAlloc = 56;
           goto c8Uh;
       c8Uh: // global
           R2 = _s7YF::P64;
           R1 = _s7YP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Uj: // global
           _s7Yy::P64 = P64[_s7YP::P64 + 7];
           _s7Yz::P64 = P64[_s7YP::P64 + 15];
           _s7YB::P64 = P64[_s7YP::P64 + 23];
           _s7YC::P64 = P64[_s7YP::P64 + 31];
           _s7YD::P64 = P64[_s7YP::P64 + 39];
           _s7YE::P64 = P64[_s7YP::P64 + 47];
           I64[Hp - 48] = sat_s7YO_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YC::P64;
           P64[Hp - 16] = _s7YD::P64;
           P64[Hp - 8] = _s7YE::P64;
           P64[Hp] = _s7YF::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YB::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8Ul,
                       label: GHC.Base.liftM5_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ul: // global
           _s7YC::P64 = R6;
           _s7YB::P64 = R5;
           _s7YA::P64 = R4;
           _s7Yz::P64 = R3;
           _s7Yy::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c8Um; else goto c8Un;
       c8Un: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Up; else goto c8Uo;
       c8Up: // global
           HpAlloc = 56;
           goto c8Um;
       c8Um: // global
           R1 = GHC.Base.liftM5_closure;
           P64[Sp - 40] = _s7Yy::P64;
           P64[Sp - 32] = _s7Yz::P64;
           P64[Sp - 24] = _s7YA::P64;
           P64[Sp - 16] = _s7YB::P64;
           P64[Sp - 8] = _s7YC::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       c8Uo: // global
           I64[Hp - 48] = sat_s7YP_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YB::P64;
           P64[Hp - 16] = _s7YC::P64;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R2 = _s7Yy::P64;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s7YA::P64;
           P64[Sp + 8] = Hp - 47;
           Sp = Sp - 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.886091902 UTC

[section ""data" . GHC.Base.liftM8_closure" {
     GHC.Base.liftM8_closure:
         const GHC.Base.liftM8_info;
 },
 GHC.Base.liftM8_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8UD,
                       label: GHC.Base.liftM8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8UE; else goto c8UF;
       c8UE: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM8_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UF: // global
           I64[Sp - 40] = block_c8Uu_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uu() //  [R1]
         { info_tbl: [(c8Uu,
                       label: block_c8Uu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uu: // global
           I64[Sp] = block_c8Uw_info;
           _s7YY::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7YY::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uw() //  [R1]
         { info_tbl: [(c8Uw,
                       label: block_c8Uw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uw: // global
           I64[Sp] = block_c8Uy_info;
           _s7Z1::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Z1::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uy() //  [R1]
         { info_tbl: [(c8Uy,
                       label: block_c8Uy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uy: // global
           I64[Sp] = block_c8UA_info;
           _s7Z4::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Z4::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UA() //  [R1]
         { info_tbl: [(c8UA,
                       label: block_c8UA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8UL; else goto c8UK;
       c8UL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UK: // global
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R1 = Hp - 48;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.887827273 UTC

[section ""data" . GHC.Base.liftM4_$sliftM1_closure" {
     GHC.Base.liftM4_$sliftM1_closure:
         const GHC.Base.liftM4_$sliftM1_info;
 },
 GHC.Base.liftM4_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8UQ,
                       label: GHC.Base.liftM4_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM8_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.889428615 UTC

[section ""data" . GHC.Base.liftM4_closure" {
     GHC.Base.liftM4_closure:
         const GHC.Base.liftM4_info;
 },
 sat_s7Zk_entry() //  [R1, R2]
         { info_tbl: [(c8Vi,
                       label: sat_s7Zk_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vi: // global
           _s7Zi::P64 = R2;
           _s7Zk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Vj; else goto c8Vk;
       c8Vk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Vm; else goto c8Vl;
       c8Vm: // global
           HpAlloc = 56;
           goto c8Vj;
       c8Vj: // global
           R2 = _s7Zi::P64;
           R1 = _s7Zk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Vl: // global
           _s7Z9::P64 = P64[_s7Zk::P64 + 7];
           _s7Za::P64 = P64[_s7Zk::P64 + 15];
           _s7Zf::P64 = P64[_s7Zk::P64 + 23];
           _s7Zg::P64 = P64[_s7Zk::P64 + 31];
           _s7Zh::P64 = P64[_s7Zk::P64 + 39];
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = _s7Za::P64;
           P64[Hp - 24] = _s7Zf::P64;
           P64[Hp - 16] = _s7Zg::P64;
           P64[Hp - 8] = _s7Zh::P64;
           P64[Hp] = _s7Zi::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7Zl_entry() //  [R1, R2]
         { info_tbl: [(c8Vn,
                       label: sat_s7Zl_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vn: // global
           _s7Zh::P64 = R2;
           _s7Zl::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Vo; else goto c8Vp;
       c8Vp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Vr; else goto c8Vq;
       c8Vr: // global
           HpAlloc = 48;
           goto c8Vo;
       c8Vo: // global
           R2 = _s7Zh::P64;
           R1 = _s7Zl::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Vq: // global
           _s7Z9::P64 = P64[_s7Zl::P64 + 7];
           _s7Za::P64 = P64[_s7Zl::P64 + 15];
           _s7Ze::P64 = P64[_s7Zl::P64 + 23];
           _s7Zf::P64 = P64[_s7Zl::P64 + 31];
           _s7Zg::P64 = P64[_s7Zl::P64 + 39];
           I64[Hp - 40] = sat_s7Zk_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zf::P64;
           P64[Hp - 8] = _s7Zg::P64;
           P64[Hp] = _s7Zh::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Ze::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7Zm_entry() //  [R1, R2]
         { info_tbl: [(c8Vs,
                       label: sat_s7Zm_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vs: // global
           _s7Zg::P64 = R2;
           _s7Zm::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Vt; else goto c8Vu;
       c8Vu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Vw; else goto c8Vv;
       c8Vw: // global
           HpAlloc = 48;
           goto c8Vt;
       c8Vt: // global
           R2 = _s7Zg::P64;
           R1 = _s7Zm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Vv: // global
           _s7Z9::P64 = P64[_s7Zm::P64 + 7];
           _s7Za::P64 = P64[_s7Zm::P64 + 15];
           _s7Zd::P64 = P64[_s7Zm::P64 + 23];
           _s7Ze::P64 = P64[_s7Zm::P64 + 31];
           _s7Zf::P64 = P64[_s7Zm::P64 + 39];
           I64[Hp - 40] = sat_s7Zl_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Ze::P64;
           P64[Hp - 8] = _s7Zf::P64;
           P64[Hp] = _s7Zg::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zd::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7Zn_entry() //  [R1, R2]
         { info_tbl: [(c8Vx,
                       label: sat_s7Zn_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vx: // global
           _s7Zf::P64 = R2;
           _s7Zn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Vy; else goto c8Vz;
       c8Vz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8VB; else goto c8VA;
       c8VB: // global
           HpAlloc = 48;
           goto c8Vy;
       c8Vy: // global
           R2 = _s7Zf::P64;
           R1 = _s7Zn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8VA: // global
           _s7Z9::P64 = P64[_s7Zn::P64 + 7];
           _s7Za::P64 = P64[_s7Zn::P64 + 15];
           _s7Zc::P64 = P64[_s7Zn::P64 + 23];
           _s7Zd::P64 = P64[_s7Zn::P64 + 31];
           _s7Ze::P64 = P64[_s7Zn::P64 + 39];
           I64[Hp - 40] = sat_s7Zm_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zd::P64;
           P64[Hp - 8] = _s7Ze::P64;
           P64[Hp] = _s7Zf::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zc::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8VC,
                       label: GHC.Base.liftM4_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VC: // global
           _s7Zd::P64 = R6;
           _s7Zc::P64 = R5;
           _s7Zb::P64 = R4;
           _s7Za::P64 = R3;
           _s7Z9::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8VD; else goto c8VE;
       c8VE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8VG; else goto c8VF;
       c8VG: // global
           HpAlloc = 48;
           goto c8VD;
       c8VD: // global
           R6 = _s7Zd::P64;
           R5 = _s7Zc::P64;
           R4 = _s7Zb::P64;
           R3 = _s7Za::P64;
           R2 = _s7Z9::P64;
           R1 = GHC.Base.liftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8VF: // global
           I64[Hp - 40] = sat_s7Zn_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zc::P64;
           P64[Hp - 8] = _s7Zd::P64;
           P64[Hp] = P64[Sp];
           R2 = _s7Z9::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s7Zb::P64;
           P64[Sp] = Hp - 39;
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.892579588 UTC

[section ""data" . GHC.Base.liftM3_$sliftM1_closure" {
     GHC.Base.liftM3_$sliftM1_closure:
         const GHC.Base.liftM3_$sliftM1_info;
 },
 GHC.Base.liftM3_$sliftM1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8VL,
                       label: GHC.Base.liftM3_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.894865039 UTC

[section ""data" . GHC.Base.liftM3_closure" {
     GHC.Base.liftM3_closure:
         const GHC.Base.liftM3_info;
 },
 sat_s7Zx_entry() //  [R1, R2]
         { info_tbl: [(c8W8,
                       label: sat_s7Zx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W8: // global
           _s7Zv::P64 = R2;
           _s7Zx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8W9; else goto c8Wa;
       c8Wa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Wc; else goto c8Wb;
       c8Wc: // global
           HpAlloc = 48;
           goto c8W9;
       c8W9: // global
           R2 = _s7Zv::P64;
           R1 = _s7Zx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Wb: // global
           _s7Zo::P64 = P64[_s7Zx::P64 + 7];
           _s7Zp::P64 = P64[_s7Zx::P64 + 15];
           _s7Zt::P64 = P64[_s7Zx::P64 + 23];
           _s7Zu::P64 = P64[_s7Zx::P64 + 31];
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = _s7Zp::P64;
           P64[Hp - 16] = _s7Zt::P64;
           P64[Hp - 8] = _s7Zu::P64;
           P64[Hp] = _s7Zv::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7Zy_entry() //  [R1, R2]
         { info_tbl: [(c8Wd,
                       label: sat_s7Zy_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wd: // global
           _s7Zu::P64 = R2;
           _s7Zy::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8We; else goto c8Wf;
       c8Wf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Wh; else goto c8Wg;
       c8Wh: // global
           HpAlloc = 40;
           goto c8We;
       c8We: // global
           R2 = _s7Zu::P64;
           R1 = _s7Zy::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Wg: // global
           _s7Zo::P64 = P64[_s7Zy::P64 + 7];
           _s7Zp::P64 = P64[_s7Zy::P64 + 15];
           _s7Zs::P64 = P64[_s7Zy::P64 + 23];
           _s7Zt::P64 = P64[_s7Zy::P64 + 31];
           I64[Hp - 32] = sat_s7Zx_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zt::P64;
           P64[Hp] = _s7Zu::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zs::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7Zz_entry() //  [R1, R2]
         { info_tbl: [(c8Wi,
                       label: sat_s7Zz_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wi: // global
           _s7Zt::P64 = R2;
           _s7Zz::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Wj; else goto c8Wk;
       c8Wk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Wm; else goto c8Wl;
       c8Wm: // global
           HpAlloc = 40;
           goto c8Wj;
       c8Wj: // global
           R2 = _s7Zt::P64;
           R1 = _s7Zz::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Wl: // global
           _s7Zo::P64 = P64[_s7Zz::P64 + 7];
           _s7Zp::P64 = P64[_s7Zz::P64 + 15];
           _s7Zr::P64 = P64[_s7Zz::P64 + 23];
           _s7Zs::P64 = P64[_s7Zz::P64 + 31];
           I64[Hp - 32] = sat_s7Zy_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zs::P64;
           P64[Hp] = _s7Zt::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zr::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8Wn,
                       label: GHC.Base.liftM3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wn: // global
           _s7Zs::P64 = R6;
           _s7Zr::P64 = R5;
           _s7Zq::P64 = R4;
           _s7Zp::P64 = R3;
           _s7Zo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Wo; else goto c8Wp;
       c8Wp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Wr; else goto c8Wq;
       c8Wr: // global
           HpAlloc = 40;
           goto c8Wo;
       c8Wo: // global
           R6 = _s7Zs::P64;
           R5 = _s7Zr::P64;
           R4 = _s7Zq::P64;
           R3 = _s7Zp::P64;
           R2 = _s7Zo::P64;
           R1 = GHC.Base.liftM3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Wq: // global
           I64[Hp - 32] = sat_s7Zz_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zr::P64;
           P64[Hp] = _s7Zs::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zq::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.897312267 UTC

[section ""data" . GHC.Base.liftM_$sliftM1_closure" {
     GHC.Base.liftM_$sliftM1_closure:
         const GHC.Base.liftM_$sliftM1_info;
 },
 GHC.Base.liftM_$sliftM1_entry() //  [R2, R3]
         { info_tbl: [(c8Ww,
                       label: GHC.Base.liftM_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ww: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.898315512 UTC

[section ""data" . GHC.Base.liftM_closure" {
     GHC.Base.liftM_closure:
         const GHC.Base.liftM_info;
 },
 sat_s7ZF_entry() //  [R1, R2]
         { info_tbl: [(c8WJ,
                       label: sat_s7ZF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WJ: // global
           _s7ZD::P64 = R2;
           _s7ZF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8WK; else goto c8WL;
       c8WL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8WN; else goto c8WM;
       c8WN: // global
           HpAlloc = 32;
           goto c8WK;
       c8WK: // global
           R2 = _s7ZD::P64;
           R1 = _s7ZF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WM: // global
           _s7ZA::P64 = P64[_s7ZF::P64 + 7];
           _s7ZB::P64 = P64[_s7ZF::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s7ZB::P64;
           P64[Hp] = _s7ZD::P64;
           R2 = _s7ZA::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM_entry() //  [R2, R3, R4]
         { info_tbl: [(c8WO,
                       label: GHC.Base.liftM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WO: // global
           _s7ZC::P64 = R4;
           _s7ZB::P64 = R3;
           _s7ZA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8WP; else goto c8WQ;
       c8WQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8WS; else goto c8WR;
       c8WS: // global
           HpAlloc = 24;
           goto c8WP;
       c8WP: // global
           R4 = _s7ZC::P64;
           R3 = _s7ZB::P64;
           R2 = _s7ZA::P64;
           R1 = GHC.Base.liftM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8WR: // global
           I64[Hp - 16] = sat_s7ZF_info;
           P64[Hp - 8] = _s7ZA::P64;
           P64[Hp] = _s7ZB::P64;
           R2 = _s7ZA::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7ZC::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.899893508 UTC

[section ""data" . GHC.Base.$!_closure" {
     GHC.Base.$!_closure:
         const GHC.Base.$!_info;
 },
 GHC.Base.$!_entry() //  [R2, R3]
         { info_tbl: [(c8WZ,
                       label: GHC.Base.$!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8X0; else goto c8X1;
       c8X0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8X1: // global
           I64[Sp - 16] = block_c8WX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WX() //  [R1]
         { info_tbl: [(c8WX,
                       label: block_c8WX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WX: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.900825968 UTC

[section ""data" . GHC.Base.$_closure" {
     GHC.Base.$_closure:
         const GHC.Base.$_info;
 },
 GHC.Base.$_entry() //  [R2, R3]
         { info_tbl: [(c8X7,
                       label: GHC.Base.$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8X7: // global
           _s7ZJ::P64 = R2;
           R2 = R3;
           R1 = _s7ZJ::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.901794889 UTC

[section ""data" . GHC.Base.flip_closure" {
     GHC.Base.flip_closure:
         const GHC.Base.flip_info;
 },
 GHC.Base.flip_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Xe,
                       label: GHC.Base.flip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Xe: // global
           R3 = R3;
           _s7ZL::P64 = R2;
           R2 = R4;
           R1 = _s7ZL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.902638233 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>_closure" {
     GHC.Base.$fMonad(->)_$c>>_closure:
         const GHC.Base.$fMonad(->)_$c>>_info;
 },
 GHC.Base.$fMonad(->)_$c>>_entry() //  [R3, R4]
         { info_tbl: [(c8Xl,
                       label: GHC.Base.$fMonad(->)_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Xl: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.903429356 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*_closure" {
     GHC.Base.$fApplicative(->)_$c<*_closure:
         const GHC.Base.$fApplicative(->)_$c<*_info;
 },
 GHC.Base.$fApplicative(->)_$c<*_entry() //  [R2, R4]
         { info_tbl: [(c8Xs,
                       label: GHC.Base.$fApplicative(->)_$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Xs: // global
           _s7ZR::P64 = R2;
           R2 = R4;
           R1 = _s7ZR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.904808062 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>_closure" {
     GHC.Base.$fMonad(,)_$c>>_closure:
         const GHC.Base.$fMonad(,)_$c>>_info;
 },
 sat_s804_entry() //  [R1]
         { info_tbl: [(c8XP,
                       label: sat_s804_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8XP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8XQ; else goto c8XR;
       c8XQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8XR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8XN_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8XN() //  [R1]
         { info_tbl: [(c8XN,
                       label: block_c8XN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8XN: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_$c>>_entry() //  [R2, R3, R4]
         { info_tbl: [(c8XV,
                       label: GHC.Base.$fMonad(,)_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8XV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8XX; else goto c8XY;
       c8XX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8XY: // global
           I64[Sp - 24] = block_c8Xz_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Y4; else goto c8XA;
       u8Y4: // global
           call _c8Xz(R1) args: 0, res: 0, upd: 0;
       c8XA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Xz() //  [R1]
         { info_tbl: [(c8Xz,
                       label: block_c8Xz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Xz: // global
           I64[Sp] = block_c8XE_info;
           _s7ZY::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7ZY::P64;
           if (R1 & 7 != 0) goto u8Y3; else goto c8XF;
       u8Y3: // global
           call _c8XE(R1) args: 0, res: 0, upd: 0;
       c8XF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8XE() //  [R1]
         { info_tbl: [(c8XE,
                       label: block_c8XE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8XE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Y2; else goto c8Y1;
       c8Y2: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Y1: // global
           _s801::P64 = P64[R1 + 7];
           _s802::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s804_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s801::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s802::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.906981127 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*_closure" {
     GHC.Base.$fApplicative(,)_$c<*_closure:
         const GHC.Base.$fApplicative(,)_$c<*_info;
 },
 sat_s80f_entry() //  [R1]
         { info_tbl: [(c8Yp,
                       label: sat_s80f_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Yp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Yq; else goto c8Yr;
       c8Yq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Yr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8Yn_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Yn() //  [R1]
         { info_tbl: [(c8Yn,
                       label: block_c8Yn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Yn: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c<*_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Yv,
                       label: GHC.Base.$fApplicative(,)_$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Yv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Yx; else goto c8Yy;
       c8Yx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Yy: // global
           I64[Sp - 24] = block_c8Y9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8YE; else goto c8Ya;
       u8YE: // global
           call _c8Y9(R1) args: 0, res: 0, upd: 0;
       c8Ya: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Y9() //  [R1]
         { info_tbl: [(c8Y9,
                       label: block_c8Y9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Y9: // global
           I64[Sp - 8] = block_c8Ye_info;
           _s809::P64 = P64[R1 + 7];
           _s80a::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s80a::P64;
           P64[Sp + 16] = _s809::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YD; else goto c8Yf;
       u8YD: // global
           call _c8Ye(R1) args: 0, res: 0, upd: 0;
       c8Yf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ye() //  [R1]
         { info_tbl: [(c8Ye,
                       label: block_c8Ye_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ye: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8YC; else goto c8YB;
       c8YC: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YB: // global
           _s80c::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s80f_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s80c::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.909072704 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$c<$_closure" {
     GHC.Base.$fFunctor(,)_$c<$_closure:
         const GHC.Base.$fFunctor(,)_$c<$_info;
 },
 GHC.Base.$fFunctor(,)_$c<$_entry() //  [R2, R3]
         { info_tbl: [(c8YM,
                       label: GHC.Base.$fFunctor(,)_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YQ; else goto c8YR;
       c8YQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8YR: // global
           I64[Sp - 16] = block_c8YJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8YV; else goto c8YK;
       u8YV: // global
           call _c8YJ(R1) args: 0, res: 0, upd: 0;
       c8YK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YJ() //  [R1]
         { info_tbl: [(c8YJ,
                       label: block_c8YJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8YU; else goto c8YT;
       c8YU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YT: // global
           _s80j::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s80j::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.910593796 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_$c<$_closure" {
     GHC.Base.$fFunctorMaybe_$c<$_closure:
         const GHC.Base.$fFunctorMaybe_$c<$_info;
 },
 GHC.Base.$fFunctorMaybe_$c<$_entry() //  [R2, R3]
         { info_tbl: [(c8Z7,
                       label: GHC.Base.$fFunctorMaybe_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Z8; else goto c8Z9;
       c8Z8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorMaybe_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Z9: // global
           I64[Sp - 16] = block_c8Z0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Zj; else goto c8Z1;
       u8Zj: // global
           call _c8Z0(R1) args: 0, res: 0, upd: 0;
       c8Z1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z0() //  [R1]
         { info_tbl: [(c8Z0,
                       label: block_c8Z0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z0: // global
           if (R1 & 7 == 1) goto c8Z4; else goto c8Z5;
       c8Z4: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Z5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Zi; else goto c8Zh;
       c8Zi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zh: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.911930783 UTC

[section ""data" . GHC.Base.$dm<$_closure" {
     GHC.Base.$dm<$_closure:
         const GHC.Base.$dm<$_info;
 },
 sat_s80s_entry() //  [R1]
         { info_tbl: [(c8Zt,
                       label: sat_s80s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zt: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$dm<$_entry() //  [R2, R3]
         { info_tbl: [(c8Zw,
                       label: GHC.Base.$dm<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zw: // global
           _s80q::P64 = R3;
           _s80p::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zx; else goto c8Zy;
       c8Zy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZA; else goto c8Zz;
       c8ZA: // global
           HpAlloc = 16;
           goto c8Zx;
       c8Zx: // global
           R3 = _s80q::P64;
           R2 = _s80p::P64;
           R1 = GHC.Base.$dm<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Zz: // global
           I64[Hp - 8] = sat_s80s_info;
           P64[Hp] = _s80q::P64;
           R2 = _s80p::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.913384904 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmappend_closure" {
     GHC.Base.$fMonoid(->)_$cmappend_closure:
         const GHC.Base.$fMonoid(->)_$cmappend_info;
 },
 GHC.Base.$fMonoid(->)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8ZJ,
                       label: GHC.Base.$fMonoid(->)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZJ: // global
           _s80w::P64 = R5;
           _s80v::P64 = R4;
           _s80u::P64 = R3;
           _s80t::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8ZK; else goto c8ZL;
       c8ZL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8ZN; else goto c8ZM;
       c8ZN: // global
           HpAlloc = 64;
           goto c8ZK;
       c8ZK: // global
           R5 = _s80w::P64;
           R4 = _s80v::P64;
           R3 = _s80u::P64;
           R2 = _s80t::P64;
           R1 = GHC.Base.$fMonoid(->)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ZM: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s80v::P64;
           P64[Hp - 32] = _s80w::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s80u::P64;
           P64[Hp] = _s80w::P64;
           I64[Sp - 24] = block_c8ZH_info;
           R2 = _s80t::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZH() //  [R1]
         { info_tbl: [(c8ZH,
                       label: block_c8ZH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZH: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _c8ZF::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _c8ZF::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.915182078 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,)_$cmappend_info;
 },
 sat_s80N_entry() //  [R1]
         { info_tbl: [(c90b,
                       label: sat_s80N_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90b: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c90c; else goto c90d;
       c90c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c90d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c909_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c909() //  [R1]
         { info_tbl: [(c909,
                       label: block_c909_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c909: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s80L_entry() //  [R1]
         { info_tbl: [(c90n,
                       label: sat_s80L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90n: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c90o; else goto c90p;
       c90o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c90p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c90l_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c90l() //  [R1]
         { info_tbl: [(c90l,
                       label: block_c90l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90l: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c90t,
                       label: GHC.Base.$fMonoid(,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90t: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c90v; else goto c90w;
       c90v: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c90w: // global
           I64[Sp - 32] = block_c8ZV_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u90C; else goto c8ZW;
       u90C: // global
           call _c8ZV(R1) args: 0, res: 0, upd: 0;
       c8ZW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZV() //  [R1]
         { info_tbl: [(c8ZV,
                       label: block_c8ZV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZV: // global
           I64[Sp - 8] = block_c900_info;
           _s80F::P64 = P64[R1 + 7];
           _s80G::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s80G::P64;
           P64[Sp + 24] = _s80F::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90B; else goto c901;
       u90B: // global
           call _c900(R1) args: 0, res: 0, upd: 0;
       c901: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c900() //  [R1]
         { info_tbl: [(c900,
                       label: block_c900_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c900: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c90A; else goto c90z;
       c90A: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90z: // global
           _s80I::P64 = P64[R1 + 7];
           _s80J::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s80N_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s80J::P64;
           I64[Hp - 56] = sat_s80L_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s80I::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.918066021 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_go_closure" {
     GHC.Base.$fSemigroupOrdering_go_closure:
         const GHC.Base.$fSemigroupOrdering_go_info;
 },
 GHC.Base.$fSemigroupOrdering_go_entry() //  [R2, R3]
         { info_tbl: [(c90O,
                       label: GHC.Base.$fSemigroupOrdering_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c90P; else goto u91f;
       c90P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u91f: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c90E() args: 0, res: 0, upd: 0;
     }
 },
 _c90E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90E: // global
           I64[Sp - 8] = block_c90H_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u91h; else goto c90I;
       u91h: // global
           call _c90H(R1) args: 0, res: 0, upd: 0;
       c90I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90H() //  [R1]
         { info_tbl: [(c90H,
                       label: block_c90H_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90H: // global
           _s80O::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c90L; else goto c90M;
       c90L: // global
           R1 = _s80O::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c90M: // global
           I64[Sp] = block_c90W_info;
           _s80R::P64 = P64[R1 + 6];
           _s80S::P64 = P64[R1 + 14];
           R1 = _s80O::P64;
           P64[Sp + 8] = _s80S::P64;
           P64[Sp + 16] = _s80R::P64;
           if (R1 & 7 != 0) goto u91i; else goto c90Y;
       u91i: // global
           call _c90W(R1) args: 0, res: 0, upd: 0;
       c90Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90W() //  [R1]
         { info_tbl: [(c90W,
                       label: block_c90W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90W: // global
           _c91d::P64 = R1 & 7;
           if (_c91d::P64 < 3) goto u91e; else goto c91c;
       u91e: // global
           if (_c91d::P64 < 2) goto c914; else goto c918;
       c914: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c918: // global
           _s80P::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s80P::P64;
           Sp = Sp + 8;
           call _c90E() args: 0, res: 0, upd: 0;
       c91c: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.919883983 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_$csconcat_closure" {
     GHC.Base.$fSemigroupOrdering_$csconcat_closure:
         const GHC.Base.$fSemigroupOrdering_$csconcat_info;
 },
 GHC.Base.$fSemigroupOrdering_$csconcat_entry() //  [R2]
         { info_tbl: [(c91s,
                       label: GHC.Base.$fSemigroupOrdering_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c91t; else goto c91u;
       c91t: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c91u: // global
           I64[Sp - 8] = block_c91p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u91y; else goto c91q;
       u91y: // global
           call _c91p(R1) args: 0, res: 0, upd: 0;
       c91q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91p() //  [R1]
         { info_tbl: [(c91p,
                       label: block_c91p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91p: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupOrdering_go_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.921017757 UTC

[section ""data" . GHC.Base.._closure" {
     GHC.Base.._closure:
         const GHC.Base.._info;
 },
 GHC.Base.._entry() //  [R2, R3, R4]
         { info_tbl: [(c91E,
                       label: GHC.Base.._info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91E: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c91I; else goto c91H;
       c91I: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c91H: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _s80Y::P64 = R2;
           R2 = Hp - 24;
           R1 = _s80Y::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.922259427 UTC

[section ""data" . GHC.Base.mapFB_closure" {
     GHC.Base.mapFB_closure:
         const GHC.Base.mapFB_info;
 },
 GHC.Base.mapFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c91O,
                       label: GHC.Base.mapFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91O: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c91S; else goto c91R;
       c91S: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c91R: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _s812::P64 = R2;
           R2 = Hp - 24;
           R1 = _s812::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.923168812 UTC

[section ""data" . GHC.Base.$fFunctor(->)_$c<$_closure" {
     GHC.Base.$fFunctor(->)_$c<$_closure:
         const GHC.Base.$fFunctor(->)_$c<$_info;
 },
 GHC.Base.$fFunctor(->)_$c<$_entry() //  [R2]
         { info_tbl: [(c91X,
                       label: GHC.Base.$fFunctor(->)_$c<$_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91X: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.923813211 UTC

[section ""data" . GHC.Base.$fFunctor(->)_closure" {
     GHC.Base.$fFunctor(->)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.._closure+3;
         const GHC.Base.$fFunctor(->)_$c<$_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.924653822 UTC

[section ""data" . GHC.Base.const_closure" {
     GHC.Base.const_closure:
         const GHC.Base.const_info;
 },
 GHC.Base.const_entry() //  [R2]
         { info_tbl: [(c924,
                       label: GHC.Base.const_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c924: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.925472928 UTC

[section ""data" . GHC.Base.asTypeOf_closure" {
     GHC.Base.asTypeOf_closure:
         const GHC.Base.asTypeOf_info;
 },
 GHC.Base.asTypeOf_entry() //  [R2, R3]
         { info_tbl: [(c92b,
                       label: GHC.Base.asTypeOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92b: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.926226453 UTC

[section ""data" . GHC.Base.$dm<*_closure" {
     GHC.Base.$dm<*_closure:
         const GHC.Base.$dm<*_info;
 },
 GHC.Base.$dm<*_entry() //  [R2]
         { info_tbl: [(c92i,
                       label: GHC.Base.$dm<*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c92j; else goto c92k;
       c92j: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c92k: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.const_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.927423344 UTC

[section ""data" . GHC.Base.$fApplicativeIO1_closure" {
     GHC.Base.$fApplicativeIO1_closure:
         const GHC.Base.$fApplicativeIO1_info;
 },
 GHC.Base.$fApplicativeIO1_entry() //  [R2, R3]
         { info_tbl: [(c92t,
                       label: GHC.Base.$fApplicativeIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c92u; else goto c92v;
       c92u: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c92v: // global
           I64[Sp - 16] = block_c92p_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c92p() //  [R1]
         { info_tbl: [(c92p,
                       label: block_c92p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92p: // global
           I64[Sp] = block_c92r_info;
           _s81i::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s81i::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c92r() //  []
         { info_tbl: [(c92r,
                       label: block_c92r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92r: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.928405174 UTC

[section ""data" . GHC.Base.$fApplicativeIO_closure" {
     GHC.Base.$fApplicativeIO_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorIO_closure+1;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fApplicativeIO3_closure+3;
         const GHC.Base.$fApplicativeIO_$cliftA2_closure+4;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.929086283 UTC

[section ""data" . GHC.Base.breakpointCond_closure" {
     GHC.Base.breakpointCond_closure:
         const GHC.Base.breakpointCond_info;
 },
 GHC.Base.breakpointCond_entry() //  [R3]
         { info_tbl: [(c92C,
                       label: GHC.Base.breakpointCond_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92C: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.930077588 UTC

[section ""data" . GHC.Base.breakpoint_closure" {
     GHC.Base.breakpoint_closure:
         const GHC.Base.breakpoint_info;
 },
 GHC.Base.breakpoint_entry() //  [R2]
         { info_tbl: [(c92J,
                       label: GHC.Base.breakpoint_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92J: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.930796097 UTC

[section ""data" . GHC.Base.assert_closure" {
     GHC.Base.assert_closure:
         const GHC.Base.assert_info;
 },
 GHC.Base.assert_entry() //  [R2, R3]
         { info_tbl: [(c92Q,
                       label: GHC.Base.assert_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92Q: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.breakpointCond_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.931578167 UTC

[section ""data" . GHC.Base.id_closure" {
     GHC.Base.id_closure:
         const GHC.Base.id_info;
 },
 GHC.Base.id_entry() //  [R2]
         { info_tbl: [(c92X,
                       label: GHC.Base.id_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c92X: // global
           R2 = R2;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.932551625 UTC

[section ""data" . GHC.Base.join_closure" {
     GHC.Base.join_closure:
         const GHC.Base.join_info;
 },
 GHC.Base.join_entry() //  [R2, R3]
         { info_tbl: [(c934,
                       label: GHC.Base.join_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c934: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c935; else goto c936;
       c935: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.join_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c936: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.933788109 UTC

[section ""data" . GHC.Base.$dm<*>_closure" {
     GHC.Base.$dm<*>_closure:
         const GHC.Base.$dm<*>_info;
 },
 GHC.Base.$dm<*>_entry() //  [R2]
         { info_tbl: [(c93b,
                       label: GHC.Base.$dm<*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c93b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c93c; else goto c93d;
       c93c: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c93d: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.934911839 UTC

[section ""data" . GHC.Base.$dm*>_closure" {
     GHC.Base.$dm*>_closure:
         const GHC.Base.$dm*>_info;
 },
 sat_s81w_entry() //  [R1]
         { info_tbl: [(c93o,
                       label: sat_s81w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c93o: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c93p; else goto c93q;
       c93p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c93q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c93m_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c93m() //  [R1]
         { info_tbl: [(c93m,
                       label: block_c93m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c93m: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 8;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dm*>_entry() //  [R2, R3, R4]
         { info_tbl: [(c93u,
                       label: GHC.Base.$dm*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c93u: // global
           _s81u::P64 = R4;
           _s81t::P64 = R3;
           _s81s::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c93v; else goto c93w;
       c93w: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c93y; else goto c93x;
       c93y: // global
           HpAlloc = 32;
           goto c93v;
       c93v: // global
           R4 = _s81u::P64;
           R3 = _s81t::P64;
           R2 = _s81s::P64;
           R1 = GHC.Base.$dm*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c93x: // global
           I64[Hp - 24] = sat_s81w_info;
           P64[Hp - 8] = _s81s::P64;
           P64[Hp] = _s81t::P64;
           R2 = _s81s::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s81u::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.936515083 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c*>_closure" {
     GHC.Base.$fApplicative(->)_$c*>_closure:
         const GHC.Base.$fApplicative(->)_$c*>_info;
 },
 GHC.Base.$fApplicative(->)_$c*>_entry() //  [R3, R4]
         { info_tbl: [(c93D,
                       label: GHC.Base.$fApplicative(->)_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c93D: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.937161106 UTC

[section ""data" . GHC.Base.maxInt_closure" {
     GHC.Base.maxInt_closure:
         const GHC.Types.I#_con_info;
         const 9223372036854775807;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.937959711 UTC

[section ""data" . GHC.Base.minInt_closure" {
     GHC.Base.minInt_closure:
         const GHC.Types.I#_con_info;
         const (-9223372036854775808);
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.938807079 UTC

[section ""data" . GHC.Base.ord_closure" {
     GHC.Base.ord_closure:
         const GHC.Base.ord_info;
 },
 GHC.Base.ord_entry() //  [R2]
         { info_tbl: [(c93N,
                       label: GHC.Base.ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c93N: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c93U; else goto c93V;
       c93U: // global
           R2 = R2;
           R1 = GHC.Base.ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c93V: // global
           I64[Sp - 8] = block_c93K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u93Z; else goto c93L;
       u93Z: // global
           call _c93K(R1) args: 0, res: 0, upd: 0;
       c93L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c93K() //  [R1]
         { info_tbl: [(c93K,
                       label: block_c93K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c93K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c93Y; else goto c93X;
       c93Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c93X: // global
           _s81D::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s81D::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.940074307 UTC

[section ""data" . GHC.Base.unsafeChr_closure" {
     GHC.Base.unsafeChr_closure:
         const GHC.Base.unsafeChr_info;
 },
 GHC.Base.unsafeChr_entry() //  [R2]
         { info_tbl: [(c947,
                       label: GHC.Base.unsafeChr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c947: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c94e; else goto c94f;
       c94e: // global
           R2 = R2;
           R1 = GHC.Base.unsafeChr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c94f: // global
           I64[Sp - 8] = block_c944_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u94j; else goto c945;
       u94j: // global
           call _c944(R1) args: 0, res: 0, upd: 0;
       c945: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c944() //  [R1]
         { info_tbl: [(c944,
                       label: block_c944_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c944: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c94i; else goto c94h;
       c94i: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c94h: // global
           _s81H::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s81H::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.941292327 UTC

[section ""data" . GHC.Base.otherwise_closure" {
     GHC.Base.otherwise_closure:
         const GHC.Types.True_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.942229408 UTC

[section ""data" . GHC.Base.until_closure" {
     GHC.Base.until_closure:
         const GHC.Base.until_info;
 },
 GHC.Base.until_entry() //  [R2, R3, R4]
         { info_tbl: [(c94q,
                       label: GHC.Base.until_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c94q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c94r; else goto c94s;
       c94r: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.until_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c94s: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c94u() args: 0, res: 0, upd: 0;
     }
 },
 _c94u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c94u: // global
           I64[Sp - 8] = block_c94w_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c94w() //  [R1]
         { info_tbl: [(c94w,
                       label: block_c94w_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c94w: // global
           _s81M::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c94A; else goto c94J;
       c94A: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c94F; else goto c94E;
       c94F: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c94E: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s81M::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call _c94u() args: 0, res: 0, upd: 0;
       c94J: // global
           R1 = _s81M::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.944164101 UTC

[section ""data" . GHC.Base.divModInt#_closure" {
     GHC.Base.divModInt#_closure:
         const GHC.Base.divModInt#_info;
 },
 GHC.Base.divModInt#_entry() //  [R2, R3]
         { info_tbl: [(c94Z,
                       label: GHC.Base.divModInt#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c94Z: // global
           if (%MO_S_Le_W64(R2, 0)) goto c94X; else goto c94Y;
       c94X: // global
           if (%MO_S_Ge_W64(R2, 0)) goto c959; else goto c95j;
       c959: // global
           _s81Q::I64 = R3;
           (_c956::I64, _c957::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _c957::I64;
           R1 = _c956::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c95j: // global
           if (%MO_S_Le_W64(R3, 0)) goto c95h; else goto c95i;
       c95h: // global
           _s81Q::I64 = R3;
           (_c95e::I64, _c95f::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _c95f::I64;
           R1 = _c95e::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c95i: // global
           _s81Q::I64 = R3;
           (_s81W::I64, _s81X::I64) = call MO_S_QuotRem W64(R2 + 1, _s81Q::I64);
           R2 = _s81X::I64 + _s81Q::I64 - 1;
           R1 = _s81W::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c94Y: // global
           if (%MO_S_Ge_W64(R3, 0)) goto c95G; else goto c95H;
       c95G: // global
           if (%MO_S_Ge_W64(R2, 0)) goto c95u; else goto c95E;
       c95u: // global
           _s81Q::I64 = R3;
           (_c95r::I64, _c95s::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _c95s::I64;
           R1 = _c95r::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c95E: // global
           if (%MO_S_Le_W64(R3, 0)) goto c95C; else goto c95D;
       c95C: // global
           _s81Q::I64 = R3;
           (_c95z::I64, _c95A::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _c95A::I64;
           R1 = _c95z::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c95D: // global
           _s81Q::I64 = R3;
           (_s826::I64, _s827::I64) = call MO_S_QuotRem W64(R2 + 1, _s81Q::I64);
           R2 = _s827::I64 + _s81Q::I64 - 1;
           R1 = _s826::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c95H: // global
           _s81Q::I64 = R3;
           (_s82d::I64, _s82e::I64) = call MO_S_QuotRem W64(R2 - 1, _s81Q::I64);
           R2 = _s82e::I64 + _s81Q::I64 + 1;
           R1 = _s82d::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.946887674 UTC

[section ""data" . GHC.Base.divModInt_closure" {
     GHC.Base.divModInt_closure:
         const GHC.Base.divModInt_info;
 },
 GHC.Base.divModInt_entry() //  [R2, R3]
         { info_tbl: [(c96m,
                       label: GHC.Base.divModInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96q; else goto c96r;
       c96q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divModInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c96r: // global
           I64[Sp - 16] = block_c96j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u98c; else goto c96k;
       u98c: // global
           call _c96j(R1) args: 0, res: 0, upd: 0;
       c96k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96j() //  [R1]
         { info_tbl: [(c96j,
                       label: block_c96j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96j: // global
           I64[Sp] = block_c96p_info;
           _s82l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s82l::I64;
           if (R1 & 7 != 0) goto u98b; else goto c96t;
       u98b: // global
           call _c96p(R1) args: 0, res: 0, upd: 0;
       c96t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96p() //  [R1]
         { info_tbl: [(c96p,
                       label: block_c96p_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c96z; else goto c96y;
       c96z: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96y: // global
           _s82l::I64 = I64[Sp + 8];
           _s82n::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s82l::I64, 0)) goto c97d; else goto c98a;
       c97d: // global
           if (%MO_S_Ge_W64(_s82l::I64, 0)) goto c96K; else goto c97b;
       c96K: // global
           (_s82r::I64, _s82s::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82s::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82r::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c97b: // global
           if (%MO_S_Le_W64(_s82n::I64, 0)) goto c96T; else goto c97a;
       c96T: // global
           (_s82x::I64, _s82y::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82y::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82x::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c97a: // global
           (_s82D::I64, _s82E::I64) = call MO_S_QuotRem W64(_s82l::I64 + 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82E::I64 + _s82n::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82D::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c98a: // global
           if (%MO_S_Ge_W64(_s82n::I64, 0)) goto c97S; else goto c989;
       c97S: // global
           if (%MO_S_Ge_W64(_s82l::I64, 0)) goto c97p; else goto c97Q;
       c97p: // global
           (_s82N::I64, _s82O::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82O::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82N::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c97Q: // global
           if (%MO_S_Le_W64(_s82n::I64, 0)) goto c97y; else goto c97P;
       c97y: // global
           (_s82T::I64, _s82U::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82U::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82T::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c97P: // global
           (_s82Z::I64, _s830::I64) = call MO_S_QuotRem W64(_s82l::I64 + 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s830::I64 + _s82n::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82Z::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c989: // global
           (_s838::I64, _s839::I64) = call MO_S_QuotRem W64(_s82l::I64 - 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s839::I64 + _s82n::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s838::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.949546971 UTC

[section ""data" . GHC.Base.shiftL#_closure" {
     GHC.Base.shiftL#_closure:
         const GHC.Base.shiftL#_info;
 },
 GHC.Base.shiftL#_entry() //  [R2, R3]
         { info_tbl: [(c98m,
                       label: GHC.Base.shiftL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c98m: // global
           if (%MO_S_Lt_W64(R3, 64)) goto c98k; else goto c98l;
       c98k: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c98l: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.950430352 UTC

[section ""data" . GHC.Base.shiftRL#_closure" {
     GHC.Base.shiftRL#_closure:
         const GHC.Base.shiftRL#_info;
 },
 GHC.Base.shiftRL#_entry() //  [R2, R3]
         { info_tbl: [(c98A,
                       label: GHC.Base.shiftRL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c98A: // global
           if (%MO_S_Lt_W64(R3, 64)) goto c98y; else goto c98z;
       c98y: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c98z: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.951276707 UTC

[section ""data" . GHC.Base.iShiftL#_closure" {
     GHC.Base.iShiftL#_closure:
         const GHC.Base.iShiftL#_info;
 },
 GHC.Base.iShiftL#_entry() //  [R2, R3]
         { info_tbl: [(c98O,
                       label: GHC.Base.iShiftL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c98O: // global
           if (%MO_S_Lt_W64(R3, 64)) goto c98M; else goto c98N;
       c98M: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c98N: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.952375965 UTC

[section ""data" . GHC.Base.iShiftRA#_closure" {
     GHC.Base.iShiftRA#_closure:
         const GHC.Base.iShiftRA#_info;
 },
 GHC.Base.iShiftRA#_entry() //  [R2, R3]
         { info_tbl: [(c992,
                       label: GHC.Base.iShiftRA#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c992: // global
           if (%MO_S_Lt_W64(R3, 64)) goto c990; else goto c991;
       c990: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c991: // global
           if (%MO_S_Ge_W64(R2, 0)) goto c99b; else goto c99c;
       c99b: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c99c: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.953315309 UTC

[section ""data" . GHC.Base.iShiftRL#_closure" {
     GHC.Base.iShiftRL#_closure:
         const GHC.Base.iShiftRL#_info;
 },
 GHC.Base.iShiftRL#_entry() //  [R2, R3]
         { info_tbl: [(c99m,
                       label: GHC.Base.iShiftRL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c99m: // global
           if (%MO_S_Lt_W64(R3, 64)) goto c99k; else goto c99l;
       c99k: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c99l: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.954340295 UTC

[section ""data" . GHC.Base.build_closure" {
     GHC.Base.build_closure:
         const GHC.Base.build_info;
 },
 GHC.Base.build_entry() //  [R2]
         { info_tbl: [(c99v,
                       label: GHC.Base.build_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c99v: // global
           R3 = GHC.Types.[]_closure+1;
           _s83v::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _s83v::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.955153103 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cpure_closure" {
     GHC.Base.$fApplicative[]_$cpure_closure:
         const GHC.Base.$fApplicative[]_$cpure_info;
 },
 GHC.Base.$fApplicative[]_$cpure_entry() //  [R2]
         { info_tbl: [(c99D,
                       label: GHC.Base.$fApplicative[]_$cpure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c99D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c99H; else goto c99G;
       c99H: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c99G: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.956063657 UTC

[section ""data" . GHC.Base.augment_closure" {
     GHC.Base.augment_closure:
         const GHC.Base.augment_info;
 },
 GHC.Base.augment_entry() //  [R2, R3]
         { info_tbl: [(c99M,
                       label: GHC.Base.augment_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c99M: // global
           R3 = R3;
           _s83x::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _s83x::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.958429549 UTC

[section ""data" . GHC.Base.++_closure" {
     GHC.Base.++_closure:
         const GHC.Base.++_info;
 },
 sat_s83E_entry() //  [R1]
         { info_tbl: [(c9a3,
                       label: sat_s83E_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9a3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9a4; else goto c9a5;
       c9a4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9a5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.++_entry() //  [R2, R3]
         { info_tbl: [(c9aa,
                       label: GHC.Base.++_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9aa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ab; else goto c9ac;
       c9ab: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.++_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ac: // global
           I64[Sp - 16] = block_c99T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9aj; else goto c99U;
       u9aj: // global
           call _c99T(R1) args: 0, res: 0, upd: 0;
       c99U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c99T() //  [R1]
         { info_tbl: [(c99T,
                       label: block_c99T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c99T: // global
           _s83A::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c9a7; else goto c9a8;
       c9a7: // global
           R1 = _s83A::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9a8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9ai; else goto c9ah;
       c9ai: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9ah: // global
           _s83C::P64 = P64[R1 + 6];
           _s83D::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_s83E_info;
           P64[Hp - 32] = _s83A::P64;
           P64[Hp - 24] = _s83D::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s83C::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.foldr_closure" {
     GHC.Base.foldr_closure:
         const GHC.Base.foldr_info;
 },
 go_s83I_entry() //  [R1, R2]
         { info_tbl: [(c9aA,
                       label: go_s83I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9aA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9aB; else goto c9aC;
       c9aB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9aC: // global
           I64[Sp - 32] = block_c9at_info;
           _s83I::P64 = R1;
           _s83F::P64 = P64[R1 + 7];
           _s83G::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s83F::P64;
           P64[Sp - 16] = _s83G::P64;
           P64[Sp - 8] = _s83I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9aM; else goto c9au;
       u9aM: // global
           call _c9at(R1) args: 0, res: 0, upd: 0;
       c9au: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9at() //  [R1]
         { info_tbl: [(c9at,
                       label: block_c9at_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9at: // global
           if (R1 & 7 == 1) goto c9ax; else goto c9ay;
       c9ax: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9ay: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9aL; else goto c9aK;
       c9aL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9aK: // global
           _s83L::P64 = P64[R1 + 6];
           _s83M::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s83M::P64;
           R3 = Hp - 24;
           R2 = _s83L::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.foldr_entry() //  [R2, R3, R4]
         { info_tbl: [(c9aN,
                       label: GHC.Base.foldr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9aN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9aR; else goto c9aQ;
       c9aR: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.foldr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9aQ: // global
           I64[Hp - 16] = go_s83I_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go_s83I_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.map_closure" {
     GHC.Base.map_closure:
         const GHC.Base.map_info;
 },
 sat_s83U_entry() //  [R1]
         { info_tbl: [(c9b6,
                       label: sat_s83U_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9b6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9b7; else goto c9b8;
       c9b7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9b8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.map_entry() //  [R2, R3]
         { info_tbl: [(c9bd,
                       label: GHC.Base.map_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9bd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9be; else goto c9bf;
       c9be: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9bf: // global
           I64[Sp - 16] = block_c9aW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9bn; else goto c9aX;
       u9bn: // global
           call _c9aW(R1) args: 0, res: 0, upd: 0;
       c9aX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9aW() //  [R1]
         { info_tbl: [(c9aW,
                       label: block_c9aW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9aW: // global
           if (R1 & 7 == 1) goto c9ba; else goto c9bb;
       c9ba: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9bb: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c9bm; else goto c9bl;
       c9bm: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9bl: // global
           _s83R::P64 = P64[R1 + 6];
           _s83S::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_s83U_info;
           _s83O::P64 = P64[Sp + 8];
           P64[Hp - 64] = _s83O::P64;
           P64[Hp - 56] = _s83S::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s83O::P64;
           P64[Hp - 24] = _s83R::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.962286217 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$c<>_closure" {
     GHC.Base.$fSemigroupNonEmpty_$c<>_closure:
         const GHC.Base.$fSemigroupNonEmpty_$c<>_info;
 },
 sat_s849_entry() //  [R1]
         { info_tbl: [(c9bE,
                       label: sat_s849_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9bE: // global
           _s849::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9bF; else goto c9bG;
       c9bG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9bI; else goto c9bH;
       c9bI: // global
           HpAlloc = 72;
           goto c9bF;
       c9bF: // global
           R1 = _s849::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9bH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s849::P64;
           _s83W::P64 = P64[_s849::P64 + 16];
           _s83Z::P64 = P64[_s849::P64 + 24];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _s83W::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _s83W::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _s83Z::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupNonEmpty_$c<>_entry() //  [R2, R3]
         { info_tbl: [(c9bJ,
                       label: GHC.Base.$fSemigroupNonEmpty_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9bJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9bL; else goto c9bM;
       c9bL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9bM: // global
           I64[Sp - 16] = block_c9bs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9bQ; else goto c9bt;
       u9bQ: // global
           call _c9bs(R1) args: 0, res: 0, upd: 0;
       c9bt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9bs() //  [R1]
         { info_tbl: [(c9bs,
                       label: block_c9bs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9bs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9bP; else goto c9bO;
       c9bP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9bO: // global
           _s83Y::P64 = P64[R1 + 7];
           _s83Z::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_s849_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s83Z::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _s83Y::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.964786583 UTC

[section ""data" . GHC.Base.$wpoly_go_closure" {
     GHC.Base.$wpoly_go_closure:
         const GHC.Base.$wpoly_go_info;
 },
 ds_s84g_entry() //  [R1]
         { info_tbl: [(c9cc,
                       label: ds_s84g_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9cc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9ci; else goto c9cj;
       c9ci: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9cj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9c9_info;
           _s84f::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s84f::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9co; else goto c9ca;
       u9co: // global
           call _c9c9(R1) args: 0, res: 0, upd: 0;
       c9ca: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9c9() //  [R1]
         { info_tbl: [(c9c9,
                       label: block_c9c9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9c9: // global
           _s84f::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9cf_info;
           R4 = _s84f::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9cf() //  [R1, R2]
         { info_tbl: [(c9cf,
                       label: block_c9cf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9cf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9cn; else goto c9cm;
       c9cn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9cm: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s84w_entry() //  [R1]
         { info_tbl: [(c9cs,
                       label: sat_s84w_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9cs: // global
           _s84w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9ct; else goto c9cu;
       c9cu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c9cw; else goto c9cv;
       c9cw: // global
           HpAlloc = 104;
           goto c9ct;
       c9ct: // global
           R1 = _s84w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9cv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s84w::P64;
           _s84b::P64 = P64[_s84w::P64 + 16];
           _s84e::P64 = P64[_s84w::P64 + 24];
           _s84f::P64 = P64[_s84w::P64 + 32];
           I64[Hp - 96] = ds_s84g_info;
           P64[Hp - 80] = _s84e::P64;
           P64[Hp - 72] = _s84f::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c9c5::P64 = Hp - 96;
           P64[Hp - 48] = _c9c5::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c9c5::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _s84b::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$wpoly_go_entry() //  [R2, R3, R4]
         { info_tbl: [(c9cB,
                       label: GHC.Base.$wpoly_go_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9cB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9cC; else goto c9cD;
       c9cC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$wpoly_go_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9cD: // global
           I64[Sp - 24] = block_c9bV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9cJ; else goto c9bW;
       u9cJ: // global
           call _c9bV(R1) args: 0, res: 0, upd: 0;
       c9bW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9bV() //  [R1]
         { info_tbl: [(c9bV,
                       label: block_c9bV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9bV: // global
           _s84a::P64 = P64[Sp + 8];
           _s84b::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9cy; else goto c9cz;
       c9cy: // global
           R2 = _s84b::P64;
           R1 = _s84a::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9cz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9cI; else goto c9cH;
       c9cI: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9cH: // global
           _s84e::P64 = P64[R1 + 6];
           _s84f::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_s84w_info;
           P64[Hp - 16] = _s84b::P64;
           P64[Hp - 8] = _s84e::P64;
           P64[Hp] = _s84f::P64;
           R2 = Hp - 32;
           R1 = _s84a::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.967672197 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty1_closure" {
     GHC.Base.$fSemigroupNonEmpty1_closure:
         const GHC.Base.$fSemigroupNonEmpty1_info;
 },
 GHC.Base.$fSemigroupNonEmpty1_entry() //  [R2, R3]
         { info_tbl: [(c9cR,
                       label: GHC.Base.$fSemigroupNonEmpty1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9cR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9cX; else goto c9cY;
       c9cX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9cY: // global
           I64[Sp - 16] = block_c9cO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9d3; else goto c9cP;
       u9d3: // global
           call _c9cO(R1) args: 0, res: 0, upd: 0;
       c9cP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9cO() //  [R1]
         { info_tbl: [(c9cO,
                       label: block_c9cO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9cO: // global
           _s84y::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9cU_info;
           R4 = _s84y::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9cU() //  [R1, R2]
         { info_tbl: [(c9cU,
                       label: block_c9cU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9cU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9d2; else goto c9d1;
       c9d2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c9d1: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.969477555 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$csconcat_closure" {
     GHC.Base.$fSemigroupNonEmpty_$csconcat_closure:
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_info;
 },
 GHC.Base.$fSemigroupNonEmpty_$csconcat_entry() //  [R2]
         { info_tbl: [(c9db,
                       label: GHC.Base.$fSemigroupNonEmpty_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9db: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9dc; else goto c9dd;
       c9dc: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9dd: // global
           I64[Sp - 8] = block_c9d8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9dh; else goto c9d9;
       u9dh: // global
           call _c9d8(R1) args: 0, res: 0, upd: 0;
       c9d9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9d8() //  [R1]
         { info_tbl: [(c9d8,
                       label: block_c9d8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9d8: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupNonEmpty1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.970563488 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_closure" {
     GHC.Base.$fSemigroupNonEmpty_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fSemigroupNonEmpty_$c<>_closure+2;
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_closure+1;
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupNonEmpty_$cstimes_closure" {
     GHC.Base.$fSemigroupNonEmpty_$cstimes_closure:
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupNonEmpty_$cstimes_entry() //  [R2]
         { info_tbl: [(c9dm,
                       label: GHC.Base.$fSemigroupNonEmpty_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9dm: // global
           R3 = GHC.Base.$fSemigroupNonEmpty_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.972011944 UTC

[section ""data" . GHC.Base.$fSemigroup[]1_closure" {
     GHC.Base.$fSemigroup[]1_closure:
         const GHC.Base.$fSemigroup[]1_info;
 },
 sat_s84P_entry() //  [R1]
         { info_tbl: [(c9dD,
                       label: sat_s84P_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9dD: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup[]1_entry() //  [R2, R3]
         { info_tbl: [(c9dK,
                       label: GHC.Base.$fSemigroup[]1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9dK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9dL; else goto c9dM;
       c9dL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9dM: // global
           I64[Sp - 16] = block_c9dt_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9dS; else goto c9du;
       u9dS: // global
           call _c9dt(R1) args: 0, res: 0, upd: 0;
       c9du: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9dt() //  [R1]
         { info_tbl: [(c9dt,
                       label: block_c9dt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9dt: // global
           _s84K::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c9dH; else goto c9dI;
       c9dH: // global
           R1 = _s84K::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9dI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9dR; else goto c9dQ;
       c9dR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9dQ: // global
           _s84N::P64 = P64[R1 + 6];
           _s84O::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s84P_info;
           P64[Hp - 8] = _s84N::P64;
           P64[Hp] = _s84O::P64;
           R3 = Hp - 24;
           R2 = _s84K::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.973835754 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$csconcat_closure" {
     GHC.Base.$fSemigroup[]_$csconcat_closure:
         const GHC.Base.$fSemigroup[]_$csconcat_info;
 },
 GHC.Base.$fSemigroup[]_$csconcat_entry() //  [R2]
         { info_tbl: [(c9e0,
                       label: GHC.Base.$fSemigroup[]_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9e0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9e1; else goto c9e2;
       c9e1: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9e2: // global
           I64[Sp - 8] = block_c9dX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9e6; else goto c9dY;
       u9e6: // global
           call _c9dX(R1) args: 0, res: 0, upd: 0;
       c9dY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9dX() //  [R1]
         { info_tbl: [(c9dX,
                       label: block_c9dX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9dX: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.975929642 UTC

[section ""data" . GHC.Base.mapM_closure" {
     GHC.Base.mapM_closure:
         const GHC.Base.mapM_info;
 },
 z_s84X_entry() //  [R1]
         { info_tbl: [(c9ef,
                       label: z_s84X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ef: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9eg; else goto c9eh;
       c9eg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9eh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s858_entry() //  [R1, R2]
         { info_tbl: [(c9eF,
                       label: sat_s858_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9eF: // global
           _s856::P64 = R2;
           _s858::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9eG; else goto c9eH;
       c9eH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9eJ; else goto c9eI;
       c9eJ: // global
           HpAlloc = 24;
           goto c9eG;
       c9eG: // global
           R2 = _s856::P64;
           R1 = _s858::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9eI: // global
           _s84U::P64 = P64[_s858::P64 + 7];
           _s855::P64 = P64[_s858::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s855::P64;
           P64[Hp] = _s856::P64;
           R2 = _s84U::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s859_entry() //  [R1, R2]
         { info_tbl: [(c9eK,
                       label: sat_s859_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9eK: // global
           _s855::P64 = R2;
           _s859::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c9eL; else goto c9eM;
       c9eM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9eO; else goto c9eN;
       c9eO: // global
           HpAlloc = 24;
           goto c9eL;
       c9eL: // global
           R2 = _s855::P64;
           R1 = _s859::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9eN: // global
           _s84U::P64 = P64[_s859::P64 + 7];
           _s853::P64 = P64[_s859::P64 + 15];
           I64[Hp - 16] = sat_s858_info;
           P64[Hp - 8] = _s84U::P64;
           P64[Hp] = _s855::P64;
           R2 = _s84U::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s853::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 go_s84Y_entry() //  [R1, R2]
         { info_tbl: [(c9eT,
                       label: go_s84Y_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9eT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9eU; else goto c9eV;
       c9eU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9eV: // global
           I64[Sp - 40] = block_c9en_info;
           _s84Y::P64 = R1;
           _s84U::P64 = P64[R1 + 7];
           _s84V::P64 = P64[R1 + 15];
           _s84X::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s84U::P64;
           P64[Sp - 24] = _s84V::P64;
           P64[Sp - 16] = _s84X::P64;
           P64[Sp - 8] = _s84Y::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9f2; else goto c9eo;
       u9f2: // global
           call _c9en(R1) args: 0, res: 0, upd: 0;
       c9eo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9en() //  [R1]
         { info_tbl: [(c9en,
                       label: block_c9en_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9en: // global
           if (R1 & 7 == 1) goto c9eQ; else goto c9eR;
       c9eQ: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9eR: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c9f0; else goto c9eZ;
       c9f0: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9eZ: // global
           _s851::P64 = P64[R1 + 6];
           _s852::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _s852::P64;
           I64[Hp - 48] = sat_s859_info;
           _s84U::P64 = P64[Sp + 8];
           P64[Hp - 40] = _s84U::P64;
           P64[Hp - 32] = Hp - 80;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s851::P64;
           R2 = _s84U::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 47;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.mapM_entry() //  [R2, R3, R4]
         { info_tbl: [(c9f3,
                       label: GHC.Base.mapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9f3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9f7; else goto c9f6;
       c9f7: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9f6: // global
           I64[Hp - 48] = z_s84X_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_s84Y_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R2 = R4;
           R1 = Hp - 23;
           call go_s84Y_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.978720729 UTC

[section ""data" . GHC.Base.sequence_closure" {
     GHC.Base.sequence_closure:
         const GHC.Base.sequence_info;
 },
 GHC.Base.sequence_entry() //  [R2, R3]
         { info_tbl: [(c9fc,
                       label: GHC.Base.sequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9fc: // global
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call GHC.Base.mapM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.980336465 UTC

[section ""data" . GHC.Base.$dmmconcat_closure" {
     GHC.Base.$dmmconcat_closure:
         const GHC.Base.$dmmconcat_info;
 },
 z_s85d_entry() //  [R1]
         { info_tbl: [(c9fn,
                       label: z_s85d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9fn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9fo; else goto c9fp;
       c9fo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9fp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s85e_entry() //  [R1, R2]
         { info_tbl: [(c9fC,
                       label: go_s85e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9fC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9fD; else goto c9fE;
       c9fD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9fE: // global
           I64[Sp - 32] = block_c9fv_info;
           _s85e::P64 = R1;
           _s85b::P64 = P64[R1 + 7];
           _s85d::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s85b::P64;
           P64[Sp - 16] = _s85d::P64;
           P64[Sp - 8] = _s85e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9fO; else goto c9fw;
       u9fO: // global
           call _c9fv(R1) args: 0, res: 0, upd: 0;
       c9fw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9fv() //  [R1]
         { info_tbl: [(c9fv,
                       label: block_c9fv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9fv: // global
           if (R1 & 7 == 1) goto c9fz; else goto c9fA;
       c9fz: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9fA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9fM; else goto c9fL;
       c9fM: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9fL: // global
           _s85h::P64 = P64[R1 + 6];
           _s85i::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s85i::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s85h::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$dmmconcat_entry() //  [R2, R3]
         { info_tbl: [(c9fP,
                       label: GHC.Base.$dmmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9fP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9fT; else goto c9fS;
       c9fT: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9fS: // global
           I64[Hp - 40] = z_s85d_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85e_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s85e_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.983160176 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmconcat_closure" {
     GHC.Base.$fMonoid(->)_$cmconcat_closure:
         const GHC.Base.$fMonoid(->)_$cmconcat_info;
 },
 lvl3_s85n_entry() //  [R1]
         { info_tbl: [(c9g2,
                       label: lvl3_s85n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9g2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9g3; else goto c9g4;
       c9g3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9g4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup_s85o_entry() //  [R1]
         { info_tbl: [(c9g9,
                       label: $dSemigroup_s85o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9g9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ga; else goto c9gb;
       c9ga: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9gb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s85p_entry() //  [R1, R2, R3]
         { info_tbl: [(c9go,
                       label: go_s85p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9go: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9gp; else goto c9gq;
       c9gp: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9gq: // global
           I64[Sp - 40] = block_c9gh_info;
           _s85p::P64 = R1;
           _s85n::P64 = P64[R1 + 6];
           _s85o::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _s85n::P64;
           P64[Sp - 24] = _s85o::P64;
           P64[Sp - 16] = _s85p::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9gB; else goto c9gi;
       u9gB: // global
           call _c9gh(R1) args: 0, res: 0, upd: 0;
       c9gi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9gh() //  [R1]
         { info_tbl: [(c9gh,
                       label: block_c9gh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9gh: // global
           if (R1 & 7 == 1) goto c9gl; else goto c9gm;
       c9gl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9gm: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9gy; else goto c9gx;
       c9gy: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9gx: // global
           _s85t::P64 = P64[R1 + 6];
           _s85u::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = _s85u::P64;
           _s85r::P64 = P64[Sp + 32];
           P64[Hp - 32] = _s85r::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s85t::P64;
           P64[Hp] = _s85r::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(->)_$cmconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c9gC,
                       label: GHC.Base.$fMonoid(->)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9gC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9gG; else goto c9gF;
       c9gG: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9gF: // global
           I64[Hp - 64] = lvl3_s85n_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = $dSemigroup_s85o_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85p_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           _s85l::P64 = R3;
           R3 = R4;
           R2 = _s85l::P64;
           R1 = Hp - 14;
           call go_s85p_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.986292389 UTC

[section ""data" . GHC.Base.$fMonoidIO1_closure" {
     GHC.Base.$fMonoidIO1_closure:
         const GHC.Base.$fMonoidIO1_info;
 },
 $dSemigroup_s85A_entry() //  [R1]
         { info_tbl: [(c9gP,
                       label: $dSemigroup_s85A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9gP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9gQ; else goto c9gR;
       c9gQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9gR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl3_s85B_entry() //  [R1]
         { info_tbl: [(c9gW,
                       label: lvl3_s85B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9gW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9gX; else goto c9gY;
       c9gX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9gY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s85O_entry() //  [R1]
         { info_tbl: [(c9hi,
                       label: sat_s85O_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9hi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9hj; else goto c9hk;
       c9hj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9hk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s85C_entry() //  [R1, R2]
         { info_tbl: [(c9hp,
                       label: go_s85C_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9hp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9hq; else goto c9hr;
       c9hq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9hr: // global
           I64[Sp - 32] = block_c9h4_info;
           _s85C::P64 = R1;
           _s85A::P64 = P64[R1 + 6];
           _s85B::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _s85A::P64;
           P64[Sp - 16] = _s85B::P64;
           P64[Sp - 8] = _s85C::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9hz; else goto c9h5;
       u9hz: // global
           call _c9h4(R1) args: 0, res: 0, upd: 0;
       c9h5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9h4() //  [R1]
         { info_tbl: [(c9h4,
                       label: block_c9h4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9h4: // global
           if (R1 & 7 == 1) goto c9hm; else goto c9hn;
       c9hm: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9hn: // global
           I64[Sp] = block_c9ha_info;
           _s85H::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s85H::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ha() //  [R1]
         { info_tbl: [(c9ha,
                       label: block_c9ha_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ha: // global
           I64[Sp] = block_c9hc_info;
           R2 = P64[Sp + 16];
           _s85K::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s85K::P64;
           call go_s85C_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9hc() //  [R1]
         { info_tbl: [(c9hc,
                       label: block_c9hc_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9hc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9hy; else goto c9hx;
       c9hy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9hx: // global
           I64[Hp - 32] = sat_s85O_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoidIO1_entry() //  [R2, R3]
         { info_tbl: [(c9hA,
                       label: GHC.Base.$fMonoidIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9hA: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9hE; else goto c9hD;
       c9hE: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9hD: // global
           I64[Hp - 64] = $dSemigroup_s85A_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl3_s85B_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85C_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 14;
           call go_s85C_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.989544966 UTC

[section ""data" . GHC.Base.$fMonoidIO_closure" {
     GHC.Base.$fMonoidIO_closure:
         const GHC.Base.$fMonoidIO_info;
         const 0;
 },
 sat_s85V_entry() //  [R1, R2]
         { info_tbl: [(c9hO,
                       label: sat_s85V_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9hO: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s85U_entry() //  [R1, R2, R3]
         { info_tbl: [(c9hW,
                       label: sat_s85U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9hW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoidIO_$cmappend_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s85S_entry() //  [R1]
         { info_tbl: [(c9i8,
                       label: sat_s85S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9i8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9i9; else goto c9ia;
       c9i9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9ia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s85T_entry() //  [R1]
         { info_tbl: [(c9ib,
                       label: sat_s85T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ib: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9if; else goto c9ie;
       c9if: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9ie: // global
           _s85P::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s85S_info;
           P64[Hp] = _s85P::P64;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s85Q_entry() //  [R1]
         { info_tbl: [(c9ik,
                       label: sat_s85Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ik: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9il; else goto c9im;
       c9il: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9im: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoidIO_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidIO_entry() //  [R2]
         { info_tbl: [(c9io,
                       label: GHC.Base.$fMonoidIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9io: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c9is; else goto c9ir;
       c9is: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9ir: // global
           I64[Hp - 104] = sat_s85V_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s85U_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s85T_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s85Q_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.991778883 UTC

[section ""data" . GHC.Base.$fFunctor[]_$c<$_closure" {
     GHC.Base.$fFunctor[]_$c<$_closure:
         const GHC.Base.$fFunctor[]_$c<$_info;
 },
 sat_s85Z_entry() //  [R1]
         { info_tbl: [(c9iC,
                       label: sat_s85Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9iC: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fFunctor[]_$c<$_entry() //  [R2, R3]
         { info_tbl: [(c9iF,
                       label: GHC.Base.$fFunctor[]_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9iF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9iJ; else goto c9iI;
       c9iJ: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor[]_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9iI: // global
           I64[Hp - 8] = sat_s85Z_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.99384576 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$c<$_closure" {
     GHC.Base.$fFunctorNonEmpty_$c<$_closure:
         const GHC.Base.$fFunctorNonEmpty_$c<$_info;
 },
 sat_s866_entry() //  [R1]
         { info_tbl: [(c9j2,
                       label: sat_s866_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9j2: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s867_entry() //  [R1]
         { info_tbl: [(c9j5,
                       label: sat_s867_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9j5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9j6; else goto c9j7;
       c9j6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9j7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9iS_info;
           _s860::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s860::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9jb; else goto c9iT;
       u9jb: // global
           call _c9iS(R1) args: 0, res: 0, upd: 0;
       c9iT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9iS() //  [R1]
         { info_tbl: [(c9iS,
                       label: block_c9iS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9iS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9ja; else goto c9j9;
       c9ja: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9j9: // global
           _s864::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s866_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _s864::P64;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fFunctorNonEmpty_$c<$_entry() //  [R2, R3]
         { info_tbl: [(c9jd,
                       label: GHC.Base.$fFunctorNonEmpty_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9jd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9jh; else goto c9jg;
       c9jh: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9jg: // global
           I64[Hp - 48] = sat_s867_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.995535256 UTC

[section ""data" . GHC.Base.$fFunctor[]_closure" {
     GHC.Base.$fFunctor[]_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.996809907 UTC

[section ""data" . GHC.Base.$fMonad[]_$c>>=_closure" {
     GHC.Base.$fMonad[]_$c>>=_closure:
         const GHC.Base.$fMonad[]_$c>>=_info;
 },
 sat_s86g_entry() //  [R1]
         { info_tbl: [(c9jB,
                       label: sat_s86g_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9jB: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s86a_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86a_entry() //  [R1, R2]
         { info_tbl: [(c9jI,
                       label: go_s86a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9jI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9jJ; else goto c9jK;
       c9jJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9jK: // global
           I64[Sp - 24] = block_c9jr_info;
           _s86a::P64 = R1;
           _s869::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s869::P64;
           P64[Sp - 8] = _s86a::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9jV; else goto c9js;
       u9jV: // global
           call _c9jr(R1) args: 0, res: 0, upd: 0;
       c9js: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9jr() //  [R1]
         { info_tbl: [(c9jr,
                       label: block_c9jr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9jr: // global
           if (R1 & 7 == 1) goto c9jF; else goto c9jG;
       c9jF: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9jG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9jQ; else goto c9jP;
       c9jQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9jP: // global
           _s86d::P64 = P64[R1 + 6];
           _s86e::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s86g_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s86e::P64;
           _s869::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9jN_info;
           R2 = _s86d::P64;
           R1 = _s869::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9jN() //  [R1]
         { info_tbl: [(c9jN,
                       label: block_c9jN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9jN: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonad[]_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c9jW,
                       label: GHC.Base.$fMonad[]_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9jW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9k0; else goto c9jZ;
       c9k0: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad[]_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9jZ: // global
           I64[Hp - 8] = go_s86a_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86a_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.998876582 UTC

[section ""data" . GHC.Base.=<<_$s=<<_closure" {
     GHC.Base.=<<_$s=<<_closure:
         const GHC.Base.=<<_$s=<<_info;
 },
 GHC.Base.=<<_$s=<<_entry() //  [R2, R3]
         { info_tbl: [(c9k5,
                       label: GHC.Base.=<<_$s=<<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9k5: // global
           _s86i::P64 = R3;
           R3 = R2;
           R2 = _s86i::P64;
           call GHC.Base.$fMonad[]_$c>>=_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:42.999675359 UTC

[section ""data" . GHC.Base.=<<_closure" {
     GHC.Base.=<<_closure:
         const GHC.Base.=<<_info;
 },
 GHC.Base.=<<_entry() //  [R2, R3, R4]
         { info_tbl: [(c9kc,
                       label: GHC.Base.=<<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9kc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9kd; else goto c9ke;
       c9kd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.=<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ke: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.001031087 UTC

[section ""data" . poly_go_r7PI_closure" {
     poly_go_r7PI_closure:
         const poly_go_r7PI_info;
 },
 sat_s86q_entry() //  [R1]
         { info_tbl: [(c9kt,
                       label: sat_s86q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9kt: // global
           R2 = P64[R1 + 16];
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 poly_go_r7PI_entry() //  [R2]
         { info_tbl: [(c9kA,
                       label: poly_go_r7PI_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9kA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9kB; else goto c9kC;
       c9kB: // global
           R2 = R2;
           R1 = poly_go_r7PI_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9kC: // global
           I64[Sp - 8] = block_c9kj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9kI; else goto c9kk;
       u9kI: // global
           call _c9kj(R1) args: 0, res: 0, upd: 0;
       c9kk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9kj() //  [R1]
         { info_tbl: [(c9kj,
                       label: block_c9kj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9kj: // global
           if (R1 & 7 == 1) goto c9kx; else goto c9ky;
       c9kx: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9ky: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9kH; else goto c9kG;
       c9kH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9kG: // global
           _s86o::P64 = P64[R1 + 6];
           _s86p::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_s86q_info;
           P64[Hp] = _s86p::P64;
           R3 = Hp - 16;
           R2 = _s86o::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.002453001 UTC

[section ""data" . GHC.Base.$fMonoid[]_$cmconcat_closure" {
     GHC.Base.$fMonoid[]_$cmconcat_closure:
         const GHC.Base.$fMonoid[]_$cmconcat_info;
 },
 GHC.Base.$fMonoid[]_$cmconcat_entry() //  [R2]
         { info_tbl: [(c9kN,
                       label: GHC.Base.$fMonoid[]_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9kN: // global
           R2 = R2;
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.004266513 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*>_closure" {
     GHC.Base.$fApplicative[]_$c<*>_closure:
         const GHC.Base.$fApplicative[]_$c<*>_info;
 },
 go1_s86A_entry() //  [R1, R2]
         { info_tbl: [(c9li,
                       label: go1_s86A_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9li: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9lj; else goto c9lk;
       c9lj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9lk: // global
           I64[Sp - 32] = block_c9lb_info;
           _s86A::P64 = R1;
           _s86x::P64 = P64[R1 + 7];
           _s86z::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s86x::P64;
           P64[Sp - 16] = _s86z::P64;
           P64[Sp - 8] = _s86A::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9lw; else goto c9lc;
       u9lw: // global
           call _c9lb(R1) args: 0, res: 0, upd: 0;
       c9lc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9lb() //  [R1]
         { info_tbl: [(c9lb,
                       label: block_c9lb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9lb: // global
           if (R1 & 7 == 1) goto c9lf; else goto c9lg;
       c9lf: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9lg: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c9lv; else goto c9lu;
       c9lv: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9lu: // global
           _s86D::P64 = P64[R1 + 6];
           _s86E::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = _s86E::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s86D::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86u_entry() //  [R1, R2]
         { info_tbl: [(c9lB,
                       label: go_s86u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9lB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9lC; else goto c9lD;
       c9lC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9lD: // global
           I64[Sp - 24] = block_c9kZ_info;
           _s86u::P64 = R1;
           _s86t::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s86t::P64;
           P64[Sp - 8] = _s86u::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9lJ; else goto c9l0;
       u9lJ: // global
           call _c9kZ(R1) args: 0, res: 0, upd: 0;
       c9l0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9kZ() //  [R1]
         { info_tbl: [(c9kZ,
                       label: block_c9kZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9kZ: // global
           if (R1 & 7 == 1) goto c9ly; else goto c9lz;
       c9ly: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9lz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9lI; else goto c9lH;
       c9lI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9lH: // global
           _s86x::P64 = P64[R1 + 6];
           _s86y::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s86y::P64;
           I64[Hp - 16] = go1_s86A_info;
           P64[Hp - 8] = _s86x::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s86A_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(c9lK,
                       label: GHC.Base.$fApplicative[]_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9lK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9lO; else goto c9lN;
       c9lO: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9lN: // global
           I64[Hp - 8] = go_s86u_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86u_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.007716629 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cliftA2_closure" {
     GHC.Base.$fApplicative[]_$cliftA2_closure:
         const GHC.Base.$fApplicative[]_$cliftA2_info;
 },
 go1_s86Q_entry() //  [R1, R2]
         { info_tbl: [(c9mh,
                       label: go1_s86Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9mh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9mi; else goto c9mj;
       c9mi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9mj: // global
           I64[Sp - 40] = block_c9ma_info;
           _s86Q::P64 = R1;
           _s86H::P64 = P64[R1 + 7];
           _s86N::P64 = P64[R1 + 15];
           _s86P::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s86H::P64;
           P64[Sp - 24] = _s86N::P64;
           P64[Sp - 16] = _s86P::P64;
           P64[Sp - 8] = _s86Q::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9mv; else goto c9mb;
       u9mv: // global
           call _c9ma(R1) args: 0, res: 0, upd: 0;
       c9mb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ma() //  [R1]
         { info_tbl: [(c9ma,
                       label: block_c9ma_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ma: // global
           if (R1 & 7 == 1) goto c9me; else goto c9mf;
       c9me: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9mf: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c9mu; else goto c9mt;
       c9mu: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9mt: // global
           _s86T::P64 = P64[R1 + 6];
           _s86U::P64 = P64[R1 + 14];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = _s86U::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s86T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86K_entry() //  [R1, R2]
         { info_tbl: [(c9mA,
                       label: go_s86K_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9mA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9mB; else goto c9mC;
       c9mB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9mC: // global
           I64[Sp - 32] = block_c9lY_info;
           _s86K::P64 = R1;
           _s86H::P64 = P64[R1 + 7];
           _s86J::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s86H::P64;
           P64[Sp - 16] = _s86J::P64;
           P64[Sp - 8] = _s86K::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9mI; else goto c9lZ;
       u9mI: // global
           call _c9lY(R1) args: 0, res: 0, upd: 0;
       c9lZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9lY() //  [R1]
         { info_tbl: [(c9lY,
                       label: block_c9lY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9lY: // global
           if (R1 & 7 == 1) goto c9mx; else goto c9my;
       c9mx: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9my: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c9mH; else goto c9mG;
       c9mH: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9mG: // global
           _s86N::P64 = P64[R1 + 6];
           _s86O::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _s86O::P64;
           I64[Hp - 24] = go1_s86Q_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s86N::P64;
           P64[Hp] = Hp - 56;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call go1_s86Q_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(c9mJ,
                       label: GHC.Base.$fApplicative[]_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9mJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9mN; else goto c9mM;
       c9mN: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9mM: // global
           I64[Hp - 16] = go_s86K_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = R3;
           R1 = Hp - 15;
           call go_s86K_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.010304371 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*_closure" {
     GHC.Base.$fApplicative[]_$c<*_closure:
         const GHC.Base.$fApplicative[]_$c<*_info;
 },
 GHC.Base.$fApplicative[]_$c<*_entry() //  [R2, R3]
         { info_tbl: [(c9mS,
                       label: GHC.Base.$fApplicative[]_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9mS: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.const_closure+2;
           call GHC.Base.$fApplicative[]_$cliftA2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.011772271 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c*>_closure" {
     GHC.Base.$fApplicative[]_$c*>_closure:
         const GHC.Base.$fApplicative[]_$c*>_info;
 },
 sat_s874_entry() //  [R1]
         { info_tbl: [(c9ne,
                       label: sat_s874_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ne: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s86Z_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86Z_entry() //  [R1, R2]
         { info_tbl: [(c9nl,
                       label: go_s86Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9nl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9nm; else goto c9nn;
       c9nm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9nn: // global
           I64[Sp - 24] = block_c9n4_info;
           _s86Z::P64 = R1;
           _s86Y::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s86Y::P64;
           P64[Sp - 8] = _s86Z::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9nt; else goto c9n5;
       u9nt: // global
           call _c9n4(R1) args: 0, res: 0, upd: 0;
       c9n5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9n4() //  [R1]
         { info_tbl: [(c9n4,
                       label: block_c9n4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9n4: // global
           if (R1 & 7 == 1) goto c9ni; else goto c9nj;
       c9ni: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9nj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9ns; else goto c9nr;
       c9ns: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9nr: // global
           _s873::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s874_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s873::P64;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$c*>_entry() //  [R2, R3]
         { info_tbl: [(c9nu,
                       label: GHC.Base.$fApplicative[]_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9nu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9ny; else goto c9nx;
       c9ny: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9nx: // global
           I64[Hp - 8] = go_s86Z_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86Z_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.013490289 UTC

[section ""data" . GHC.Base.$fApplicative[]_closure" {
     GHC.Base.$fApplicative[]_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor[]_closure+1;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fApplicative[]_$c<*>_closure+2;
         const GHC.Base.$fApplicative[]_$cliftA2_closure+3;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.014578853 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$cfmap_closure" {
     GHC.Base.$fFunctorNonEmpty_$cfmap_closure:
         const GHC.Base.$fFunctorNonEmpty_$cfmap_info;
 },
 sat_s87f_entry() //  [R1]
         { info_tbl: [(c9nK,
                       label: sat_s87f_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9nK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9nL; else goto c9nM;
       c9nL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9nM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9nH_info;
           _s875::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s875::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9nQ; else goto c9nI;
       u9nQ: // global
           call _c9nH(R1) args: 0, res: 0, upd: 0;
       c9nI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9nH() //  [R1]
         { info_tbl: [(c9nH,
                       label: block_c9nH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9nH: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s87b_entry() //  [R1]
         { info_tbl: [(c9nW,
                       label: sat_s87b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9nW: // global
           _s87b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9nX; else goto c9nY;
       c9nY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9o0; else goto c9nZ;
       c9o0: // global
           HpAlloc = 24;
           goto c9nX;
       c9nX: // global
           R1 = _s87b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9nZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87b::P64;
           _s875::P64 = P64[_s87b::P64 + 16];
           _s876::P64 = P64[_s87b::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s876::P64;
           R2 = Hp - 16;
           R1 = _s875::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fFunctorNonEmpty_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(c9o2,
                       label: GHC.Base.$fFunctorNonEmpty_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9o2: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c9o6; else goto c9o5;
       c9o6: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9o5: // global
           I64[Hp - 80] = sat_s87f_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s87b_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.016275963 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_closure" {
     GHC.Base.$fFunctorNonEmpty_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorNonEmpty_$cfmap_closure+2;
         const GHC.Base.$fFunctorNonEmpty_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.016783394 UTC

[section ""data" . GHC.Base.$fAlternative[]1_closure" {
     GHC.Base.$fAlternative[]1_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.018466166 UTC

[section ""data" . GHC.Base.$fAlternative[]_$csome_closure" {
     GHC.Base.$fAlternative[]_$csome_closure:
         const GHC.Base.$fAlternative[]_$csome_info;
 },
 ys_s87i_entry() //  [R1]
         { info_tbl: [(c9oj,
                       label: ys_s87i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9oj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ok; else goto c9ol;
       c9ok: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9ol: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_s87p_entry() //  [R1, R2]
         { info_tbl: [(c9oK,
                       label: go1_s87p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9oK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9oL; else goto c9oM;
       c9oL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9oM: // global
           I64[Sp - 32] = block_c9oD_info;
           _s87p::P64 = R1;
           _s87m::P64 = P64[R1 + 7];
           _s87o::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s87m::P64;
           P64[Sp - 16] = _s87o::P64;
           P64[Sp - 8] = _s87p::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9oY; else goto c9oE;
       u9oY: // global
           call _c9oD(R1) args: 0, res: 0, upd: 0;
       c9oE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9oD() //  [R1]
         { info_tbl: [(c9oD,
                       label: block_c9oD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9oD: // global
           if (R1 & 7 == 1) goto c9oH; else goto c9oI;
       c9oH: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9oI: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c9oX; else goto c9oW;
       c9oX: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9oW: // global
           _s87s::P64 = P64[R1 + 6];
           _s87t::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s87t::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s87s::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s87j_entry() //  [R1, R2]
         { info_tbl: [(c9p3,
                       label: go_s87j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9p3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9p4; else goto c9p5;
       c9p4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9p5: // global
           I64[Sp - 24] = block_c9or_info;
           _s87j::P64 = R1;
           _s87i::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87i::P64;
           P64[Sp - 8] = _s87j::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9pb; else goto c9os;
       u9pb: // global
           call _c9or(R1) args: 0, res: 0, upd: 0;
       c9os: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9or() //  [R1]
         { info_tbl: [(c9or,
                       label: block_c9or_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9or: // global
           if (R1 & 7 == 1) goto c9p0; else goto c9p1;
       c9p0: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9p1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9pa; else goto c9p9;
       c9pa: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9p9: // global
           _s87m::P64 = P64[R1 + 6];
           _s87n::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s87n::P64;
           I64[Hp - 16] = go1_s87p_info;
           P64[Hp - 8] = _s87m::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s87p_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 some_v_s87h_entry() //  [R1]
         { info_tbl: [(c9pc,
                       label: some_v_s87h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9pc: // global
           _s87h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9pd; else goto c9pe;
       c9pe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9pg; else goto c9pf;
       c9pg: // global
           HpAlloc = 40;
           goto c9pd;
       c9pd: // global
           R1 = _s87h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9pf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87h::P64;
           _s87g::P64 = P64[_s87h::P64 + 16];
           I64[Hp - 32] = ys_s87i_info;
           P64[Hp - 16] = _s87h::P64;
           I64[Hp - 8] = go_s87j_info;
           P64[Hp] = Hp - 32;
           R2 = _s87g::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_s87j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternative[]_$csome_entry() //  [R2]
         { info_tbl: [(c9ph,
                       label: GHC.Base.$fAlternative[]_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ph: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9pl; else goto c9pk;
       c9pl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9pk: // global
           I64[Hp - 16] = some_v_s87h_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.022448497 UTC

[section ""data" . GHC.Base.$fAlternative[]_$cmany_closure" {
     GHC.Base.$fAlternative[]_$cmany_closure:
         const GHC.Base.$fAlternative[]_$cmany_info;
 },
 go1_s87E_entry() //  [R1, R2]
         { info_tbl: [(c9pS,
                       label: go1_s87E_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9pS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9pT; else goto c9pU;
       c9pT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9pU: // global
           I64[Sp - 32] = block_c9pL_info;
           _s87E::P64 = R1;
           _s87B::P64 = P64[R1 + 7];
           _s87D::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s87B::P64;
           P64[Sp - 16] = _s87D::P64;
           P64[Sp - 8] = _s87E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9q6; else goto c9pM;
       u9q6: // global
           call _c9pL(R1) args: 0, res: 0, upd: 0;
       c9pM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9pL() //  [R1]
         { info_tbl: [(c9pL,
                       label: block_c9pL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9pL: // global
           if (R1 & 7 == 1) goto c9pP; else goto c9pQ;
       c9pP: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9pQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c9q5; else goto c9q4;
       c9q5: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9q4: // global
           _s87H::P64 = P64[R1 + 6];
           _s87I::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s87I::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s87H::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s87y_entry() //  [R1, R2]
         { info_tbl: [(c9qb,
                       label: go_s87y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9qb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9qc; else goto c9qd;
       c9qc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9qd: // global
           I64[Sp - 24] = block_c9pz_info;
           _s87y::P64 = R1;
           _s87x::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87x::P64;
           P64[Sp - 8] = _s87y::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9qj; else goto c9pA;
       u9qj: // global
           call _c9pz(R1) args: 0, res: 0, upd: 0;
       c9pA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9pz() //  [R1]
         { info_tbl: [(c9pz,
                       label: block_c9pz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9pz: // global
           if (R1 & 7 == 1) goto c9q8; else goto c9q9;
       c9q8: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9q9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9qi; else goto c9qh;
       c9qi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9qh: // global
           _s87B::P64 = P64[R1 + 6];
           _s87C::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s87C::P64;
           I64[Hp - 16] = go1_s87E_info;
           P64[Hp - 8] = _s87B::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s87E_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v_s87x_entry() //  [R1]
         { info_tbl: [(c9qm,
                       label: many_v_s87x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9qm: // global
           _s87x::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c9qn; else goto c9qo;
       c9qo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9qq; else goto c9qp;
       c9qq: // global
           HpAlloc = 16;
           goto c9qn;
       c9qn: // global
           R1 = _s87x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9qp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87x::P64;
           _s87w::P64 = P64[_s87x::P64 + 16];
           I64[Hp - 8] = go_s87y_info;
           P64[Hp] = _s87x::P64;
           I64[Sp - 24] = block_c9qk_info;
           R2 = _s87w::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_s87y_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9qk() //  [R1]
         { info_tbl: [(c9qk,
                       label: block_c9qk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9qk: // global
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternative[]_$cmany_entry() //  [R2]
         { info_tbl: [(c9qu,
                       label: GHC.Base.$fAlternative[]_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9qu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9qy; else goto c9qx;
       c9qy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9qx: // global
           I64[Hp - 16] = many_v_s87x_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.02515131 UTC

[section ""data" . GHC.Base.$fAlternative[]_closure" {
     GHC.Base.$fAlternative[]_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fAlternative[]_$csome_closure+1;
         const GHC.Base.$fAlternative[]_$cmany_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.027314062 UTC

[section ""data" . GHC.Base.$w$c>>=_closure" {
     GHC.Base.$w$c>>=_closure:
         const GHC.Base.$w$c>>=_info;
 },
 ds_s87O_entry() //  [R1]
         { info_tbl: [(c9qI,
                       label: ds_s87O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9qI: // global
           _s87O::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9qJ; else goto c9qK;
       c9qK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9qM; else goto c9qL;
       c9qM: // global
           HpAlloc = 24;
           goto c9qJ;
       c9qJ: // global
           R1 = _s87O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9qL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87O::P64;
           _s87M::P64 = P64[_s87O::P64 + 16];
           _s87N::P64 = P64[_s87O::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s87M::P64;
           R2 = Hp - 16;
           R1 = _s87N::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s88i_entry() //  [R1]
         { info_tbl: [(c9rl,
                       label: sat_s88i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9rl: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s883_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s883_entry() //  [R1, R2]
         { info_tbl: [(c9rs,
                       label: go_s883_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9rs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9rt; else goto c9ru;
       c9rt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9ru: // global
           I64[Sp - 24] = block_c9ra_info;
           _s883::P64 = R1;
           _s87N::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87N::P64;
           P64[Sp - 8] = _s883::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9rD; else goto c9rb;
       u9rD: // global
           call _c9ra(R1) args: 0, res: 0, upd: 0;
       c9rb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ra() //  [R1]
         { info_tbl: [(c9ra,
                       label: block_c9ra_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ra: // global
           if (R1 & 7 == 1) goto c9rp; else goto c9rq;
       c9rp: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9rq: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c9rC; else goto c9rB;
       c9rC: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9rB: // global
           _s886::P64 = P64[R1 + 6];
           _s887::P64 = P64[R1 + 14];
           I64[Hp - 128] = stg_ap_2_upd_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _s886::P64;
           I64[Hp - 96] = sat_s88i_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s887::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c9rg::P64 = Hp - 128;
           P64[Hp - 48] = _c9rg::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c9rg::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 96;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s88j_entry() //  [R1]
         { info_tbl: [(c9rE,
                       label: sat_s88j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9rE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9rF; else goto c9rG;
       c9rF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9rG: // global
           I64[Sp - 16] = block_c9r0_info;
           _s87N::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s87N::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9rK; else goto c9r1;
       u9rK: // global
           call _c9r0(R1) args: 0, res: 0, upd: 0;
       c9r1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9r0() //  [R1]
         { info_tbl: [(c9r0,
                       label: block_c9r0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9r0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9rJ; else goto c9rI;
       c9rJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9rI: // global
           _s882::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_s883_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _s882::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_s883_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s88k_entry() //  [R1]
         { info_tbl: [(c9rL,
                       label: sat_s88k_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9rL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9rM; else goto c9rN;
       c9rM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9rN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9qR_info;
           _s87M::P64 = P64[R1 + 16];
           _s87N::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _s87M::P64;
           P64[Sp - 24] = _s87N::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9rR; else goto c9qS;
       u9rR: // global
           call _c9qR(R1) args: 0, res: 0, upd: 0;
       c9qS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9qR() //  [R1]
         { info_tbl: [(c9qR,
                       label: block_c9qR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9qR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9rQ; else goto c9rP;
       c9rQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9rP: // global
           _s87Z::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s88j_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 24;
           R2 = _s87Z::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$w$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c9rT,
                       label: GHC.Base.$w$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9rT: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c9rX; else goto c9rW;
       c9rX: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9rW: // global
           I64[Hp - 88] = ds_s87O_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s88k_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _c9qD::P64 = Hp - 88;
           P64[Hp - 24] = _c9qD::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _c9qD::P64;
           R2 = Hp - 56;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.031273763 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>=_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>=_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>=_info;
 },
 GHC.Base.$fMonadNonEmpty_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c9s5,
                       label: GHC.Base.$fMonadNonEmpty_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9s5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9s6; else goto c9s7;
       c9s6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9s7: // global
           I64[Sp - 8] = block_c9s2_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9s2() //  [R1, R2]
         { info_tbl: [(c9s2,
                       label: block_c9s2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9s2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9sa; else goto c9s9;
       c9sa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c9s9: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.032915968 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>_info;
 },
 sat_s88t_entry() //  [R1]
         { info_tbl: [(c9sk,
                       label: sat_s88t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9sk: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonadNonEmpty_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c9sq,
                       label: GHC.Base.$fMonadNonEmpty_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9sq: // global
           _s88r::P64 = R3;
           _s88q::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9sr; else goto c9ss;
       c9ss: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9su; else goto c9st;
       c9su: // global
           HpAlloc = 16;
           goto c9sr;
       c9sr: // global
           R3 = _s88r::P64;
           R2 = _s88q::P64;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9st: // global
           I64[Hp - 8] = sat_s88t_info;
           P64[Hp] = _s88r::P64;
           I64[Sp - 8] = block_c9sn_info;
           R3 = Hp - 7;
           R2 = _s88q::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9sn() //  [R1, R2]
         { info_tbl: [(c9sn,
                       label: block_c9sn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9sn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9sx; else goto c9sw;
       c9sx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c9sw: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.034515129 UTC

[section ""data" . GHC.Base.<**>1_closure" {
     GHC.Base.<**>1_closure:
         const GHC.Base.<**>1_info;
 },
 GHC.Base.<**>1_entry() //  [R2, R3]
         { info_tbl: [(c9sC,
                       label: GHC.Base.<**>1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9sC: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.035258106 UTC

[section ""data" . GHC.Base.<**>_closure" {
     GHC.Base.<**>_closure:
         const GHC.Base.<**>_info;
 },
 GHC.Base.<**>_entry() //  [R2]
         { info_tbl: [(c9sJ,
                       label: GHC.Base.<**>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9sJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9sK; else goto c9sL;
       c9sK: // global
           R2 = R2;
           R1 = GHC.Base.<**>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9sL: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.<**>1_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.036358403 UTC

[section ""data" . GHC.Base.$dmliftA2_closure" {
     GHC.Base.$dmliftA2_closure:
         const GHC.Base.$dmliftA2_info;
 },
 sat_s88E_entry() //  [R1]
         { info_tbl: [(c9sW,
                       label: sat_s88E_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9sW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9sX; else goto c9sY;
       c9sX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9sY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9sU_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9sU() //  [R1]
         { info_tbl: [(c9sU,
                       label: block_c9sU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9sU: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(c9t2,
                       label: GHC.Base.$dmliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9t2: // global
           _s88C::P64 = R4;
           _s88B::P64 = R3;
           _s88A::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9t3; else goto c9t4;
       c9t4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9t6; else goto c9t5;
       c9t6: // global
           HpAlloc = 40;
           goto c9t3;
       c9t3: // global
           R4 = _s88C::P64;
           R3 = _s88B::P64;
           R2 = _s88A::P64;
           R1 = GHC.Base.$dmliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9t5: // global
           I64[Hp - 32] = sat_s88E_info;
           P64[Hp - 16] = _s88A::P64;
           P64[Hp - 8] = _s88B::P64;
           P64[Hp] = _s88C::P64;
           R2 = _s88A::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.038492245 UTC

[section ""data" . GHC.Base.$dmsome_closure" {
     GHC.Base.$dmsome_closure:
         const GHC.Base.$dmsome_info;
 },
 sat_s88J_entry() //  [R1]
         { info_tbl: [(c9tr,
                       label: sat_s88J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9tr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9ts; else goto c9tt;
       c9ts: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9tt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s88K_entry() //  [R1]
         { info_tbl: [(c9tu,
                       label: sat_s88K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9tu: // global
           _s88K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c9tv; else goto c9tw;
       c9tw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9ty; else goto c9tx;
       c9ty: // global
           HpAlloc = 24;
           goto c9tv;
       c9tv: // global
           R1 = _s88K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9tx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s88K::P64;
           _s88F::P64 = P64[_s88K::P64 + 16];
           _s88H::P64 = P64[_s88K::P64 + 24];
           _s88I::P64 = P64[_s88K::P64 + 32];
           I64[Hp - 16] = sat_s88J_info;
           P64[Hp] = _s88I::P64;
           R2 = _s88F::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s88H::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 some_v_s88H_entry() //  [R1]
         { info_tbl: [(c9tz,
                       label: some_v_s88H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9tz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c9tA; else goto c9tB;
       c9tA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9tB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_c9tf_info;
           _s88F::P64 = P64[R1 + 16];
           R2 = _s88F::P64;
           P64[Sp - 40] = _s88F::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9tf() //  [R1]
         { info_tbl: [(c9tf,
                       label: block_c9tf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9tf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9tE; else goto c9tD;
       c9tE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9tD: // global
           I64[Hp - 32] = sat_s88K_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 32;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmsome_entry() //  [R2, R3]
         { info_tbl: [(c9tF,
                       label: GHC.Base.$dmsome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9tF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9tJ; else goto c9tI;
       c9tJ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9tI: // global
           I64[Hp - 24] = some_v_s88H_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.041130526 UTC

[section ""data" . GHC.Base.$dmmany_closure" {
     GHC.Base.$dmmany_closure:
         const GHC.Base.$dmmany_info;
 },
 $dApplicative_s88O_entry() //  [R1]
         { info_tbl: [(c9tW,
                       label: $dApplicative_s88O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9tW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9tX; else goto c9tY;
       c9tX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9tY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s88Q_entry() //  [R1]
         { info_tbl: [(c9u3,
                       label: sat_s88Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9u3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9u4; else goto c9u5;
       c9u4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9u5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s88P_entry() //  [R1]
         { info_tbl: [(c9ua,
                       label: sat_s88P_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ua: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c9ub; else goto c9uc;
       c9ub: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9uc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 many_v_s88N_entry() //  [R1]
         { info_tbl: [(c9ud,
                       label: many_v_s88N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ud: // global
           _s88N::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c9ue; else goto c9uf;
       c9uf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c9uh; else goto c9ug;
       c9uh: // global
           HpAlloc = 88;
           goto c9ue;
       c9ue: // global
           R1 = _s88N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9ug: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s88N::P64;
           _s88L::P64 = P64[_s88N::P64 + 16];
           _s88M::P64 = P64[_s88N::P64 + 24];
           I64[Hp - 80] = $dApplicative_s88O_info;
           P64[Hp - 64] = _s88L::P64;
           I64[Hp - 56] = sat_s88Q_info;
           _c9tS::P64 = Hp - 80;
           P64[Hp - 40] = _c9tS::P64;
           I64[Hp - 32] = sat_s88P_info;
           P64[Hp - 16] = _s88M::P64;
           P64[Hp - 8] = _s88N::P64;
           P64[Hp] = _c9tS::P64;
           R2 = _s88L::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmmany_entry() //  [R2, R3]
         { info_tbl: [(c9ui,
                       label: GHC.Base.$dmmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ui: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9um; else goto c9ul;
       c9um: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ul: // global
           I64[Hp - 24] = many_v_s88N_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.044319631 UTC

[section ""data" . GHC.Base.$w$csconcat3_closure" {
     GHC.Base.$w$csconcat3_closure:
         const GHC.Base.$w$csconcat3_info;
 },
 sat_s894_entry() //  [R1, R2]
         { info_tbl: [(c9uK,
                       label: sat_s894_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9uK: // global
           _s891::P64 = R2;
           _s894::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c9uL; else goto c9uM;
       c9uM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c9uO; else goto c9uN;
       c9uO: // global
           HpAlloc = 64;
           goto c9uL;
       c9uL: // global
           R2 = _s891::P64;
           R1 = _s894::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9uN: // global
           _s88R::P64 = P64[_s894::P64 + 7];
           _s88V::P64 = P64[_s894::P64 + 15];
           _s890::P64 = P64[_s894::P64 + 23];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s890::P64;
           P64[Hp - 32] = _s891::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s88V::P64;
           P64[Hp] = _s891::P64;
           R2 = _s88R::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 go_s88U_entry() //  [R1, R2, R3]
         { info_tbl: [(c9uT,
                       label: go_s88U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9uT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9uU; else goto c9uV;
       c9uU: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9uV: // global
           I64[Sp - 32] = block_c9uw_info;
           _s88U::P64 = R1;
           _s88R::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s88R::P64;
           P64[Sp - 16] = _s88U::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9v1; else goto c9ux;
       u9v1: // global
           call _c9uw(R1) args: 0, res: 0, upd: 0;
       c9ux: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9uw() //  [R1]
         { info_tbl: [(c9uw,
                       label: block_c9uw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9uw: // global
           _s88V::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c9uQ; else goto c9uR;
       c9uQ: // global
           R1 = _s88V::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9uR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9v0; else goto c9uZ;
       c9v0: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9uZ: // global
           _s88Y::P64 = P64[R1 + 6];
           _s88Z::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _s88Y::P64;
           P64[Hp - 32] = _s88Z::P64;
           I64[Hp - 24] = sat_s894_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s88V::P64;
           P64[Hp] = Hp - 64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat3_entry() //  [R2, R3, R4]
         { info_tbl: [(c9v2,
                       label: GHC.Base.$w$csconcat3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9v2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9v6; else goto c9v5;
       c9v6: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9v5: // global
           I64[Hp - 8] = go_s88U_info;
           P64[Hp] = R2;
           _s88S::P64 = R3;
           R3 = R4;
           R2 = _s88S::P64;
           R1 = Hp - 6;
           call go_s88U_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.046917324 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$csconcat_closure" {
     GHC.Base.$fSemigroup(->)_$csconcat_closure:
         const GHC.Base.$fSemigroup(->)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(->)_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c9ve,
                       label: GHC.Base.$fSemigroup(->)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ve: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9vf; else goto c9vg;
       c9vf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9vg: // global
           I64[Sp - 16] = block_c9vb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9vk; else goto c9vc;
       u9vk: // global
           call _c9vb(R1) args: 0, res: 0, upd: 0;
       c9vc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9vb() //  [R1]
         { info_tbl: [(c9vb,
                       label: block_c9vb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9vb: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.049160334 UTC

[section ""data" . GHC.Base.$w$csconcat_closure" {
     GHC.Base.$w$csconcat_closure:
         const GHC.Base.$w$csconcat_info;
 },
 sat_s89t_entry() //  [R1]
         { info_tbl: [(c9vL,
                       label: sat_s89t_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9vL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9vM; else goto c9vN;
       c9vM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9vN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s89s_entry() //  [R1]
         { info_tbl: [(c9vS,
                       label: sat_s89s_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9vS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9vT; else goto c9vU;
       c9vT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9vU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s89f_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c9vZ,
                       label: $wgo_s89f_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9vZ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c9w0; else goto c9w1;
       c9w0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9w1: // global
           I64[Sp - 48] = block_c9vu_info;
           _s89f::P64 = R1;
           _s89a::P64 = P64[R1 + 5];
           _s89b::P64 = P64[R1 + 13];
           R1 = R4;
           P64[Sp - 40] = _s89a::P64;
           P64[Sp - 32] = _s89b::P64;
           P64[Sp - 24] = _s89f::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u9wa; else goto c9vv;
       u9wa: // global
           call _c9vu(R1) args: 0, res: 0, upd: 0;
       c9vv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9vu() //  [R1]
         { info_tbl: [(c9vu,
                       label: block_c9vu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9vu: // global
           if (R1 & 7 == 1) goto c9vW; else goto c9vX;
       c9vW: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c9vX: // global
           I64[Sp - 8] = block_c9vA_info;
           _s89l::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s89l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9w9; else goto c9vB;
       u9w9: // global
           call _c9vA(R1) args: 0, res: 0, upd: 0;
       c9vB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9vA() //  [R1]
         { info_tbl: [(c9vA,
                       label: block_c9vA_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9vA: // global
           _s89l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9vF_info;
           R4 = _s89l::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           Sp = Sp + 8;
           call $wgo_s89f_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9vF() //  [R1, R2]
         { info_tbl: [(c9vF,
                       label: block_c9vF_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9vF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c9w8; else goto c9w7;
       c9w8: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c9w7: // global
           I64[Hp - 72] = sat_s89t_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s89s_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c9wb,
                       label: GHC.Base.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9wb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9wf; else goto c9we;
       c9wf: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9we: // global
           I64[Hp - 16] = $wgo_s89f_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _s89c::P64 = R4;
           R4 = R6;
           R3 = R5;
           R2 = _s89c::P64;
           R1 = Hp - 13;
           call $wgo_s89f_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.052328553 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,)_$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c9wn,
                       label: GHC.Base.$fSemigroup(,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9wn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9wy; else goto c9wz;
       c9wy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9wz: // global
           I64[Sp - 24] = block_c9wk_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9wG; else goto c9wl;
       u9wG: // global
           call _c9wk(R1) args: 0, res: 0, upd: 0;
       c9wl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9wk() //  [R1]
         { info_tbl: [(c9wk,
                       label: block_c9wk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9wk: // global
           I64[Sp - 8] = block_c9wq_info;
           _s89z::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s89z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9wF; else goto c9wr;
       u9wF: // global
           call _c9wq(R1) args: 0, res: 0, upd: 0;
       c9wr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9wq() //  [R1]
         { info_tbl: [(c9wq,
                       label: block_c9wq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9wq: // global
           _s89v::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c9wv_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s89v::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Base.$w$csconcat_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9wv() //  [R1, R2]
         { info_tbl: [(c9wv,
                       label: block_c9wv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9wv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9wE; else goto c9wD;
       c9wE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c9wD: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.054617756 UTC

[section ""data" . GHC.Base.$dmsconcat_closure" {
     GHC.Base.$dmsconcat_closure:
         const GHC.Base.$dmsconcat_info;
 },
 go_s89L_entry() //  [R1, R2, R3]
         { info_tbl: [(c9x2,
                       label: go_s89L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9x2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9x3; else goto c9x4;
       c9x3: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9x4: // global
           I64[Sp - 32] = block_c9wV_info;
           _s89L::P64 = R1;
           _s89G::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s89G::P64;
           P64[Sp - 16] = _s89L::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9xe; else goto c9wW;
       u9xe: // global
           call _c9wV(R1) args: 0, res: 0, upd: 0;
       c9wW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9wV() //  [R1]
         { info_tbl: [(c9wV,
                       label: block_c9wV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9wV: // global
           _s89M::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c9wZ; else goto c9x0;
       c9wZ: // global
           R1 = _s89M::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9x0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9xc; else goto c9xb;
       c9xc: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9xb: // global
           _s89P::P64 = P64[R1 + 6];
           _s89Q::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s89P::P64;
           P64[Hp] = _s89Q::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s89M::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$dmsconcat_entry() //  [R2, R3]
         { info_tbl: [(c9xf,
                       label: GHC.Base.$dmsconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9xf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9xg; else goto c9xh;
       c9xg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9xh: // global
           I64[Sp - 16] = block_c9wL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9xl; else goto c9wM;
       u9xl: // global
           call _c9wL(R1) args: 0, res: 0, upd: 0;
       c9wM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9wL() //  [R1]
         { info_tbl: [(c9wL,
                       label: block_c9wL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9wL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9xk; else goto c9xj;
       c9xk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9xj: // global
           _s89J::P64 = P64[R1 + 7];
           _s89K::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_s89L_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _s89K::P64;
           R2 = _s89J::P64;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call go_s89L_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.056600494 UTC

[section ""data" . GHC.Base.$dmstimes_closure" {
     GHC.Base.$dmstimes_closure:
         const GHC.Base.$dmstimes_info;
         const 0;
 },
 GHC.Base.$dmstimes_entry() //  [R2, R3]
         { info_tbl: [(c9xq,
                       label: GHC.Base.$dmstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9xq: // global
           _s89T::P64 = R3;
           R3 = R2;
           R2 = _s89T::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.058082615 UTC

[section ""data" . GHC.Base.$dmmappend_closure" {
     GHC.Base.$dmmappend_closure:
         const GHC.Base.$dmmappend_info;
 },
 GHC.Base.$dmmappend_entry() //  [R2]
         { info_tbl: [(c9xz,
                       label: GHC.Base.$dmmappend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9xz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9xA; else goto c9xB;
       c9xA: // global
           R2 = R2;
           R1 = GHC.Base.$dmmappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9xB: // global
           I64[Sp - 8] = block_c9xx_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9xx() //  [R1]
         { info_tbl: [(c9xx,
                       label: block_c9xx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9xx: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.059194768 UTC

[section ""data" . GHC.Base.$dm>>_closure" {
     GHC.Base.$dm>>_closure:
         const GHC.Base.$dm>>_info;
 },
 sat_s8a0_entry() //  [R1]
         { info_tbl: [(c9xO,
                       label: sat_s8a0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9xO: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$dm>>_entry() //  [R2, R3, R4]
         { info_tbl: [(c9xR,
                       label: GHC.Base.$dm>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9xR: // global
           _s89Y::P64 = R4;
           _s89X::P64 = R3;
           _s89W::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c9xS; else goto c9xT;
       c9xT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9xV; else goto c9xU;
       c9xV: // global
           HpAlloc = 16;
           goto c9xS;
       c9xS: // global
           R4 = _s89Y::P64;
           R3 = _s89X::P64;
           R2 = _s89W::P64;
           R1 = GHC.Base.$dm>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9xU: // global
           I64[Hp - 8] = sat_s8a0_info;
           P64[Hp] = _s89Y::P64;
           R2 = _s89W::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s89X::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.060565781 UTC

[section ""data" . GHC.Base.$dmreturn_closure" {
     GHC.Base.$dmreturn_closure:
         const GHC.Base.$dmreturn_info;
 },
 GHC.Base.$dmreturn_entry() //  [R2]
         { info_tbl: [(c9y2,
                       label: GHC.Base.$dmreturn_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9y2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9y3; else goto c9y4;
       c9y3: // global
           R2 = R2;
           R1 = GHC.Base.$dmreturn_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9y4: // global
           I64[Sp - 8] = block_c9y0_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9y0() //  [R1]
         { info_tbl: [(c9y0,
                       label: block_c9y0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9y0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.061586451 UTC

[section ""data" . GHC.Base.$dmfail_closure" {
     GHC.Base.$dmfail_closure:
         const GHC.Base.$dmfail_info;
         const 0;
 },
 GHC.Base.$dmfail_entry() //  [R3]
         { info_tbl: [(c9yc,
                       label: GHC.Base.$dmfail_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9yc: // global
           R2 = R3;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.062593385 UTC

[section ""data" . GHC.Base.$dmmzero_closure" {
     GHC.Base.$dmmzero_closure:
         const GHC.Base.$dmmzero_info;
 },
 GHC.Base.$dmmzero_entry() //  [R2]
         { info_tbl: [(c9yl,
                       label: GHC.Base.$dmmzero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9yl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9ym; else goto c9yn;
       c9ym: // global
           R2 = R2;
           R1 = GHC.Base.$dmmzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9yn: // global
           I64[Sp - 8] = block_c9yj_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9yj() //  [R1]
         { info_tbl: [(c9yj,
                       label: block_c9yj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9yj: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.063559659 UTC

[section ""data" . GHC.Base.$dmmplus_closure" {
     GHC.Base.$dmmplus_closure:
         const GHC.Base.$dmmplus_info;
 },
 GHC.Base.$dmmplus_entry() //  [R2]
         { info_tbl: [(c9yx,
                       label: GHC.Base.$dmmplus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9yx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9yy; else goto c9yz;
       c9yy: // global
           R2 = R2;
           R1 = GHC.Base.$dmmplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9yz: // global
           I64[Sp - 8] = block_c9yv_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9yv() //  [R1]
         { info_tbl: [(c9yv,
                       label: block_c9yv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9yv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.065143696 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c==_closure" {
     GHC.Base.$fEqMaybe_$c==_closure:
         const GHC.Base.$fEqMaybe_$c==_info;
 },
 GHC.Base.$fEqMaybe_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(c9yO,
                       label: GHC.Base.$fEqMaybe_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9yO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9yP; else goto c9yQ;
       c9yP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9yQ: // global
           I64[Sp - 24] = block_c9yH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9zr; else goto c9yI;
       u9zr: // global
           call _c9yH(R1) args: 0, res: 0, upd: 0;
       c9yI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9yH() //  [R1]
         { info_tbl: [(c9yH,
                       label: block_c9yH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9yH: // global
           _s8ab::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9yL; else goto c9yM;
       c9yL: // global
           I64[Sp + 16] = block_c9yT_info;
           R1 = _s8ab::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9zp; else goto c9yV;
       u9zp: // global
           call _c9yT(R1) args: 0, res: 0, upd: 0;
       c9yV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9yM: // global
           I64[Sp] = block_c9z8_info;
           _s8af::P64 = P64[R1 + 6];
           R1 = _s8ab::P64;
           P64[Sp + 16] = _s8af::P64;
           if (R1 & 7 != 0) goto u9zq; else goto c9za;
       u9zq: // global
           call _c9z8(R1) args: 0, res: 0, upd: 0;
       c9za: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9yT() //  [R1]
         { info_tbl: [(c9yT,
                       label: block_c9yT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9yT: // global
           if (R1 & 7 == 1) goto c9z1; else goto u9zo;
       c9z1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9zo: // global
           Sp = Sp + 8;
           call _c9zg() args: 0, res: 0, upd: 0;
     }
 },
 _c9z8() //  [R1]
         { info_tbl: [(c9z8,
                       label: block_c9z8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9z8: // global
           if (R1 & 7 == 1) goto u9zn; else goto c9zk;
       u9zn: // global
           Sp = Sp + 24;
           call _c9zg() args: 0, res: 0, upd: 0;
       c9zk: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c9zg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9zg: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.067569668 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c/=_closure" {
     GHC.Base.$fEqMaybe_$c/=_closure:
         const GHC.Base.$fEqMaybe_$c/=_info;
 },
 GHC.Base.$fEqMaybe_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(c9zF,
                       label: GHC.Base.$fEqMaybe_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9zF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9zG; else goto c9zH;
       c9zG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9zH: // global
           I64[Sp - 24] = block_c9zy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Ax; else goto c9zz;
       u9Ax: // global
           call _c9zy(R1) args: 0, res: 0, upd: 0;
       c9zz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9zy() //  [R1]
         { info_tbl: [(c9zy,
                       label: block_c9zy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9zy: // global
           _s8ak::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9zC; else goto c9zD;
       c9zC: // global
           I64[Sp + 16] = block_c9zK_info;
           R1 = _s8ak::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9Av; else goto c9zM;
       u9Av: // global
           call _c9zK(R1) args: 0, res: 0, upd: 0;
       c9zM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9zD: // global
           I64[Sp] = block_c9zZ_info;
           _s8ao::P64 = P64[R1 + 6];
           R1 = _s8ak::P64;
           P64[Sp + 16] = _s8ao::P64;
           if (R1 & 7 != 0) goto u9Aw; else goto c9A1;
       u9Aw: // global
           call _c9zZ(R1) args: 0, res: 0, upd: 0;
       c9A1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9zK() //  [R1]
         { info_tbl: [(c9zK,
                       label: block_c9zK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9zK: // global
           if (R1 & 7 == 1) goto u9At; else goto u9Au;
       u9At: // global
           Sp = Sp + 8;
           call _c9Am() args: 0, res: 0, upd: 0;
       u9Au: // global
           Sp = Sp + 8;
           call _c9Ai() args: 0, res: 0, upd: 0;
     }
 },
 _c9zZ() //  [R1]
         { info_tbl: [(c9zZ,
                       label: block_c9zZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9zZ: // global
           if (R1 & 7 == 1) goto u9Aq; else goto c9Ac;
       u9Aq: // global
           Sp = Sp + 24;
           call _c9Ai() args: 0, res: 0, upd: 0;
       c9Ac: // global
           _s8ao::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9Aa_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8ao::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9Aa() //  [R1]
         { info_tbl: [(c9Aa,
                       label: block_c9Aa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Aa: // global
           if (R1 & 7 == 1) goto u9Ar; else goto u9As;
       u9Ar: // global
           Sp = Sp + 8;
           call _c9Ai() args: 0, res: 0, upd: 0;
       u9As: // global
           Sp = Sp + 8;
           call _c9Am() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ai() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ai: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Am() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Am: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.069895316 UTC

[section ""data" . GHC.Base.$fEqMaybe_closure" {
     GHC.Base.$fEqMaybe_closure:
         const GHC.Base.$fEqMaybe_info;
 },
 sat_s8au_entry() //  [R1, R2, R3]
         { info_tbl: [(c9AM,
                       label: sat_s8au_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9AM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8at_entry() //  [R1, R2, R3]
         { info_tbl: [(c9AU,
                       label: sat_s8at_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9AU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fEqMaybe_entry() //  [R2]
         { info_tbl: [(c9AY,
                       label: GHC.Base.$fEqMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9AY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9B2; else goto c9B1;
       c9B2: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9B1: // global
           I64[Hp - 48] = sat_s8au_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8at_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.071335634 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cp1Ord_closure" {
     GHC.Base.$fOrdMaybe_$cp1Ord_closure:
         const GHC.Base.$fOrdMaybe_$cp1Ord_info;
 },
 sat_s8aw_entry() //  [R1]
         { info_tbl: [(c9Bb,
                       label: sat_s8aw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Bb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Bc; else goto c9Bd;
       c9Bc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Bd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdMaybe_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c9Be,
                       label: GHC.Base.$fOrdMaybe_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Be: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Bi; else goto c9Bh;
       c9Bi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Bh: // global
           I64[Hp - 16] = sat_s8aw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqMaybe_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.073329363 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$ccompare_closure" {
     GHC.Base.$fOrdMaybe_$ccompare_closure:
         const GHC.Base.$fOrdMaybe_$ccompare_info;
 },
 GHC.Base.$fOrdMaybe_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Bu,
                       label: GHC.Base.$fOrdMaybe_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Bu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Bv; else goto c9Bw;
       c9Bv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Bw: // global
           I64[Sp - 24] = block_c9Bn_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9C5; else goto c9Bo;
       u9C5: // global
           call _c9Bn(R1) args: 0, res: 0, upd: 0;
       c9Bo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Bn() //  [R1]
         { info_tbl: [(c9Bn,
                       label: block_c9Bn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Bn: // global
           _s8az::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9Br; else goto c9Bs;
       c9Br: // global
           I64[Sp + 16] = block_c9Bz_info;
           R1 = _s8az::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9C3; else goto c9BB;
       u9C3: // global
           call _c9Bz(R1) args: 0, res: 0, upd: 0;
       c9BB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Bs: // global
           I64[Sp] = block_c9BO_info;
           _s8aD::P64 = P64[R1 + 6];
           R1 = _s8az::P64;
           P64[Sp + 16] = _s8aD::P64;
           if (R1 & 7 != 0) goto u9C4; else goto c9BQ;
       u9C4: // global
           call _c9BO(R1) args: 0, res: 0, upd: 0;
       c9BQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Bz() //  [R1]
         { info_tbl: [(c9Bz,
                       label: block_c9Bz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Bz: // global
           if (R1 & 7 == 1) goto c9BH; else goto c9BL;
       c9BH: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9BL: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9BO() //  [R1]
         { info_tbl: [(c9BO,
                       label: block_c9BO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9BO: // global
           if (R1 & 7 == 1) goto c9BW; else goto c9C0;
       c9BW: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9C0: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.076552456 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<_closure" {
     GHC.Base.$fOrdMaybe_$c<_closure:
         const GHC.Base.$fOrdMaybe_$c<_info;
 },
 GHC.Base.$fOrdMaybe_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Ch,
                       label: GHC.Base.$fOrdMaybe_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ch: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ci; else goto c9Cj;
       c9Ci: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Cj: // global
           I64[Sp - 24] = block_c9Ca_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9CU; else goto c9Cb;
       u9CU: // global
           call _c9Ca(R1) args: 0, res: 0, upd: 0;
       c9Cb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ca() //  [R1]
         { info_tbl: [(c9Ca,
                       label: block_c9Ca_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ca: // global
           _s8aI::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9Ce; else goto c9Cf;
       c9Ce: // global
           I64[Sp + 16] = block_c9Cm_info;
           R1 = _s8aI::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9CS; else goto c9Co;
       u9CS: // global
           call _c9Cm(R1) args: 0, res: 0, upd: 0;
       c9Co: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Cf: // global
           I64[Sp] = block_c9CB_info;
           _s8aM::P64 = P64[R1 + 6];
           R1 = _s8aI::P64;
           P64[Sp + 16] = _s8aM::P64;
           if (R1 & 7 != 0) goto u9CT; else goto c9CD;
       u9CT: // global
           call _c9CB(R1) args: 0, res: 0, upd: 0;
       c9CD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Cm() //  [R1]
         { info_tbl: [(c9Cm,
                       label: block_c9Cm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Cm: // global
           if (R1 & 7 == 1) goto u9CR; else goto c9Cy;
       u9CR: // global
           Sp = Sp + 8;
           call _c9CJ() args: 0, res: 0, upd: 0;
       c9Cy: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9CB() //  [R1]
         { info_tbl: [(c9CB,
                       label: block_c9CB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9CB: // global
           if (R1 & 7 == 1) goto u9CQ; else goto c9CN;
       u9CQ: // global
           Sp = Sp + 24;
           call _c9CJ() args: 0, res: 0, upd: 0;
       c9CN: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _c9CJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9CJ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.078899113 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<=_closure" {
     GHC.Base.$fOrdMaybe_$c<=_closure:
         const GHC.Base.$fOrdMaybe_$c<=_info;
 },
 GHC.Base.$fOrdMaybe_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(c9D8,
                       label: GHC.Base.$fOrdMaybe_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9D8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9D9; else goto c9Da;
       c9D9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Da: // global
           I64[Sp - 24] = block_c9D1_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9E0; else goto c9D2;
       u9E0: // global
           call _c9D1(R1) args: 0, res: 0, upd: 0;
       c9D2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9D1() //  [R1]
         { info_tbl: [(c9D1,
                       label: block_c9D1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9D1: // global
           _s8aQ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9D5; else goto c9D6;
       c9D5: // global
           I64[Sp + 16] = block_c9Dd_info;
           R1 = _s8aQ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9DY; else goto c9Df;
       u9DY: // global
           call _c9Dd(R1) args: 0, res: 0, upd: 0;
       c9Df: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9D6: // global
           I64[Sp] = block_c9Ds_info;
           _s8aV::P64 = P64[R1 + 6];
           R1 = _s8aQ::P64;
           P64[Sp + 16] = _s8aV::P64;
           if (R1 & 7 != 0) goto u9DZ; else goto c9Du;
       u9DZ: // global
           call _c9Ds(R1) args: 0, res: 0, upd: 0;
       c9Du: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Dd() //  [R1]
         { info_tbl: [(c9Dd,
                       label: block_c9Dd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Dd: // global
           if (R1 & 7 == 1) goto u9DW; else goto u9DX;
       u9DW: // global
           Sp = Sp + 8;
           call _c9DL() args: 0, res: 0, upd: 0;
       u9DX: // global
           Sp = Sp + 8;
           call _c9DP() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ds() //  [R1]
         { info_tbl: [(c9Ds,
                       label: block_c9Ds_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ds: // global
           if (R1 & 7 == 1) goto u9DT; else goto c9DF;
       u9DT: // global
           Sp = Sp + 24;
           call _c9DL() args: 0, res: 0, upd: 0;
       c9DF: // global
           _s8aV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9DD_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8aV::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9DD() //  [R1]
         { info_tbl: [(c9DD,
                       label: block_c9DD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9DD: // global
           if (R1 & 7 == 1) goto u9DU; else goto u9DV;
       u9DU: // global
           Sp = Sp + 8;
           call _c9DL() args: 0, res: 0, upd: 0;
       u9DV: // global
           Sp = Sp + 8;
           call _c9DP() args: 0, res: 0, upd: 0;
     }
 },
 _c9DL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9DL: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9DP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9DP: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.081452147 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmax_closure" {
     GHC.Base.$fOrdMaybe_$cmax_closure:
         const GHC.Base.$fOrdMaybe_$cmax_info;
 },
 GHC.Base.$fOrdMaybe_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Eh,
                       label: GHC.Base.$fOrdMaybe_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Eh: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c9Ei; else goto c9Ej;
       c9Ei: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Ej: // global
           I64[Sp - 24] = block_c9Ea_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9ES; else goto c9Eb;
       u9ES: // global
           call _c9Ea(R1) args: 0, res: 0, upd: 0;
       c9Eb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ea() //  [R1]
         { info_tbl: [(c9Ea,
                       label: block_c9Ea_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ea: // global
           _s8b0::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9Ee; else goto c9Ef;
       c9Ee: // global
           R1 = _s8b0::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Ef: // global
           I64[Sp - 8] = block_c9Ep_info;
           _s8b2::P64 = R1;
           _s8b3::P64 = P64[R1 + 6];
           R1 = _s8b0::P64;
           P64[Sp] = _s8b3::P64;
           P64[Sp + 16] = _s8b2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9ER; else goto c9Er;
       u9ER: // global
           call _c9Ep(R1) args: 0, res: 0, upd: 0;
       c9Er: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ep() //  [R1]
         { info_tbl: [(c9Ep,
                       label: block_c9Ep_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ep: // global
           if (R1 & 7 == 1) goto u9EP; else goto c9EC;
       u9EP: // global
           Sp = Sp + 24;
           call _c9EI() args: 0, res: 0, upd: 0;
       c9EC: // global
           _s8b3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9EA_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s8b3::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9EA() //  [R1]
         { info_tbl: [(c9EA,
                       label: block_c9EA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9EA: // global
           if (R1 & 7 == 1) goto u9EQ; else goto c9EM;
       u9EQ: // global
           Sp = Sp + 16;
           call _c9EI() args: 0, res: 0, upd: 0;
       c9EM: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9EI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9EI: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.083809584 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmin_closure" {
     GHC.Base.$fOrdMaybe_$cmin_closure:
         const GHC.Base.$fOrdMaybe_$cmin_info;
 },
 GHC.Base.$fOrdMaybe_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(c9F6,
                       label: GHC.Base.$fOrdMaybe_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9F6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c9F7; else goto c9F8;
       c9F7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9F8: // global
           I64[Sp - 24] = block_c9EZ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9FM; else goto c9F0;
       u9FM: // global
           call _c9EZ(R1) args: 0, res: 0, upd: 0;
       c9F0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9EZ() //  [R1]
         { info_tbl: [(c9EZ,
                       label: block_c9EZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9EZ: // global
           _s8b8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9F3; else goto c9F4;
       c9F3: // global
           I64[Sp + 16] = block_c9Fb_info;
           R1 = _s8b8::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9FK; else goto c9Fd;
       u9FK: // global
           call _c9Fb() args: 0, res: 0, upd: 0;
       c9Fd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9F4: // global
           I64[Sp - 8] = block_c9Fk_info;
           _s8ba::P64 = R1;
           _s8bc::P64 = P64[R1 + 6];
           R1 = _s8b8::P64;
           P64[Sp] = _s8bc::P64;
           P64[Sp + 16] = _s8ba::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9FL; else goto c9Fm;
       u9FL: // global
           call _c9Fk(R1) args: 0, res: 0, upd: 0;
       c9Fm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Fb() //  []
         { info_tbl: [(c9Fb,
                       label: block_c9Fb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Fb: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Fk() //  [R1]
         { info_tbl: [(c9Fk,
                       label: block_c9Fk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Fk: // global
           if (R1 & 7 == 1) goto c9Fs; else goto c9Fx;
       c9Fs: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Fx: // global
           _s8bc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9Fv_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s8bc::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9Fv() //  [R1]
         { info_tbl: [(c9Fv,
                       label: block_c9Fv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Fv: // global
           if (R1 & 7 == 1) goto c9FD; else goto c9FH;
       c9FD: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9FH: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.086281483 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c>=_closure" {
     GHC.Base.$fOrdMaybe_$c>=_closure:
         const GHC.Base.$fOrdMaybe_$c>=_info;
 },
 GHC.Base.$fOrdMaybe_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(c9FY,
                       label: GHC.Base.$fOrdMaybe_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9FZ; else goto c9G0;
       c9FZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G0: // global
           I64[Sp - 24] = block_c9FR_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9GQ; else goto c9FS;
       u9GQ: // global
           call _c9FR(R1) args: 0, res: 0, upd: 0;
       c9FS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FR() //  [R1]
         { info_tbl: [(c9FR,
                       label: block_c9FR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FR: // global
           _s8bi::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9FV; else goto c9FW;
       c9FV: // global
           I64[Sp + 16] = block_c9G3_info;
           R1 = _s8bi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9GO; else goto c9G5;
       u9GO: // global
           call _c9G3(R1) args: 0, res: 0, upd: 0;
       c9G5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FW: // global
           I64[Sp] = block_c9Gi_info;
           _s8bm::P64 = P64[R1 + 6];
           R1 = _s8bi::P64;
           P64[Sp + 16] = _s8bm::P64;
           if (R1 & 7 != 0) goto u9GP; else goto c9Gk;
       u9GP: // global
           call _c9Gi(R1) args: 0, res: 0, upd: 0;
       c9Gk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G3() //  [R1]
         { info_tbl: [(c9G3,
                       label: block_c9G3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G3: // global
           if (R1 & 7 == 1) goto u9GM; else goto u9GN;
       u9GM: // global
           Sp = Sp + 8;
           call _c9GB() args: 0, res: 0, upd: 0;
       u9GN: // global
           Sp = Sp + 8;
           call _c9GF() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gi() //  [R1]
         { info_tbl: [(c9Gi,
                       label: block_c9Gi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gi: // global
           if (R1 & 7 == 1) goto u9GJ; else goto c9Gv;
       u9GJ: // global
           Sp = Sp + 24;
           call _c9GB() args: 0, res: 0, upd: 0;
       c9Gv: // global
           _s8bm::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9Gt_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8bm::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9Gt() //  [R1]
         { info_tbl: [(c9Gt,
                       label: block_c9Gt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gt: // global
           if (R1 & 7 == 1) goto u9GK; else goto u9GL;
       u9GK: // global
           Sp = Sp + 8;
           call _c9GB() args: 0, res: 0, upd: 0;
       u9GL: // global
           Sp = Sp + 8;
           call _c9GF() args: 0, res: 0, upd: 0;
     }
 },
 _c9GB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GB: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GF: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.089217391 UTC

[section ""data" . GHC.Base.$fOrdMaybe_closure" {
     GHC.Base.$fOrdMaybe_closure:
         const GHC.Base.$fOrdMaybe_info;
 },
 sat_s8bA_entry() //  [R1, R2, R3]
         { info_tbl: [(c9H5,
                       label: sat_s8bA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bz_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Hd,
                       label: sat_s8bz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8by_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Hl,
                       label: sat_s8by_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hl: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bx_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Ht,
                       label: sat_s8bx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ht: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bu_entry() //  [R1, R2, R3]
         { info_tbl: [(c9HB,
                       label: sat_s8bu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bt_entry() //  [R1, R2, R3]
         { info_tbl: [(c9HJ,
                       label: sat_s8bt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bs_entry() //  [R1, R2, R3]
         { info_tbl: [(c9HR,
                       label: sat_s8bs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HR: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8br_entry() //  [R1]
         { info_tbl: [(c9HY,
                       label: sat_s8br_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HZ; else goto c9I0;
       c9HZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9I0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdMaybe_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdMaybe_entry() //  [R2]
         { info_tbl: [(c9I2,
                       label: GHC.Base.$fOrdMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I2: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c9I6; else goto c9I5;
       c9I6: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9I5: // global
           I64[Hp - 200] = sat_s8bA_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s8bz_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8by_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s8bx_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s8bu_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s8bt_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8bs_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8br_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.092213441 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c/=_closure" {
     GHC.Base.$fEqNonEmpty_$c/=_closure:
         const GHC.Base.$fEqNonEmpty_$c/=_info;
 },
 GHC.Base.$fEqNonEmpty_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Ie,
                       label: GHC.Base.$fEqNonEmpty_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ie: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c9Ii; else goto c9Ij;
       c9Ii: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Ij: // global
           I64[Sp - 24] = block_c9Ib_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9IR; else goto c9Ic;
       u9IR: // global
           call _c9Ib(R1) args: 0, res: 0, upd: 0;
       c9Ic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ib() //  [R1]
         { info_tbl: [(c9Ib,
                       label: block_c9Ib_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ib: // global
           I64[Sp - 8] = block_c9Ih_info;
           _s8bF::P64 = P64[R1 + 7];
           _s8bG::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8bG::P64;
           P64[Sp + 16] = _s8bF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IQ; else goto c9Il;
       u9IQ: // global
           call _c9Ih(R1) args: 0, res: 0, upd: 0;
       c9Il: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ih() //  [R1]
         { info_tbl: [(c9Ih,
                       label: block_c9Ih_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ih: // global
           I64[Sp] = block_c9Ip_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9Ip() //  [R1]
         { info_tbl: [(c9Ip,
                       label: block_c9Ip_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ip: // global
           if (R1 & 7 == 1) goto u9IO; else goto c9IB;
       u9IO: // global
           Sp = Sp + 32;
           call _c9IH() args: 0, res: 0, upd: 0;
       c9IB: // global
           _s8bJ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c9Iz_info;
           R4 = _s8bJ::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Iz() //  [R1]
         { info_tbl: [(c9Iz,
                       label: block_c9Iz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iz: // global
           if (R1 & 7 == 1) goto u9IP; else goto c9IL;
       u9IP: // global
           Sp = Sp + 8;
           call _c9IH() args: 0, res: 0, upd: 0;
       c9IL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IH: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.094275145 UTC

[section ""data" . GHC.Base.$w$c==_closure" {
     GHC.Base.$w$c==_closure:
         const GHC.Base.$w$c==_info;
 },
 GHC.Base.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c9J4,
                       label: GHC.Base.$w$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J4: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c9J5; else goto c9J6;
       c9J5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9J6: // global
           I64[Sp - 32] = block_c9IY_info;
           _s8bM::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8bM::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9IY() //  [R1]
         { info_tbl: [(c9IY,
                       label: block_c9IY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IY: // global
           if (R1 & 7 == 1) goto c9J1; else goto c9J2;
       c9J1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9J2: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.09563723 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c==_closure" {
     GHC.Base.$fEqNonEmpty_$c==_closure:
         const GHC.Base.$fEqNonEmpty_$c==_info;
 },
 GHC.Base.$fEqNonEmpty_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Jk,
                       label: GHC.Base.$fEqNonEmpty_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Jo; else goto c9Jp;
       c9Jo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Jp: // global
           I64[Sp - 24] = block_c9Jh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Jx; else goto c9Ji;
       u9Jx: // global
           call _c9Jh(R1) args: 0, res: 0, upd: 0;
       c9Ji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jh() //  [R1]
         { info_tbl: [(c9Jh,
                       label: block_c9Jh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jh: // global
           I64[Sp - 8] = block_c9Jn_info;
           _s8bW::P64 = P64[R1 + 7];
           _s8bX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8bX::P64;
           P64[Sp + 16] = _s8bW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Jw; else goto c9Jr;
       u9Jw: // global
           call _c9Jn(R1) args: 0, res: 0, upd: 0;
       c9Jr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jn() //  [R1]
         { info_tbl: [(c9Jn,
                       label: block_c9Jn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jn: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c==_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.097412756 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_closure" {
     GHC.Base.$fEqNonEmpty_closure:
         const GHC.Base.$fEqNonEmpty_info;
 },
 sat_s8c3_entry() //  [R1, R2, R3]
         { info_tbl: [(c9JH,
                       label: sat_s8c3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c/=_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8c2_entry() //  [R1, R2, R3]
         { info_tbl: [(c9JP,
                       label: sat_s8c2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c==_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fEqNonEmpty_entry() //  [R2]
         { info_tbl: [(c9JT,
                       label: GHC.Base.$fEqNonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9JX; else goto c9JW;
       c9JX: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JW: // global
           I64[Hp - 48] = sat_s8c3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8c2_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.098923591 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cp1Ord_closure" {
     GHC.Base.$fOrdNonEmpty_$cp1Ord_closure:
         const GHC.Base.$fOrdNonEmpty_$cp1Ord_info;
 },
 sat_s8c5_entry() //  [R1]
         { info_tbl: [(c9K6,
                       label: sat_s8c5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9K7; else goto c9K8;
       c9K7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9K8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdNonEmpty_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c9K9,
                       label: GHC.Base.$fOrdNonEmpty_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Kd; else goto c9Kc;
       c9Kd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Kc: // global
           I64[Hp - 16] = sat_s8c5_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqNonEmpty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.100336549 UTC

[section ""data" . GHC.Base.$w$ccompare_closure" {
     GHC.Base.$w$ccompare_closure:
         const GHC.Base.$w$ccompare_info;
 },
 GHC.Base.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c9Kp,
                       label: GHC.Base.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kp: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c9Kq; else goto c9Kr;
       c9Kq: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Kr: // global
           I64[Sp - 32] = block_c9Ki_info;
           _s8c6::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8c6::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9Ki() //  [R1]
         { info_tbl: [(c9Ki,
                       label: block_c9Ki_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ki: // global
           _c9Ko::P64 = R1 & 7;
           if (_c9Ko::P64 < 3) goto u9KB; else goto c9Kn;
       u9KB: // global
           if (_c9Ko::P64 < 2) goto c9Kl; else goto c9Km;
       c9Kl: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Km: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
       c9Kn: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.101753434 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$ccompare_closure" {
     GHC.Base.$fOrdNonEmpty_$ccompare_closure:
         const GHC.Base.$fOrdNonEmpty_$ccompare_info;
 },
 GHC.Base.$fOrdNonEmpty_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(c9KJ,
                       label: GHC.Base.$fOrdNonEmpty_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9KN; else goto c9KO;
       c9KN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KO: // global
           I64[Sp - 24] = block_c9KG_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9KW; else goto c9KH;
       u9KW: // global
           call _c9KG(R1) args: 0, res: 0, upd: 0;
       c9KH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KG() //  [R1]
         { info_tbl: [(c9KG,
                       label: block_c9KG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KG: // global
           I64[Sp - 8] = block_c9KM_info;
           _s8cg::P64 = P64[R1 + 7];
           _s8ch::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8ch::P64;
           P64[Sp + 16] = _s8cg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9KV; else goto c9KQ;
       u9KV: // global
           call _c9KM(R1) args: 0, res: 0, upd: 0;
       c9KQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KM() //  [R1]
         { info_tbl: [(c9KM,
                       label: block_c9KM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KM: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.1035286 UTC

[section ""data" . GHC.Base.$w$c<_closure" {
     GHC.Base.$w$c<_closure:
         const GHC.Base.$w$c<_info;
 },
 GHC.Base.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c9L8,
                       label: GHC.Base.$w$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L8: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c9L9; else goto c9La;
       c9L9: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9La: // global
           I64[Sp - 32] = block_c9L1_info;
           _s8cl::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8cl::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9L1() //  [R1]
         { info_tbl: [(c9L1,
                       label: block_c9L1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L1: // global
           _c9L7::P64 = R1 & 7;
           if (_c9L7::P64 < 3) goto u9Lk; else goto c9L6;
       u9Lk: // global
           if (_c9L7::P64 < 2) goto c9L4; else goto c9L5;
       c9L4: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9L5: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       c9L6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.105114404 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<_closure" {
     GHC.Base.$fOrdNonEmpty_$c<_closure:
         const GHC.Base.$fOrdNonEmpty_$c<_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Ls,
                       label: GHC.Base.$fOrdNonEmpty_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ls: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Lw; else goto c9Lx;
       c9Lw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Lx: // global
           I64[Sp - 24] = block_c9Lp_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9LF; else goto c9Lq;
       u9LF: // global
           call _c9Lp(R1) args: 0, res: 0, upd: 0;
       c9Lq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lp() //  [R1]
         { info_tbl: [(c9Lp,
                       label: block_c9Lp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lp: // global
           I64[Sp - 8] = block_c9Lv_info;
           _s8cv::P64 = P64[R1 + 7];
           _s8cw::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8cw::P64;
           P64[Sp + 16] = _s8cv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9LE; else goto c9Lz;
       u9LE: // global
           call _c9Lv(R1) args: 0, res: 0, upd: 0;
       c9Lz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lv() //  [R1]
         { info_tbl: [(c9Lv,
                       label: block_c9Lv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lv: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.106964113 UTC

[section ""data" . GHC.Base.$w$c<=_closure" {
     GHC.Base.$w$c<=_closure:
         const GHC.Base.$w$c<=_info;
 },
 GHC.Base.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c9LR,
                       label: GHC.Base.$w$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LR: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c9LS; else goto c9LT;
       c9LS: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9LT: // global
           I64[Sp - 32] = block_c9LK_info;
           _s8cA::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R5;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _s8cA::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9LK() //  [R1]
         { info_tbl: [(c9LK,
                       label: block_c9LK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LK: // global
           _c9LQ::P64 = R1 & 7;
           if (_c9LQ::P64 < 3) goto u9Mf; else goto u9Mg;
       u9Mf: // global
           if (_c9LQ::P64 < 2) goto u9Mh; else goto c9LO;
       u9Mh: // global
           Sp = Sp + 32;
           call _c9Ma() args: 0, res: 0, upd: 0;
       c9LO: // global
           _s8cE::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c9LZ_info;
           R4 = P64[Sp + 16];
           R3 = _s8cE::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       u9Mg: // global
           Sp = Sp + 32;
           call _c9LP() args: 0, res: 0, upd: 0;
     }
 },
 _c9LZ() //  [R1]
         { info_tbl: [(c9LZ,
                       label: block_c9LZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LZ: // global
           if (R1 & 7 == 1) goto u9Mi; else goto u9Mj;
       u9Mi: // global
           Sp = Sp + 8;
           call _c9Ma() args: 0, res: 0, upd: 0;
       u9Mj: // global
           Sp = Sp + 8;
           call _c9LP() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ma() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ma: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9LP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.108613163 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<=_closure" {
     GHC.Base.$fOrdNonEmpty_$c<=_closure:
         const GHC.Base.$fOrdNonEmpty_$c<=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Mv,
                       label: GHC.Base.$fOrdNonEmpty_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Mz; else goto c9MA;
       c9Mz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MA: // global
           I64[Sp - 24] = block_c9Ms_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9MI; else goto c9Mt;
       u9MI: // global
           call _c9Ms(R1) args: 0, res: 0, upd: 0;
       c9Mt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ms() //  [R1]
         { info_tbl: [(c9Ms,
                       label: block_c9Ms_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ms: // global
           I64[Sp - 8] = block_c9My_info;
           _s8cL::P64 = P64[R1 + 7];
           _s8cM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8cM::P64;
           P64[Sp + 16] = _s8cL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9MH; else goto c9MC;
       u9MH: // global
           call _c9My(R1) args: 0, res: 0, upd: 0;
       c9MC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9My() //  [R1]
         { info_tbl: [(c9My,
                       label: block_c9My_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9My: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.110764253 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmax_closure" {
     GHC.Base.$fOrdNonEmpty_$cmax_closure:
         const GHC.Base.$fOrdNonEmpty_$cmax_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(c9MQ,
                       label: GHC.Base.$fOrdNonEmpty_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MQ: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c9MU; else goto c9MV;
       c9MU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MV: // global
           I64[Sp - 24] = block_c9MN_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9NA; else goto c9MO;
       u9NA: // global
           call _c9MN(R1) args: 0, res: 0, upd: 0;
       c9MO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MN() //  [R1]
         { info_tbl: [(c9MN,
                       label: block_c9MN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MN: // global
           I64[Sp - 16] = block_c9MT_info;
           _s8cT::P64 = R1;
           _s8cU::P64 = P64[R1 + 7];
           _s8cV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8cV::P64;
           P64[Sp] = _s8cU::P64;
           P64[Sp + 16] = _s8cT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Nz; else goto c9MX;
       u9Nz: // global
           call _c9MT(R1) args: 0, res: 0, upd: 0;
       c9MX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MT() //  [R1]
         { info_tbl: [(c9MT,
                       label: block_c9MT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MT: // global
           I64[Sp - 8] = block_c9N1_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9N1() //  [R1]
         { info_tbl: [(c9N1,
                       label: block_c9N1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N1: // global
           _c9Ns::P64 = R1 & 7;
           if (_c9Ns::P64 < 3) goto u9Nu; else goto u9Nv;
       u9Nu: // global
           if (_c9Ns::P64 < 2) goto u9Nw; else goto c9Nd;
       u9Nw: // global
           Sp = Sp + 40;
           call _c9Nn() args: 0, res: 0, upd: 0;
       c9Nd: // global
           _s8cV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9Nb_info;
           R4 = _s8cV::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       u9Nv: // global
           Sp = Sp + 24;
           call _c9Nr() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nb() //  [R1]
         { info_tbl: [(c9Nb,
                       label: block_c9Nb_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nb: // global
           if (R1 & 7 == 1) goto u9Nx; else goto u9Ny;
       u9Nx: // global
           Sp = Sp + 24;
           call _c9Nn() args: 0, res: 0, upd: 0;
       u9Ny: // global
           Sp = Sp + 8;
           call _c9Nr() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nn: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Nr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nr: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.113517009 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmin_closure" {
     GHC.Base.$fOrdNonEmpty_$cmin_closure:
         const GHC.Base.$fOrdNonEmpty_$cmin_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(c9NM,
                       label: GHC.Base.$fOrdNonEmpty_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NM: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c9NQ; else goto c9NR;
       c9NQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NR: // global
           I64[Sp - 24] = block_c9NJ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Ow; else goto c9NK;
       u9Ow: // global
           call _c9NJ(R1) args: 0, res: 0, upd: 0;
       c9NK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NJ() //  [R1]
         { info_tbl: [(c9NJ,
                       label: block_c9NJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NJ: // global
           I64[Sp - 16] = block_c9NP_info;
           _s8d4::P64 = R1;
           _s8d5::P64 = P64[R1 + 7];
           _s8d6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8d6::P64;
           P64[Sp] = _s8d5::P64;
           P64[Sp + 16] = _s8d4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Ov; else goto c9NT;
       u9Ov: // global
           call _c9NP(R1) args: 0, res: 0, upd: 0;
       c9NT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NP() //  [R1]
         { info_tbl: [(c9NP,
                       label: block_c9NP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NP: // global
           I64[Sp - 8] = block_c9NX_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9NX() //  [R1]
         { info_tbl: [(c9NX,
                       label: block_c9NX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NX: // global
           _c9Oo::P64 = R1 & 7;
           if (_c9Oo::P64 < 3) goto u9Oq; else goto u9Or;
       u9Oq: // global
           if (_c9Oo::P64 < 2) goto u9Os; else goto c9O9;
       u9Os: // global
           Sp = Sp + 24;
           call _c9Oj() args: 0, res: 0, upd: 0;
       c9O9: // global
           _s8d6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9O7_info;
           R4 = _s8d6::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       u9Or: // global
           Sp = Sp + 40;
           call _c9On() args: 0, res: 0, upd: 0;
     }
 },
 _c9O7() //  [R1]
         { info_tbl: [(c9O7,
                       label: block_c9O7_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O7: // global
           if (R1 & 7 == 1) goto u9Ot; else goto u9Ou;
       u9Ot: // global
           Sp = Sp + 8;
           call _c9Oj() args: 0, res: 0, upd: 0;
       u9Ou: // global
           Sp = Sp + 24;
           call _c9On() args: 0, res: 0, upd: 0;
     }
 },
 _c9Oj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oj: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9On() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9On: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.11587757 UTC

[section ""data" . GHC.Base.$w$c>=_closure" {
     GHC.Base.$w$c>=_closure:
         const GHC.Base.$w$c>=_info;
 },
 GHC.Base.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c9OM,
                       label: GHC.Base.$w$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OM: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c9ON; else goto c9OO;
       c9ON: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9OO: // global
           I64[Sp - 32] = block_c9OF_info;
           _s8dc::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8dc::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c9OF() //  [R1]
         { info_tbl: [(c9OF,
                       label: block_c9OF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OF: // global
           _c9OL::P64 = R1 & 7;
           if (_c9OL::P64 < 3) goto u9Pa; else goto u9Pb;
       u9Pa: // global
           if (_c9OL::P64 < 2) goto u9Pc; else goto c9OJ;
       u9Pc: // global
           Sp = Sp + 32;
           call _c9P5() args: 0, res: 0, upd: 0;
       c9OJ: // global
           _s8dg::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c9OU_info;
           R4 = _s8dg::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       u9Pb: // global
           Sp = Sp + 32;
           call _c9OK() args: 0, res: 0, upd: 0;
     }
 },
 _c9OU() //  [R1]
         { info_tbl: [(c9OU,
                       label: block_c9OU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OU: // global
           if (R1 & 7 == 1) goto u9Pd; else goto u9Pe;
       u9Pd: // global
           Sp = Sp + 8;
           call _c9P5() args: 0, res: 0, upd: 0;
       u9Pe: // global
           Sp = Sp + 8;
           call _c9OK() args: 0, res: 0, upd: 0;
     }
 },
 _c9P5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9P5: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9OK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.117733517 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c>=_closure" {
     GHC.Base.$fOrdNonEmpty_$c>=_closure:
         const GHC.Base.$fOrdNonEmpty_$c>=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Pq,
                       label: GHC.Base.$fOrdNonEmpty_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Pq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Pu; else goto c9Pv;
       c9Pu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Pv: // global
           I64[Sp - 24] = block_c9Pn_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9PD; else goto c9Po;
       u9PD: // global
           call _c9Pn(R1) args: 0, res: 0, upd: 0;
       c9Po: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Pn() //  [R1]
         { info_tbl: [(c9Pn,
                       label: block_c9Pn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Pn: // global
           I64[Sp - 8] = block_c9Pt_info;
           _s8dn::P64 = P64[R1 + 7];
           _s8do::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8do::P64;
           P64[Sp + 16] = _s8dn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9PC; else goto c9Px;
       u9PC: // global
           call _c9Pt(R1) args: 0, res: 0, upd: 0;
       c9Px: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Pt() //  [R1]
         { info_tbl: [(c9Pt,
                       label: block_c9Pt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Pt: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c>=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.120129271 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_closure" {
     GHC.Base.$fOrdNonEmpty_closure:
         const GHC.Base.$fOrdNonEmpty_info;
 },
 sat_s8dC_entry() //  [R1, R2, R3]
         { info_tbl: [(c9PN,
                       label: sat_s8dC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9PN: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmin_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dB_entry() //  [R1, R2, R3]
         { info_tbl: [(c9PV,
                       label: sat_s8dB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9PV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmax_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dA_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Q3,
                       label: sat_s8dA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Q3: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c>=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dz_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Qb,
                       label: sat_s8dz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Qb: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dw_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Qj,
                       label: sat_s8dw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Qj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dv_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Qr,
                       label: sat_s8dv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Qr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8du_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Qz,
                       label: sat_s8du_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Qz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$ccompare_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dt_entry() //  [R1]
         { info_tbl: [(c9QG,
                       label: sat_s8dt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9QG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9QH; else goto c9QI;
       c9QH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9QI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdNonEmpty_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdNonEmpty_entry() //  [R2]
         { info_tbl: [(c9QK,
                       label: GHC.Base.$fOrdNonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9QK: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c9QO; else goto c9QN;
       c9QO: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9QN: // global
           I64[Hp - 200] = sat_s8dC_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s8dB_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8dA_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s8dz_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s8dw_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s8dv_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8du_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8dt_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.122775787 UTC

[section ""data" . GHC.Base.$fMonadIO_$cfail_closure" {
     GHC.Base.$fMonadIO_$cfail_closure:
         const GHC.Base.$fMonadIO_$cfail_info;
         const 0;
 },
 GHC.Base.$fMonadIO_$cfail_entry() //  [R2]
         { info_tbl: [(c9QT,
                       label: GHC.Base.$fMonadIO_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9QT: // global
           R2 = R2;
           R1 = GHC.IO.failIO_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.123432181 UTC

[section ""data" . GHC.Base.$fMonadIO_closure" {
     GHC.Base.$fMonadIO_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fMonadIO1_closure+3;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fMonadIO_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.124233271 UTC

[section ""data" . GHC.Base.$fMonad[]_$cfail_closure" {
     GHC.Base.$fMonad[]_$cfail_closure:
         const GHC.Base.$fMonad[]_$cfail_info;
 },
 GHC.Base.$fMonad[]_$cfail_entry() //  []
         { info_tbl: [(c9R0,
                       label: GHC.Base.$fMonad[]_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9R0: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.124883206 UTC

[section ""data" . GHC.Base.$fMonad[]_closure" {
     GHC.Base.$fMonad[]_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Base.$fMonad[]_$c>>=_closure+2;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fMonad[]_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.125571448 UTC

[section ""data" . GHC.Base.$fMonadPlus[]_closure" {
     GHC.Base.$fMonadPlus[]_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternative[]_closure+1;
         const GHC.Base.$fMonad[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.12638832 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$c>>=_closure" {
     GHC.Base.$fMonadMaybe_$c>>=_closure:
         const GHC.Base.$fMonadMaybe_$c>>=_info;
 },
 GHC.Base.$fMonadMaybe_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c9Re,
                       label: GHC.Base.$fMonadMaybe_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Re: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Rf; else goto c9Rg;
       c9Rf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadMaybe_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Rg: // global
           I64[Sp - 16] = block_c9R7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Rn; else goto c9R8;
       u9Rn: // global
           call _c9R7(R1) args: 0, res: 0, upd: 0;
       c9R8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9R7() //  [R1]
         { info_tbl: [(c9R7,
                       label: block_c9R7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9R7: // global
           if (R1 & 7 == 1) goto c9Rb; else goto c9Rc;
       c9Rb: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Rc: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.127439019 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$cfail_closure" {
     GHC.Base.$fMonadMaybe_$cfail_closure:
         const GHC.Base.$fMonadMaybe_$cfail_info;
 },
 GHC.Base.$fMonadMaybe_$cfail_entry() //  []
         { info_tbl: [(c9Rs,
                       label: GHC.Base.$fMonadMaybe_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Rs: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.128405879 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>=_closure" {
     GHC.Base.$fMonad(->)_$c>>=_closure:
         const GHC.Base.$fMonad(->)_$c>>=_info;
 },
 GHC.Base.$fMonad(->)_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(c9RA,
                       label: GHC.Base.$fMonad(->)_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9RA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9RE; else goto c9RD;
       c9RE: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(->)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9RD: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _s8dL::P64 = R3;
           R3 = R4;
           R2 = Hp - 24;
           R1 = _s8dL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.129992915 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>=_closure" {
     GHC.Base.$fMonad(,)_$c>>=_closure:
         const GHC.Base.$fMonad(,)_$c>>=_info;
 },
 sat_s8dY_entry() //  [R1]
         { info_tbl: [(c9RY,
                       label: sat_s8dY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9RY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9RZ; else goto c9S0;
       c9RZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9S0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9RW_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9RW() //  [R1]
         { info_tbl: [(c9RW,
                       label: block_c9RW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9RW: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(c9S4,
                       label: GHC.Base.$fMonad(,)_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9S4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9S6; else goto c9S7;
       c9S6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9S7: // global
           I64[Sp - 24] = block_c9RJ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Sc; else goto c9RK;
       u9Sc: // global
           call _c9RJ(R1) args: 0, res: 0, upd: 0;
       c9RK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9RJ() //  [R1]
         { info_tbl: [(c9RJ,
                       label: block_c9RJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9RJ: // global
           I64[Sp] = block_c9RO_info;
           R2 = P64[R1 + 15];
           _s8dS::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8dS::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9RO() //  [R1]
         { info_tbl: [(c9RO,
                       label: block_c9RO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9RO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c9Sb; else goto c9Sa;
       c9Sb: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Sa: // global
           _s8dV::P64 = P64[R1 + 7];
           _s8dW::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s8dY_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s8dV::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s8dW::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.132279644 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*>_closure" {
     GHC.Base.$fApplicative(,)_$c<*>_closure:
         const GHC.Base.$fApplicative(,)_$c<*>_info;
 },
 sat_s8e9_entry() //  [R1]
         { info_tbl: [(c9Sy,
                       label: sat_s8e9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Sy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9Sz; else goto c9SA;
       c9Sz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9SA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9Sw_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Sw() //  [R1]
         { info_tbl: [(c9Sw,
                       label: block_c9Sw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Sw: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(c9SE,
                       label: GHC.Base.$fApplicative(,)_$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9SE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9SG; else goto c9SH;
       c9SG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9SH: // global
           I64[Sp - 24] = block_c9Sh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9SN; else goto c9Si;
       u9SN: // global
           call _c9Sh(R1) args: 0, res: 0, upd: 0;
       c9Si: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Sh() //  [R1]
         { info_tbl: [(c9Sh,
                       label: block_c9Sh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Sh: // global
           I64[Sp - 8] = block_c9Sm_info;
           _s8e3::P64 = P64[R1 + 7];
           _s8e4::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8e4::P64;
           P64[Sp + 16] = _s8e3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9SM; else goto c9Sn;
       u9SM: // global
           call _c9Sm(R1) args: 0, res: 0, upd: 0;
       c9Sn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Sm() //  [R1]
         { info_tbl: [(c9Sm,
                       label: block_c9Sm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Sm: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c9SL; else goto c9SK;
       c9SL: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9SK: // global
           _s8e6::P64 = P64[R1 + 7];
           _s8e7::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8e7::P64;
           I64[Hp - 56] = sat_s8e9_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s8e6::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.134635998 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c*>_closure" {
     GHC.Base.$fApplicative(,)_$c*>_closure:
         const GHC.Base.$fApplicative(,)_$c*>_info;
 },
 sat_s8el_entry() //  [R1]
         { info_tbl: [(c9T8,
                       label: sat_s8el_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9T8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9T9; else goto c9Ta;
       c9T9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Ta: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9T6_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9T6() //  [R1]
         { info_tbl: [(c9T6,
                       label: block_c9T6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9T6: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c*>_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Te,
                       label: GHC.Base.$fApplicative(,)_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Te: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Tg; else goto c9Th;
       c9Tg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Th: // global
           I64[Sp - 24] = block_c9SS_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Tn; else goto c9ST;
       u9Tn: // global
           call _c9SS(R1) args: 0, res: 0, upd: 0;
       c9ST: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9SS() //  [R1]
         { info_tbl: [(c9SS,
                       label: block_c9SS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9SS: // global
           I64[Sp] = block_c9SX_info;
           _s8ef::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8ef::P64;
           if (R1 & 7 != 0) goto u9Tm; else goto c9SY;
       u9Tm: // global
           call _c9SX(R1) args: 0, res: 0, upd: 0;
       c9SY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9SX() //  [R1]
         { info_tbl: [(c9SX,
                       label: block_c9SX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9SX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c9Tl; else goto c9Tk;
       c9Tl: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Tk: // global
           _s8ei::P64 = P64[R1 + 7];
           _s8ej::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s8el_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s8ei::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s8ej::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.136979699 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$cliftA2_closure" {
     GHC.Base.$fApplicative(,)_$cliftA2_closure:
         const GHC.Base.$fApplicative(,)_$cliftA2_info;
 },
 sat_s8ex_entry() //  [R1]
         { info_tbl: [(c9TJ,
                       label: sat_s8ex_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9TJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9TK; else goto c9TL;
       c9TK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9TL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9TH_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9TH() //  [R1]
         { info_tbl: [(c9TH,
                       label: block_c9TH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9TH: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c9TP,
                       label: GHC.Base.$fApplicative(,)_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9TP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9TR; else goto c9TS;
       c9TR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9TS: // global
           I64[Sp - 32] = block_c9Ts_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9TY; else goto c9Tt;
       u9TY: // global
           call _c9Ts(R1) args: 0, res: 0, upd: 0;
       c9Tt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ts() //  [R1]
         { info_tbl: [(c9Ts,
                       label: block_c9Ts_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ts: // global
           I64[Sp - 8] = block_c9Tx_info;
           _s8er::P64 = P64[R1 + 7];
           _s8es::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8es::P64;
           P64[Sp + 24] = _s8er::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9TX; else goto c9Ty;
       u9TX: // global
           call _c9Tx(R1) args: 0, res: 0, upd: 0;
       c9Ty: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Tx() //  [R1]
         { info_tbl: [(c9Tx,
                       label: block_c9Tx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Tx: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c9TW; else goto c9TV;
       c9TW: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9TV: // global
           _s8eu::P64 = P64[R1 + 7];
           _s8ev::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8ev::P64;
           I64[Hp - 56] = sat_s8ex_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8eu::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.139633959 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmempty_info;
 },
 sat_s8eI_entry() //  [R1]
         { info_tbl: [(c9U7,
                       label: sat_s8eI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9U7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9U8; else goto c9U9;
       c9U8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9U9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eH_entry() //  [R1]
         { info_tbl: [(c9Ue,
                       label: sat_s8eH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ue: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Uf; else goto c9Ug;
       c9Uf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Ug: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eG_entry() //  [R1]
         { info_tbl: [(c9Ul,
                       label: sat_s8eG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ul: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Um; else goto c9Un;
       c9Um: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Un: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eF_entry() //  [R1]
         { info_tbl: [(c9Us,
                       label: sat_s8eF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Us: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Ut; else goto c9Uu;
       c9Ut: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Uu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eE_entry() //  [R1]
         { info_tbl: [(c9Uz,
                       label: sat_s8eE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Uz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9UA; else goto c9UB;
       c9UA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9UB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cmempty_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c9UD,
                       label: GHC.Base.$fMonoid(,,,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9UD: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c9UH; else goto c9UG;
       c9UH: // global
           HpAlloc = 168;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmempty_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9UG: // global
           I64[Hp - 160] = sat_s8eI_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_s8eH_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_s8eG_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8eF_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8eE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.142241739 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,)_$cmempty_info;
 },
 sat_s8eQ_entry() //  [R1]
         { info_tbl: [(c9UQ,
                       label: sat_s8eQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9UQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9UR; else goto c9US;
       c9UR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9US: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eP_entry() //  [R1]
         { info_tbl: [(c9UX,
                       label: sat_s8eP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9UX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9UY; else goto c9UZ;
       c9UY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9UZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eO_entry() //  [R1]
         { info_tbl: [(c9V4,
                       label: sat_s8eO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9V4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9V5; else goto c9V6;
       c9V5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9V6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eN_entry() //  [R1]
         { info_tbl: [(c9Vb,
                       label: sat_s8eN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Vc; else goto c9Vd;
       c9Vc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_$cmempty_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c9Vf,
                       label: GHC.Base.$fMonoid(,,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vf: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c9Vj; else goto c9Vi;
       c9Vj: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmempty_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Vi: // global
           I64[Hp - 128] = sat_s8eQ_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8eP_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_s8eO_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s8eN_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.145427818 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,)_$cmempty_info;
 },
 sat_s8eW_entry() //  [R1]
         { info_tbl: [(c9Vs,
                       label: sat_s8eW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Vt; else goto c9Vu;
       c9Vt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Vu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eV_entry() //  [R1]
         { info_tbl: [(c9Vz,
                       label: sat_s8eV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Vz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VA; else goto c9VB;
       c9VA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eU_entry() //  [R1]
         { info_tbl: [(c9VG,
                       label: sat_s8eU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VH; else goto c9VI;
       c9VH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmempty_entry() //  [R2, R3, R4]
         { info_tbl: [(c9VK,
                       label: GHC.Base.$fMonoid(,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VK: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c9VO; else goto c9VN;
       c9VO: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmempty_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9VN: // global
           I64[Hp - 96] = sat_s8eW_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s8eV_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s8eU_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.147441705 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,)_$cmempty_info;
 },
 sat_s8f0_entry() //  [R1]
         { info_tbl: [(c9VX,
                       label: sat_s8f0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9VX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9VY; else goto c9VZ;
       c9VY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9VZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eZ_entry() //  [R1]
         { info_tbl: [(c9W4,
                       label: sat_s8eZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9W5; else goto c9W6;
       c9W5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9W6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cmempty_entry() //  [R2, R3]
         { info_tbl: [(c9W8,
                       label: GHC.Base.$fMonoid(,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9W8: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9Wc; else goto c9Wb;
       c9Wc: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Wb: // global
           I64[Hp - 64] = sat_s8f0_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_s8eZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.150374516 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,)_$cmconcat_info;
 },
 $dSemigroup_s8f4_entry() //  [R1]
         { info_tbl: [(c9Wl,
                       label: $dSemigroup_s8f4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wm; else goto c9Wn;
       c9Wm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup1_s8f5_entry() //  [R1]
         { info_tbl: [(c9Ws,
                       label: $dSemigroup1_s8f5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ws: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Wt; else goto c9Wu;
       c9Wt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Wu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8f6_entry() //  [R1]
         { info_tbl: [(c9Wz,
                       label: z_s8f6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Wz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9WA; else goto c9WB;
       c9WA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9WB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8f7_entry() //  [R1]
         { info_tbl: [(c9WG,
                       label: z1_s8f7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9WH; else goto c9WI;
       c9WH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9WI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8fl_entry() //  [R1]
         { info_tbl: [(c9X8,
                       label: sat_s8fl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9X8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9X9; else goto c9Xa;
       c9X9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Xa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8fk_entry() //  [R1]
         { info_tbl: [(c9Xf,
                       label: sat_s8fk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Xf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9Xg; else goto c9Xh;
       c9Xg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Xh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8f9_entry() //  [R1, R2]
         { info_tbl: [(c9Xm,
                       label: go_s8f9_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Xm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9Xn; else goto c9Xo;
       c9Xn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Xo: // global
           I64[Sp - 40] = block_c9WP_info;
           _s8f9::P64 = R1;
           _s8f4::P64 = P64[R1 + 7];
           _s8f5::P64 = P64[R1 + 15];
           _s8f8::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s8f4::P64;
           P64[Sp - 24] = _s8f5::P64;
           P64[Sp - 16] = _s8f8::P64;
           P64[Sp - 8] = _s8f9::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9Xy; else goto c9WQ;
       u9Xy: // global
           call _c9WP(R1) args: 0, res: 0, upd: 0;
       c9WQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9WP() //  [R1]
         { info_tbl: [(c9WP,
                       label: block_c9WP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WP: // global
           if (R1 & 7 == 1) goto c9Xj; else goto c9Xk;
       c9Xj: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Xk: // global
           I64[Sp] = block_c9WV_info;
           _s8fd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _s8fd::P64;
           if (R1 & 7 != 0) goto u9Xx; else goto c9WW;
       u9Xx: // global
           call _c9WV(R1) args: 0, res: 0, upd: 0;
       c9WW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9WV() //  [R1]
         { info_tbl: [(c9WV,
                       label: block_c9WV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9WV: // global
           I64[Sp] = block_c9X0_info;
           R2 = P64[Sp + 24];
           _s8ff::P64 = P64[R1 + 7];
           _s8fg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _s8fg::P64;
           P64[Sp + 32] = _s8ff::P64;
           call go_s8f9_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9X0() //  [R1]
         { info_tbl: [(c9X0,
                       label: block_c9X0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9X0: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c9Xw; else goto c9Xv;
       c9Xw: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Xv: // global
           _s8fi::P64 = P64[R1 + 7];
           _s8fj::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s8fl_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = _s8fj::P64;
           I64[Hp - 56] = sat_s8fk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8fi::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,)_$cmconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Xz,
                       label: GHC.Base.$fMonoid(,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Xz: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c9XD; else goto c9XC;
       c9XD: // global
           HpAlloc = 152;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9XC: // global
           I64[Hp - 144] = $dSemigroup_s8f4_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = $dSemigroup1_s8f5_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = z_s8f6_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = z1_s8f7_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = Hp - 96;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = go_s8f9_info;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 47;
           R2 = R4;
           R1 = Hp - 23;
           call go_s8f9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.153914782 UTC

[section ""data" . GHC.Base.$fMonoid()_$cmconcat_closure" {
     GHC.Base.$fMonoid()_$cmconcat_closure:
         const GHC.Base.$fMonoid()_$cmconcat_info;
 },
 GHC.Base.$fMonoid()_$cmconcat_entry() //  []
         { info_tbl: [(c9XI,
                       label: GHC.Base.$fMonoid()_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9XI: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.155159528 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$c<>_closure" {
     GHC.Base.$fMonoidMaybe_$c<>_closure:
         const GHC.Base.$fMonoidMaybe_$c<>_info;
 },
 sat_s8fu_entry() //  [R1]
         { info_tbl: [(c9Y5,
                       label: sat_s8fu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Y5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9Y6; else goto c9Y7;
       c9Y6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Y7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidMaybe_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Yc,
                       label: GHC.Base.$fMonoidMaybe_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Yc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Yd; else goto c9Ye;
       c9Yd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Ye: // global
           I64[Sp - 24] = block_c9XP_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Yt; else goto c9XQ;
       u9Yt: // global
           call _c9XP(R1) args: 0, res: 0, upd: 0;
       c9XQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9XP() //  [R1]
         { info_tbl: [(c9XP,
                       label: block_c9XP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9XP: // global
           _s8fp::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9Y9; else goto c9Ya;
       c9Y9: // global
           R1 = _s8fp::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Ya: // global
           I64[Sp - 8] = block_c9XV_info;
           _s8fq::P64 = R1;
           _s8fr::P64 = P64[R1 + 6];
           R1 = _s8fp::P64;
           P64[Sp] = _s8fr::P64;
           P64[Sp + 16] = _s8fq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Ys; else goto c9XW;
       u9Ys: // global
           call _c9XV(R1) args: 0, res: 0, upd: 0;
       c9XW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9XV() //  [R1]
         { info_tbl: [(c9XV,
                       label: block_c9XV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9XV: // global
           if (R1 & 7 == 1) goto c9Yl; else goto c9Yn;
       c9Yl: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Yn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Yq; else goto c9Yp;
       c9Yq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Yp: // global
           _s8ft::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8fu_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8ft::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.158151495 UTC

[section ""data" . GHC.Base.$w$csconcat5_closure" {
     GHC.Base.$w$csconcat5_closure:
         const GHC.Base.$w$csconcat5_info;
 },
 sat_s8fI_entry() //  [R1]
         { info_tbl: [(c9YY,
                       label: sat_s8fI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9YY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9YZ; else goto c9Z0;
       c9YZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Z0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8fy_entry() //  [R1, R2, R3]
         { info_tbl: [(c9Z5,
                       label: go_s8fy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Z5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9Z6; else goto u9Zs;
       c9Z6: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u9Zs: // global
           P64[Sp - 24] = R1;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _c9YA() args: 0, res: 0, upd: 0;
     }
 },
 _c9YA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9YA: // global
           _s8fv::P64 = P64[P64[Sp] + 6];
           I64[Sp - 8] = block_c9YD_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8fv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Zu; else goto c9YE;
       u9Zu: // global
           call _c9YD(R1) args: 0, res: 0, upd: 0;
       c9YE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9YD() //  [R1]
         { info_tbl: [(c9YD,
                       label: block_c9YD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9YD: // global
           _s8fz::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c9Z2; else goto c9Z3;
       c9Z2: // global
           R1 = _s8fz::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Z3: // global
           I64[Sp - 8] = block_c9YJ_info;
           _s8fC::P64 = P64[R1 + 6];
           _s8fD::P64 = P64[R1 + 14];
           R1 = _s8fz::P64;
           P64[Sp] = _s8fD::P64;
           P64[Sp + 16] = _s8fC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Zv; else goto c9YK;
       u9Zv: // global
           call _c9YJ(R1) args: 0, res: 0, upd: 0;
       c9YK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9YJ() //  [R1]
         { info_tbl: [(c9YJ,
                       label: block_c9YJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9YJ: // global
           _s8fC::P64 = P64[Sp + 24];
           _s8fD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c9Ze; else goto c9Zg;
       c9Ze: // global
           P64[Sp + 24] = _s8fC::P64;
           P64[Sp + 32] = _s8fD::P64;
           Sp = Sp + 16;
           call _c9YA() args: 0, res: 0, upd: 0;
       c9Zg: // global
           I64[Sp + 8] = block_c9YP_info;
           R3 = _s8fD::P64;
           R2 = _s8fC::P64;
           _s8fE::P64 = R1;
           _s8fF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8fF::P64;
           P64[Sp + 24] = _s8fE::P64;
           Sp = Sp + 8;
           call go_s8fy_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9YP() //  [R1]
         { info_tbl: [(c9YP,
                       label: block_c9YP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9YP: // global
           if (R1 & 7 == 1) goto c9Zk; else goto c9Zm;
       c9Zk: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Zm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9Zp; else goto c9Zo;
       c9Zp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Zo: // global
           _s8fH::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8fI_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8fH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat5_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Zy,
                       label: GHC.Base.$w$csconcat5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Zy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9ZC; else goto c9ZB;
       c9ZC: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ZB: // global
           I64[Hp - 8] = go_s8fy_info;
           P64[Hp] = R2;
           _s8fw::P64 = R3;
           R3 = R4;
           R2 = _s8fw::P64;
           R1 = Hp - 6;
           call go_s8fy_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.160783896 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_$csconcat_closure" {
     GHC.Base.$fSemigroupMaybe_$csconcat_closure:
         const GHC.Base.$fSemigroupMaybe_$csconcat_info;
 },
 GHC.Base.$fSemigroupMaybe_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(c9ZK,
                       label: GHC.Base.$fSemigroupMaybe_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ZK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ZL; else goto c9ZM;
       c9ZL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ZM: // global
           I64[Sp - 16] = block_c9ZH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9ZQ; else goto c9ZI;
       u9ZQ: // global
           call _c9ZH(R1) args: 0, res: 0, upd: 0;
       c9ZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ZH() //  [R1]
         { info_tbl: [(c9ZH,
                       label: block_c9ZH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ZH: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat5_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.162360098 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_closure" {
     GHC.Base.$fSemigroupMaybe_closure:
         const GHC.Base.$fSemigroupMaybe_info;
         const 0;
 },
 sat_s8fS_entry() //  [R1, R2]
         { info_tbl: [(ca00,
                       label: sat_s8fS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca00: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8fQ_entry() //  [R1, R2]
         { info_tbl: [(ca08,
                       label: sat_s8fQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca08: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupMaybe_$csconcat_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8fP_entry() //  [R1, R2, R3]
         { info_tbl: [(ca0g,
                       label: sat_s8fP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0g: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroupMaybe_entry() //  [R2]
         { info_tbl: [(ca0k,
                       label: GHC.Base.$fSemigroupMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0k: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ca0o; else goto ca0n;
       ca0o: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca0n: // global
           I64[Hp - 72] = sat_s8fS_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8fQ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8fP_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.164726946 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$cmconcat_closure" {
     GHC.Base.$fMonoidMaybe_$cmconcat_closure:
         const GHC.Base.$fMonoidMaybe_$cmconcat_info;
 },
 sat_s8g4_entry() //  [R1]
         { info_tbl: [(ca0T,
                       label: sat_s8g4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca0U; else goto ca0V;
       ca0U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca0V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8fV_entry() //  [R1, R2]
         { info_tbl: [(ca10,
                       label: go_s8fV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca10: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ca11; else goto ua1n;
       ca11: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ua1n: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _ca0v() args: 0, res: 0, upd: 0;
     }
 },
 _ca0v() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0v: // global
           _s8fT::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_ca0y_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8fT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1p; else goto ca0z;
       ua1p: // global
           call _ca0y(R1) args: 0, res: 0, upd: 0;
       ca0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca0y() //  [R1]
         { info_tbl: [(ca0y,
                       label: block_ca0y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0y: // global
           if (R1 & 7 == 1) goto ca0X; else goto ca0Y;
       ca0X: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca0Y: // global
           I64[Sp - 8] = block_ca0E_info;
           _s8fZ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8fZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1q; else goto ca0F;
       ua1q: // global
           call _ca0E(R1) args: 0, res: 0, upd: 0;
       ca0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca0E() //  [R1]
         { info_tbl: [(ca0E,
                       label: block_ca0E_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0E: // global
           _s8fZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ca19; else goto ca1b;
       ca19: // global
           P64[Sp + 24] = _s8fZ::P64;
           Sp = Sp + 16;
           call _ca0v() args: 0, res: 0, upd: 0;
       ca1b: // global
           I64[Sp] = block_ca0K_info;
           R2 = _s8fZ::P64;
           _s8g0::P64 = R1;
           _s8g1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _s8g1::P64;
           P64[Sp + 16] = _s8g0::P64;
           call go_s8fV_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca0K() //  [R1]
         { info_tbl: [(ca0K,
                       label: block_ca0K_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca0K: // global
           if (R1 & 7 == 1) goto ca1f; else goto ca1h;
       ca1f: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca1h: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca1k; else goto ca1j;
       ca1k: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1j: // global
           _s8g3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8g4_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8g3::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoidMaybe_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(ca1t,
                       label: GHC.Base.$fMonoidMaybe_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1x; else goto ca1w;
       ca1x: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca1w: // global
           I64[Hp - 8] = go_s8fV_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s8fV_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.167781497 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_closure" {
     GHC.Base.$fMonoidMaybe_closure:
         const GHC.Base.$fMonoidMaybe_info;
         const 0;
 },
 sat_s8g8_entry() //  [R1, R2]
         { info_tbl: [(ca1H,
                       label: sat_s8g8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1H: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoidMaybe_$cmconcat_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8g7_entry() //  [R1, R2, R3]
         { info_tbl: [(ca1P,
                       label: sat_s8g7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1P: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8g6_entry() //  [R1]
         { info_tbl: [(ca1W,
                       label: sat_s8g6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1X; else goto ca1Y;
       ca1X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidMaybe_entry() //  [R2]
         { info_tbl: [(ca20,
                       label: GHC.Base.$fMonoidMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca20: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ca24; else goto ca23;
       ca24: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca23: // global
           I64[Hp - 88] = sat_s8g8_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s8g7_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8g6_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.169394092 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_$c<>_closure" {
     GHC.Base.$fMonoidOrdering_$c<>_closure:
         const GHC.Base.$fMonoidOrdering_$c<>_info;
 },
 GHC.Base.$fMonoidOrdering_$c<>_entry() //  [R2, R3]
         { info_tbl: [(ca2h,
                       label: GHC.Base.$fMonoidOrdering_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca2h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca2i; else goto ca2j;
       ca2i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca2j: // global
           I64[Sp - 16] = block_ca29_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua2u; else goto ca2a;
       ua2u: // global
           call _ca29(R1) args: 0, res: 0, upd: 0;
       ca2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca29() //  [R1]
         { info_tbl: [(ca29,
                       label: block_ca29_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca29: // global
           _ca2g::P64 = R1 & 7;
           if (_ca2g::P64 < 3) goto ua2t; else goto ca2f;
       ua2t: // global
           if (_ca2g::P64 < 2) goto ca2d; else goto ca2e;
       ca2d: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca2e: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ca2f: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.171056953 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_go_closure" {
     GHC.Base.$fMonoidOrdering_go_closure:
         const GHC.Base.$fMonoidOrdering_go_info;
 },
 GHC.Base.$fMonoidOrdering_go_entry() //  [R2]
         { info_tbl: [(ca2G,
                       label: GHC.Base.$fMonoidOrdering_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca2G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca2H; else goto ua37;
       ca2H: // global
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ua37: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _ca2w() args: 0, res: 0, upd: 0;
     }
 },
 _ca2w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca2w: // global
           _s8gc::P64 = P64[Sp];
           I64[Sp] = block_ca2z_info;
           R1 = _s8gc::P64;
           if (R1 & 7 != 0) goto ua39; else goto ca2A;
       ua39: // global
           call _ca2z(R1) args: 0, res: 0, upd: 0;
       ca2A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca2z() //  [R1]
         { info_tbl: [(ca2z,
                       label: block_ca2z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca2z: // global
           if (R1 & 7 == 1) goto ca2D; else goto ca2E;
       ca2D: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca2E: // global
           I64[Sp - 8] = block_ca2O_info;
           _s8gf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8gf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua3a; else goto ca2Q;
       ua3a: // global
           call _ca2O(R1) args: 0, res: 0, upd: 0;
       ca2Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca2O() //  [R1]
         { info_tbl: [(ca2O,
                       label: block_ca2O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca2O: // global
           _ca35::P64 = R1 & 7;
           if (_ca35::P64 < 3) goto ua36; else goto ca34;
       ua36: // global
           if (_ca35::P64 < 2) goto ca2W; else goto ca30;
       ca2W: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca30: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _ca2w() args: 0, res: 0, upd: 0;
       ca34: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.172759841 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_closure" {
     GHC.Base.$fSemigroupOrdering_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fSemigroupOrdering_$csconcat_closure+1;
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fMonoidOrdering_closure" {
     GHC.Base.$fMonoidOrdering_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroupOrdering_closure+1;
         const GHC.Types.EQ_closure+2;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fMonoidOrdering_go_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupOrdering_$cstimes_closure" {
     GHC.Base.$fSemigroupOrdering_$cstimes_closure:
         const GHC.Base.$fSemigroupOrdering_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupOrdering_$cstimes_entry() //  [R2]
         { info_tbl: [(ca3h,
                       label: GHC.Base.$fSemigroupOrdering_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3h: // global
           R3 = GHC.Base.$fMonoidOrdering_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.174965461 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,,)_$c<>_info;
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3l: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8gF_entry() //  [R1]
         { info_tbl: [(ca3D,
                       label: sat_s8gF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3D: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca3E; else goto ca3F;
       ca3E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gE_entry() //  [R1]
         { info_tbl: [(ca3K,
                       label: sat_s8gE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3K: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca3L; else goto ca3M;
       ca3L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gD_entry() //  [R1]
         { info_tbl: [(ca3R,
                       label: sat_s8gD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca3S; else goto ca3T;
       ca3S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca3T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gC_entry() //  [R1]
         { info_tbl: [(ca3Y,
                       label: sat_s8gC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3Y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca3Z; else goto ca40;
       ca3Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca40: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gB_entry() //  [R1]
         { info_tbl: [(ca45,
                       label: sat_s8gB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca45: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca46; else goto ca47;
       ca46: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca47: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca48,
                       label: GHC.Base.$fMonoid(,,,,)_$c<>_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca48: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ca4a; else goto ca4b;
       ca4a: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$c<>_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ca4b: // global
           I64[Sp - 40] = block_ca3p_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ua4h; else goto ca3q;
       ua4h: // global
           call _ca3p(R1) args: 0, res: 0, upd: 0;
       ca3q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3p() //  [R1]
         { info_tbl: [(ca3p,
                       label: block_ca3p_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3p: // global
           I64[Sp - 32] = block_ca3u_info;
           _s8gq::P64 = P64[R1 + 7];
           _s8gr::P64 = P64[R1 + 15];
           _s8gs::P64 = P64[R1 + 23];
           _s8gt::P64 = P64[R1 + 31];
           _s8gu::P64 = P64[R1 + 39];
           R1 = P64[Sp + 48];
           P64[Sp - 24] = _s8gs::P64;
           P64[Sp - 16] = _s8gt::P64;
           P64[Sp - 8] = _s8gu::P64;
           P64[Sp] = _s8gr::P64;
           P64[Sp + 48] = _s8gq::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ua4g; else goto ca3v;
       ua4g: // global
           call _ca3u(R1) args: 0, res: 0, upd: 0;
       ca3v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca3u() //  [R1]
         { info_tbl: [(ca3u,
                       label: block_ca3u_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca3u: // global
           Hp = Hp + 248;
           if (Hp > HpLim) (likely: False) goto ca4f; else goto ca4e;
       ca4f: // global
           HpAlloc = 248;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca4e: // global
           _s8gw::P64 = P64[R1 + 7];
           _s8gx::P64 = P64[R1 + 15];
           _s8gy::P64 = P64[R1 + 23];
           _s8gz::P64 = P64[R1 + 31];
           _s8gA::P64 = P64[R1 + 39];
           I64[Hp - 240] = sat_s8gF_info;
           P64[Hp - 224] = P64[Sp + 64];
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _s8gA::P64;
           I64[Hp - 200] = sat_s8gE_info;
           P64[Hp - 184] = P64[Sp + 56];
           P64[Hp - 176] = P64[Sp + 16];
           P64[Hp - 168] = _s8gz::P64;
           I64[Hp - 160] = sat_s8gD_info;
           P64[Hp - 144] = P64[Sp + 48];
           P64[Hp - 136] = P64[Sp + 8];
           P64[Hp - 128] = _s8gy::P64;
           I64[Hp - 120] = sat_s8gC_info;
           P64[Hp - 104] = P64[Sp + 40];
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = _s8gx::P64;
           I64[Hp - 80] = sat_s8gB_info;
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = _s8gw::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 160;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 240;
           R1 = Hp - 39;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.184449949 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$csconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$csconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$csconcat_info;
 },
 sat_s8hl_entry() //  [R1]
         { info_tbl: [(ca4U,
                       label: sat_s8hl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4U: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca4V; else goto ca4W;
       ca4V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca4W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hk_entry() //  [R1]
         { info_tbl: [(ca51,
                       label: sat_s8hk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca51: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca52; else goto ca53;
       ca52: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca53: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hj_entry() //  [R1]
         { info_tbl: [(ca58,
                       label: sat_s8hj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca58: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca59; else goto ca5a;
       ca59: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca5a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hi_entry() //  [R1]
         { info_tbl: [(ca5f,
                       label: sat_s8hi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca5f: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca5g; else goto ca5h;
       ca5g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca5h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hh_entry() //  [R1]
         { info_tbl: [(ca5m,
                       label: sat_s8hh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca5m: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca5n; else goto ca5o;
       ca5n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca5o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s8gV_entry() //  [R1, R2, R3, R4, R5, R6]
         { info_tbl: [(ca5t,
                       label: $wgo_s8gV_info
                       rep:HeapRep 5 ptrs { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca5t: // global
           if ((Sp + -120) < SpLim) (likely: False) goto ca5u; else goto ca5v;
       ca5u: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ca5v: // global
           I64[Sp - 88] = block_ca4B_info;
           _s8gV::P64 = R1;
           _s8gG::P64 = P64[R1 + 2];
           _s8gH::P64 = P64[R1 + 10];
           _s8gI::P64 = P64[R1 + 18];
           _s8gJ::P64 = P64[R1 + 26];
           _s8gK::P64 = P64[R1 + 34];
           R1 = P64[Sp];
           P64[Sp - 80] = _s8gH::P64;
           P64[Sp - 72] = _s8gI::P64;
           P64[Sp - 64] = _s8gJ::P64;
           P64[Sp - 56] = _s8gK::P64;
           P64[Sp - 48] = _s8gV::P64;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = _s8gG::P64;
           Sp = Sp - 88;
           if (R1 & 7 != 0) goto ua5G; else goto ca4C;
       ua5G: // global
           call _ca4B(R1) args: 0, res: 0, upd: 0;
       ca4C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca4B() //  [R1]
         { info_tbl: [(ca4B,
                       label: block_ca4B_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4B: // global
           if (R1 & 7 == 1) goto ca5q; else goto ca5r;
       ca5q: // global
           R5 = P64[Sp + 80];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca5r: // global
           I64[Sp - 8] = block_ca4H_info;
           _s8h4::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8h4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua5E; else goto ca4I;
       ua5E: // global
           call _ca4H(R1) args: 0, res: 0, upd: 0;
       ca4I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca4H() //  [R1]
         { info_tbl: [(ca4H,
                       label: block_ca4H_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4H: // global
           _s8h4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ca4M_info;
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp] = _s8h4::P64;
           call $wgo_s8gV_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 _ca4M() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(ca4M,
                       label: block_ca4M_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4M: // global
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R2;
           P64[Sp + 40] = R1;
           Sp = Sp - 32;
           call _ca4N() args: 0, res: 0, upd: 0;
     }
 },
 _ca4N() //  []
         { info_tbl: [(ca4N,
                       label: block_ca4N_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4N: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto ca5C; else goto ca5B;
       ca5C: // global
           HpAlloc = 200;
           I64[Sp] = block_ca4N_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ca5B: // global
           I64[Hp - 192] = sat_s8hl_info;
           P64[Hp - 176] = P64[Sp + 64];
           P64[Hp - 168] = P64[Sp + 112];
           P64[Hp - 160] = P64[Sp + 24];
           I64[Hp - 152] = sat_s8hk_info;
           P64[Hp - 136] = P64[Sp + 56];
           P64[Hp - 128] = P64[Sp + 104];
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = sat_s8hj_info;
           P64[Hp - 96] = P64[Sp + 48];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = sat_s8hi_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 32];
           I64[Hp - 32] = sat_s8hh_info;
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 80];
           P64[Hp] = P64[Sp + 72];
           R5 = Hp - 192;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca5H,
                       label: GHC.Base.$fMonoid(,,,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca5H: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca5N; else goto ca5O;
       ca5N: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ca5O: // global
           I64[Sp - 40] = block_ca4m_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ua5Y; else goto ca4n;
       ua5Y: // global
           call _ca4m(R1) args: 0, res: 0, upd: 0;
       ca4n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca4m() //  [R1]
         { info_tbl: [(ca4m,
                       label: block_ca4m_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4m: // global
           I64[Sp - 8] = block_ca4r_info;
           _s8gO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8gO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua5X; else goto ca4s;
       ua5X: // global
           call _ca4r(R1) args: 0, res: 0, upd: 0;
       ca4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca4r() //  [R1]
         { info_tbl: [(ca4r,
                       label: block_ca4r_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca4r: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca5S; else goto ca5R;
       ca5S: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca5R: // global
           _s8gQ::P64 = P64[R1 + 7];
           _s8gR::P64 = P64[R1 + 15];
           _s8gS::P64 = P64[R1 + 23];
           _s8gT::P64 = P64[R1 + 31];
           _s8gU::P64 = P64[R1 + 39];
           I64[Hp - 40] = $wgo_s8gV_info;
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 48] = block_ca5I_info;
           R6 = _s8gU::P64;
           R5 = _s8gT::P64;
           R4 = _s8gS::P64;
           R3 = _s8gR::P64;
           R2 = _s8gQ::P64;
           R1 = Hp - 34;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call $wgo_s8gV_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 _ca5I() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(ca5I,
                       label: block_ca5I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca5I: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call _ca5J() args: 0, res: 0, upd: 0;
     }
 },
 _ca5J() //  []
         { info_tbl: [(ca5J,
                       label: block_ca5J_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca5J: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ca5V; else goto ca5U;
       ca5V: // global
           HpAlloc = 48;
           I64[Sp] = block_ca5J_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ca5U: // global
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.191365017 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cstimes_closure" {
     GHC.Base.$fMonoid(,,,,)_$cstimes_closure:
         const GHC.Base.$fMonoid(,,,,)_$cstimes_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca61: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8hK_entry() //  [R1]
         { info_tbl: [(ca6e,
                       label: sat_s8hK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca6e: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca6f; else goto ca6g;
       ca6f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca6g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hJ_entry() //  [R1]
         { info_tbl: [(ca6l,
                       label: sat_s8hJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca6l: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca6m; else goto ca6n;
       ca6m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca6n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hI_entry() //  [R1]
         { info_tbl: [(ca6s,
                       label: sat_s8hI_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca6s: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca6t; else goto ca6u;
       ca6t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca6u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hH_entry() //  [R1]
         { info_tbl: [(ca6z,
                       label: sat_s8hH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca6z: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca6A; else goto ca6B;
       ca6A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca6B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hG_entry() //  [R1]
         { info_tbl: [(ca6G,
                       label: sat_s8hG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca6G: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca6H; else goto ca6I;
       ca6H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca6I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca6J,
                       label: GHC.Base.$fMonoid(,,,,)_$cstimes_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca6J: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ca6L; else goto ca6M;
       ca6L: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       ca6M: // global
           I64[Sp - 40] = block_ca65_info;
           R1 = P64[Sp + 16];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 16] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ua6Q; else goto ca66;
       ua6Q: // global
           call _ca65(R1) args: 0, res: 0, upd: 0;
       ca66: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca65() //  [R1]
         { info_tbl: [(ca65,
                       label: block_ca65_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca65: // global
           Hp = Hp + 288;
           if (Hp > HpLim) (likely: False) goto ca6P; else goto ca6O;
       ca6P: // global
           HpAlloc = 288;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca6O: // global
           _s8hB::P64 = P64[R1 + 7];
           _s8hC::P64 = P64[R1 + 15];
           _s8hD::P64 = P64[R1 + 23];
           _s8hE::P64 = P64[R1 + 31];
           _s8hF::P64 = P64[R1 + 39];
           I64[Hp - 280] = sat_s8hK_info;
           P64[Hp - 264] = P64[Sp + 32];
           _s8hx::P64 = P64[Sp + 40];
           P64[Hp - 256] = _s8hx::P64;
           _s8hy::P64 = P64[Sp + 48];
           P64[Hp - 248] = _s8hy::P64;
           P64[Hp - 240] = _s8hF::P64;
           I64[Hp - 232] = sat_s8hJ_info;
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _s8hx::P64;
           P64[Hp - 200] = _s8hy::P64;
           P64[Hp - 192] = _s8hE::P64;
           I64[Hp - 184] = sat_s8hI_info;
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _s8hx::P64;
           P64[Hp - 152] = _s8hy::P64;
           P64[Hp - 144] = _s8hD::P64;
           I64[Hp - 136] = sat_s8hH_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8hx::P64;
           P64[Hp - 104] = _s8hy::P64;
           P64[Hp - 96] = _s8hC::P64;
           I64[Hp - 88] = sat_s8hG_info;
           P64[Hp - 72] = P64[Sp + 56];
           P64[Hp - 64] = _s8hx::P64;
           P64[Hp - 56] = _s8hy::P64;
           P64[Hp - 48] = _s8hB::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 88;
           P64[Hp - 24] = Hp - 136;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 280;
           R1 = Hp - 39;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.195428696 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,,)_closure" {
     GHC.Base.$fSemigroup(,,,,)_closure:
         const GHC.Base.$fSemigroup(,,,,)_info;
 },
 sat_s8hS_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ca70,
                       label: sat_s8hS_info
                       rep:HeapRep 5 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca70: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca71; else goto ca72;
       ca71: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca72: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8hR_entry() //  [R1, R2]
         { info_tbl: [(ca78,
                       label: sat_s8hR_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca78: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca79; else goto ca7a;
       ca79: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca7a: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_s8hQ_entry() //  [R1, R2, R3]
         { info_tbl: [(ca7g,
                       label: sat_s8hQ_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca7g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca7h; else goto ca7i;
       ca7h: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca7i: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca7k,
                       label: GHC.Base.$fSemigroup(,,,,)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca7k: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ca7o; else goto ca7n;
       ca7o: // global
           HpAlloc = 176;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca7n: // global
           I64[Hp - 168] = sat_s8hS_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = sat_s8hR_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_s8hQ_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 165;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.200201522 UTC

[section ""data" . GHC.Base.$w$cp1Monoid1_closure" {
     GHC.Base.$w$cp1Monoid1_closure:
         const GHC.Base.$w$cp1Monoid1_info;
 },
 sat_s8ie_entry() //  [R1]
         { info_tbl: [(ca7x,
                       label: sat_s8ie_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca7x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca7y; else goto ca7z;
       ca7y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca7z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8id_entry() //  [R1]
         { info_tbl: [(ca7E,
                       label: sat_s8id_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca7E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca7F; else goto ca7G;
       ca7F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca7G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ic_entry() //  [R1]
         { info_tbl: [(ca7L,
                       label: sat_s8ic_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca7L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca7M; else goto ca7N;
       ca7M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca7N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ib_entry() //  [R1]
         { info_tbl: [(ca7S,
                       label: sat_s8ib_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca7S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca7T; else goto ca7U;
       ca7T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca7U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ia_entry() //  [R1]
         { info_tbl: [(ca7Z,
                       label: sat_s8ia_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca7Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca80; else goto ca81;
       ca80: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca81: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8if_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ca87,
                       label: sat_s8if_info
                       rep:HeapRep 5 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca87: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca88; else goto ca89;
       ca88: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca89: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8i8_entry() //  [R1]
         { info_tbl: [(ca8e,
                       label: sat_s8i8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8f; else goto ca8g;
       ca8f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i7_entry() //  [R1]
         { info_tbl: [(ca8l,
                       label: sat_s8i7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8m; else goto ca8n;
       ca8m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i6_entry() //  [R1]
         { info_tbl: [(ca8s,
                       label: sat_s8i6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8t; else goto ca8u;
       ca8t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i5_entry() //  [R1]
         { info_tbl: [(ca8z,
                       label: sat_s8i5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8A; else goto ca8B;
       ca8A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i4_entry() //  [R1]
         { info_tbl: [(ca8G,
                       label: sat_s8i4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8H; else goto ca8I;
       ca8H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i9_entry() //  [R1, R2]
         { info_tbl: [(ca8O,
                       label: sat_s8i9_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca8P; else goto ca8Q;
       ca8P: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca8Q: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_s8i2_entry() //  [R1]
         { info_tbl: [(ca8V,
                       label: sat_s8i2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca8V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca8W; else goto ca8X;
       ca8W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca8X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i1_entry() //  [R1]
         { info_tbl: [(ca92,
                       label: sat_s8i1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca92: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca93; else goto ca94;
       ca93: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca94: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i0_entry() //  [R1]
         { info_tbl: [(ca99,
                       label: sat_s8i0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca99: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9a; else goto ca9b;
       ca9a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8hZ_entry() //  [R1]
         { info_tbl: [(ca9g,
                       label: sat_s8hZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9h; else goto ca9i;
       ca9h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8hY_entry() //  [R1]
         { info_tbl: [(ca9n,
                       label: sat_s8hY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9o; else goto ca9p;
       ca9o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca9p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i3_entry() //  [R1, R2, R3]
         { info_tbl: [(ca9v,
                       label: sat_s8i3_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca9w; else goto ca9x;
       ca9w: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9x: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cp1Monoid1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca9y,
                       label: GHC.Base.$w$cp1Monoid1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9y: // global
           Hp = Hp + 504;
           if (Hp > HpLim) (likely: False) goto ca9C; else goto ca9B;
       ca9C: // global
           HpAlloc = 504;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9B: // global
           I64[Hp - 496] = sat_s8ie_info;
           P64[Hp - 480] = R6;
           I64[Hp - 472] = sat_s8id_info;
           P64[Hp - 456] = R5;
           I64[Hp - 448] = sat_s8ic_info;
           P64[Hp - 432] = R4;
           I64[Hp - 424] = sat_s8ib_info;
           P64[Hp - 408] = R3;
           I64[Hp - 400] = sat_s8ia_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s8if_info;
           P64[Hp - 368] = Hp - 400;
           P64[Hp - 360] = Hp - 424;
           P64[Hp - 352] = Hp - 448;
           P64[Hp - 344] = Hp - 472;
           P64[Hp - 336] = Hp - 496;
           I64[Hp - 328] = sat_s8i8_info;
           P64[Hp - 312] = R6;
           I64[Hp - 304] = sat_s8i7_info;
           P64[Hp - 288] = R5;
           I64[Hp - 280] = sat_s8i6_info;
           P64[Hp - 264] = R4;
           I64[Hp - 256] = sat_s8i5_info;
           P64[Hp - 240] = R3;
           I64[Hp - 232] = sat_s8i4_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s8i9_info;
           P64[Hp - 200] = Hp - 232;
           P64[Hp - 192] = Hp - 256;
           P64[Hp - 184] = Hp - 280;
           P64[Hp - 176] = Hp - 304;
           P64[Hp - 168] = Hp - 328;
           I64[Hp - 160] = sat_s8i2_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_s8i1_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_s8i0_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8hZ_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8hY_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8i3_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R3 = Hp - 373;
           R2 = Hp - 207;
           R1 = Hp - 38;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.206121701 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca9K,
                       label: GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca9L; else goto ca9M;
       ca9L: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9M: // global
           I64[Sp - 8] = block_ca9H_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9H() //  [R1, R2, R3]
         { info_tbl: [(ca9H,
                       label: block_ca9H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9H: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca9P; else goto ca9O;
       ca9P: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ca9O: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.207567314 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ca9W,
                       label: GHC.Base.$fMonoid(,,,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca9X; else goto ca9Y;
       ca9X: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ca9Y: // global
           I64[Sp - 8] = block_ca9U_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca9U() //  [R1]
         { info_tbl: [(ca9U,
                       label: block_ca9U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca9U: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.210254622 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmconcat_info;
 },
 k_s8iD_entry() //  [R1]
         { info_tbl: [(caab,
                       label: k_s8iD_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caab: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caac; else goto caad;
       caac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caad: // global
           I64[Sp - 8] = block_caa8_info;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _caa8() //  [R1, R2, R3]
         { info_tbl: [(caa8,
                       label: block_caa8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caa8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caag; else goto caaf;
       caag: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caaf: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 k1_s8iI_entry() //  [R1]
         { info_tbl: [(caal,
                       label: k1_s8iI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caal: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caam; else goto caan;
       caam: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caan: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8iJ_entry() //  [R1]
         { info_tbl: [(caas,
                       label: z_s8iJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caas: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caat; else goto caau;
       caat: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caau: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8iK_entry() //  [R1]
         { info_tbl: [(caaz,
                       label: z1_s8iK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaA; else goto caaB;
       caaA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_s8iL_entry() //  [R1]
         { info_tbl: [(caaG,
                       label: z2_s8iL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaH; else goto caaI;
       caaH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z3_s8iM_entry() //  [R1]
         { info_tbl: [(caaN,
                       label: z3_s8iM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaO; else goto caaP;
       caaO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z4_s8iN_entry() //  [R1]
         { info_tbl: [(caaU,
                       label: z4_s8iN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caaU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caaV; else goto caaW;
       caaV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caaW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8iP_entry() //  [R1, R2]
         { info_tbl: [(caba,
                       label: go_s8iP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caba: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cabb; else goto cabc;
       cabb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cabc: // global
           I64[Sp - 32] = block_cab3_info;
           _s8iP::P64 = R1;
           _s8iI::P64 = P64[R1 + 7];
           _s8iO::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s8iI::P64;
           P64[Sp - 16] = _s8iO::P64;
           P64[Sp - 8] = _s8iP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uabm; else goto cab4;
       uabm: // global
           call _cab3(R1) args: 0, res: 0, upd: 0;
       cab4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cab3() //  [R1]
         { info_tbl: [(cab3,
                       label: block_cab3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cab3: // global
           if (R1 & 7 == 1) goto cab7; else goto cab8;
       cab7: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cab8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cabl; else goto cabk;
       cabl: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cabk: // global
           _s8iS::P64 = P64[R1 + 6];
           _s8iT::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s8iT::P64;
           R3 = Hp - 24;
           R2 = _s8iS::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cmconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cabn,
                       label: GHC.Base.$fMonoid(,,,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabn: // global
           Hp = Hp + 272;
           if (Hp > HpLim) (likely: False) goto cabr; else goto cabq;
       cabr: // global
           HpAlloc = 272;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cabq: // global
           I64[Hp - 264] = k_s8iD_info;
           P64[Hp - 248] = R2;
           P64[Hp - 240] = R3;
           P64[Hp - 232] = R4;
           P64[Hp - 224] = R5;
           P64[Hp - 216] = R6;
           I64[Hp - 208] = k1_s8iI_info;
           P64[Hp - 192] = Hp - 264;
           I64[Hp - 184] = z_s8iJ_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = z1_s8iK_info;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = z2_s8iL_info;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = z3_s8iM_info;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = z4_s8iN_info;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = (,,,,)_con_info;
           P64[Hp - 56] = Hp - 184;
           P64[Hp - 48] = Hp - 160;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = go_s8iP_info;
           P64[Hp - 8] = Hp - 208;
           P64[Hp] = Hp - 63;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.214983193 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_closure" {
     GHC.Base.$fMonoid(,,,,)_closure:
         const GHC.Base.$fMonoid(,,,,)_info;
 },
 sat_s8j3_entry() //  [R1]
         { info_tbl: [(cabA,
                       label: sat_s8j3_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabB; else goto cabC;
       cabB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j2_entry() //  [R1]
         { info_tbl: [(cabH,
                       label: sat_s8j2_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabI; else goto cabJ;
       cabI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmappend_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j1_entry() //  [R1]
         { info_tbl: [(cabO,
                       label: sat_s8j1_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabP; else goto cabQ;
       cabP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmempty_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j0_entry() //  [R1]
         { info_tbl: [(cabV,
                       label: sat_s8j0_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cabW; else goto cabX;
       cabW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cabX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cabZ,
                       label: GHC.Base.$fMonoid(,,,,)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cabZ: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cac3; else goto cac2;
       cac3: // global
           HpAlloc = 264;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cac2: // global
           I64[Hp - 256] = sat_s8j3_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           P64[Hp - 224] = R4;
           P64[Hp - 216] = R5;
           P64[Hp - 208] = R6;
           I64[Hp - 200] = sat_s8j2_info;
           P64[Hp - 184] = R2;
           P64[Hp - 176] = R3;
           P64[Hp - 168] = R4;
           P64[Hp - 160] = R5;
           P64[Hp - 152] = R6;
           I64[Hp - 144] = sat_s8j1_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           P64[Hp - 104] = R5;
           P64[Hp - 96] = R6;
           I64[Hp - 88] = sat_s8j0_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 256;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.218383712 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,)_$c<>_info;
 },
 sat_s8jn_entry() //  [R1]
         { info_tbl: [(cacm,
                       label: sat_s8jn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacn; else goto caco;
       cacn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caco: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jm_entry() //  [R1]
         { info_tbl: [(cact,
                       label: sat_s8jm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cact: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacu; else goto cacv;
       cacu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cacv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jl_entry() //  [R1]
         { info_tbl: [(cacA,
                       label: sat_s8jl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacB; else goto cacC;
       cacB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cacC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jk_entry() //  [R1]
         { info_tbl: [(cacH,
                       label: sat_s8jk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cacI; else goto cacJ;
       cacI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cacJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cacK,
                       label: GHC.Base.$fMonoid(,,,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacK: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cacM; else goto cacN;
       cacM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cacN: // global
           I64[Sp - 40] = block_cac8_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uacT; else goto cac9;
       uacT: // global
           call _cac8(R1) args: 0, res: 0, upd: 0;
       cac9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cac8() //  [R1]
         { info_tbl: [(cac8,
                       label: block_cac8_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cac8: // global
           I64[Sp - 24] = block_cacd_info;
           _s8jb::P64 = P64[R1 + 7];
           _s8jc::P64 = P64[R1 + 15];
           _s8jd::P64 = P64[R1 + 23];
           _s8je::P64 = P64[R1 + 31];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _s8jd::P64;
           P64[Sp - 8] = _s8je::P64;
           P64[Sp] = _s8jc::P64;
           P64[Sp + 40] = _s8jb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uacS; else goto cace;
       uacS: // global
           call _cacd(R1) args: 0, res: 0, upd: 0;
       cace: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cacd() //  [R1]
         { info_tbl: [(cacd,
                       label: block_cacd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacd: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cacR; else goto cacQ;
       cacR: // global
           HpAlloc = 200;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cacQ: // global
           _s8jg::P64 = P64[R1 + 7];
           _s8jh::P64 = P64[R1 + 15];
           _s8ji::P64 = P64[R1 + 23];
           _s8jj::P64 = P64[R1 + 31];
           I64[Hp - 192] = sat_s8jn_info;
           P64[Hp - 176] = P64[Sp + 56];
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _s8jj::P64;
           I64[Hp - 152] = sat_s8jm_info;
           P64[Hp - 136] = P64[Sp + 48];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = _s8ji::P64;
           I64[Hp - 112] = sat_s8jl_info;
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = _s8jh::P64;
           I64[Hp - 72] = sat_s8jk_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = _s8jg::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.223026676 UTC

[section ""data" . GHC.Base.$w$csconcat2_closure" {
     GHC.Base.$w$csconcat2_closure:
         const GHC.Base.$w$csconcat2_info;
 },
 GHC.Base.$w$csconcat2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cacV: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_s8jT_entry() //  [R1]
         { info_tbl: [(cadl,
                       label: sat_s8jT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cadm; else goto cadn;
       cadm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jS_entry() //  [R1]
         { info_tbl: [(cads,
                       label: sat_s8jS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cads: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cadt; else goto cadu;
       cadt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jR_entry() //  [R1]
         { info_tbl: [(cadz,
                       label: sat_s8jR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cadA; else goto cadB;
       cadA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jQ_entry() //  [R1]
         { info_tbl: [(cadG,
                       label: sat_s8jQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cadH; else goto cadI;
       cadH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cadI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s8jx_entry() //  [R1, R2, R3, R4, R5, R6]
         { info_tbl: [(cadN,
                       label: $wgo_s8jx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadN: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cadO; else goto cadP;
       cadO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cadP: // global
           I64[Sp - 80] = block_cad4_info;
           _s8jx::P64 = R1;
           _s8jo::P64 = P64[R1 + 3];
           _s8jp::P64 = P64[R1 + 11];
           _s8jq::P64 = P64[R1 + 19];
           _s8jr::P64 = P64[R1 + 27];
           R1 = R6;
           P64[Sp - 72] = _s8jo::P64;
           P64[Sp - 64] = _s8jp::P64;
           P64[Sp - 56] = _s8jq::P64;
           P64[Sp - 48] = _s8jr::P64;
           P64[Sp - 40] = _s8jx::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto uadY; else goto cad5;
       uadY: // global
           call _cad4(R1) args: 0, res: 0, upd: 0;
       cad5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cad4() //  [R1]
         { info_tbl: [(cad4,
                       label: block_cad4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cad4: // global
           if (R1 & 7 == 1) goto cadK; else goto cadL;
       cadK: // global
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cadL: // global
           I64[Sp - 8] = block_cada_info;
           _s8jF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8jF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uadX; else goto cadb;
       uadX: // global
           call _cada(R1) args: 0, res: 0, upd: 0;
       cadb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cada() //  [R1]
         { info_tbl: [(cada,
                       label: block_cada_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cada: // global
           _s8jF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cadf_info;
           R6 = _s8jF::P64;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           Sp = Sp + 8;
           call $wgo_s8jx_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 8, upd: 8;
     }
 },
 _cadf() //  [R1, R2, R3, R4]
         { info_tbl: [(cadf,
                       label: block_cadf_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadf: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cadW; else goto cadV;
       cadW: // global
           HpAlloc = 160;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cadV: // global
           I64[Hp - 152] = sat_s8jT_info;
           P64[Hp - 136] = P64[Sp + 32];
           P64[Hp - 128] = P64[Sp + 72];
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_s8jS_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8jR_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8jQ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cadZ,
                       label: GHC.Base.$w$csconcat2_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cadZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cae3; else goto cae2;
       cae3: // global
           HpAlloc = 40;
           R1 = GHC.Base.$w$csconcat2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cae2: // global
           I64[Hp - 32] = $wgo_s8jx_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _s8js::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _s8js::P64;
           R1 = Hp - 27;
           Sp = Sp + 32;
           call $wgo_s8jx_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.227428347 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,,)_$csconcat_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(caeb,
                       label: GHC.Base.$fSemigroup(,,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caem; else goto caen;
       caem: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caen: // global
           I64[Sp - 40] = block_cae8_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaeu; else goto cae9;
       uaeu: // global
           call _cae8(R1) args: 0, res: 0, upd: 0;
       cae9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cae8() //  [R1]
         { info_tbl: [(cae8,
                       label: block_cae8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cae8: // global
           I64[Sp - 8] = block_caee_info;
           _s8k1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8k1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaet; else goto caef;
       uaet: // global
           call _caee(R1) args: 0, res: 0, upd: 0;
       caef: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caee() //  [R1]
         { info_tbl: [(caee,
                       label: block_caee_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caee: // global
           _s8jX::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_caej_info;
           R6 = P64[R1 + 7];
           R5 = _s8jX::P64;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           _s8k1::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _s8k1::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 _caej() //  [R1, R2, R3, R4]
         { info_tbl: [(caej,
                       label: block_caej_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caej: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caes; else goto caer;
       caes: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       caer: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.230441356 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,,)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caew: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8kr_entry() //  [R1]
         { info_tbl: [(caeJ,
                       label: sat_s8kr_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caeK; else goto caeL;
       caeK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8kq_entry() //  [R1]
         { info_tbl: [(caeQ,
                       label: sat_s8kq_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caeR; else goto caeS;
       caeR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8kp_entry() //  [R1]
         { info_tbl: [(caeX,
                       label: sat_s8kp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caeY; else goto caeZ;
       caeY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caeZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8ko_entry() //  [R1]
         { info_tbl: [(caf4,
                       label: sat_s8ko_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caf5; else goto caf6;
       caf5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caf6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caf7,
                       label: GHC.Base.$fSemigroup(,,,)_$cstimes_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caf7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caf9; else goto cafa;
       caf9: // global
           R1 = GHC.Base.$fSemigroup(,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cafa: // global
           I64[Sp - 40] = block_caeA_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uafe; else goto caeB;
       uafe: // global
           call _caeA(R1) args: 0, res: 0, upd: 0;
       caeB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caeA() //  [R1]
         { info_tbl: [(caeA,
                       label: block_caeA_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caeA: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cafd; else goto cafc;
       cafd: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafc: // global
           _s8kk::P64 = P64[R1 + 7];
           _s8kl::P64 = P64[R1 + 15];
           _s8km::P64 = P64[R1 + 23];
           _s8kn::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_s8kr_info;
           P64[Hp - 208] = P64[Sp + 24];
           _s8kg::P64 = P64[Sp + 32];
           P64[Hp - 200] = _s8kg::P64;
           _s8kh::P64 = P64[Sp + 40];
           P64[Hp - 192] = _s8kh::P64;
           P64[Hp - 184] = _s8kn::P64;
           I64[Hp - 176] = sat_s8kq_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _s8kg::P64;
           P64[Hp - 144] = _s8kh::P64;
           P64[Hp - 136] = _s8km::P64;
           I64[Hp - 128] = sat_s8kp_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _s8kg::P64;
           P64[Hp - 96] = _s8kh::P64;
           P64[Hp - 88] = _s8kl::P64;
           I64[Hp - 80] = sat_s8ko_info;
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = _s8kg::P64;
           P64[Hp - 48] = _s8kh::P64;
           P64[Hp - 40] = _s8kk::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.234070164 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_closure" {
     GHC.Base.$fSemigroup(,,,)_closure:
         const GHC.Base.$fSemigroup(,,,)_info;
 },
 sat_s8ky_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cafo,
                       label: sat_s8ky_info
                       rep:HeapRep 4 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cafp; else goto cafq;
       cafp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cafq: // global
           R6 = R2;
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8kx_entry() //  [R1, R2]
         { info_tbl: [(cafw,
                       label: sat_s8kx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafw: // global
           R6 = R2;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,,)_$csconcat_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8kw_entry() //  [R1, R2, R3]
         { info_tbl: [(cafE,
                       label: sat_s8kw_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cafF; else goto cafG;
       cafF: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cafG: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cafI,
                       label: GHC.Base.$fSemigroup(,,,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafI: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cafM; else goto cafL;
       cafM: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cafL: // global
           I64[Hp - 144] = sat_s8ky_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8kx_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_s8kw_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 62;
           P64[Hp - 8] = Hp - 103;
           P64[Hp] = Hp - 141;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.240011592 UTC

[section ""data" . GHC.Base.$w$cp1Monoid_closure" {
     GHC.Base.$w$cp1Monoid_closure:
         const GHC.Base.$w$cp1Monoid_info;
 },
 w4_s8l1_entry() //  [R1]
         { info_tbl: [(cafV,
                       label: w4_s8l1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cafW; else goto cafX;
       cafW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cafX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_s8l2_entry() //  [R1]
         { info_tbl: [(cag2,
                       label: w5_s8l2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cag2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cag3; else goto cag4;
       cag3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cag4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_s8l3_entry() //  [R1]
         { info_tbl: [(cag9,
                       label: w6_s8l3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cag9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caga; else goto cagb;
       caga: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cagb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_s8l4_entry() //  [R1]
         { info_tbl: [(cagg,
                       label: w7_s8l4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cagh; else goto cagi;
       cagh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cagi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lg_entry() //  [R1]
         { info_tbl: [(cagx,
                       label: sat_s8lg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cagy; else goto cagz;
       cagy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cagz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8lf_entry() //  [R1]
         { info_tbl: [(cagE,
                       label: sat_s8lf_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagE: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cagF; else goto cagG;
       cagF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cagG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8le_entry() //  [R1]
         { info_tbl: [(cagL,
                       label: sat_s8le_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cagM; else goto cagN;
       cagM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cagN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8ld_entry() //  [R1]
         { info_tbl: [(cagS,
                       label: sat_s8ld_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cagT; else goto cagU;
       cagT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cagU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8lh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cagV,
                       label: sat_s8lh_info
                       rep:HeapRep 4 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cagV: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cagX; else goto cagY;
       cagX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cagY: // global
           I64[Sp - 56] = block_cago_info;
           _s8l1::P64 = P64[R1 + 5];
           _s8l2::P64 = P64[R1 + 13];
           _s8l3::P64 = P64[R1 + 21];
           _s8l4::P64 = P64[R1 + 29];
           R1 = R4;
           P64[Sp - 48] = _s8l1::P64;
           P64[Sp - 40] = _s8l2::P64;
           P64[Sp - 32] = _s8l3::P64;
           P64[Sp - 24] = _s8l4::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uah2; else goto cagp;
       uah2: // global
           call _cago(R1) args: 0, res: 0, upd: 0;
       cagp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cago() //  [R1]
         { info_tbl: [(cago,
                       label: block_cago_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cago: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cah1; else goto cah0;
       cah1: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cah0: // global
           _s8l9::P64 = P64[R1 + 7];
           _s8la::P64 = P64[R1 + 15];
           _s8lb::P64 = P64[R1 + 23];
           _s8lc::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_s8lg_info;
           P64[Hp - 208] = P64[Sp + 8];
           _s8l5::P64 = P64[Sp + 40];
           P64[Hp - 200] = _s8l5::P64;
           _s8l6::P64 = P64[Sp + 48];
           P64[Hp - 192] = _s8l6::P64;
           P64[Hp - 184] = _s8lc::P64;
           I64[Hp - 176] = sat_s8lf_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _s8l5::P64;
           P64[Hp - 144] = _s8l6::P64;
           P64[Hp - 136] = _s8lb::P64;
           I64[Hp - 128] = sat_s8le_info;
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = _s8l5::P64;
           P64[Hp - 96] = _s8l6::P64;
           P64[Hp - 88] = _s8la::P64;
           I64[Hp - 80] = sat_s8ld_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _s8l5::P64;
           P64[Hp - 48] = _s8l6::P64;
           P64[Hp - 40] = _s8l9::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 w4_s8kI_entry() //  [R1]
         { info_tbl: [(cah7,
                       label: w4_s8kI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cah7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cah8; else goto cah9;
       cah8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cah9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_s8kJ_entry() //  [R1]
         { info_tbl: [(cahe,
                       label: w5_s8kJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahf; else goto cahg;
       cahf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cahg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_s8kK_entry() //  [R1]
         { info_tbl: [(cahl,
                       label: w6_s8kK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cahm; else goto cahn;
       cahm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cahn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_s8kL_entry() //  [R1]
         { info_tbl: [(cahs,
                       label: w7_s8kL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caht; else goto cahu;
       caht: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cahu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8l0_entry() //  [R1, R2]
         { info_tbl: [(cahD,
                       label: sat_s8l0_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cahO; else goto cahP;
       cahO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cahP: // global
           I64[Sp - 40] = block_cahA_info;
           _s8kI::P64 = P64[R1 + 7];
           _s8kJ::P64 = P64[R1 + 15];
           _s8kK::P64 = P64[R1 + 23];
           _s8kL::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _s8kI::P64;
           P64[Sp - 24] = _s8kJ::P64;
           P64[Sp - 16] = _s8kK::P64;
           P64[Sp - 8] = _s8kL::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uahW; else goto cahB;
       uahW: // global
           call _cahA(R1) args: 0, res: 0, upd: 0;
       cahB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahA() //  [R1]
         { info_tbl: [(cahA,
                       label: block_cahA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahA: // global
           I64[Sp - 8] = block_cahG_info;
           _s8kP::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8kP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uahV; else goto cahH;
       uahV: // global
           call _cahG(R1) args: 0, res: 0, upd: 0;
       cahH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cahG() //  [R1]
         { info_tbl: [(cahG,
                       label: block_cahG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahG: // global
           _s8kL::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cahL_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = _s8kL::P64;
           _s8kP::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _s8kP::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 _cahL() //  [R1, R2, R3, R4]
         { info_tbl: [(cahL,
                       label: block_cahL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cahL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cahU; else goto cahT;
       cahU: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cahT: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8kG_entry() //  [R1]
         { info_tbl: [(cai1,
                       label: sat_s8kG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cai1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cai2; else goto cai3;
       cai2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cai3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kF_entry() //  [R1]
         { info_tbl: [(cai8,
                       label: sat_s8kF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cai8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cai9; else goto caia;
       cai9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kE_entry() //  [R1]
         { info_tbl: [(caif,
                       label: sat_s8kE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caif: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caig; else goto caih;
       caig: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caih: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kD_entry() //  [R1]
         { info_tbl: [(caim,
                       label: sat_s8kD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caim: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cain; else goto caio;
       cain: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caio: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kH_entry() //  [R1, R2, R3]
         { info_tbl: [(caiu,
                       label: sat_s8kH_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caiu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caiv; else goto caiw;
       caiv: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caiw: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caix,
                       label: GHC.Base.$w$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caix: // global
           Hp = Hp + 408;
           if (Hp > HpLim) (likely: False) goto caiB; else goto caiA;
       caiB: // global
           HpAlloc = 408;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caiA: // global
           I64[Hp - 400] = w4_s8l1_info;
           P64[Hp - 384] = R5;
           I64[Hp - 376] = w5_s8l2_info;
           P64[Hp - 360] = R4;
           I64[Hp - 352] = w6_s8l3_info;
           P64[Hp - 336] = R3;
           I64[Hp - 328] = w7_s8l4_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s8lh_info;
           P64[Hp - 296] = Hp - 400;
           P64[Hp - 288] = Hp - 376;
           P64[Hp - 280] = Hp - 352;
           P64[Hp - 272] = Hp - 328;
           I64[Hp - 264] = w4_s8kI_info;
           P64[Hp - 248] = R5;
           I64[Hp - 240] = w5_s8kJ_info;
           P64[Hp - 224] = R4;
           I64[Hp - 216] = w6_s8kK_info;
           P64[Hp - 200] = R3;
           I64[Hp - 192] = w7_s8kL_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8l0_info;
           P64[Hp - 160] = Hp - 264;
           P64[Hp - 152] = Hp - 240;
           P64[Hp - 144] = Hp - 216;
           P64[Hp - 136] = Hp - 192;
           I64[Hp - 128] = sat_s8kG_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8kF_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_s8kE_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s8kD_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8kH_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R3 = Hp - 301;
           R2 = Hp - 167;
           R1 = Hp - 30;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.248078699 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caiJ,
                       label: GHC.Base.$fMonoid(,,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caiJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caiK; else goto caiL;
       caiK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caiL: // global
           I64[Sp - 8] = block_caiG_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _caiG() //  [R1, R2, R3]
         { info_tbl: [(caiG,
                       label: block_caiG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caiG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caiO; else goto caiN;
       caiO: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caiN: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.249549468 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caiV,
                       label: GHC.Base.$fMonoid(,,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caiV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caiW; else goto caiX;
       caiW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caiX: // global
           I64[Sp - 8] = block_caiT_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _caiT() //  [R1]
         { info_tbl: [(caiT,
                       label: block_caiT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caiT: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.251981331 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,)_$cmconcat_info;
 },
 k_s8lC_entry() //  [R1]
         { info_tbl: [(caja,
                       label: k_s8lC_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caja: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cajb; else goto cajc;
       cajb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajc: // global
           I64[Sp - 8] = block_caj7_info;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _caj7() //  [R1, R2, R3]
         { info_tbl: [(caj7,
                       label: block_caj7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caj7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cajf; else goto caje;
       cajf: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       caje: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 k1_s8lH_entry() //  [R1]
         { info_tbl: [(cajk,
                       label: k1_s8lH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajl; else goto cajm;
       cajl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8lI_entry() //  [R1]
         { info_tbl: [(cajr,
                       label: z_s8lI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajs; else goto cajt;
       cajs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8lJ_entry() //  [R1]
         { info_tbl: [(cajy,
                       label: z1_s8lJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajz; else goto cajA;
       cajz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_s8lK_entry() //  [R1]
         { info_tbl: [(cajF,
                       label: z2_s8lK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajG; else goto cajH;
       cajG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z3_s8lL_entry() //  [R1]
         { info_tbl: [(cajM,
                       label: z3_s8lL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cajN; else goto cajO;
       cajN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cajO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8lN_entry() //  [R1, R2]
         { info_tbl: [(cak2,
                       label: go_s8lN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cak2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cak3; else goto cak4;
       cak3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cak4: // global
           I64[Sp - 32] = block_cajV_info;
           _s8lN::P64 = R1;
           _s8lH::P64 = P64[R1 + 7];
           _s8lM::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s8lH::P64;
           P64[Sp - 16] = _s8lM::P64;
           P64[Sp - 8] = _s8lN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uake; else goto cajW;
       uake: // global
           call _cajV(R1) args: 0, res: 0, upd: 0;
       cajW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cajV() //  [R1]
         { info_tbl: [(cajV,
                       label: block_cajV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cajV: // global
           if (R1 & 7 == 1) goto cajZ; else goto cak0;
       cajZ: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cak0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cakd; else goto cakc;
       cakd: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cakc: // global
           _s8lQ::P64 = P64[R1 + 6];
           _s8lR::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s8lR::P64;
           R3 = Hp - 24;
           R2 = _s8lQ::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cakf,
                       label: GHC.Base.$fMonoid(,,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakf: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cakj; else goto caki;
       cakj: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caki: // global
           I64[Hp - 224] = k_s8lC_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = k1_s8lH_info;
           P64[Hp - 160] = Hp - 224;
           I64[Hp - 152] = z_s8lI_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = z1_s8lJ_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = z2_s8lK_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = z3_s8lL_info;
           P64[Hp - 64] = R5;
           I64[Hp - 56] = (,,,)_con_info;
           P64[Hp - 48] = Hp - 152;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 104;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = go_s8lN_info;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.258681702 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_closure" {
     GHC.Base.$fMonoid(,,,)_closure:
         const GHC.Base.$fMonoid(,,,)_info;
 },
 sat_s8m0_entry() //  [R1]
         { info_tbl: [(caks,
                       label: sat_s8m0_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caks: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakt; else goto caku;
       cakt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caku: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmconcat_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lZ_entry() //  [R1]
         { info_tbl: [(cakz,
                       label: sat_s8lZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakA; else goto cakB;
       cakA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmappend_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lY_entry() //  [R1]
         { info_tbl: [(cakG,
                       label: sat_s8lY_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakH; else goto cakI;
       cakH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmempty_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lX_entry() //  [R1]
         { info_tbl: [(cakN,
                       label: sat_s8lX_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cakO; else goto cakP;
       cakO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cakP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cakR,
                       label: GHC.Base.$fMonoid(,,,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cakR: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cakV; else goto cakU;
       cakV: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cakU: // global
           I64[Hp - 224] = sat_s8m0_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = sat_s8lZ_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           I64[Hp - 128] = sat_s8lY_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           I64[Hp - 80] = sat_s8lX_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.26272987 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,)_$c<>_info;
 },
 sat_s8mg_entry() //  [R1]
         { info_tbl: [(cale,
                       label: sat_s8mg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cale: // global
           if ((Sp + -40) < SpLim) (likely: False) goto calf; else goto calg;
       calf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8mf_entry() //  [R1]
         { info_tbl: [(call,
                       label: sat_s8mf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       call: // global
           if ((Sp + -40) < SpLim) (likely: False) goto calm; else goto caln;
       calm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caln: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8me_entry() //  [R1]
         { info_tbl: [(cals,
                       label: sat_s8me_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cals: // global
           if ((Sp + -40) < SpLim) (likely: False) goto calt; else goto calu;
       calt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       calu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(calv,
                       label: GHC.Base.$fMonoid(,,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calv: // global
           if ((Sp + -56) < SpLim) (likely: False) goto calx; else goto caly;
       calx: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caly: // global
           I64[Sp - 40] = block_cal0_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ualE; else goto cal1;
       ualE: // global
           call _cal0(R1) args: 0, res: 0, upd: 0;
       cal1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal0() //  [R1]
         { info_tbl: [(cal0,
                       label: block_cal0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal0: // global
           I64[Sp - 16] = block_cal5_info;
           _s8m7::P64 = P64[R1 + 7];
           _s8m8::P64 = P64[R1 + 15];
           _s8m9::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _s8m9::P64;
           P64[Sp] = _s8m8::P64;
           P64[Sp + 32] = _s8m7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ualD; else goto cal6;
       ualD: // global
           call _cal5(R1) args: 0, res: 0, upd: 0;
       cal6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cal5() //  [R1]
         { info_tbl: [(cal5,
                       label: block_cal5_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cal5: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto calC; else goto calB;
       calC: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       calB: // global
           _s8mb::P64 = P64[R1 + 7];
           _s8mc::P64 = P64[R1 + 15];
           _s8md::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8mg_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8md::P64;
           I64[Hp - 104] = sat_s8mf_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s8mc::P64;
           I64[Hp - 64] = sat_s8me_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8mb::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.266786768 UTC

[section ""data" . GHC.Base.$w$csconcat1_closure" {
     GHC.Base.$w$csconcat1_closure:
         const GHC.Base.$w$csconcat1_info;
 },
 GHC.Base.$w$csconcat1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calG: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8mG_entry() //  [R1]
         { info_tbl: [(cam6,
                       label: sat_s8mG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cam7; else goto cam8;
       cam7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cam8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8mF_entry() //  [R1]
         { info_tbl: [(camd,
                       label: sat_s8mF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto came; else goto camf;
       came: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       camf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8mE_entry() //  [R1]
         { info_tbl: [(camk,
                       label: sat_s8mE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caml; else goto camm;
       caml: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       camm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s8mo_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(camr,
                       label: $wgo_s8mo_info
                       rep:HeapRep 3 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camr: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cams; else goto camt;
       cams: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       camt: // global
           I64[Sp - 64] = block_calP_info;
           _s8mo::P64 = R1;
           _s8mh::P64 = P64[R1 + 4];
           _s8mi::P64 = P64[R1 + 12];
           _s8mj::P64 = P64[R1 + 20];
           R1 = R5;
           P64[Sp - 56] = _s8mh::P64;
           P64[Sp - 48] = _s8mi::P64;
           P64[Sp - 40] = _s8mj::P64;
           P64[Sp - 32] = _s8mo::P64;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto uamC; else goto calQ;
       uamC: // global
           call _calP(R1) args: 0, res: 0, upd: 0;
       calQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calP() //  [R1]
         { info_tbl: [(calP,
                       label: block_calP_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calP: // global
           if (R1 & 7 == 1) goto camo; else goto camp;
       camo: // global
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       camp: // global
           I64[Sp - 8] = block_calV_info;
           _s8mv::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8mv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uamB; else goto calW;
       uamB: // global
           call _calV(R1) args: 0, res: 0, upd: 0;
       calW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _calV() //  [R1]
         { info_tbl: [(calV,
                       label: block_calV_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       calV: // global
           _s8mv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cam0_info;
           R5 = _s8mv::P64;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wgo_s8mo_entry(R5, R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cam0() //  [R1, R2, R3]
         { info_tbl: [(cam0,
                       label: block_cam0_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cam0: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto camA; else goto camz;
       camA: // global
           HpAlloc = 120;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       camz: // global
           I64[Hp - 112] = sat_s8mG_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 56];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8mF_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8mE_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(camD,
                       label: GHC.Base.$w$csconcat1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camH; else goto camG;
       camH: // global
           HpAlloc = 32;
           R1 = GHC.Base.$w$csconcat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       camG: // global
           I64[Hp - 24] = $wgo_s8mo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _s8mk::P64 = R5;
           R5 = P64[Sp + 8];
           R4 = P64[Sp];
           R3 = R6;
           R2 = _s8mk::P64;
           R1 = Hp - 20;
           Sp = Sp + 16;
           call $wgo_s8mo_entry(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.270806625 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,)_$csconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(camP,
                       label: GHC.Base.$fSemigroup(,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto can0; else goto can1;
       can0: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$csconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       can1: // global
           I64[Sp - 32] = block_camM_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uan8; else goto camN;
       uan8: // global
           call _camM(R1) args: 0, res: 0, upd: 0;
       camN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camM() //  [R1]
         { info_tbl: [(camM,
                       label: block_camM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camM: // global
           I64[Sp - 8] = block_camS_info;
           _s8mN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8mN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uan7; else goto camT;
       uan7: // global
           call _camS(R1) args: 0, res: 0, upd: 0;
       camT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camS() //  [R1]
         { info_tbl: [(camS,
                       label: block_camS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camS: // global
           _s8mJ::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_camX_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = _s8mJ::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 24, res: 8, upd: 8;
     }
 },
 _camX() //  [R1, R2, R3]
         { info_tbl: [(camX,
                       label: block_camX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto can6; else goto can5;
       can6: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       can5: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.273801532 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,)_$cmappend_info;
 },
 sat_s8ne_entry() //  [R1]
         { info_tbl: [(cant,
                       label: sat_s8ne_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cant: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canu; else goto canv;
       canu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       canv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_canr_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _canr() //  [R1]
         { info_tbl: [(canr,
                       label: block_canr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canr: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8nc_entry() //  [R1]
         { info_tbl: [(canF,
                       label: sat_s8nc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canG; else goto canH;
       canG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       canH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_canD_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _canD() //  [R1]
         { info_tbl: [(canD,
                       label: block_canD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canD: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8na_entry() //  [R1]
         { info_tbl: [(canR,
                       label: sat_s8na_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canS; else goto canT;
       canS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       canT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_canP_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _canP() //  [R1]
         { info_tbl: [(canP,
                       label: block_canP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canP: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(canX,
                       label: GHC.Base.$fMonoid(,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canX: // global
           if ((Sp + -56) < SpLim) (likely: False) goto canZ; else goto cao0;
       canZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cao0: // global
           I64[Sp - 40] = block_cand_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uao6; else goto cane;
       uao6: // global
           call _cand(R1) args: 0, res: 0, upd: 0;
       cane: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cand() //  [R1]
         { info_tbl: [(cand,
                       label: block_cand_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cand: // global
           I64[Sp - 16] = block_cani_info;
           _s8n2::P64 = P64[R1 + 7];
           _s8n3::P64 = P64[R1 + 15];
           _s8n4::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _s8n4::P64;
           P64[Sp] = _s8n3::P64;
           P64[Sp + 32] = _s8n2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uao5; else goto canj;
       uao5: // global
           call _cani(R1) args: 0, res: 0, upd: 0;
       canj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cani() //  [R1]
         { info_tbl: [(cani,
                       label: block_cani_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cani: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cao4; else goto cao3;
       cao4: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cao3: // global
           _s8n6::P64 = P64[R1 + 7];
           _s8n7::P64 = P64[R1 + 15];
           _s8n8::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8ne_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8n8::P64;
           I64[Hp - 104] = sat_s8nc_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s8n7::P64;
           I64[Hp - 64] = sat_s8na_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8n6::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.27913196 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,)_$cmconcat_info;
 },
 $dSemigroup_s8nj_entry() //  [R1]
         { info_tbl: [(caof,
                       label: $dSemigroup_s8nj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caof: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caog; else goto caoh;
       caog: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caoh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup1_s8nk_entry() //  [R1]
         { info_tbl: [(caom,
                       label: $dSemigroup1_s8nk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caom: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caon; else goto caoo;
       caon: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caoo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup2_s8nl_entry() //  [R1]
         { info_tbl: [(caot,
                       label: $dSemigroup2_s8nl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caot: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caou; else goto caov;
       caou: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caov: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8nm_entry() //  [R1]
         { info_tbl: [(caoA,
                       label: z_s8nm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caoA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caoB; else goto caoC;
       caoB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caoC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8nn_entry() //  [R1]
         { info_tbl: [(caoH,
                       label: z1_s8nn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caoH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caoI; else goto caoJ;
       caoI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caoJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_s8no_entry() //  [R1]
         { info_tbl: [(caoO,
                       label: z2_s8no_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caoO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caoP; else goto caoQ;
       caoP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caoQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8nF_entry() //  [R1]
         { info_tbl: [(capg,
                       label: sat_s8nF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       capg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caph; else goto capi;
       caph: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       capi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8nE_entry() //  [R1]
         { info_tbl: [(capn,
                       label: sat_s8nE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       capn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto capo; else goto capp;
       capo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       capp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8nD_entry() //  [R1]
         { info_tbl: [(capu,
                       label: sat_s8nD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       capu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto capv; else goto capw;
       capv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       capw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8nq_entry() //  [R1, R2]
         { info_tbl: [(capB,
                       label: go_s8nq_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       capB: // global
           if ((Sp + -56) < SpLim) (likely: False) goto capC; else goto capD;
       capC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       capD: // global
           I64[Sp - 48] = block_caoX_info;
           _s8nq::P64 = R1;
           _s8nj::P64 = P64[R1 + 7];
           _s8nk::P64 = P64[R1 + 15];
           _s8nl::P64 = P64[R1 + 23];
           _s8np::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _s8nj::P64;
           P64[Sp - 32] = _s8nk::P64;
           P64[Sp - 24] = _s8nl::P64;
           P64[Sp - 16] = _s8np::P64;
           P64[Sp - 8] = _s8nq::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto uapN; else goto caoY;
       uapN: // global
           call _caoX(R1) args: 0, res: 0, upd: 0;
       caoY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caoX() //  [R1]
         { info_tbl: [(caoX,
                       label: block_caoX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caoX: // global
           if (R1 & 7 == 1) goto capy; else goto capz;
       capy: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       capz: // global
           I64[Sp] = block_cap3_info;
           _s8nu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 32] = _s8nu::P64;
           if (R1 & 7 != 0) goto uapM; else goto cap4;
       uapM: // global
           call _cap3(R1) args: 0, res: 0, upd: 0;
       cap4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cap3() //  [R1]
         { info_tbl: [(cap3,
                       label: block_cap3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cap3: // global
           I64[Sp - 8] = block_cap8_info;
           R2 = P64[Sp + 32];
           _s8nw::P64 = P64[R1 + 7];
           _s8nx::P64 = P64[R1 + 15];
           _s8ny::P64 = P64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp] = _s8ny::P64;
           P64[Sp + 32] = _s8nx::P64;
           P64[Sp + 40] = _s8nw::P64;
           Sp = Sp - 8;
           call go_s8nq_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cap8() //  [R1]
         { info_tbl: [(cap8,
                       label: block_cap8_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cap8: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto capL; else goto capK;
       capL: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       capK: // global
           _s8nA::P64 = P64[R1 + 7];
           _s8nB::P64 = P64[R1 + 15];
           _s8nC::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8nF_info;
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8nC::P64;
           I64[Hp - 104] = sat_s8nE_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = _s8nB::P64;
           I64[Hp - 64] = sat_s8nD_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8nA::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(capO,
                       label: GHC.Base.$fMonoid(,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       capO: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto capS; else goto capR;
       capS: // global
           HpAlloc = 216;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       capR: // global
           I64[Hp - 208] = $dSemigroup_s8nj_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = $dSemigroup1_s8nk_info;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = $dSemigroup2_s8nl_info;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = z_s8nm_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = z1_s8nn_info;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = z2_s8no_info;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = (,,)_con_info;
           P64[Hp - 56] = Hp - 136;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 88;
           I64[Hp - 32] = go_s8nq_info;
           P64[Hp - 24] = Hp - 208;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 160;
           P64[Hp] = Hp - 63;
           R2 = R5;
           R1 = Hp - 31;
           call go_s8nq_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.284800139 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,)_$cstimes_info;
 },
 sat_s8nS_entry() //  [R1]
         { info_tbl: [(caq6,
                       label: sat_s8nS_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caq6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caq7; else goto caq8;
       caq7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caq8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8nR_entry() //  [R1]
         { info_tbl: [(caqd,
                       label: sat_s8nR_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caqd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caqe; else goto caqf;
       caqe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caqf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8nQ_entry() //  [R1]
         { info_tbl: [(caqk,
                       label: sat_s8nQ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caqk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caql; else goto caqm;
       caql: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caqm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caqn,
                       label: GHC.Base.$fSemigroup(,,)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caqn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caqp; else goto caqq;
       caqp: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caqq: // global
           I64[Sp - 40] = block_capX_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaqu; else goto capY;
       uaqu: // global
           call _capX(R1) args: 0, res: 0, upd: 0;
       capY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _capX() //  [R1]
         { info_tbl: [(capX,
                       label: block_capX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       capX: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto caqt; else goto caqs;
       caqt: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caqs: // global
           _s8nN::P64 = P64[R1 + 7];
           _s8nO::P64 = P64[R1 + 15];
           _s8nP::P64 = P64[R1 + 23];
           I64[Hp - 168] = sat_s8nS_info;
           P64[Hp - 152] = P64[Sp + 16];
           _s8nJ::P64 = P64[Sp + 24];
           P64[Hp - 144] = _s8nJ::P64;
           _s8nK::P64 = P64[Sp + 32];
           P64[Hp - 136] = _s8nK::P64;
           P64[Hp - 128] = _s8nP::P64;
           I64[Hp - 120] = sat_s8nR_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = _s8nJ::P64;
           P64[Hp - 88] = _s8nK::P64;
           P64[Hp - 80] = _s8nO::P64;
           I64[Hp - 72] = sat_s8nQ_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = _s8nJ::P64;
           P64[Hp - 40] = _s8nK::P64;
           P64[Hp - 32] = _s8nN::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 168;
           R1 = Hp - 23;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.287874258 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_closure" {
     GHC.Base.$fSemigroup(,,)_closure:
         const GHC.Base.$fSemigroup(,,)_info;
 },
 sat_s8nY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(caqE,
                       label: sat_s8nY_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caqE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caqF; else goto caqG;
       caqF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caqG: // global
           R6 = R3;
           R5 = R2;
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fSemigroup(,,)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_s8nX_entry() //  [R1, R2]
         { info_tbl: [(caqM,
                       label: sat_s8nX_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caqM: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,)_$csconcat_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8nW_entry() //  [R1, R2, R3]
         { info_tbl: [(caqU,
                       label: sat_s8nW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caqU: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$c<>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,)_entry() //  [R2, R3, R4]
         { info_tbl: [(caqY,
                       label: GHC.Base.$fSemigroup(,,)_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caqY: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto car2; else goto car1;
       car2: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       car1: // global
           I64[Hp - 120] = sat_s8nY_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8nX_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_s8nW_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 117;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.290341253 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,)_$cp1Monoid_info;
 },
 sat_s8o4_entry() //  [R1]
         { info_tbl: [(carb,
                       label: sat_s8o4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       carb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto carc; else goto card;
       carc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       card: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8o3_entry() //  [R1]
         { info_tbl: [(cari,
                       label: sat_s8o3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cari: // global
           if ((Sp + -16) < SpLim) (likely: False) goto carj; else goto cark;
       carj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cark: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8o2_entry() //  [R1]
         { info_tbl: [(carp,
                       label: sat_s8o2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       carp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto carq; else goto carr;
       carq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       carr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cp1Monoid_entry() //  [R2, R3, R4]
         { info_tbl: [(cars,
                       label: GHC.Base.$fMonoid(,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cars: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto carw; else goto carv;
       carw: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       carv: // global
           I64[Hp - 64] = sat_s8o4_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s8o3_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8o2_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,,)_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.292662271 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_closure" {
     GHC.Base.$fMonoid(,,)_closure:
         const GHC.Base.$fMonoid(,,)_info;
 },
 sat_s8ob_entry() //  [R1, R2]
         { info_tbl: [(carG,
                       label: sat_s8ob_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       carG: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,,)_$cmconcat_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oa_entry() //  [R1, R2, R3]
         { info_tbl: [(carO,
                       label: sat_s8oa_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       carO: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$cmappend_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8o9_entry() //  [R1]
         { info_tbl: [(carV,
                       label: sat_s8o9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       carV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto carW; else goto carX;
       carW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       carX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cmempty_entry(R4,
                                                     R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8o8_entry() //  [R1]
         { info_tbl: [(cas2,
                       label: sat_s8o8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cas2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cas3; else goto cas4;
       cas3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cas4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cp1Monoid_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_entry() //  [R2, R3, R4]
         { info_tbl: [(cas6,
                       label: GHC.Base.$fMonoid(,,)_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cas6: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto casa; else goto cas9;
       casa: // global
           HpAlloc = 184;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cas9: // global
           I64[Hp - 176] = sat_s8ob_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           P64[Hp - 152] = R4;
           I64[Hp - 144] = sat_s8oa_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_s8o9_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s8o8_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 142;
           P64[Hp] = Hp - 175;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.295608438 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$c<>_closure" {
     GHC.Base.$fSemigroup(,)_$c<>_closure:
         const GHC.Base.$fSemigroup(,)_$c<>_info;
 },
 sat_s8on_entry() //  [R1]
         { info_tbl: [(cast,
                       label: sat_s8on_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cast: // global
           if ((Sp + -40) < SpLim) (likely: False) goto casu; else goto casv;
       casu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       casv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8om_entry() //  [R1]
         { info_tbl: [(casA,
                       label: sat_s8om_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto casB; else goto casC;
       casB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       casC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,)_$c<>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(casD,
                       label: GHC.Base.$fSemigroup(,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto casF; else goto casG;
       casF: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       casG: // global
           I64[Sp - 32] = block_casf_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uasM; else goto casg;
       uasM: // global
           call _casf(R1) args: 0, res: 0, upd: 0;
       casg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casf() //  [R1]
         { info_tbl: [(casf,
                       label: block_casf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casf: // global
           I64[Sp - 8] = block_cask_info;
           _s8oh::P64 = P64[R1 + 7];
           _s8oi::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8oi::P64;
           P64[Sp + 24] = _s8oh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uasL; else goto casl;
       uasL: // global
           call _cask(R1) args: 0, res: 0, upd: 0;
       casl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cask() //  [R1]
         { info_tbl: [(cask,
                       label: block_cask_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cask: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto casK; else goto casJ;
       casK: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       casJ: // global
           _s8ok::P64 = P64[R1 + 7];
           _s8ol::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s8on_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8ol::P64;
           I64[Hp - 56] = sat_s8om_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8ok::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.29874938 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,)_$cstimes_info;
 },
 sat_s8ox_entry() //  [R1]
         { info_tbl: [(cat0,
                       label: sat_s8ox_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cat1; else goto cat2;
       cat1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cat2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8ow_entry() //  [R1]
         { info_tbl: [(cat7,
                       label: sat_s8ow_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cat7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cat8; else goto cat9;
       cat8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cat9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cata,
                       label: GHC.Base.$fSemigroup(,)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cata: // global
           if ((Sp + -40) < SpLim) (likely: False) goto catc; else goto catd;
       catc: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       catd: // global
           I64[Sp - 40] = block_casR_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uath; else goto casS;
       uath: // global
           call _casR(R1) args: 0, res: 0, upd: 0;
       casS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _casR() //  [R1]
         { info_tbl: [(casR,
                       label: block_casR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       casR: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto catg; else goto catf;
       catg: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       catf: // global
           _s8ou::P64 = P64[R1 + 7];
           _s8ov::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_s8ox_info;
           P64[Hp - 96] = P64[Sp + 16];
           _s8oq::P64 = P64[Sp + 24];
           P64[Hp - 88] = _s8oq::P64;
           _s8or::P64 = P64[Sp + 32];
           P64[Hp - 80] = _s8or::P64;
           P64[Hp - 72] = _s8ov::P64;
           I64[Hp - 64] = sat_s8ow_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _s8oq::P64;
           P64[Hp - 32] = _s8or::P64;
           P64[Hp - 24] = _s8ou::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.3015086 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_closure" {
     GHC.Base.$fSemigroup(,)_closure:
         const GHC.Base.$fSemigroup(,)_info;
 },
 sat_s8oC_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(catr,
                       label: sat_s8oC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catr: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oB_entry() //  [R1, R2]
         { info_tbl: [(catz,
                       label: sat_s8oB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catz: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,)_$csconcat_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oA_entry() //  [R1, R2, R3]
         { info_tbl: [(catH,
                       label: sat_s8oA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catH: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroup(,)_$c<>_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,)_entry() //  [R2, R3]
         { info_tbl: [(catL,
                       label: GHC.Base.$fSemigroup(,)_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catL: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto catP; else goto catO;
       catP: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       catO: // global
           I64[Hp - 96] = sat_s8oC_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8oB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s8oA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 46;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 93;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.303630262 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,)_$cp1Monoid_info;
 },
 sat_s8oG_entry() //  [R1]
         { info_tbl: [(catY,
                       label: sat_s8oG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       catY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto catZ; else goto cau0;
       catZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cau0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oF_entry() //  [R1]
         { info_tbl: [(cau5,
                       label: sat_s8oF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cau6; else goto cau7;
       cau6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cau7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cp1Monoid_entry() //  [R2, R3]
         { info_tbl: [(cau8,
                       label: GHC.Base.$fMonoid(,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cau8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cauc; else goto caub;
       cauc: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caub: // global
           I64[Hp - 40] = sat_s8oG_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8oF_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,)_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.305809708 UTC

[section ""data" . GHC.Base.$fMonoid(,)_closure" {
     GHC.Base.$fMonoid(,)_closure:
         const GHC.Base.$fMonoid(,)_info;
 },
 sat_s8oM_entry() //  [R1, R2]
         { info_tbl: [(caum,
                       label: sat_s8oM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caum: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,)_$cmconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oL_entry() //  [R1, R2, R3]
         { info_tbl: [(cauu,
                       label: sat_s8oL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauu: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,)_$cmappend_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oK_entry() //  [R1]
         { info_tbl: [(cauB,
                       label: sat_s8oK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cauC; else goto cauD;
       cauC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cmempty_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oJ_entry() //  [R1]
         { info_tbl: [(cauI,
                       label: sat_s8oJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cauJ; else goto cauK;
       cauJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cauK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cp1Monoid_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_entry() //  [R2, R3]
         { info_tbl: [(cauM,
                       label: GHC.Base.$fMonoid(,)_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauM: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cauQ; else goto cauP;
       cauQ: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cauP: // global
           I64[Hp - 144] = sat_s8oM_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_s8oL_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_s8oK_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8oJ_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 143;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.307977393 UTC

[section ""data" . GHC.Base.$fMonoid()_$c<>_closure" {
     GHC.Base.$fMonoid()_$c<>_closure:
         const GHC.Base.$fMonoid()_$c<>_info;
 },
 GHC.Base.$fMonoid()_$c<>_entry() //  []
         { info_tbl: [(cauV,
                       label: GHC.Base.$fMonoid()_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cauV: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.30883304 UTC

[section ""data" . GHC.Base.$fSemigroup()_$csconcat_closure" {
     GHC.Base.$fSemigroup()_$csconcat_closure:
         const GHC.Base.$fSemigroup()_$csconcat_info;
 },
 GHC.Base.$fSemigroup()_$csconcat_entry() //  []
         { info_tbl: [(cav2,
                       label: GHC.Base.$fSemigroup()_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav2: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.309747303 UTC

[section ""data" . GHC.Base.$fSemigroup()_$cstimes_closure" {
     GHC.Base.$fSemigroup()_$cstimes_closure:
         const GHC.Base.$fSemigroup()_$cstimes_info;
 },
 GHC.Base.$fSemigroup()_$cstimes_entry() //  []
         { info_tbl: [(cav9,
                       label: GHC.Base.$fSemigroup()_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cav9: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.310635229 UTC

[section ""data" . GHC.Base.$fSemigroup()_closure" {
     GHC.Base.$fSemigroup()_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fSemigroup()_$csconcat_closure+1;
         const GHC.Base.$fSemigroup()_$cstimes_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.311273282 UTC

[section ""data" . GHC.Base.$fMonoid()_closure" {
     GHC.Base.$fMonoid()_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup()_closure+1;
         const GHC.Tuple.()_closure+1;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fMonoid()_$cmconcat_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.312166487 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$c<>_closure" {
     GHC.Base.$fSemigroup(->)_$c<>_closure:
         const GHC.Base.$fSemigroup(->)_$c<>_info;
 },
 GHC.Base.$fSemigroup(->)_$c<>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cavi,
                       label: GHC.Base.$fSemigroup(->)_$c<>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavi: // global
           _s8oW::P64 = R5;
           _s8oV::P64 = R4;
           _s8oU::P64 = R3;
           _s8oT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cavj; else goto cavk;
       cavk: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cavm; else goto cavl;
       cavm: // global
           HpAlloc = 64;
           goto cavj;
       cavj: // global
           R5 = _s8oW::P64;
           R4 = _s8oV::P64;
           R3 = _s8oU::P64;
           R2 = _s8oT::P64;
           R1 = GHC.Base.$fSemigroup(->)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cavl: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s8oV::P64;
           P64[Hp - 32] = _s8oW::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s8oU::P64;
           P64[Hp] = _s8oW::P64;
           R2 = _s8oT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.313666563 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$cstimes_closure" {
     GHC.Base.$fSemigroup(->)_$cstimes_closure:
         const GHC.Base.$fSemigroup(->)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(->)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cavs,
                       label: GHC.Base.$fSemigroup(->)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavs: // global
           _s8p3::P64 = R6;
           _s8p2::P64 = R5;
           _s8p1::P64 = R4;
           _s8p0::P64 = R3;
           _s8oZ::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cavt; else goto cavu;
       cavu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cavw; else goto cavv;
       cavw: // global
           HpAlloc = 32;
           goto cavt;
       cavt: // global
           R6 = _s8p3::P64;
           R5 = _s8p2::P64;
           R4 = _s8p1::P64;
           R3 = _s8p0::P64;
           R2 = _s8oZ::P64;
           R1 = GHC.Base.$fSemigroup(->)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cavv: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s8p2::P64;
           P64[Hp] = _s8p3::P64;
           R2 = _s8oZ::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s8p0::P64;
           P64[Sp - 16] = _s8p1::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.315539615 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_closure" {
     GHC.Base.$fSemigroup(->)_closure:
         const GHC.Base.$fSemigroup(->)_info;
 },
 sat_s8p8_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cavG,
                       label: sat_s8p8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavG: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8p7_entry() //  [R1, R2]
         { info_tbl: [(cavO,
                       label: sat_s8p7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavO: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8p6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cavW,
                       label: sat_s8p6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cavW: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(->)_entry() //  [R2]
         { info_tbl: [(caw0,
                       label: GHC.Base.$fSemigroup(->)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caw0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caw4; else goto caw3;
       caw4: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caw3: // global
           I64[Hp - 72] = sat_s8p8_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8p7_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8p6_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.317484673 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(->)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(->)_$cp1Monoid_info;
 },
 sat_s8pa_entry() //  [R1]
         { info_tbl: [(cawd,
                       label: sat_s8pa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cawe; else goto cawf;
       cawe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cawf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(->)_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cawg,
                       label: GHC.Base.$fMonoid(->)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cawk; else goto cawj;
       cawk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cawj: // global
           I64[Hp - 16] = sat_s8pa_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(->)_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.31960144 UTC

[section ""data" . GHC.Base.$fMonoid(->)_closure" {
     GHC.Base.$fMonoid(->)_closure:
         const GHC.Base.$fMonoid(->)_info;
 },
 lvl3_s8pc_entry() //  [R1]
         { info_tbl: [(cawt,
                       label: lvl3_s8pc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cawu; else goto cawv;
       cawu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cawv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ph_entry() //  [R1, R2, R3]
         { info_tbl: [(cawB,
                       label: sat_s8ph_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cawJ,
                       label: sat_s8pg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawJ: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pf_entry() //  [R1]
         { info_tbl: [(cawR,
                       label: sat_s8pf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawR: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pd_entry() //  [R1]
         { info_tbl: [(cawY,
                       label: sat_s8pd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cawY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cawZ; else goto cax0;
       cawZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cax0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(->)_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(->)_entry() //  [R2]
         { info_tbl: [(cax2,
                       label: GHC.Base.$fMonoid(->)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cax2: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cax6; else goto cax5;
       cax6: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cax5: // global
           I64[Hp - 128] = lvl3_s8pc_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8ph_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8pg_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s8pf_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_s8pd_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.321863479 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$cstimes_closure" {
     GHC.Base.$fSemigroup[]_$cstimes_closure:
         const GHC.Base.$fSemigroup[]_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroup[]_$cstimes_entry() //  [R2]
         { info_tbl: [(caxb,
                       label: GHC.Base.$fSemigroup[]_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caxb: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.322724607 UTC

[section ""data" . GHC.Base.$fSemigroup[]_closure" {
     GHC.Base.$fSemigroup[]_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fSemigroup[]_$csconcat_closure+1;
         const GHC.Base.$fSemigroup[]_$cstimes_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.32337275 UTC

[section ""data" . GHC.Base.$fMonoid[]_closure" {
     GHC.Base.$fMonoid[]_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fMonoid[]_$cmconcat_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.324321946 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cpure_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cpure_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cpure_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cpure_entry() //  [R2]
         { info_tbl: [(caxj,
                       label: GHC.Base.$fApplicativeNonEmpty_$cpure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caxj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caxn; else goto caxm;
       caxn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caxm: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.326151814 UTC

[section ""data" . GHC.Base.$w$cliftA2_closure" {
     GHC.Base.$w$cliftA2_closure:
         const GHC.Base.$w$cliftA2_info;
 },
 sat_s8pq_entry() //  [R1, R2]
         { info_tbl: [(caxE,
                       label: sat_s8pq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caxE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caxI; else goto caxH;
       caxI: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caxH: // global
           _s8pk::P64 = P64[R1 + 7];
           _s8pn::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _s8pk::P64;
           P64[Hp - 32] = _s8pn::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pu_entry() //  [R1, R2]
         { info_tbl: [(caxM,
                       label: sat_s8pu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caxM: // global
           _s8pn::P64 = R2;
           _s8pu::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto caxN; else goto caxO;
       caxO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caxQ; else goto caxP;
       caxQ: // global
           HpAlloc = 24;
           goto caxN;
       caxN: // global
           R2 = _s8pn::P64;
           R1 = _s8pu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caxP: // global
           _s8pk::P64 = P64[_s8pu::P64 + 7];
           _s8pm::P64 = P64[_s8pu::P64 + 15];
           I64[Hp - 16] = sat_s8pq_info;
           P64[Hp - 8] = _s8pk::P64;
           P64[Hp] = _s8pn::P64;
           I64[Sp - 8] = block_caxJ_info;
           R3 = Hp - 15;
           R2 = _s8pm::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caxJ() //  [R1, R2]
         { info_tbl: [(caxJ,
                       label: block_caxJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caxJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caxT; else goto caxS;
       caxT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caxS: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(caxU,
                       label: GHC.Base.$w$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caxU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caxY; else goto caxX;
       caxY: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caxX: // global
           I64[Hp - 16] = sat_s8pu_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _s8pl::P64 = R3;
           R3 = Hp - 15;
           R2 = _s8pl::P64;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.328516465 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cay6,
                       label: GHC.Base.$fApplicativeNonEmpty_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cay6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cay7; else goto cay8;
       cay7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cay8: // global
           I64[Sp - 8] = block_cay3_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cliftA2_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cay3() //  [R1, R2]
         { info_tbl: [(cay3,
                       label: block_cay3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cay3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cayb; else goto caya;
       cayb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caya: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.330365605 UTC

[section ""data" . GHC.Base.$w$c<*_closure" {
     GHC.Base.$w$c<*_closure:
         const GHC.Base.$w$c<*_info;
 },
 sat_s8pG_entry() //  [R1]
         { info_tbl: [(cayr,
                       label: sat_s8pG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cayr: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pK_entry() //  [R1, R2]
         { info_tbl: [(cayx,
                       label: sat_s8pK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cayx: // global
           _s8pD::P64 = R2;
           _s8pK::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cayy; else goto cayz;
       cayz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cayB; else goto cayA;
       cayB: // global
           HpAlloc = 40;
           goto cayy;
       cayy: // global
           R2 = _s8pD::P64;
           R1 = _s8pK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cayA: // global
           _s8pC::P64 = P64[_s8pK::P64 + 7];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _s8pD::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = sat_s8pG_info;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_cayu_info;
           R3 = Hp - 7;
           R2 = _s8pC::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cayu() //  [R1, R2]
         { info_tbl: [(cayu,
                       label: block_cayu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cayu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cayE; else goto cayD;
       cayE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cayD: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$c<*_entry() //  [R2, R3]
         { info_tbl: [(cayF,
                       label: GHC.Base.$w$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cayF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cayJ; else goto cayI;
       cayJ: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cayI: // global
           I64[Hp - 8] = sat_s8pK_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.332465525 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*_entry() //  [R2, R3]
         { info_tbl: [(cayR,
                       label: GHC.Base.$fApplicativeNonEmpty_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cayR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cayS; else goto cayT;
       cayS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cayT: // global
           I64[Sp - 8] = block_cayO_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cayO() //  [R1, R2]
         { info_tbl: [(cayO,
                       label: block_cayO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cayO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cayW; else goto cayV;
       cayW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cayV: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.334348253 UTC

[section ""data" . GHC.Base.$w$c<*>_closure" {
     GHC.Base.$w$c<*>_closure:
         const GHC.Base.$w$c<*>_info;
 },
 sat_s8pV_entry() //  [R1, R2]
         { info_tbl: [(cazd,
                       label: sat_s8pV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cazd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cazh; else goto cazg;
       cazh: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cazg: // global
           _s8pS::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s8pS::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pZ_entry() //  [R1, R2]
         { info_tbl: [(cazl,
                       label: sat_s8pZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cazl: // global
           _s8pS::P64 = R2;
           _s8pZ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cazm; else goto cazn;
       cazn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cazp; else goto cazo;
       cazp: // global
           HpAlloc = 16;
           goto cazm;
       cazm: // global
           R2 = _s8pS::P64;
           R1 = _s8pZ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cazo: // global
           _s8pR::P64 = P64[_s8pZ::P64 + 7];
           I64[Hp - 8] = sat_s8pV_info;
           P64[Hp] = _s8pS::P64;
           I64[Sp - 8] = block_cazi_info;
           R3 = Hp - 7;
           R2 = _s8pR::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cazi() //  [R1, R2]
         { info_tbl: [(cazi,
                       label: block_cazi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cazi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cazs; else goto cazr;
       cazs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cazr: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$c<*>_entry() //  [R2, R3]
         { info_tbl: [(cazt,
                       label: GHC.Base.$w$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cazt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cazx; else goto cazw;
       cazx: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cazw: // global
           I64[Hp - 8] = sat_s8pZ_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.336603394 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(cazF,
                       label: GHC.Base.$fApplicativeNonEmpty_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cazF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cazG; else goto cazH;
       cazG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cazH: // global
           I64[Sp - 8] = block_cazC_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cazC() //  [R1, R2]
         { info_tbl: [(cazC,
                       label: block_cazC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cazC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cazK; else goto cazJ;
       cazK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cazJ: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.338035514 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty1_closure" {
     GHC.Base.$fApplicativeNonEmpty1_closure:
         const GHC.Base.$fApplicativeNonEmpty1_info;
 },
 GHC.Base.$fApplicativeNonEmpty1_entry() //  [R3]
         { info_tbl: [(cazP,
                       label: GHC.Base.$fApplicativeNonEmpty1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cazP: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.3393663 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c*>_info;
 },
 sat_s8qc_entry() //  [R1]
         { info_tbl: [(caA3,
                       label: sat_s8qc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caA3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caA4; else goto caA5;
       caA4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caA5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_caA0_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaA9; else goto caA1;
       uaA9: // global
           call _caA0(R1) args: 0, res: 0, upd: 0;
       caA1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caA0() //  [R1]
         { info_tbl: [(caA0,
                       label: block_caA0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caA0: // global
           R3 = P64[R1 + 15];
           R2 = GHC.Base.$fApplicativeNonEmpty1_closure+2;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicativeNonEmpty_$c*>_entry() //  [R2, R3]
         { info_tbl: [(caAe,
                       label: GHC.Base.$fApplicativeNonEmpty_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAe: // global
           _s8q8::P64 = R3;
           _s8q7::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto caAf; else goto caAg;
       caAg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caAi; else goto caAh;
       caAi: // global
           HpAlloc = 48;
           goto caAf;
       caAf: // global
           R3 = _s8q8::P64;
           R2 = _s8q7::P64;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caAh: // global
           I64[Hp - 40] = sat_s8qc_info;
           P64[Hp - 24] = _s8q7::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = GHC.Base.breakpoint_closure+1;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_caAb_info;
           R3 = _s8q8::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _caAb() //  [R1, R2]
         { info_tbl: [(caAb,
                       label: block_caAb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caAl; else goto caAk;
       caAl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       caAk: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.341297821 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_closure" {
     GHC.Base.$fApplicativeNonEmpty_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeNonEmpty_$c*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.342266983 UTC

[section ""data" . lvl_r7PJ_closure" {
     lvl_r7PJ_closure:
         const lvl_r7PJ_info;
         const 0;
 },
 lvl_r7PJ_entry() //  [R2]
         { info_tbl: [(caAq,
                       label: lvl_r7PJ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAq: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.343118725 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_closure" {
     GHC.Base.$fMonadNonEmpty_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeNonEmpty_closure+1;
         const GHC.Base.$fMonadNonEmpty_$c>>=_closure+2;
         const GHC.Base.$fMonadNonEmpty_$c>>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const lvl_r7PJ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.343881039 UTC

[section ""cstring" . GHC.Base.$fAlternativeIO4_bytes" {
     GHC.Base.$fAlternativeIO4_bytes:
         I8[] [109,122,101,114,111]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.34473368 UTC

[section ""data" . GHC.Base.$fAlternativeIO3_closure" {
     GHC.Base.$fAlternativeIO3_closure:
         const GHC.Base.$fAlternativeIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO3_entry() //  [R1]
         { info_tbl: [(caAz,
                       label: GHC.Base.$fAlternativeIO3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAA; else goto caAB;
       caAA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caAB: // global
           (_caAw::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caAw::I64 == 0) goto caAy; else goto caAx;
       caAy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caAx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caAw::I64;
           R2 = GHC.Base.$fAlternativeIO4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.346290336 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cempty_closure" {
     GHC.Base.$fAlternativeIO_$cempty_closure:
         const GHC.Base.$fAlternativeIO_$cempty_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO_$cempty_entry() //  [R1]
         { info_tbl: [(caAI,
                       label: GHC.Base.$fAlternativeIO_$cempty_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAJ; else goto caAK;
       caAJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caAK: // global
           (_caAF::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caAF::I64 == 0) goto caAH; else goto caAG;
       caAH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caAG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caAF::I64;
           R2 = GHC.Base.$fAlternativeIO3_closure;
           R1 = GHC.IO.failIO_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.347392738 UTC

[section ""data" . GHC.Base.$fAlternativeIO_closure" {
     GHC.Base.$fAlternativeIO_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure+2;
         const GHC.Base.$fAlternativeIO_$cmany_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.348114448 UTC

[section ""data" . GHC.Base.$fMonadPlusIO_closure" {
     GHC.Base.$fMonadPlusIO_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeIO_closure+1;
         const GHC.Base.$fMonadIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.349205252 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$c<|>_closure" {
     GHC.Base.$fAlternativeMaybe_$c<|>_closure:
         const GHC.Base.$fAlternativeMaybe_$c<|>_info;
 },
 GHC.Base.$fAlternativeMaybe_$c<|>_entry() //  [R2, R3]
         { info_tbl: [(caAW,
                       label: GHC.Base.$fAlternativeMaybe_$c<|>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caAX; else goto caAY;
       caAX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$c<|>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caAY: // global
           I64[Sp - 16] = block_caAP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaB5; else goto caAQ;
       uaB5: // global
           call _caAP(R1) args: 0, res: 0, upd: 0;
       caAQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caAP() //  [R1]
         { info_tbl: [(caAP,
                       label: block_caAP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caAP: // global
           if (R1 & 7 == 1) goto caAT; else goto caAU;
       caAT: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       caAU: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.416539923 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cliftA2_closure" {
     GHC.Base.$fApplicativeMaybe_$cliftA2_closure:
         const GHC.Base.$fApplicativeMaybe_$cliftA2_info;
 },
 GHC.Base.$fApplicativeMaybe_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(caBh,
                       label: GHC.Base.$fApplicativeMaybe_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caBi; else goto caBj;
       caBi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caBj: // global
           I64[Sp - 24] = block_caBa_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaBL; else goto caBb;
       uaBL: // global
           call _caBa(R1) args: 0, res: 0, upd: 0;
       caBb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBa() //  [R1]
         { info_tbl: [(caBa,
                       label: block_caBa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBa: // global
           if (R1 & 7 == 1) goto uaBH; else goto caBf;
       uaBH: // global
           Sp = Sp + 24;
           call _caBx() args: 0, res: 0, upd: 0;
       caBf: // global
           I64[Sp] = block_caBp_info;
           _s8qq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8qq::P64;
           if (R1 & 7 != 0) goto uaBJ; else goto caBr;
       uaBJ: // global
           call _caBp(R1) args: 0, res: 0, upd: 0;
       caBr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBp() //  [R1]
         { info_tbl: [(caBp,
                       label: block_caBp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBp: // global
           if (R1 & 7 == 1) goto uaBI; else goto caBC;
       uaBI: // global
           Sp = Sp + 24;
           call _caBx() args: 0, res: 0, upd: 0;
       caBC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caBF; else goto caBE;
       caBF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caBE: // global
           _s8qs::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _s8qs::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caBx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBx: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.41929306 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c*>_entry() //  [R2, R3]
         { info_tbl: [(caBY,
                       label: GHC.Base.$fApplicativeMaybe_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caBZ; else goto caC0;
       caBZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caC0: // global
           I64[Sp - 16] = block_caBR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaC7; else goto caBS;
       uaC7: // global
           call _caBR(R1) args: 0, res: 0, upd: 0;
       caBS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caBR() //  [R1]
         { info_tbl: [(caBR,
                       label: block_caBR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caBR: // global
           if (R1 & 7 == 1) goto caBV; else goto caBW;
       caBV: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caBW: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.421068767 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*>_closure" {
     GHC.Base.$fApplicative(->)_$c<*>_closure:
         const GHC.Base.$fApplicative(->)_$c<*>_info;
 },
 GHC.Base.$fApplicative(->)_$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(caCd,
                       label: GHC.Base.$fApplicative(->)_$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caCh; else goto caCg;
       caCh: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caCg: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 24;
           _s8qy::P64 = R2;
           R2 = R4;
           R1 = _s8qy::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.422745915 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$cliftA2_closure" {
     GHC.Base.$fApplicative(->)_$cliftA2_closure:
         const GHC.Base.$fApplicative(->)_$cliftA2_info;
 },
 GHC.Base.$fApplicative(->)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caCo,
                       label: GHC.Base.$fApplicative(->)_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caCs; else goto caCr;
       caCs: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caCr: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _s8qC::P64 = R2;
           R2 = Hp - 24;
           R1 = _s8qC::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.423866824 UTC

[section ""data" . GHC.Base.$fApplicative(->)_closure" {
     GHC.Base.$fApplicative(->)_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor(->)_closure+1;
         const GHC.Base.const_closure+2;
         const GHC.Base.$fApplicative(->)_$c<*>_closure+3;
         const GHC.Base.$fApplicative(->)_$cliftA2_closure+4;
         const GHC.Base.$fApplicative(->)_$c*>_closure+3;
         const GHC.Base.$fApplicative(->)_$c<*_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.424606373 UTC

[section ""data" . lvl1_r7PK_closure" {
     lvl1_r7PK_closure:
         const lvl1_r7PK_info;
         const 0;
 },
 lvl1_r7PK_entry() //  [R2]
         { info_tbl: [(caCx,
                       label: lvl1_r7PK_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCx: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.425700806 UTC

[section ""data" . GHC.Base.$fMonad(->)_closure" {
     GHC.Base.$fMonad(->)_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative(->)_closure+1;
         const GHC.Base.$fMonad(->)_$c>>=_closure+3;
         const GHC.Base.$fMonad(->)_$c>>_closure+3;
         const GHC.Base.const_closure+2;
         const lvl1_r7PK_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.427202519 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cfmap_closure" {
     GHC.Base.$fApplicativeMaybe_$cfmap_closure:
         const GHC.Base.$fApplicativeMaybe_$cfmap_info;
 },
 GHC.Base.$fApplicativeMaybe_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(caCL,
                       label: GHC.Base.$fApplicativeMaybe_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caCM; else goto caCN;
       caCM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caCN: // global
           I64[Sp - 16] = block_caCE_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaCY; else goto caCF;
       uaCY: // global
           call _caCE(R1) args: 0, res: 0, upd: 0;
       caCF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caCE() //  [R1]
         { info_tbl: [(caCE,
                       label: block_caCE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caCE: // global
           if (R1 & 7 == 1) goto caCI; else goto caCJ;
       caCI: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caCJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caCX; else goto caCW;
       caCX: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caCW: // global
           _s8qM::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8qM::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.42873586 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_closure" {
     GHC.Base.$fFunctorMaybe_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.430010298 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(caDa,
                       label: GHC.Base.$fApplicativeMaybe_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caDb; else goto caDc;
       caDb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caDc: // global
           I64[Sp - 16] = block_caD3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaDj; else goto caD4;
       uaDj: // global
           call _caD3(R1) args: 0, res: 0, upd: 0;
       caD4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caD3() //  [R1]
         { info_tbl: [(caD3,
                       label: block_caD3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caD3: // global
           if (R1 & 7 == 1) goto caD7; else goto caD8;
       caD7: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caD8: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.431496392 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_closure" {
     GHC.Base.$fApplicativeMaybe_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorMaybe_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.432496306 UTC

[section ""data" . GHC.Base.$fMonadMaybe_closure" {
     GHC.Base.$fMonadMaybe_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.433409229 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_closure" {
     GHC.Base.$fAlternativeMaybe_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const GHC.Base.$fAlternativeMaybe_$csome_closure+1;
         const GHC.Base.$fAlternativeMaybe_$cmany_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.434281772 UTC

[section ""data" . GHC.Base.$fMonadPlusMaybe_closure" {
     GHC.Base.$fMonadPlusMaybe_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.435917741 UTC

[section ""data" . GHC.Base.liftA3_$sliftA3_closure" {
     GHC.Base.liftA3_$sliftA3_closure:
         const GHC.Base.liftA3_$sliftA3_info;
 },
 GHC.Base.liftA3_$sliftA3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caDv,
                       label: GHC.Base.liftA3_$sliftA3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caDw; else goto caDx;
       caDw: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA3_$sliftA3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caDx: // global
           I64[Sp - 32] = block_caDo_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaEd; else goto caDp;
       uaEd: // global
           call _caDo(R1) args: 0, res: 0, upd: 0;
       caDp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDo() //  [R1]
         { info_tbl: [(caDo,
                       label: block_caDo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDo: // global
           if (R1 & 7 == 1) goto uaE8; else goto caDt;
       uaE8: // global
           Sp = Sp + 32;
           call _caDX() args: 0, res: 0, upd: 0;
       caDt: // global
           I64[Sp] = block_caDD_info;
           _s8qX::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8qX::P64;
           if (R1 & 7 != 0) goto uaEb; else goto caDF;
       uaEb: // global
           call _caDD(R1) args: 0, res: 0, upd: 0;
       caDF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDD() //  [R1]
         { info_tbl: [(caDD,
                       label: block_caDD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDD: // global
           if (R1 & 7 == 1) goto uaE9; else goto caDQ;
       uaE9: // global
           Sp = Sp + 32;
           call _caDX() args: 0, res: 0, upd: 0;
       caDQ: // global
           I64[Sp] = block_caDO_info;
           _s8qZ::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s8qZ::P64;
           if (R1 & 7 != 0) goto uaEe; else goto caDR;
       uaEe: // global
           call _caDO(R1) args: 0, res: 0, upd: 0;
       caDR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caDO() //  [R1]
         { info_tbl: [(caDO,
                       label: block_caDO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDO: // global
           if (R1 & 7 == 1) goto uaEa; else goto caE2;
       uaEa: // global
           Sp = Sp + 32;
           call _caDX() args: 0, res: 0, upd: 0;
       caE2: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caE5; else goto caE4;
       caE5: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caE4: // global
           _s8r1::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s8r1::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caDX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caDX: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.439122491 UTC

[section ""data" . GHC.Base.liftA3_closure" {
     GHC.Base.liftA3_closure:
         const GHC.Base.liftA3_info;
 },
 sat_s8r8_entry() //  [R1]
         { info_tbl: [(caEp,
                       label: sat_s8r8_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto caEq; else goto caEr;
       caEq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caEr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.liftA3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caEs,
                       label: GHC.Base.liftA3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEs: // global
           _s8r7::P64 = R6;
           _s8r6::P64 = R5;
           _s8r5::P64 = R4;
           _s8r4::P64 = R3;
           _s8r3::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto caEt; else goto caEu;
       caEu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caEw; else goto caEv;
       caEw: // global
           HpAlloc = 48;
           goto caEt;
       caEt: // global
           R6 = _s8r7::P64;
           R5 = _s8r6::P64;
           R4 = _s8r5::P64;
           R3 = _s8r4::P64;
           R2 = _s8r3::P64;
           R1 = GHC.Base.liftA3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caEv: // global
           I64[Hp - 40] = sat_s8r8_info;
           P64[Hp - 24] = _s8r3::P64;
           P64[Hp - 16] = _s8r4::P64;
           P64[Hp - 8] = _s8r5::P64;
           P64[Hp] = _s8r6::P64;
           R2 = _s8r3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = _s8r7::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.440577015 UTC

[section ""data" . GHC.Base.liftA_$sliftA_closure" {
     GHC.Base.liftA_$sliftA_closure:
         const GHC.Base.liftA_$sliftA_info;
 },
 GHC.Base.liftA_$sliftA_entry() //  [R2, R3]
         { info_tbl: [(caEB,
                       label: GHC.Base.liftA_$sliftA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEB: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.441679483 UTC

[section ""data" . GHC.Base.liftA_closure" {
     GHC.Base.liftA_closure:
         const GHC.Base.liftA_info;
 },
 sat_s8rc_entry() //  [R1]
         { info_tbl: [(caEM,
                       label: sat_s8rc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caEN; else goto caEO;
       caEN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caEO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Base.liftA_entry() //  [R2, R3, R4]
         { info_tbl: [(caEP,
                       label: GHC.Base.liftA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEP: // global
           _s8rb::P64 = R4;
           _s8ra::P64 = R3;
           _s8r9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto caEQ; else goto caER;
       caER: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caET; else goto caES;
       caET: // global
           HpAlloc = 32;
           goto caEQ;
       caEQ: // global
           R4 = _s8rb::P64;
           R3 = _s8ra::P64;
           R2 = _s8r9::P64;
           R1 = GHC.Base.liftA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caES: // global
           I64[Hp - 24] = sat_s8rc_info;
           P64[Hp - 8] = _s8r9::P64;
           P64[Hp] = _s8ra::P64;
           R2 = _s8r9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s8rb::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.443235073 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$cfmap_closure" {
     GHC.Base.$fFunctor(,)_$cfmap_closure:
         const GHC.Base.$fFunctor(,)_$cfmap_info;
 },
 GHC.Base.$fFunctor(,)_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(caF1,
                       label: GHC.Base.$fFunctor(,)_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caF1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caF6; else goto caF7;
       caF6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caF7: // global
           I64[Sp - 16] = block_caEY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaFb; else goto caEZ;
       uaFb: // global
           call _caEY(R1) args: 0, res: 0, upd: 0;
       caEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caEY() //  [R1]
         { info_tbl: [(caEY,
                       label: block_caEY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caEY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caFa; else goto caF9;
       caFa: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caF9: // global
           _s8rg::P64 = P64[R1 + 7];
           _s8rh::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s8rh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rg::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.444391369 UTC

[section ""data" . GHC.Base.$fFunctor(,)_closure" {
     GHC.Base.$fFunctor(,)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctor(,)_$cfmap_closure+2;
         const GHC.Base.$fFunctor(,)_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.445992152 UTC

[section ""data" . GHC.Base.$fApplicative(,)_closure" {
     GHC.Base.$fApplicative(,)_closure:
         const GHC.Base.$fApplicative(,)_info;
 },
 lvl3_s8rk_entry() //  [R1]
         { info_tbl: [(caFk,
                       label: lvl3_s8rk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caFl; else goto caFm;
       caFl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caFm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8rq_entry() //  [R1, R2, R3]
         { info_tbl: [(caFs,
                       label: sat_s8rq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFs: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rp_entry() //  [R1, R2, R3]
         { info_tbl: [(caFA,
                       label: sat_s8rp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c*>_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ro_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(caFI,
                       label: sat_s8ro_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFI: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fApplicative(,)_$cliftA2_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rn_entry() //  [R1, R2, R3]
         { info_tbl: [(caFQ,
                       label: sat_s8rn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*>_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rm_entry() //  [R1, R2]
         { info_tbl: [(caFZ,
                       label: sat_s8rm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caFZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caG3; else goto caG2;
       caG3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG2: // global
           _s8rk::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rk::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative(,)_entry() //  [R2]
         { info_tbl: [(caG5,
                       label: GHC.Base.$fApplicative(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caG5: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto caG9; else goto caG8;
       caG9: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caG8: // global
           I64[Hp - 152] = lvl3_s8rk_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s8rq_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s8rp_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s8ro_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s8rn_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s8rm_info;
           P64[Hp - 56] = Hp - 152;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = GHC.Base.$fFunctor(,)_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 93;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 126;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.448163702 UTC

[section ""data" . lvl2_r7PL_closure" {
     lvl2_r7PL_closure:
         const lvl2_r7PL_info;
         const 0;
 },
 lvl2_r7PL_entry() //  [R2]
         { info_tbl: [(caGe,
                       label: lvl2_r7PL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGe: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.44977048 UTC

[section ""data" . GHC.Base.$fMonad(,)_closure" {
     GHC.Base.$fMonad(,)_closure:
         const GHC.Base.$fMonad(,)_info;
         const 0;
 },
 lvl3_s8rt_entry() //  [R1]
         { info_tbl: [(caGp,
                       label: lvl3_s8rt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGq; else goto caGr;
       caGq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ry_entry() //  [R1, R2]
         { info_tbl: [(caGy,
                       label: sat_s8ry_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caGC; else goto caGB;
       caGC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caGB: // global
           _s8rt::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rt::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rw_entry() //  [R1, R2, R3]
         { info_tbl: [(caGI,
                       label: sat_s8rw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rv_entry() //  [R1, R2, R3]
         { info_tbl: [(caGQ,
                       label: sat_s8rv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>=_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ru_entry() //  [R1]
         { info_tbl: [(caGX,
                       label: sat_s8ru_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caGX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caGY; else goto caGZ;
       caGY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caGZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fApplicative(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_entry() //  [R2]
         { info_tbl: [(caH1,
                       label: GHC.Base.$fMonad(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caH1: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto caH5; else goto caH4;
       caH5: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caH4: // global
           I64[Hp - 136] = lvl3_s8rt_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s8ry_info;
           P64[Hp - 104] = Hp - 136;
           I64[Hp - 96] = sat_s8rw_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s8rv_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s8ru_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl2_r7PL_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.451892799 UTC

[section ""data" . GHC.Base.C:Monad_closure" {
     GHC.Base.C:Monad_closure:
         const GHC.Base.C:Monad_info;
 },
 GHC.Base.C:Monad_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caHb,
                       label: GHC.Base.C:Monad_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caHf; else goto caHe;
       caHf: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monad_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caHe: // global
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.45296647 UTC

[section ""data" . GHC.Base.C:Functor_closure" {
     GHC.Base.C:Functor_closure:
         const GHC.Base.C:Functor_info;
 },
 GHC.Base.C:Functor_entry() //  [R2, R3]
         { info_tbl: [(caHl,
                       label: GHC.Base.C:Functor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caHp; else goto caHo;
       caHp: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Functor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caHo: // global
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.454475099 UTC

[section ""data" . GHC.Base.C:Applicative_closure" {
     GHC.Base.C:Applicative_closure:
         const GHC.Base.C:Applicative_info;
 },
 GHC.Base.C:Applicative_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caHv,
                       label: GHC.Base.C:Applicative_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caHz; else goto caHy;
       caHz: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Applicative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caHy: // global
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.455593437 UTC

[section ""data" . GHC.Base.C:Semigroup_closure" {
     GHC.Base.C:Semigroup_closure:
         const GHC.Base.C:Semigroup_info;
 },
 GHC.Base.C:Semigroup_entry() //  [R2, R3, R4]
         { info_tbl: [(caHF,
                       label: GHC.Base.C:Semigroup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caHJ; else goto caHI;
       caHJ: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Semigroup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caHI: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.4567237 UTC

[section ""data" . GHC.Base.C:Monoid_closure" {
     GHC.Base.C:Monoid_closure:
         const GHC.Base.C:Monoid_info;
 },
 GHC.Base.C:Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caHP,
                       label: GHC.Base.C:Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caHT; else goto caHS;
       caHT: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caHS: // global
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.458397043 UTC

[section ""data" . GHC.Base.Nothing_closure" {
     GHC.Base.Nothing_closure:
         const GHC.Base.Nothing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.459138102 UTC

[section ""data" . GHC.Base.Just_closure" {
     GHC.Base.Just_closure:
         const GHC.Base.Just_info;
 },
 GHC.Base.Just_entry() //  [R2]
         { info_tbl: [(caHZ,
                       label: GHC.Base.Just_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caHZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caI3; else goto caI2;
       caI3: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.Just_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caI2: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.460117683 UTC

[section ""data" . GHC.Base.O_closure" {
     GHC.Base.O_closure:
         const GHC.Base.O_info;
 },
 GHC.Base.O_entry() //  [R2]
         { info_tbl: [(caI9,
                       label: GHC.Base.O_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caI9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caId; else goto caIc;
       caId: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.O_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caIc: // global
           I64[Hp - 8] = GHC.Base.O_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.461128399 UTC

[section ""data" . GHC.Base.:|_closure" {
     GHC.Base.:|_closure:
         const GHC.Base.:|_info;
 },
 GHC.Base.:|_entry() //  [R2, R3]
         { info_tbl: [(caIj,
                       label: GHC.Base.:|_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caIn; else goto caIm;
       caIn: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.:|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caIm: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.462194197 UTC

[section ""data" . GHC.Base.C:MonadPlus_closure" {
     GHC.Base.C:MonadPlus_closure:
         const GHC.Base.C:MonadPlus_info;
 },
 GHC.Base.C:MonadPlus_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caIt,
                       label: GHC.Base.C:MonadPlus_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caIx; else goto caIw;
       caIx: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:MonadPlus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caIw: // global
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.463331435 UTC

[section ""data" . GHC.Base.C:Alternative_closure" {
     GHC.Base.C:Alternative_closure:
         const GHC.Base.C:Alternative_info;
 },
 GHC.Base.C:Alternative_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caID,
                       label: GHC.Base.C:Alternative_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caID: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caIH; else goto caIG;
       caIH: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Alternative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caIG: // global
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.464249425 UTC

[GHC.Base.C:Monad_con_entry() //  [R1]
         { info_tbl: [(caII,
                       label: GHC.Base.C:Monad_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caII: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.46494885 UTC

[GHC.Base.C:Functor_con_entry() //  [R1]
         { info_tbl: [(caIJ,
                       label: GHC.Base.C:Functor_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,70,117,110,99,116,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.465812273 UTC

[GHC.Base.C:Applicative_con_entry() //  [R1]
         { info_tbl: [(caIK,
                       label: GHC.Base.C:Applicative_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,112,112,108,105,99,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIK: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.466552798 UTC

[GHC.Base.C:Semigroup_con_entry() //  [R1]
         { info_tbl: [(caIL,
                       label: GHC.Base.C:Semigroup_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,83,101,109,105,103,114,111,117,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIL: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.467260663 UTC

[GHC.Base.C:Monoid_con_entry() //  [R1]
         { info_tbl: [(caIM,
                       label: GHC.Base.C:Monoid_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,111,105,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIM: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.467979261 UTC

[GHC.Base.Nothing_con_entry() //  [R1]
         { info_tbl: [(caIN,
                       label: GHC.Base.Nothing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,78,111,116,104,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIN: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.468685327 UTC

[GHC.Base.Just_con_entry() //  [R1]
         { info_tbl: [(caIO,
                       label: GHC.Base.Just_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,74,117,115,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIO: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.469664248 UTC

[GHC.Base.O_con_entry() //  [R1]
         { info_tbl: [(caIP,
                       label: GHC.Base.O_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,79]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIP: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.470379772 UTC

[GHC.Base.:|_con_entry() //  [R1]
         { info_tbl: [(caIQ,
                       label: GHC.Base.:|_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,58,124]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.471121018 UTC

[GHC.Base.C:MonadPlus_con_entry() //  [R1]
         { info_tbl: [(caIR,
                       label: GHC.Base.C:MonadPlus_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIR: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.471831016 UTC

[GHC.Base.C:Alternative_con_entry() //  [R1]
         { info_tbl: [(caIS,
                       label: GHC.Base.C:Alternative_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,108,116,101,114,110,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.472508813 UTC

[section ""relreadonly" . S8R0_srt" {
     S8R0_srt:
         const GHC.Base.$fSemigroupIO_$cstimes_closure;
         const GHC.Base.$fSemigroupIO_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const GHC.Base.$fMonoidIO_$cp1Monoid_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure;
         const GHC.Base.$fAlternativeIO_$cmany_closure;
         const GHC.Base.$fSemigroupNonEmpty_closure;
         const GHC.Base.$fMonoidIO_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.failIO_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const GHC.Base.$fSemigroupMaybe_closure;
         const GHC.Base.$fMonoidMaybe_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const GHC.Base.$fAlternativeIO3_closure;
         const GHC.Base.$fMonad(,)_closure;
         const lvl2_r7PL_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.473215274 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:54:43.475011542 UTC

[section ""data" . GHC.Base.$p1Monad_closure" {
     GHC.Base.$p1Monad_closure:
         const GHC.Base.$p1Monad_info;
 },
 GHC.Base.$p1Monad_entry() //  [R2]
         { info_tbl: [(caJ0,
                       label: GHC.Base.$p1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caJ0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caJ1; else goto caJ2;
       caJ1: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caJ2: // global
           I64[Sp - 8] = block_caIX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaJ6; else goto caIY;
       uaJ6: // global
           call _caIX(R1) args: 0, res: 0, upd: 0;
       caIY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caIX() //  [R1]
         { info_tbl: [(caIX,
                       label: block_caIX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caIX: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.476175826 UTC

[section ""data" . GHC.Base.>>=_closure" {
     GHC.Base.>>=_closure:
         const GHC.Base.>>=_info;
 },
 GHC.Base.>>=_entry() //  [R2]
         { info_tbl: [(caJe,
                       label: GHC.Base.>>=_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caJe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caJf; else goto caJg;
       caJf: // global
           R2 = R2;
           R1 = GHC.Base.>>=_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caJg: // global
           I64[Sp - 8] = block_caJb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaJk; else goto caJc;
       uaJk: // global
           call _caJb(R1) args: 0, res: 0, upd: 0;
       caJc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caJb() //  [R1]
         { info_tbl: [(caJb,
                       label: block_caJb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caJb: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.477364906 UTC

[section ""data" . GHC.Base.>>_closure" {
     GHC.Base.>>_closure:
         const GHC.Base.>>_info;
 },
 GHC.Base.>>_entry() //  [R2]
         { info_tbl: [(caJs,
                       label: GHC.Base.>>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caJs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caJt; else goto caJu;
       caJt: // global
           R2 = R2;
           R1 = GHC.Base.>>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caJu: // global
           I64[Sp - 8] = block_caJp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaJy; else goto caJq;
       uaJy: // global
           call _caJp(R1) args: 0, res: 0, upd: 0;
       caJq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caJp() //  [R1]
         { info_tbl: [(caJp,
                       label: block_caJp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caJp: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.478586371 UTC

[section ""data" . GHC.Base.return_closure" {
     GHC.Base.return_closure:
         const GHC.Base.return_info;
 },
 GHC.Base.return_entry() //  [R2]
         { info_tbl: [(caJG,
                       label: GHC.Base.return_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caJG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caJH; else goto caJI;
       caJH: // global
           R2 = R2;
           R1 = GHC.Base.return_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caJI: // global
           I64[Sp - 8] = block_caJD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaJM; else goto caJE;
       uaJM: // global
           call _caJD(R1) args: 0, res: 0, upd: 0;
       caJE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caJD() //  [R1]
         { info_tbl: [(caJD,
                       label: block_caJD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caJD: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.479769823 UTC

[section ""data" . GHC.Base.fail_closure" {
     GHC.Base.fail_closure:
         const GHC.Base.fail_info;
 },
 GHC.Base.fail_entry() //  [R2]
         { info_tbl: [(caJU,
                       label: GHC.Base.fail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caJU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caJV; else goto caJW;
       caJV: // global
           R2 = R2;
           R1 = GHC.Base.fail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caJW: // global
           I64[Sp - 8] = block_caJR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaK0; else goto caJS;
       uaK0: // global
           call _caJR(R1) args: 0, res: 0, upd: 0;
       caJS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caJR() //  [R1]
         { info_tbl: [(caJR,
                       label: block_caJR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caJR: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.480908704 UTC

[section ""data" . GHC.Base.fmap_closure" {
     GHC.Base.fmap_closure:
         const GHC.Base.fmap_info;
 },
 GHC.Base.fmap_entry() //  [R2]
         { info_tbl: [(caK8,
                       label: GHC.Base.fmap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caK8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caK9; else goto caKa;
       caK9: // global
           R2 = R2;
           R1 = GHC.Base.fmap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caKa: // global
           I64[Sp - 8] = block_caK5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaKe; else goto caK6;
       uaKe: // global
           call _caK5(R1) args: 0, res: 0, upd: 0;
       caK6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caK5() //  [R1]
         { info_tbl: [(caK5,
                       label: block_caK5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caK5: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.482455664 UTC

[section ""data" . GHC.Base.<$_closure" {
     GHC.Base.<$_closure:
         const GHC.Base.<$_info;
 },
 GHC.Base.<$_entry() //  [R2]
         { info_tbl: [(caKm,
                       label: GHC.Base.<$_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caKm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caKn; else goto caKo;
       caKn: // global
           R2 = R2;
           R1 = GHC.Base.<$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caKo: // global
           I64[Sp - 8] = block_caKj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaKs; else goto caKk;
       uaKs: // global
           call _caKj(R1) args: 0, res: 0, upd: 0;
       caKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caKj() //  [R1]
         { info_tbl: [(caKj,
                       label: block_caKj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caKj: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.483619317 UTC

[section ""data" . GHC.Base.$p1Applicative_closure" {
     GHC.Base.$p1Applicative_closure:
         const GHC.Base.$p1Applicative_info;
 },
 GHC.Base.$p1Applicative_entry() //  [R2]
         { info_tbl: [(caKA,
                       label: GHC.Base.$p1Applicative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caKA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caKB; else goto caKC;
       caKB: // global
           R2 = R2;
           R1 = GHC.Base.$p1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caKC: // global
           I64[Sp - 8] = block_caKx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaKG; else goto caKy;
       uaKG: // global
           call _caKx(R1) args: 0, res: 0, upd: 0;
       caKy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caKx() //  [R1]
         { info_tbl: [(caKx,
                       label: block_caKx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caKx: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.484767927 UTC

[section ""data" . GHC.Base.pure_closure" {
     GHC.Base.pure_closure:
         const GHC.Base.pure_info;
 },
 GHC.Base.pure_entry() //  [R2]
         { info_tbl: [(caKO,
                       label: GHC.Base.pure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caKO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caKP; else goto caKQ;
       caKP: // global
           R2 = R2;
           R1 = GHC.Base.pure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caKQ: // global
           I64[Sp - 8] = block_caKL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaKU; else goto caKM;
       uaKU: // global
           call _caKL(R1) args: 0, res: 0, upd: 0;
       caKM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caKL() //  [R1]
         { info_tbl: [(caKL,
                       label: block_caKL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caKL: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.486007775 UTC

[section ""data" . GHC.Base.<*>_closure" {
     GHC.Base.<*>_closure:
         const GHC.Base.<*>_info;
 },
 GHC.Base.<*>_entry() //  [R2]
         { info_tbl: [(caL2,
                       label: GHC.Base.<*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caL2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caL3; else goto caL4;
       caL3: // global
           R2 = R2;
           R1 = GHC.Base.<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caL4: // global
           I64[Sp - 8] = block_caKZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaL8; else goto caL0;
       uaL8: // global
           call _caKZ(R1) args: 0, res: 0, upd: 0;
       caL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caKZ() //  [R1]
         { info_tbl: [(caKZ,
                       label: block_caKZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caKZ: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.487142249 UTC

[section ""data" . GHC.Base.liftA2_closure" {
     GHC.Base.liftA2_closure:
         const GHC.Base.liftA2_info;
 },
 GHC.Base.liftA2_entry() //  [R2]
         { info_tbl: [(caLg,
                       label: GHC.Base.liftA2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caLh; else goto caLi;
       caLh: // global
           R2 = R2;
           R1 = GHC.Base.liftA2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caLi: // global
           I64[Sp - 8] = block_caLd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaLm; else goto caLe;
       uaLm: // global
           call _caLd(R1) args: 0, res: 0, upd: 0;
       caLe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caLd() //  [R1]
         { info_tbl: [(caLd,
                       label: block_caLd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLd: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.488348364 UTC

[section ""data" . GHC.Base.*>_closure" {
     GHC.Base.*>_closure:
         const GHC.Base.*>_info;
 },
 GHC.Base.*>_entry() //  [R2]
         { info_tbl: [(caLu,
                       label: GHC.Base.*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caLv; else goto caLw;
       caLv: // global
           R2 = R2;
           R1 = GHC.Base.*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caLw: // global
           I64[Sp - 8] = block_caLr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaLA; else goto caLs;
       uaLA: // global
           call _caLr(R1) args: 0, res: 0, upd: 0;
       caLs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caLr() //  [R1]
         { info_tbl: [(caLr,
                       label: block_caLr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLr: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.489547046 UTC

[section ""data" . GHC.Base.<*_closure" {
     GHC.Base.<*_closure:
         const GHC.Base.<*_info;
 },
 GHC.Base.<*_entry() //  [R2]
         { info_tbl: [(caLI,
                       label: GHC.Base.<*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caLJ; else goto caLK;
       caLJ: // global
           R2 = R2;
           R1 = GHC.Base.<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caLK: // global
           I64[Sp - 8] = block_caLF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaLO; else goto caLG;
       uaLO: // global
           call _caLF(R1) args: 0, res: 0, upd: 0;
       caLG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caLF() //  [R1]
         { info_tbl: [(caLF,
                       label: block_caLF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLF: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.490657659 UTC

[section ""data" . GHC.Base.<>_closure" {
     GHC.Base.<>_closure:
         const GHC.Base.<>_info;
 },
 GHC.Base.<>_entry() //  [R2]
         { info_tbl: [(caLW,
                       label: GHC.Base.<>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caLX; else goto caLY;
       caLX: // global
           R2 = R2;
           R1 = GHC.Base.<>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caLY: // global
           I64[Sp - 8] = block_caLT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaM2; else goto caLU;
       uaM2: // global
           call _caLT(R1) args: 0, res: 0, upd: 0;
       caLU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caLT() //  [R1]
         { info_tbl: [(caLT,
                       label: block_caLT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caLT: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.491896232 UTC

[section ""data" . GHC.Base.sconcat_closure" {
     GHC.Base.sconcat_closure:
         const GHC.Base.sconcat_info;
 },
 GHC.Base.sconcat_entry() //  [R2]
         { info_tbl: [(caMa,
                       label: GHC.Base.sconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMb; else goto caMc;
       caMb: // global
           R2 = R2;
           R1 = GHC.Base.sconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMc: // global
           I64[Sp - 8] = block_caM7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMg; else goto caM8;
       uaMg: // global
           call _caM7(R1) args: 0, res: 0, upd: 0;
       caM8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caM7() //  [R1]
         { info_tbl: [(caM7,
                       label: block_caM7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caM7: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.493092648 UTC

[section ""data" . GHC.Base.stimes_closure" {
     GHC.Base.stimes_closure:
         const GHC.Base.stimes_info;
 },
 GHC.Base.stimes_entry() //  [R2]
         { info_tbl: [(caMo,
                       label: GHC.Base.stimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMp; else goto caMq;
       caMp: // global
           R2 = R2;
           R1 = GHC.Base.stimes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMq: // global
           I64[Sp - 8] = block_caMl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMu; else goto caMm;
       uaMu: // global
           call _caMl(R1) args: 0, res: 0, upd: 0;
       caMm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMl() //  [R1]
         { info_tbl: [(caMl,
                       label: block_caMl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMl: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.494878612 UTC

[section ""data" . GHC.Base.$p1Monoid_closure" {
     GHC.Base.$p1Monoid_closure:
         const GHC.Base.$p1Monoid_info;
 },
 GHC.Base.$p1Monoid_entry() //  [R2]
         { info_tbl: [(caMC,
                       label: GHC.Base.$p1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMD; else goto caME;
       caMD: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caME: // global
           I64[Sp - 8] = block_caMz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMI; else goto caMA;
       uaMI: // global
           call _caMz(R1) args: 0, res: 0, upd: 0;
       caMA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMz() //  [R1]
         { info_tbl: [(caMz,
                       label: block_caMz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMz: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.496013129 UTC

[section ""data" . GHC.Base.mempty_closure" {
     GHC.Base.mempty_closure:
         const GHC.Base.mempty_info;
 },
 GHC.Base.mempty_entry() //  [R2]
         { info_tbl: [(caMQ,
                       label: GHC.Base.mempty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caMR; else goto caMS;
       caMR: // global
           R2 = R2;
           R1 = GHC.Base.mempty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caMS: // global
           I64[Sp - 8] = block_caMN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaMW; else goto caMO;
       uaMW: // global
           call _caMN(R1) args: 0, res: 0, upd: 0;
       caMO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caMN() //  [R1]
         { info_tbl: [(caMN,
                       label: block_caMN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caMN: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.497145742 UTC

[section ""data" . GHC.Base.mappend_closure" {
     GHC.Base.mappend_closure:
         const GHC.Base.mappend_info;
 },
 GHC.Base.mappend_entry() //  [R2]
         { info_tbl: [(caN4,
                       label: GHC.Base.mappend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caN5; else goto caN6;
       caN5: // global
           R2 = R2;
           R1 = GHC.Base.mappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caN6: // global
           I64[Sp - 8] = block_caN1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNa; else goto caN2;
       uaNa: // global
           call _caN1(R1) args: 0, res: 0, upd: 0;
       caN2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caN1() //  [R1]
         { info_tbl: [(caN1,
                       label: block_caN1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caN1: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.49831545 UTC

[section ""data" . GHC.Base.mconcat_closure" {
     GHC.Base.mconcat_closure:
         const GHC.Base.mconcat_info;
 },
 GHC.Base.mconcat_entry() //  [R2]
         { info_tbl: [(caNi,
                       label: GHC.Base.mconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNj; else goto caNk;
       caNj: // global
           R2 = R2;
           R1 = GHC.Base.mconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNk: // global
           I64[Sp - 8] = block_caNf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNo; else goto caNg;
       uaNo: // global
           call _caNf(R1) args: 0, res: 0, upd: 0;
       caNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNf() //  [R1]
         { info_tbl: [(caNf,
                       label: block_caNf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNf: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.499442001 UTC

[section ""data" . GHC.Base.$p1MonadPlus_closure" {
     GHC.Base.$p1MonadPlus_closure:
         const GHC.Base.$p1MonadPlus_info;
 },
 GHC.Base.$p1MonadPlus_entry() //  [R2]
         { info_tbl: [(caNw,
                       label: GHC.Base.$p1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNx; else goto caNy;
       caNx: // global
           R2 = R2;
           R1 = GHC.Base.$p1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNy: // global
           I64[Sp - 8] = block_caNt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNC; else goto caNu;
       uaNC: // global
           call _caNt(R1) args: 0, res: 0, upd: 0;
       caNu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNt() //  [R1]
         { info_tbl: [(caNt,
                       label: block_caNt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNt: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.500592142 UTC

[section ""data" . GHC.Base.$p2MonadPlus_closure" {
     GHC.Base.$p2MonadPlus_closure:
         const GHC.Base.$p2MonadPlus_info;
 },
 GHC.Base.$p2MonadPlus_entry() //  [R2]
         { info_tbl: [(caNK,
                       label: GHC.Base.$p2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNL; else goto caNM;
       caNL: // global
           R2 = R2;
           R1 = GHC.Base.$p2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNM: // global
           I64[Sp - 8] = block_caNH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaNQ; else goto caNI;
       uaNQ: // global
           call _caNH(R1) args: 0, res: 0, upd: 0;
       caNI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNH() //  [R1]
         { info_tbl: [(caNH,
                       label: block_caNH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNH: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.501801876 UTC

[section ""data" . GHC.Base.mzero_closure" {
     GHC.Base.mzero_closure:
         const GHC.Base.mzero_info;
 },
 GHC.Base.mzero_entry() //  [R2]
         { info_tbl: [(caNY,
                       label: GHC.Base.mzero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caNZ; else goto caO0;
       caNZ: // global
           R2 = R2;
           R1 = GHC.Base.mzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caO0: // global
           I64[Sp - 8] = block_caNV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaO4; else goto caNW;
       uaO4: // global
           call _caNV(R1) args: 0, res: 0, upd: 0;
       caNW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caNV() //  [R1]
         { info_tbl: [(caNV,
                       label: block_caNV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caNV: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.502988922 UTC

[section ""data" . GHC.Base.mplus_closure" {
     GHC.Base.mplus_closure:
         const GHC.Base.mplus_info;
 },
 GHC.Base.mplus_entry() //  [R2]
         { info_tbl: [(caOc,
                       label: GHC.Base.mplus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOd; else goto caOe;
       caOd: // global
           R2 = R2;
           R1 = GHC.Base.mplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOe: // global
           I64[Sp - 8] = block_caO9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOi; else goto caOa;
       uaOi: // global
           call _caO9(R1) args: 0, res: 0, upd: 0;
       caOa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caO9() //  [R1]
         { info_tbl: [(caO9,
                       label: block_caO9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caO9: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.504234456 UTC

[section ""data" . GHC.Base.$p1Alternative_closure" {
     GHC.Base.$p1Alternative_closure:
         const GHC.Base.$p1Alternative_info;
 },
 GHC.Base.$p1Alternative_entry() //  [R2]
         { info_tbl: [(caOq,
                       label: GHC.Base.$p1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOr; else goto caOs;
       caOr: // global
           R2 = R2;
           R1 = GHC.Base.$p1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOs: // global
           I64[Sp - 8] = block_caOn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOw; else goto caOo;
       uaOw: // global
           call _caOn(R1) args: 0, res: 0, upd: 0;
       caOo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOn() //  [R1]
         { info_tbl: [(caOn,
                       label: block_caOn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOn: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.505707683 UTC

[section ""data" . GHC.Base.empty_closure" {
     GHC.Base.empty_closure:
         const GHC.Base.empty_info;
 },
 GHC.Base.empty_entry() //  [R2]
         { info_tbl: [(caOE,
                       label: GHC.Base.empty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOF; else goto caOG;
       caOF: // global
           R2 = R2;
           R1 = GHC.Base.empty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOG: // global
           I64[Sp - 8] = block_caOB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOK; else goto caOC;
       uaOK: // global
           call _caOB(R1) args: 0, res: 0, upd: 0;
       caOC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOB() //  [R1]
         { info_tbl: [(caOB,
                       label: block_caOB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOB: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.506850439 UTC

[section ""data" . GHC.Base.<|>_closure" {
     GHC.Base.<|>_closure:
         const GHC.Base.<|>_info;
 },
 GHC.Base.<|>_entry() //  [R2]
         { info_tbl: [(caOS,
                       label: GHC.Base.<|>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caOT; else goto caOU;
       caOT: // global
           R2 = R2;
           R1 = GHC.Base.<|>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOU: // global
           I64[Sp - 8] = block_caOP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaOY; else goto caOQ;
       uaOY: // global
           call _caOP(R1) args: 0, res: 0, upd: 0;
       caOQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caOP() //  [R1]
         { info_tbl: [(caOP,
                       label: block_caOP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caOP: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.507987582 UTC

[section ""data" . GHC.Base.some_closure" {
     GHC.Base.some_closure:
         const GHC.Base.some_info;
 },
 GHC.Base.some_entry() //  [R2]
         { info_tbl: [(caP6,
                       label: GHC.Base.some_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caP7; else goto caP8;
       caP7: // global
           R2 = R2;
           R1 = GHC.Base.some_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caP8: // global
           I64[Sp - 8] = block_caP3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPc; else goto caP4;
       uaPc: // global
           call _caP3(R1) args: 0, res: 0, upd: 0;
       caP4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caP3() //  [R1]
         { info_tbl: [(caP3,
                       label: block_caP3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caP3: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.509207975 UTC

[section ""data" . GHC.Base.many_closure" {
     GHC.Base.many_closure:
         const GHC.Base.many_info;
 },
 GHC.Base.many_entry() //  [R2]
         { info_tbl: [(caPk,
                       label: GHC.Base.many_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caPl; else goto caPm;
       caPl: // global
           R2 = R2;
           R1 = GHC.Base.many_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPm: // global
           I64[Sp - 8] = block_caPh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaPq; else goto caPi;
       uaPq: // global
           call _caPh(R1) args: 0, res: 0, upd: 0;
       caPi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPh() //  [R1]
         { info_tbl: [(caPh,
                       label: block_caPh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPh: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.511086332 UTC

[section ""data" . GHC.Base.eqString_closure" {
     GHC.Base.eqString_closure:
         const GHC.Base.eqString_info;
 },
 GHC.Base.eqString_entry() //  [R2, R3]
         { info_tbl: [(caPC,
                       label: GHC.Base.eqString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caPD; else goto uaQs;
       caPD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.eqString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uaQs: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _caPs() args: 0, res: 0, upd: 0;
     }
 },
 _caPs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPs: // global
           _s7SQ::P64 = P64[Sp];
           I64[Sp] = block_caPv_info;
           R1 = _s7SQ::P64;
           if (R1 & 7 != 0) goto uaQx; else goto caPw;
       uaQx: // global
           call _caPv(R1) args: 0, res: 0, upd: 0;
       caPw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPv() //  [R1]
         { info_tbl: [(caPv,
                       label: block_caPv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPv: // global
           _s7SR::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto caPz; else goto caPA;
       caPz: // global
           I64[Sp + 8] = block_caPH_info;
           R1 = _s7SR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uaQy; else goto caPJ;
       uaQy: // global
           call _caPH(R1) args: 0, res: 0, upd: 0;
       caPJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caPA: // global
           I64[Sp - 8] = block_caPW_info;
           _s7SW::P64 = P64[R1 + 6];
           _s7SX::P64 = P64[R1 + 14];
           R1 = _s7SR::P64;
           P64[Sp] = _s7SX::P64;
           P64[Sp + 8] = _s7SW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQz; else goto caPY;
       uaQz: // global
           call _caPW(R1) args: 0, res: 0, upd: 0;
       caPY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caPH() //  [R1]
         { info_tbl: [(caPH,
                       label: block_caPH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPH: // global
           if (R1 & 7 == 1) goto caPP; else goto uaQw;
       caPP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uaQw: // global
           Sp = Sp + 8;
           call _caQo() args: 0, res: 0, upd: 0;
     }
 },
 _caPW() //  [R1]
         { info_tbl: [(caPW,
                       label: block_caPW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caPW: // global
           if (R1 & 7 == 1) goto uaQt; else goto caQe;
       uaQt: // global
           Sp = Sp + 24;
           call _caQo() args: 0, res: 0, upd: 0;
       caQe: // global
           I64[Sp - 8] = block_caQ7_info;
           _s7SZ::P64 = P64[R1 + 6];
           _s7T0::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _s7T0::P64;
           P64[Sp + 16] = _s7SZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaQC; else goto caQ8;
       uaQC: // global
           call _caQ7(R1) args: 0, res: 0, upd: 0;
       caQ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQ7() //  [R1]
         { info_tbl: [(caQ7,
                       label: block_caQ7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQ7: // global
           I64[Sp] = block_caQc_info;
           _s7T2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7T2::I64;
           if (R1 & 7 != 0) goto uaQE; else goto caQg;
       uaQE: // global
           call _caQc(R1) args: 0, res: 0, upd: 0;
       caQg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQc() //  [R1]
         { info_tbl: [(caQc,
                       label: block_caQc_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQc: // global
           if (I64[Sp + 24] == I64[R1 + 7]) goto caQp; else goto uaQu;
       caQp: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _caPs() args: 0, res: 0, upd: 0;
       uaQu: // global
           Sp = Sp + 32;
           call _caQo() args: 0, res: 0, upd: 0;
     }
 },
 _caQo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQo: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.514357629 UTC

[section ""data" . GHC.Base.when2_closure" {
     GHC.Base.when2_closure:
         const GHC.Base.when2_info;
 },
 GHC.Base.when2_entry() //  [R2, R3]
         { info_tbl: [(caQS,
                       label: GHC.Base.when2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caQT; else goto caQU;
       caQT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caQU: // global
           I64[Sp - 16] = block_caQL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaR1; else goto caQM;
       uaR1: // global
           call _caQL(R1) args: 0, res: 0, upd: 0;
       caQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caQL() //  [R1]
         { info_tbl: [(caQL,
                       label: block_caQL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caQL: // global
           if (R1 & 7 == 1) goto caQP; else goto caQQ;
       caQP: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caQQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.515513904 UTC

[section ""data" . GHC.Base.when_$swhen1_closure" {
     GHC.Base.when_$swhen1_closure:
         const GHC.Base.when_$swhen1_info;
 },
 GHC.Base.when_$swhen1_entry() //  [R2, R3]
         { info_tbl: [(caR6,
                       label: GHC.Base.when_$swhen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caR6: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.when2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.516480112 UTC

[section ""data" . GHC.Base.$fFunctorIO2_closure" {
     GHC.Base.$fFunctorIO2_closure:
         const GHC.Base.$fFunctorIO2_info;
 },
 GHC.Base.$fFunctorIO2_entry() //  [R2, R3]
         { info_tbl: [(caRg,
                       label: GHC.Base.$fFunctorIO2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRh; else goto caRi;
       caRh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caRi: // global
           I64[Sp - 16] = block_caRd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRd() //  [R1]
         { info_tbl: [(caRd,
                       label: block_caRd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto caRl; else goto caRk;
       caRl: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caRk: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.517719238 UTC

[section ""data" . GHC.Base.$fFunctorIO1_closure" {
     GHC.Base.$fFunctorIO1_closure:
         const GHC.Base.$fFunctorIO1_info;
 },
 GHC.Base.$fFunctorIO1_entry() //  [R2, R3]
         { info_tbl: [(caRs,
                       label: GHC.Base.$fFunctorIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caRt; else goto caRu;
       caRt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caRu: // global
           I64[Sp - 16] = block_caRq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caRq() //  []
         { info_tbl: [(caRq,
                       label: block_caRq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.518657033 UTC

[section ""data" . GHC.Base.$fFunctorIO_closure" {
     GHC.Base.$fFunctorIO_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorIO2_closure+3;
         const GHC.Base.$fFunctorIO1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.519242199 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe1_closure" {
     GHC.Base.$fAlternativeMaybe1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.520522541 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$cmany_closure" {
     GHC.Base.$fAlternativeMaybe_$cmany_closure:
         const GHC.Base.$fAlternativeMaybe_$cmany_info;
 },
 many_v_s7To_entry() //  [R1]
         { info_tbl: [(caRL,
                       label: many_v_s7To_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caRM; else goto caRN;
       caRM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caRE_info;
           _s7To::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s7To::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaSf; else goto caRF;
       uaSf: // global
           call _caRE(R1) args: 0, res: 0, upd: 0;
       caRF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caRE() //  [R1]
         { info_tbl: [(caRE,
                       label: block_caRE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRE: // global
           if (R1 & 7 == 1) goto uaSb; else goto caRJ;
       uaSb: // global
           Sp = Sp + 16;
           call _caS1() args: 0, res: 0, upd: 0;
       caRJ: // global
           I64[Sp] = block_caRT_info;
           _s7Tq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Tq::P64;
           if (R1 & 7 != 0) goto uaSd; else goto caRV;
       uaSd: // global
           call _caRT(R1) args: 0, res: 0, upd: 0;
       caRV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caRT() //  [R1]
         { info_tbl: [(caRT,
                       label: block_caRT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caRT: // global
           if (R1 & 7 == 1) goto uaSc; else goto caS6;
       uaSc: // global
           Sp = Sp + 16;
           call _caS1() args: 0, res: 0, upd: 0;
       caS6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caS9; else goto caS8;
       caS9: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caS8: // global
           _s7Ts::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7Ts::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _caS1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caS1: // global
           R1 = GHC.Base.$fAlternativeMaybe1_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$cmany_entry() //  [R2]
         { info_tbl: [(caSh,
                       label: GHC.Base.$fAlternativeMaybe_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caSl; else goto caSk;
       caSl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caSk: // global
           I64[Hp - 16] = many_v_s7To_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.523015091 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$csome_closure" {
     GHC.Base.$fAlternativeMaybe_$csome_closure:
         const GHC.Base.$fAlternativeMaybe_$csome_info;
 },
 some_v_s7Tv_entry() //  [R1]
         { info_tbl: [(caSB,
                       label: some_v_s7Tv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caSC; else goto caSD;
       caSC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caSD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_caSu_info;
           _s7Tv::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s7Tv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaT6; else goto caSv;
       uaT6: // global
           call _caSu(R1) args: 0, res: 0, upd: 0;
       caSv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caSu() //  [R1]
         { info_tbl: [(caSu,
                       label: block_caSu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSu: // global
           if (R1 & 7 == 1) goto caSy; else goto caSz;
       caSy: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caSz: // global
           I64[Sp] = block_caSJ_info;
           _s7Tx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Tx::P64;
           if (R1 & 7 != 0) goto uaT5; else goto caSL;
       uaT5: // global
           call _caSJ(R1) args: 0, res: 0, upd: 0;
       caSL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _caSJ() //  [R1]
         { info_tbl: [(caSJ,
                       label: block_caSJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caSJ: // global
           _s7Tx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto caSS; else goto caT0;
       caSS: // global
           Hp = Hp + 40;
           _s7Ty::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caT3; else goto caSU;
       caSU: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _s7Tx::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       caT0: // global
           Hp = Hp + 40;
           _s7Ty::P64 = R1;
           if (Hp > HpLim) (likely: False) goto caT3; else goto caT2;
       caT3: // global
           HpAlloc = 40;
           R1 = _s7Ty::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       caT2: // global
           _s7TA::P64 = P64[_s7Ty::P64 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _s7Tx::P64;
           P64[Hp - 16] = _s7TA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$csome_entry() //  [R2]
         { info_tbl: [(caT7,
                       label: GHC.Base.$fAlternativeMaybe_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caT7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTb; else goto caTa;
       caTb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTa: // global
           I64[Hp - 16] = some_v_s7Tv_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.525417427 UTC

[section ""data" . GHC.Base.ap_$sap_closure" {
     GHC.Base.ap_$sap_closure:
         const GHC.Base.ap_$sap_info;
 },
 GHC.Base.ap_$sap_entry() //  [R2, R3]
         { info_tbl: [(caTn,
                       label: GHC.Base.ap_$sap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTo; else goto caTp;
       caTo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap_$sap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caTp: // global
           I64[Sp - 16] = block_caTg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaTR; else goto caTh;
       uaTR: // global
           call _caTg(R1) args: 0, res: 0, upd: 0;
       caTh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTg() //  [R1]
         { info_tbl: [(caTg,
                       label: block_caTg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTg: // global
           if (R1 & 7 == 1) goto uaTN; else goto caTl;
       uaTN: // global
           Sp = Sp + 16;
           call _caTD() args: 0, res: 0, upd: 0;
       caTl: // global
           I64[Sp] = block_caTv_info;
           _s7TF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7TF::P64;
           if (R1 & 7 != 0) goto uaTP; else goto caTx;
       uaTP: // global
           call _caTv(R1) args: 0, res: 0, upd: 0;
       caTx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTv() //  [R1]
         { info_tbl: [(caTv,
                       label: block_caTv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTv: // global
           if (R1 & 7 == 1) goto uaTO; else goto caTI;
       uaTO: // global
           Sp = Sp + 16;
           call _caTD() args: 0, res: 0, upd: 0;
       caTI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caTL; else goto caTK;
       caTL: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTK: // global
           _s7TH::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7TH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caTD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTD: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.527853424 UTC

[section ""data" . GHC.Base.liftM5_$sliftM5_closure" {
     GHC.Base.liftM5_$sliftM5_closure:
         const GHC.Base.liftM5_$sliftM5_info;
 },
 GHC.Base.liftM5_$sliftM5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caU4,
                       label: GHC.Base.liftM5_$sliftM5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caU5; else goto caU6;
       caU5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM5_$sliftM5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       caU6: // global
           I64[Sp - 40] = block_caTX_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaVe; else goto caTY;
       uaVe: // global
           call _caTX(R1) args: 0, res: 0, upd: 0;
       caTY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTX() //  [R1]
         { info_tbl: [(caTX,
                       label: block_caTX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTX: // global
           if (R1 & 7 == 1) goto uaV7; else goto caU2;
       uaV7: // global
           Sp = Sp + 48;
           call _caUU() args: 0, res: 0, upd: 0;
       caU2: // global
           I64[Sp] = block_caUc_info;
           _s7TQ::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7TQ::P64;
           if (R1 & 7 != 0) goto uaVc; else goto caUe;
       uaVc: // global
           call _caUc(R1) args: 0, res: 0, upd: 0;
       caUe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caUc() //  [R1]
         { info_tbl: [(caUc,
                       label: block_caUc_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caUc: // global
           if (R1 & 7 == 1) goto uaV8; else goto caUp;
       uaV8: // global
           Sp = Sp + 48;
           call _caUU() args: 0, res: 0, upd: 0;
       caUp: // global
           I64[Sp] = block_caUn_info;
           _s7TS::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7TS::P64;
           if (R1 & 7 != 0) goto uaVf; else goto caUq;
       uaVf: // global
           call _caUn(R1) args: 0, res: 0, upd: 0;
       caUq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caUn() //  [R1]
         { info_tbl: [(caUn,
                       label: block_caUn_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caUn: // global
           if (R1 & 7 == 1) goto uaV9; else goto caUB;
       uaV9: // global
           Sp = Sp + 48;
           call _caUU() args: 0, res: 0, upd: 0;
       caUB: // global
           I64[Sp] = block_caUz_info;
           _s7TU::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7TU::P64;
           if (R1 & 7 != 0) goto uaVh; else goto caUC;
       uaVh: // global
           call _caUz(R1) args: 0, res: 0, upd: 0;
       caUC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caUz() //  [R1]
         { info_tbl: [(caUz,
                       label: block_caUz_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caUz: // global
           if (R1 & 7 == 1) goto uaVa; else goto caUN;
       uaVa: // global
           Sp = Sp + 48;
           call _caUU() args: 0, res: 0, upd: 0;
       caUN: // global
           I64[Sp] = block_caUL_info;
           _s7TW::P64 = P64[R1 + 6];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s7TW::P64;
           if (R1 & 7 != 0) goto uaVj; else goto caUO;
       uaVj: // global
           call _caUL(R1) args: 0, res: 0, upd: 0;
       caUO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caUL() //  [R1]
         { info_tbl: [(caUL,
                       label: block_caUL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caUL: // global
           if (R1 & 7 == 1) goto uaVb; else goto caUZ;
       uaVb: // global
           Sp = Sp + 48;
           call _caUU() args: 0, res: 0, upd: 0;
       caUZ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto caV2; else goto caV1;
       caV2: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caV1: // global
           _s7TY::P64 = P64[R1 + 6];
           I64[Hp - 72] = stg_ap_6_upd_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = _s7TY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 72;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caUU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caUU: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.532152298 UTC

[section ""data" . GHC.Base.liftM4_$sliftM4_closure" {
     GHC.Base.liftM4_$sliftM4_closure:
         const GHC.Base.liftM4_$sliftM4_info;
 },
 GHC.Base.liftM4_$sliftM4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(caVx,
                       label: GHC.Base.liftM4_$sliftM4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caVx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto caVy; else goto caVz;
       caVy: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM4_$sliftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caVz: // global
           I64[Sp - 40] = block_caVq_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uaWt; else goto caVr;
       uaWt: // global
           call _caVq(R1) args: 0, res: 0, upd: 0;
       caVr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caVq() //  [R1]
         { info_tbl: [(caVq,
                       label: block_caVq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caVq: // global
           if (R1 & 7 == 1) goto uaWn; else goto caVv;
       uaWn: // global
           Sp = Sp + 40;
           call _caWb() args: 0, res: 0, upd: 0;
       caVv: // global
           I64[Sp] = block_caVF_info;
           _s7U6::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7U6::P64;
           if (R1 & 7 != 0) goto uaWr; else goto caVH;
       uaWr: // global
           call _caVF(R1) args: 0, res: 0, upd: 0;
       caVH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caVF() //  [R1]
         { info_tbl: [(caVF,
                       label: block_caVF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caVF: // global
           if (R1 & 7 == 1) goto uaWo; else goto caVS;
       uaWo: // global
           Sp = Sp + 40;
           call _caWb() args: 0, res: 0, upd: 0;
       caVS: // global
           I64[Sp] = block_caVQ_info;
           _s7U8::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7U8::P64;
           if (R1 & 7 != 0) goto uaWu; else goto caVT;
       uaWu: // global
           call _caVQ(R1) args: 0, res: 0, upd: 0;
       caVT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caVQ() //  [R1]
         { info_tbl: [(caVQ,
                       label: block_caVQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caVQ: // global
           if (R1 & 7 == 1) goto uaWp; else goto caW4;
       uaWp: // global
           Sp = Sp + 40;
           call _caWb() args: 0, res: 0, upd: 0;
       caW4: // global
           I64[Sp] = block_caW2_info;
           _s7Ua::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Ua::P64;
           if (R1 & 7 != 0) goto uaWw; else goto caW5;
       uaWw: // global
           call _caW2(R1) args: 0, res: 0, upd: 0;
       caW5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caW2() //  [R1]
         { info_tbl: [(caW2,
                       label: block_caW2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caW2: // global
           if (R1 & 7 == 1) goto uaWq; else goto caWg;
       uaWq: // global
           Sp = Sp + 40;
           call _caWb() args: 0, res: 0, upd: 0;
       caWg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto caWj; else goto caWi;
       caWj: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caWi: // global
           _s7Uc::P64 = P64[R1 + 6];
           I64[Hp - 64] = stg_ap_5_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = _s7Uc::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caWb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caWb: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.534971916 UTC

[section ""data" . GHC.Base.liftM3_$sliftM3_closure" {
     GHC.Base.liftM3_$sliftM3_closure:
         const GHC.Base.liftM3_$sliftM3_info;
 },
 GHC.Base.liftM3_$sliftM3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(caWK,
                       label: GHC.Base.liftM3_$sliftM3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caWK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caWL; else goto caWM;
       caWL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM3_$sliftM3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caWM: // global
           I64[Sp - 32] = block_caWD_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uaXs; else goto caWE;
       uaXs: // global
           call _caWD(R1) args: 0, res: 0, upd: 0;
       caWE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caWD() //  [R1]
         { info_tbl: [(caWD,
                       label: block_caWD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caWD: // global
           if (R1 & 7 == 1) goto uaXn; else goto caWI;
       uaXn: // global
           Sp = Sp + 32;
           call _caXc() args: 0, res: 0, upd: 0;
       caWI: // global
           I64[Sp] = block_caWS_info;
           _s7Uj::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Uj::P64;
           if (R1 & 7 != 0) goto uaXq; else goto caWU;
       uaXq: // global
           call _caWS(R1) args: 0, res: 0, upd: 0;
       caWU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caWS() //  [R1]
         { info_tbl: [(caWS,
                       label: block_caWS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caWS: // global
           if (R1 & 7 == 1) goto uaXo; else goto caX5;
       uaXo: // global
           Sp = Sp + 32;
           call _caXc() args: 0, res: 0, upd: 0;
       caX5: // global
           I64[Sp] = block_caX3_info;
           _s7Ul::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Ul::P64;
           if (R1 & 7 != 0) goto uaXt; else goto caX6;
       uaXt: // global
           call _caX3(R1) args: 0, res: 0, upd: 0;
       caX6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caX3() //  [R1]
         { info_tbl: [(caX3,
                       label: block_caX3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caX3: // global
           if (R1 & 7 == 1) goto uaXp; else goto caXh;
       uaXp: // global
           Sp = Sp + 32;
           call _caXc() args: 0, res: 0, upd: 0;
       caXh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caXk; else goto caXj;
       caXk: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caXj: // global
           _s7Un::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s7Un::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caXc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXc: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.537342363 UTC

[section ""data" . GHC.Base.liftM2_$sliftM2_closure" {
     GHC.Base.liftM2_$sliftM2_closure:
         const GHC.Base.liftM2_$sliftM2_info;
 },
 GHC.Base.liftM2_$sliftM2_entry() //  [R2, R3, R4]
         { info_tbl: [(caXH,
                       label: GHC.Base.liftM2_$sliftM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caXI; else goto caXJ;
       caXI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM2_$sliftM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caXJ: // global
           I64[Sp - 24] = block_caXA_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaYb; else goto caXB;
       uaYb: // global
           call _caXA(R1) args: 0, res: 0, upd: 0;
       caXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXA() //  [R1]
         { info_tbl: [(caXA,
                       label: block_caXA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXA: // global
           if (R1 & 7 == 1) goto uaY7; else goto caXF;
       uaY7: // global
           Sp = Sp + 24;
           call _caXX() args: 0, res: 0, upd: 0;
       caXF: // global
           I64[Sp] = block_caXP_info;
           _s7Ut::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Ut::P64;
           if (R1 & 7 != 0) goto uaY9; else goto caXR;
       uaY9: // global
           call _caXP(R1) args: 0, res: 0, upd: 0;
       caXR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caXP() //  [R1]
         { info_tbl: [(caXP,
                       label: block_caXP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXP: // global
           if (R1 & 7 == 1) goto uaY8; else goto caY2;
       uaY8: // global
           Sp = Sp + 24;
           call _caXX() args: 0, res: 0, upd: 0;
       caY2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caY5; else goto caY4;
       caY5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caY4: // global
           _s7Uv::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _s7Uv::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caXX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caXX: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.539208305 UTC

[section ""data" . GHC.Base.liftM_$sliftM_closure" {
     GHC.Base.liftM_$sliftM_closure:
         const GHC.Base.liftM_$sliftM_info;
 },
 GHC.Base.liftM_$sliftM_entry() //  [R2, R3]
         { info_tbl: [(caYo,
                       label: GHC.Base.liftM_$sliftM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYp; else goto caYq;
       caYp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM_$sliftM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYq: // global
           I64[Sp - 16] = block_caYh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYB; else goto caYi;
       uaYB: // global
           call _caYh(R1) args: 0, res: 0, upd: 0;
       caYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYh() //  [R1]
         { info_tbl: [(caYh,
                       label: block_caYh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYh: // global
           if (R1 & 7 == 1) goto caYl; else goto caYm;
       caYl: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto caYA; else goto caYz;
       caYA: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caYz: // global
           _s7UA::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7UA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.540376157 UTC

[section ""data" . GHC.Base.when1_closure" {
     GHC.Base.when1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.541292648 UTC

[section ""data" . GHC.Base.when_$swhen_closure" {
     GHC.Base.when_$swhen_closure:
         const GHC.Base.when_$swhen_info;
 },
 GHC.Base.when_$swhen_entry() //  [R2, R3]
         { info_tbl: [(caYN,
                       label: GHC.Base.when_$swhen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caYO; else goto caYP;
       caYO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_$swhen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYP: // global
           I64[Sp - 16] = block_caYG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaYW; else goto caYH;
       uaYW: // global
           call _caYG(R1) args: 0, res: 0, upd: 0;
       caYH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caYG() //  [R1]
         { info_tbl: [(caYG,
                       label: block_caYG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caYG: // global
           if (R1 & 7 == 1) goto caYK; else goto caYL;
       caYK: // global
           R1 = GHC.Base.when1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       caYL: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.542595797 UTC

[section ""data" . GHC.Base.when_closure" {
     GHC.Base.when_closure:
         const GHC.Base.when_info;
 },
 GHC.Base.when_entry() //  [R2, R3, R4]
         { info_tbl: [(caZ8,
                       label: GHC.Base.when_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caZ9; else goto caZa;
       caZ9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZa: // global
           I64[Sp - 24] = block_caZ1_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uaZh; else goto caZ2;
       uaZh: // global
           call _caZ1(R1) args: 0, res: 0, upd: 0;
       caZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZ1() //  [R1]
         { info_tbl: [(caZ1,
                       label: block_caZ1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZ1: // global
           if (R1 & 7 == 1) goto caZ5; else goto caZ6;
       caZ5: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       caZ6: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.544153213 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*_entry() //  [R2, R3]
         { info_tbl: [(caZt,
                       label: GHC.Base.$fApplicativeMaybe_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caZu; else goto caZv;
       caZu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caZv: // global
           I64[Sp - 16] = block_caZm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaZT; else goto caZn;
       uaZT: // global
           call _caZm(R1) args: 0, res: 0, upd: 0;
       caZn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZm() //  [R1]
         { info_tbl: [(caZm,
                       label: block_caZm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZm: // global
           if (R1 & 7 == 1) goto uaZP; else goto caZr;
       uaZP: // global
           Sp = Sp + 16;
           call _caZJ() args: 0, res: 0, upd: 0;
       caZr: // global
           I64[Sp] = block_caZB_info;
           _s7UL::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7UL::P64;
           if (R1 & 7 != 0) goto uaZR; else goto caZD;
       uaZR: // global
           call _caZB(R1) args: 0, res: 0, upd: 0;
       caZD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZB() //  [R1]
         { info_tbl: [(caZB,
                       label: block_caZB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZB: // global
           if (R1 & 7 == 1) goto uaZQ; else goto caZN;
       uaZQ: // global
           Sp = Sp + 16;
           call _caZJ() args: 0, res: 0, upd: 0;
       caZN: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _caZJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZJ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.545747513 UTC

[section ""cstring" . GHC.Base.$tc'O3_bytes" {
     GHC.Base.$tc'O3_bytes:
         I8[] [39,79]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.546281157 UTC

[section ""data" . GHC.Base.$tc'O2_closure" {
     GHC.Base.$tc'O2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'O3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.546836197 UTC

[section ""cstring" . GHC.Base.$tcOpaque2_bytes" {
     GHC.Base.$tcOpaque2_bytes:
         I8[] [79,112,97,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.547398052 UTC

[section ""data" . GHC.Base.$tcOpaque1_closure" {
     GHC.Base.$tcOpaque1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcOpaque2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.548743817 UTC

[section ""cstring" . GHC.Base.$tcMonadPlus2_bytes" {
     GHC.Base.$tcMonadPlus2_bytes:
         I8[] [77,111,110,97,100,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.549374463 UTC

[section ""data" . GHC.Base.$tcMonadPlus1_closure" {
     GHC.Base.$tcMonadPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonadPlus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.549946027 UTC

[section ""cstring" . GHC.Base.$tcMonad2_bytes" {
     GHC.Base.$tcMonad2_bytes:
         I8[] [77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.550491019 UTC

[section ""data" . GHC.Base.$tcMonad1_closure" {
     GHC.Base.$tcMonad1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonad2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.551048647 UTC

[section ""cstring" . GHC.Base.$tc'C:Monoid3_bytes" {
     GHC.Base.$tc'C:Monoid3_bytes:
         I8[] [39,67,58,77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.551596308 UTC

[section ""data" . GHC.Base.$tc'C:Monoid2_closure" {
     GHC.Base.$tc'C:Monoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'C:Monoid3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.552128121 UTC

[section ""cstring" . GHC.Base.$tcMonoid3_bytes" {
     GHC.Base.$tcMonoid3_bytes:
         I8[] [77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.552694955 UTC

[section ""data" . GHC.Base.$tcMonoid2_closure" {
     GHC.Base.$tcMonoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonoid3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.553233007 UTC

[section ""cstring" . GHC.Base.$tcSemigroup2_bytes" {
     GHC.Base.$tcSemigroup2_bytes:
         I8[] [83,101,109,105,103,114,111,117,112]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.554147056 UTC

[section ""data" . GHC.Base.$tcSemigroup1_closure" {
     GHC.Base.$tcSemigroup1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcSemigroup2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.554674811 UTC

[section ""cstring" . GHC.Base.$tc':|3_bytes" {
     GHC.Base.$tc':|3_bytes:
         I8[] [39,58,124]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.555239487 UTC

[section ""data" . GHC.Base.$tc':|2_closure" {
     GHC.Base.$tc':|2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc':|3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.555791226 UTC

[section ""cstring" . GHC.Base.$tcNonEmpty2_bytes" {
     GHC.Base.$tcNonEmpty2_bytes:
         I8[] [78,111,110,69,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.556331239 UTC

[section ""data" . GHC.Base.$tcNonEmpty1_closure" {
     GHC.Base.$tcNonEmpty1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcNonEmpty2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.556877849 UTC

[section ""cstring" . GHC.Base.$tcAlternative3_bytes" {
     GHC.Base.$tcAlternative3_bytes:
         I8[] [65,108,116,101,114,110,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.557572061 UTC

[section ""data" . GHC.Base.$tcAlternative2_closure" {
     GHC.Base.$tcAlternative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcAlternative3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.55814259 UTC

[section ""cstring" . GHC.Base.$tcApplicative2_bytes" {
     GHC.Base.$tcApplicative2_bytes:
         I8[] [65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.558693461 UTC

[section ""data" . GHC.Base.$tcApplicative1_closure" {
     GHC.Base.$tcApplicative1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcApplicative2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.559293653 UTC

[section ""cstring" . GHC.Base.$tcFunctor2_bytes" {
     GHC.Base.$tcFunctor2_bytes:
         I8[] [70,117,110,99,116,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.559846717 UTC

[section ""data" . GHC.Base.$tcFunctor1_closure" {
     GHC.Base.$tcFunctor1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcFunctor2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.560421796 UTC

[section ""cstring" . GHC.Base.$tc'Just3_bytes" {
     GHC.Base.$tc'Just3_bytes:
         I8[] [39,74,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.560997255 UTC

[section ""data" . GHC.Base.$tc'Just2_closure" {
     GHC.Base.$tc'Just2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Just3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.561629897 UTC

[section ""cstring" . GHC.Base.$tc'Nothing3_bytes" {
     GHC.Base.$tc'Nothing3_bytes:
         I8[] [39,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.562212921 UTC

[section ""data" . GHC.Base.$tc'Nothing2_closure" {
     GHC.Base.$tc'Nothing2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Nothing3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.5633841 UTC

[section ""cstring" . GHC.Base.$tcMaybe2_bytes" {
     GHC.Base.$tcMaybe2_bytes:
         I8[] [77,97,121,98,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.563914894 UTC

[section ""data" . GHC.Base.$tcMaybe1_closure" {
     GHC.Base.$tcMaybe1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMaybe2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.5644948 UTC

[section ""data" . $krep_r7Pr_closure" {
     $krep_r7Pr_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.565039878 UTC

[section ""data" . $krep1_r7Ps_closure" {
     $krep1_r7Ps_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.565842094 UTC

[section ""data" . $krep2_r7Pt_closure" {
     $krep2_r7Pt_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep1_r7Ps_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.566408244 UTC

[section ""data" . $krep3_r7Pu_closure" {
     $krep3_r7Pu_closure:
         const :_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.566991948 UTC

[section ""data" . $krep4_r7Pv_closure" {
     $krep4_r7Pv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.567539761 UTC

[section ""data" . $krep5_r7Pw_closure" {
     $krep5_r7Pw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.568139015 UTC

[section ""data" . $krep6_r7Px_closure" {
     $krep6_r7Px_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.568722919 UTC

[section ""data" . GHC.Base.$tcMonoid1_closure" {
     GHC.Base.$tcMonoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.569366642 UTC

[section ""data" . GHC.Base.$tcAlternative1_closure" {
     GHC.Base.$tcAlternative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.569991163 UTC

[section ""cstring" . GHC.Base.$trModule2_bytes" {
     GHC.Base.$trModule2_bytes:
         I8[] [71,72,67,46,66,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.570555804 UTC

[section ""data" . GHC.Base.$trModule1_closure" {
     GHC.Base.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.571057899 UTC

[section ""cstring" . GHC.Base.$trModule4_bytes" {
     GHC.Base.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.571582582 UTC

[section ""data" . GHC.Base.$trModule3_closure" {
     GHC.Base.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.572128262 UTC

[section ""data" . GHC.Base.$trModule_closure" {
     GHC.Base.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Base.$trModule3_closure+1;
         const GHC.Base.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.572685888 UTC

[section ""data" . GHC.Base.$tcMaybe_closure" {
     GHC.Base.$tcMaybe_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMaybe1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 625655543500963593;
         const 6391758309165051762;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.57323341 UTC

[section ""data" . GHC.Base.$tc'Nothing1_closure" {
     GHC.Base.$tc'Nothing1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.574193799 UTC

[section ""data" . GHC.Base.$tc'Just1_closure" {
     GHC.Base.$tc'Just1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.574763884 UTC

[section ""data" . GHC.Base.$tc'Nothing_closure" {
     GHC.Base.$tc'Nothing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Nothing2_closure+1;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 14633289528184412192;
         const 12773126156421542470;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.575389395 UTC

[section ""data" . GHC.Base.$tc'Just_closure" {
     GHC.Base.$tc'Just_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Just2_closure+1;
         const GHC.Base.$tc'Just1_closure+4;
         const 5794512144280699493;
         const 9434423460978218117;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.57598379 UTC

[section ""data" . GHC.Base.$tcFunctor_closure" {
     GHC.Base.$tcFunctor_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcFunctor1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 211182333006544237;
         const 5556320544348084514;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.5765997 UTC

[section ""data" . GHC.Base.$tcApplicative_closure" {
     GHC.Base.$tcApplicative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcApplicative1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 12705055220831243597;
         const 2963353171490466073;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.577282466 UTC

[section ""data" . GHC.Base.$tcAlternative_closure" {
     GHC.Base.$tcAlternative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcAlternative2_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 1073491102990665358;
         const 14320772755704808948;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.57838585 UTC

[section ""data" . GHC.Base.$tcNonEmpty_closure" {
     GHC.Base.$tcNonEmpty_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcNonEmpty1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13207016872645468285;
         const 3455542966739695982;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.578993316 UTC

[section ""data" . $krep7_r7Py_closure" {
     $krep7_r7Py_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcNonEmpty_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.579560372 UTC

[section ""data" . $krep8_r7Pz_closure" {
     $krep8_r7Pz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep7_r7Py_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.580184975 UTC

[section ""data" . GHC.Base.$tc':|1_closure" {
     GHC.Base.$tc':|1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep8_r7Pz_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.580803535 UTC

[section ""data" . GHC.Base.$tc':|_closure" {
     GHC.Base.$tc':|_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc':|2_closure+1;
         const GHC.Base.$tc':|1_closure+4;
         const 9440832435183810765;
         const 3053237465234607583;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.581467522 UTC

[section ""data" . GHC.Base.$tcSemigroup_closure" {
     GHC.Base.$tcSemigroup_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcSemigroup1_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 16195352186364298277;
         const 3285685594139281062;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.582067138 UTC

[section ""data" . $krep9_r7PA_closure" {
     $krep9_r7PA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcSemigroup_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.582629863 UTC

[section ""data" . GHC.Base.$tcMonoid_closure" {
     GHC.Base.$tcMonoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonoid2_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 13838560045895743776;
         const 1291018260833769143;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.583241377 UTC

[section ""data" . $krep10_r7PB_closure" {
     $krep10_r7PB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMonoid_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.583815748 UTC

[section ""data" . $krep11_r7PC_closure" {
     $krep11_r7PC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r7Pw_closure+4;
         const $krep10_r7PB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.584379413 UTC

[section ""data" . $krep12_r7PD_closure" {
     $krep12_r7PD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r7Pt_closure+4;
         const $krep11_r7PC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.584947662 UTC

[section ""data" . $krep13_r7PE_closure" {
     $krep13_r7PE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep12_r7PD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.58623092 UTC

[section ""data" . GHC.Base.$tc'C:Monoid1_closure" {
     GHC.Base.$tc'C:Monoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r7PA_closure+1;
         const $krep13_r7PE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.586751367 UTC

[section ""data" . GHC.Base.$tc'C:Monoid_closure" {
     GHC.Base.$tc'C:Monoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'C:Monoid2_closure+1;
         const GHC.Base.$tc'C:Monoid1_closure+4;
         const 16099296089107510343;
         const 5895832073319104984;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.587352234 UTC

[section ""data" . GHC.Base.$tcMonad_closure" {
     GHC.Base.$tcMonad_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonad1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 3168880480603756299;
         const 8398240611646296094;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.587997811 UTC

[section ""data" . GHC.Base.$tcMonadPlus_closure" {
     GHC.Base.$tcMonadPlus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonadPlus1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 14115673251620372550;
         const 14155357326069389390;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.588649898 UTC

[section ""data" . GHC.Base.$tcOpaque_closure" {
     GHC.Base.$tcOpaque_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcOpaque1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9339725405829241186;
         const 15550233501624900571;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.589331432 UTC

[section ""data" . $krep14_r7PF_closure" {
     $krep14_r7PF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcOpaque_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.589920458 UTC

[section ""data" . GHC.Base.$tc'O1_closure" {
     GHC.Base.$tc'O1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep14_r7PF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.590485214 UTC

[section ""data" . GHC.Base.$tc'O_closure" {
     GHC.Base.$tc'O_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'O2_closure+1;
         const GHC.Base.$tc'O1_closure+4;
         const 12551274612394834805;
         const 13000664474148134329;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.591696331 UTC

[section ""data" . GHC.Base.quotRemInt_closure" {
     GHC.Base.quotRemInt_closure:
         const GHC.Base.quotRemInt_info;
 },
 GHC.Base.quotRemInt_entry() //  [R2, R3]
         { info_tbl: [(cb02,
                       label: GHC.Base.quotRemInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb02: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0d; else goto cb0e;
       cb0d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotRemInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0e: // global
           I64[Sp - 16] = block_caZZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub0k; else goto cb00;
       ub0k: // global
           call _caZZ(R1) args: 0, res: 0, upd: 0;
       cb00: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caZZ() //  [R1]
         { info_tbl: [(caZZ,
                       label: block_caZZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caZZ: // global
           I64[Sp] = block_cb05_info;
           _s7US::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7US::I64;
           if (R1 & 7 != 0) goto ub0j; else goto cb06;
       ub0j: // global
           call _cb05(R1) args: 0, res: 0, upd: 0;
       cb06: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb05() //  [R1]
         { info_tbl: [(cb05,
                       label: block_cb05_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb05: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cb0i; else goto cb0h;
       cb0i: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb0h: // global
           (_s7UW::I64, _s7UX::I64) = call MO_S_QuotRem W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7UX::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s7UW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.593623342 UTC

[section ""data" . GHC.Base.modInt_closure" {
     GHC.Base.modInt_closure:
         const GHC.Base.modInt_info;
 },
 GHC.Base.modInt_entry() //  [R2, R3]
         { info_tbl: [(cb0s,
                       label: GHC.Base.modInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb0F; else goto cb0G;
       cb0F: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.modInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0G: // global
           I64[Sp - 16] = block_cb0p_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub0N; else goto cb0q;
       ub0N: // global
           call _cb0p(R1) args: 0, res: 0, upd: 0;
       cb0q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0p() //  [R1]
         { info_tbl: [(cb0p,
                       label: block_cb0p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0p: // global
           I64[Sp] = block_cb0v_info;
           _s7V3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7V3::I64;
           if (R1 & 7 != 0) goto ub0M; else goto cb0w;
       ub0M: // global
           call _cb0v(R1) args: 0, res: 0, upd: 0;
       cb0w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0v() //  [R1]
         { info_tbl: [(cb0v,
                       label: block_cb0v_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0v: // global
           _s7V3::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cb0A_info;
           R3 = I64[R1 + 7];
           R2 = _s7V3::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb0A() //  [R1]
         { info_tbl: [(cb0A,
                       label: block_cb0A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb0L; else goto cb0K;
       cb0L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb0K: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.595840281 UTC

[section ""data" . GHC.Base.divInt_closure" {
     GHC.Base.divInt_closure:
         const GHC.Base.divInt_info;
 },
 GHC.Base.divInt_entry() //  [R2, R3]
         { info_tbl: [(cb0V,
                       label: GHC.Base.divInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb18; else goto cb19;
       cb18: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb19: // global
           I64[Sp - 16] = block_cb0S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1g; else goto cb0T;
       ub1g: // global
           call _cb0S(R1) args: 0, res: 0, upd: 0;
       cb0T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0S() //  [R1]
         { info_tbl: [(cb0S,
                       label: block_cb0S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0S: // global
           I64[Sp] = block_cb0Y_info;
           _s7Va::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Va::I64;
           if (R1 & 7 != 0) goto ub1f; else goto cb0Z;
       ub1f: // global
           call _cb0Y(R1) args: 0, res: 0, upd: 0;
       cb0Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb0Y() //  [R1]
         { info_tbl: [(cb0Y,
                       label: block_cb0Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb0Y: // global
           _s7Va::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cb13_info;
           R3 = I64[R1 + 7];
           R2 = _s7Va::I64;
           Sp = Sp + 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cb13() //  [R1]
         { info_tbl: [(cb13,
                       label: block_cb13_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb13: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1e; else goto cb1d;
       cb1e: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cb1d: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.597699483 UTC

[section ""data" . GHC.Base.remInt_closure" {
     GHC.Base.remInt_closure:
         const GHC.Base.remInt_info;
 },
 GHC.Base.remInt_entry() //  [R2, R3]
         { info_tbl: [(cb1o,
                       label: GHC.Base.remInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb1A; else goto cb1B;
       cb1A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.remInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb1B: // global
           I64[Sp - 16] = block_cb1l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub1H; else goto cb1m;
       ub1H: // global
           call _cb1l(R1) args: 0, res: 0, upd: 0;
       cb1m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1l() //  [R1]
         { info_tbl: [(cb1l,
                       label: block_cb1l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1l: // global
           I64[Sp] = block_cb1r_info;
           _s7Vh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Vh::I64;
           if (R1 & 7 != 0) goto ub1G; else goto cb1s;
       ub1G: // global
           call _cb1r(R1) args: 0, res: 0, upd: 0;
       cb1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1r() //  [R1]
         { info_tbl: [(cb1r,
                       label: block_cb1r_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb1F; else goto cb1E;
       cb1F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb1E: // global
           _s7Vk::I64 = %MO_S_Rem_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Vk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.599359629 UTC

[section ""data" . GHC.Base.quotInt_closure" {
     GHC.Base.quotInt_closure:
         const GHC.Base.quotInt_info;
 },
 GHC.Base.quotInt_entry() //  [R2, R3]
         { info_tbl: [(cb1P,
                       label: GHC.Base.quotInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb21; else goto cb22;
       cb21: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb22: // global
           I64[Sp - 16] = block_cb1M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub28; else goto cb1N;
       ub28: // global
           call _cb1M(R1) args: 0, res: 0, upd: 0;
       cb1N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1M() //  [R1]
         { info_tbl: [(cb1M,
                       label: block_cb1M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1M: // global
           I64[Sp] = block_cb1S_info;
           _s7Vo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Vo::I64;
           if (R1 & 7 != 0) goto ub27; else goto cb1T;
       ub27: // global
           call _cb1S(R1) args: 0, res: 0, upd: 0;
       cb1T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb1S() //  [R1]
         { info_tbl: [(cb1S,
                       label: block_cb1S_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb1S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb26; else goto cb25;
       cb26: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb25: // global
           _s7Vr::I64 = %MO_S_Quot_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Vr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.60080876 UTC

[section ""data" . GHC.Base.getTag_closure" {
     GHC.Base.getTag_closure:
         const GHC.Base.getTag_info;
 },
 GHC.Base.getTag_entry() //  [R2]
         { info_tbl: [(cb2g,
                       label: GHC.Base.getTag_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cb2h; else goto cb2i;
       cb2h: // global
           R2 = R2;
           R1 = GHC.Base.getTag_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb2i: // global
           I64[Sp - 8] = block_cb2d_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb2d() //  [R1]
         { info_tbl: [(cb2d,
                       label: block_cb2d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2d: // global
           R1 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.601930979 UTC

[section ""data" . GHC.Base.$fMonadIO1_closure" {
     GHC.Base.$fMonadIO1_closure:
         const GHC.Base.$fMonadIO1_info;
 },
 GHC.Base.$fMonadIO1_entry() //  [R2, R3]
         { info_tbl: [(cb2q,
                       label: GHC.Base.$fMonadIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb2r; else goto cb2s;
       cb2r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb2s: // global
           I64[Sp - 16] = block_cb2o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb2o() //  [R1]
         { info_tbl: [(cb2o,
                       label: block_cb2o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2o: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.60301964 UTC

[section ""data" . GHC.Base.bindIO_closure" {
     GHC.Base.bindIO_closure:
         const GHC.Base.bindIO_info;
 },
 GHC.Base.bindIO_entry() //  [R2, R3]
         { info_tbl: [(cb2y,
                       label: GHC.Base.bindIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2y: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fMonadIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.603901612 UTC

[section ""data" . GHC.Base.$fApplicativeIO2_closure" {
     GHC.Base.$fApplicativeIO2_closure:
         const GHC.Base.$fApplicativeIO2_info;
 },
 GHC.Base.$fApplicativeIO2_entry() //  [R2, R3]
         { info_tbl: [(cb2H,
                       label: GHC.Base.$fApplicativeIO2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb2I; else goto cb2J;
       cb2I: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb2J: // global
           I64[Sp - 16] = block_cb2F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb2F() //  []
         { info_tbl: [(cb2F,
                       label: block_cb2F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2F: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.604917857 UTC

[section ""data" . GHC.Base.thenIO_closure" {
     GHC.Base.thenIO_closure:
         const GHC.Base.thenIO_info;
 },
 GHC.Base.thenIO_entry() //  [R2, R3]
         { info_tbl: [(cb2P,
                       label: GHC.Base.thenIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2P: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeIO2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.605815779 UTC

[section ""data" . GHC.Base.unIO1_closure" {
     GHC.Base.unIO1_closure:
         const GHC.Base.unIO1_info;
 },
 GHC.Base.unIO1_entry() //  [R2]
         { info_tbl: [(cb2W,
                       label: GHC.Base.unIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb2W: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.60661094 UTC

[section ""data" . GHC.Base.unIO_closure" {
     GHC.Base.unIO_closure:
         const GHC.Base.unIO_info;
 },
 GHC.Base.unIO_entry() //  [R2]
         { info_tbl: [(cb33,
                       label: GHC.Base.unIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb33: // global
           R2 = R2;
           call GHC.Base.unIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.607392029 UTC

[section ""data" . GHC.Base.$fApplicativeIO4_closure" {
     GHC.Base.$fApplicativeIO4_closure:
         const GHC.Base.$fApplicativeIO4_info;
 },
 GHC.Base.$fApplicativeIO4_entry() //  [R2]
         { info_tbl: [(cb3a,
                       label: GHC.Base.$fApplicativeIO4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb3a: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.608230097 UTC

[section ""data" . GHC.Base.returnIO_closure" {
     GHC.Base.returnIO_closure:
         const GHC.Base.returnIO_info;
 },
 GHC.Base.returnIO_entry() //  [R2]
         { info_tbl: [(cb3h,
                       label: GHC.Base.returnIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb3h: // global
           R2 = R2;
           call GHC.Base.$fApplicativeIO4_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.609235015 UTC

[section ""data" . GHC.Base.$fApplicativeIO3_closure" {
     GHC.Base.$fApplicativeIO3_closure:
         const GHC.Base.$fApplicativeIO3_info;
 },
 GHC.Base.$fApplicativeIO3_entry() //  [R2, R3]
         { info_tbl: [(cb3t,
                       label: GHC.Base.$fApplicativeIO3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb3t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb3u; else goto cb3v;
       cb3u: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb3v: // global
           I64[Sp - 16] = block_cb3o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb3o() //  [R1]
         { info_tbl: [(cb3o,
                       label: block_cb3o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb3o: // global
           I64[Sp] = block_cb3q_info;
           _s7VN::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7VN::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb3q() //  [R1]
         { info_tbl: [(cb3q,
                       label: block_cb3q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb3q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb3z; else goto cb3y;
       cb3z: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb3y: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.611235106 UTC

[section ""data" . GHC.Base.liftA_$sliftA1_closure" {
     GHC.Base.liftA_$sliftA1_closure:
         const GHC.Base.liftA_$sliftA1_info;
 },
 GHC.Base.liftA_$sliftA1_entry() //  [R2, R3]
         { info_tbl: [(cb3E,
                       label: GHC.Base.liftA_$sliftA1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb3E: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.612898671 UTC

[section ""data" . GHC.Base.ap1_closure" {
     GHC.Base.ap1_closure:
         const GHC.Base.ap1_info;
 },
 GHC.Base.ap1_entry() //  [R2, R3]
         { info_tbl: [(cb3Q,
                       label: GHC.Base.ap1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb3Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb3R; else goto cb3S;
       cb3R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb3S: // global
           I64[Sp - 16] = block_cb3L_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb3L() //  [R1]
         { info_tbl: [(cb3L,
                       label: block_cb3L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb3L: // global
           I64[Sp] = block_cb3N_info;
           _s7VX::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7VX::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb3N() //  [R1]
         { info_tbl: [(cb3N,
                       label: block_cb3N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb3N: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb3W; else goto cb3V;
       cb3W: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb3V: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.614232231 UTC

[section ""data" . GHC.Base.ap_$sap1_closure" {
     GHC.Base.ap_$sap1_closure:
         const GHC.Base.ap_$sap1_info;
 },
 GHC.Base.ap_$sap1_entry() //  [R2, R3]
         { info_tbl: [(cb41,
                       label: GHC.Base.ap_$sap1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb41: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.ap1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.61543302 UTC

[section ""data" . GHC.Base.ap_closure" {
     GHC.Base.ap_closure:
         const GHC.Base.ap_info;
 },
 sat_s7W8_entry() //  [R1, R2]
         { info_tbl: [(cb4j,
                       label: sat_s7W8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb4j: // global
           _s7W6::P64 = R2;
           _s7W8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb4k; else goto cb4l;
       cb4l: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb4n; else goto cb4m;
       cb4n: // global
           HpAlloc = 32;
           goto cb4k;
       cb4k: // global
           R2 = _s7W6::P64;
           R1 = _s7W8::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb4m: // global
           _s7W2::P64 = P64[_s7W8::P64 + 7];
           _s7W5::P64 = P64[_s7W8::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s7W5::P64;
           P64[Hp] = _s7W6::P64;
           R2 = _s7W2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7W9_entry() //  [R1, R2]
         { info_tbl: [(cb4o,
                       label: sat_s7W9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb4o: // global
           _s7W5::P64 = R2;
           _s7W9::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cb4p; else goto cb4q;
       cb4q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb4s; else goto cb4r;
       cb4s: // global
           HpAlloc = 24;
           goto cb4p;
       cb4p: // global
           R2 = _s7W5::P64;
           R1 = _s7W9::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb4r: // global
           _s7W2::P64 = P64[_s7W9::P64 + 7];
           _s7W4::P64 = P64[_s7W9::P64 + 15];
           I64[Hp - 16] = sat_s7W8_info;
           P64[Hp - 8] = _s7W2::P64;
           P64[Hp] = _s7W5::P64;
           R2 = _s7W2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7W4::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.ap_entry() //  [R2, R3, R4]
         { info_tbl: [(cb4t,
                       label: GHC.Base.ap_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb4t: // global
           _s7W4::P64 = R4;
           _s7W3::P64 = R3;
           _s7W2::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cb4u; else goto cb4v;
       cb4v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb4x; else goto cb4w;
       cb4x: // global
           HpAlloc = 24;
           goto cb4u;
       cb4u: // global
           R4 = _s7W4::P64;
           R3 = _s7W3::P64;
           R2 = _s7W2::P64;
           R1 = GHC.Base.ap_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb4w: // global
           I64[Hp - 16] = sat_s7W9_info;
           P64[Hp - 8] = _s7W2::P64;
           P64[Hp] = _s7W4::P64;
           R2 = _s7W2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7W3::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.617524709 UTC

[section ""data" . GHC.Base.liftM1_closure" {
     GHC.Base.liftM1_closure:
         const GHC.Base.liftM1_info;
 },
 GHC.Base.liftM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb4H,
                       label: GHC.Base.liftM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb4H: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb4I; else goto cb4J;
       cb4I: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb4J: // global
           I64[Sp - 24] = block_cb4C_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb4C() //  [R1]
         { info_tbl: [(cb4C,
                       label: block_cb4C_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb4C: // global
           I64[Sp] = block_cb4E_info;
           _s7Wg::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Wg::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb4E() //  [R1]
         { info_tbl: [(cb4E,
                       label: block_cb4E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb4E: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb4N; else goto cb4M;
       cb4N: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb4M: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.618846697 UTC

[section ""data" . GHC.Base.liftM2_$sliftM1_closure" {
     GHC.Base.liftM2_$sliftM1_closure:
         const GHC.Base.liftM2_$sliftM1_info;
 },
 GHC.Base.liftM2_$sliftM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cb4S,
                       label: GHC.Base.liftM2_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb4S: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.620087692 UTC

[section ""data" . GHC.Base.liftM2_closure" {
     GHC.Base.liftM2_closure:
         const GHC.Base.liftM2_info;
 },
 sat_s7Ws_entry() //  [R1, R2]
         { info_tbl: [(cb5a,
                       label: sat_s7Ws_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5a: // global
           _s7Wq::P64 = R2;
           _s7Ws::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cb5b; else goto cb5c;
       cb5c: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb5e; else goto cb5d;
       cb5e: // global
           HpAlloc = 40;
           goto cb5b;
       cb5b: // global
           R2 = _s7Wq::P64;
           R1 = _s7Ws::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb5d: // global
           _s7Wl::P64 = P64[_s7Ws::P64 + 7];
           _s7Wm::P64 = P64[_s7Ws::P64 + 15];
           _s7Wp::P64 = P64[_s7Ws::P64 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _s7Wm::P64;
           P64[Hp - 8] = _s7Wp::P64;
           P64[Hp] = _s7Wq::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7Wt_entry() //  [R1, R2]
         { info_tbl: [(cb5f,
                       label: sat_s7Wt_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5f: // global
           _s7Wp::P64 = R2;
           _s7Wt::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cb5g; else goto cb5h;
       cb5h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb5j; else goto cb5i;
       cb5j: // global
           HpAlloc = 32;
           goto cb5g;
       cb5g: // global
           R2 = _s7Wp::P64;
           R1 = _s7Wt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb5i: // global
           _s7Wl::P64 = P64[_s7Wt::P64 + 7];
           _s7Wm::P64 = P64[_s7Wt::P64 + 15];
           _s7Wo::P64 = P64[_s7Wt::P64 + 23];
           I64[Hp - 24] = sat_s7Ws_info;
           P64[Hp - 16] = _s7Wl::P64;
           P64[Hp - 8] = _s7Wm::P64;
           P64[Hp] = _s7Wp::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Wo::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb5k,
                       label: GHC.Base.liftM2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5k: // global
           _s7Wo::P64 = R5;
           _s7Wn::P64 = R4;
           _s7Wm::P64 = R3;
           _s7Wl::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cb5l; else goto cb5m;
       cb5m: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cb5o; else goto cb5n;
       cb5o: // global
           HpAlloc = 32;
           goto cb5l;
       cb5l: // global
           R5 = _s7Wo::P64;
           R4 = _s7Wn::P64;
           R3 = _s7Wm::P64;
           R2 = _s7Wl::P64;
           R1 = GHC.Base.liftM2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb5n: // global
           I64[Hp - 24] = sat_s7Wt_info;
           P64[Hp - 16] = _s7Wl::P64;
           P64[Hp - 8] = _s7Wm::P64;
           P64[Hp] = _s7Wo::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Wn::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.62220821 UTC

[section ""data" . $cliftA2_r7PG_closure" {
     $cliftA2_r7PG_closure:
         const $cliftA2_r7PG_info;
 },
 $cliftA2_r7PG_entry() //  [R2, R3, R4]
         { info_tbl: [(cb5y,
                       label: $cliftA2_r7PG_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb5z; else goto cb5A;
       cb5z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb5A: // global
           I64[Sp - 24] = block_cb5t_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb5t() //  [R1]
         { info_tbl: [(cb5t,
                       label: block_cb5t_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5t: // global
           I64[Sp] = block_cb5v_info;
           _s7WA::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WA::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb5v() //  [R1]
         { info_tbl: [(cb5v,
                       label: block_cb5v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5v: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb5E; else goto cb5D;
       cb5E: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb5D: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.62352552 UTC

[section ""data" . GHC.Base.$fApplicativeIO_$cliftA2_closure" {
     GHC.Base.$fApplicativeIO_$cliftA2_closure:
         const GHC.Base.$fApplicativeIO_$cliftA2_info;
 },
 GHC.Base.$fApplicativeIO_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cb5J,
                       label: GHC.Base.$fApplicativeIO_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.624623868 UTC

[section ""data" . GHC.Base.liftA1_closure" {
     GHC.Base.liftA1_closure:
         const GHC.Base.liftA1_info;
 },
 GHC.Base.liftA1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb5X,
                       label: GHC.Base.liftA1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5X: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cb5Y; else goto cb5Z;
       cb5Y: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb5Z: // global
           I64[Sp - 32] = block_cb5Q_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb5Q() //  [R1]
         { info_tbl: [(cb5Q,
                       label: block_cb5Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5Q: // global
           I64[Sp] = block_cb5S_info;
           _s7WM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WM::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb5S() //  [R1]
         { info_tbl: [(cb5S,
                       label: block_cb5S_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5S: // global
           I64[Sp] = block_cb5U_info;
           _s7WP::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7WP::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb5U() //  [R1]
         { info_tbl: [(cb5U,
                       label: block_cb5U_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb5U: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cb64; else goto cb63;
       cb64: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb63: // global
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.626366641 UTC

[section ""data" . GHC.Base.liftA3_$sliftA1_closure" {
     GHC.Base.liftA3_$sliftA1_closure:
         const GHC.Base.liftA3_$sliftA1_info;
 },
 GHC.Base.liftA3_$sliftA1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cb69,
                       label: GHC.Base.liftA3_$sliftA1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb69: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.627527875 UTC

[section ""data" . GHC.Base.$fSemigroupIO2_closure" {
     GHC.Base.$fSemigroupIO2_closure:
         const GHC.Base.$fSemigroupIO2_info;
 },
 sat_s7X4_entry() //  [R1]
         { info_tbl: [(cb6o,
                       label: sat_s7X4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6o: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb6p; else goto cb6q;
       cb6p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb6q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupIO2_entry() //  [R2, R3, R4]
         { info_tbl: [(cb6r,
                       label: GHC.Base.$fSemigroupIO2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb6s; else goto cb6t;
       cb6s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb6t: // global
           I64[Sp - 24] = block_cb6g_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb6g() //  [R1]
         { info_tbl: [(cb6g,
                       label: block_cb6g_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6g: // global
           I64[Sp] = block_cb6i_info;
           _s7X0::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7X0::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb6i() //  [R1]
         { info_tbl: [(cb6i,
                       label: block_cb6i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6i: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb6x; else goto cb6w;
       cb6x: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb6w: // global
           I64[Hp - 32] = sat_s7X4_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.629864777 UTC

[section ""data" . GHC.Base.$w$csconcat4_closure" {
     GHC.Base.$w$csconcat4_closure:
         const GHC.Base.$w$csconcat4_info;
 },
 sat_s7Xm_entry() //  [R1]
         { info_tbl: [(cb6V,
                       label: sat_s7Xm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6V: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb6W; else goto cb6X;
       cb6W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb6X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s7X9_entry() //  [R1, R2, R3]
         { info_tbl: [(cb72,
                       label: go_s7X9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb72: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb73; else goto cb74;
       cb73: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb74: // global
           I64[Sp - 32] = block_cb6H_info;
           _s7X9::P64 = R1;
           _s7X5::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 24] = _s7X5::P64;
           P64[Sp - 16] = _s7X9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ub7c; else goto cb6I;
       ub7c: // global
           call _cb6H(R1) args: 0, res: 0, upd: 0;
       cb6I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb6H() //  [R1]
         { info_tbl: [(cb6H,
                       label: block_cb6H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6H: // global
           _s7Xa::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cb6Z; else goto cb70;
       cb6Z: // global
           R1 = _s7Xa::P64;
           Sp = Sp + 32;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cb70: // global
           I64[Sp - 8] = block_cb6N_info;
           _s7Xe::P64 = P64[R1 + 6];
           _s7Xf::P64 = P64[R1 + 14];
           R1 = _s7Xa::P64;
           P64[Sp] = _s7Xf::P64;
           P64[Sp + 24] = _s7Xe::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb6N() //  [R1]
         { info_tbl: [(cb6N,
                       label: block_cb6N_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6N: // global
           _s7Xf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cb6P_info;
           R3 = _s7Xf::P64;
           R2 = P64[Sp + 32];
           _s7Xi::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 32] = _s7Xi::P64;
           Sp = Sp + 8;
           call go_s7X9_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb6P() //  [R1]
         { info_tbl: [(cb6P,
                       label: block_cb6P_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb6P: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb7b; else goto cb7a;
       cb7b: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb7a: // global
           I64[Hp - 32] = sat_s7Xm_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat4_entry() //  [R2, R3, R4]
         { info_tbl: [(cb7d,
                       label: GHC.Base.$w$csconcat4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb7h; else goto cb7g;
       cb7h: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb7g: // global
           I64[Hp - 8] = go_s7X9_info;
           P64[Hp] = R2;
           _s7X6::P64 = R3;
           R3 = R4;
           R2 = _s7X6::P64;
           R1 = Hp - 5;
           call go_s7X9_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.633031416 UTC

[section ""data" . GHC.Base.$fSemigroupIO1_closure" {
     GHC.Base.$fSemigroupIO1_closure:
         const GHC.Base.$fSemigroupIO1_info;
 },
 GHC.Base.$fSemigroupIO1_entry() //  [R2, R3]
         { info_tbl: [(cb7p,
                       label: GHC.Base.$fSemigroupIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb7q; else goto cb7r;
       cb7q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb7r: // global
           I64[Sp - 16] = block_cb7m_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ub7v; else goto cb7n;
       ub7v: // global
           call _cb7m(R1) args: 0, res: 0, upd: 0;
       cb7n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb7m() //  [R1]
         { info_tbl: [(cb7m,
                       label: block_cb7m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7m: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat4_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.634958676 UTC

[section ""data" . GHC.Base.$fSemigroupIO_closure" {
     GHC.Base.$fSemigroupIO_closure:
         const GHC.Base.$fSemigroupIO_info;
         const 0;
 },
 sat_s7Xw_entry() //  [R1, R2]
         { info_tbl: [(cb7F,
                       label: sat_s7Xw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7F: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupIO_$cstimes_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Xv_entry() //  [R1, R2]
         { info_tbl: [(cb7N,
                       label: sat_s7Xv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7N: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroupIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Xu_entry() //  [R1, R2, R3]
         { info_tbl: [(cb7V,
                       label: sat_s7Xu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7V: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroupIO2_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroupIO_entry() //  [R2]
         { info_tbl: [(cb7Z,
                       label: GHC.Base.$fSemigroupIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb7Z: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cb83; else goto cb82;
       cb83: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb82: // global
           I64[Hp - 72] = sat_s7Xw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s7Xv_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s7Xu_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 54;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.$fSemigroupIO_$cstimes_closure" {
     GHC.Base.$fSemigroupIO_$cstimes_closure:
         const GHC.Base.$fSemigroupIO_$cstimes_info;
         const 0;
 },
 sat_s7Xz_entry() //  [R1]
         { info_tbl: [(cb8c,
                       label: sat_s7Xz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8d; else goto cb8e;
       cb8d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupIO_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(cb8f,
                       label: GHC.Base.$fSemigroupIO_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8j; else goto cb8i;
       cb8j: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8i: // global
           I64[Hp - 16] = sat_s7Xz_info;
           P64[Hp] = R2;
           _s7Xy::P64 = R3;
           R3 = Hp - 16;
           R2 = _s7Xy::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.637116489 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cp1Monoid_closure" {
     GHC.Base.$fMonoidIO_$cp1Monoid_closure:
         const GHC.Base.$fMonoidIO_$cp1Monoid_info;
         const 0;
 },
 sat_s7XB_entry() //  [R1]
         { info_tbl: [(cb8s,
                       label: sat_s7XB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb8t; else goto cb8u;
       cb8t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidIO_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cb8v,
                       label: GHC.Base.$fMonoidIO_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb8z; else goto cb8y;
       cb8z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb8y: // global
           I64[Hp - 16] = sat_s7XB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.638810182 UTC

[section ""data" . $cmappend_r7PH_closure" {
     $cmappend_r7PH_closure:
         const $cmappend_r7PH_info;
 },
 sat_s7XN_entry() //  [R1]
         { info_tbl: [(cb8O,
                       label: sat_s7XN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8O: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cb8P; else goto cb8Q;
       cb8P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb8Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cb8M_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cb8M() //  [R1]
         { info_tbl: [(cb8M,
                       label: block_cb8M_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8M: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $cmappend_r7PH_entry() //  [R2, R3, R4]
         { info_tbl: [(cb8U,
                       label: $cmappend_r7PH_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cb8V; else goto cb8W;
       cb8V: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8W: // global
           I64[Sp - 24] = block_cb8E_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8E() //  [R1]
         { info_tbl: [(cb8E,
                       label: block_cb8E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8E: // global
           I64[Sp] = block_cb8G_info;
           _s7XI::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7XI::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb8G() //  [R1]
         { info_tbl: [(cb8G,
                       label: block_cb8G_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb8G: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cb90; else goto cb8Z;
       cb90: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb8Z: // global
           I64[Hp - 32] = sat_s7XN_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.640483001 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cmappend_closure" {
     GHC.Base.$fMonoidIO_$cmappend_closure:
         const GHC.Base.$fMonoidIO_$cmappend_info;
 },
 GHC.Base.$fMonoidIO_$cmappend_entry() //  [R2, R3, R4]
         { info_tbl: [(cb95,
                       label: GHC.Base.$fMonoidIO_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb95: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.641324343 UTC

[section ""data" . GHC.Base.$fAlternativeIO1_closure" {
     GHC.Base.$fAlternativeIO1_closure:
         const GHC.Base.$fAlternativeIO1_info;
 },
 GHC.Base.$fAlternativeIO1_entry() //  []
         { info_tbl: [(cb9c,
                       label: GHC.Base.$fAlternativeIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9c: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.642502751 UTC

[section ""data" . GHC.Base.$fAlternativeIO2_closure" {
     GHC.Base.$fAlternativeIO2_closure:
         const GHC.Base.$fAlternativeIO2_info;
         const 0;
 },
 some_v_s7XR_entry() //  [R1]
         { info_tbl: [(cb9t,
                       label: some_v_s7XR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9u; else goto cb9v;
       cb9u: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb9v: // global
           I64[Sp - 16] = block_cb9o_info;
           _s7XR::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s7XR::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9o() //  [R1]
         { info_tbl: [(cb9o,
                       label: block_cb9o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9o: // global
           I64[Sp] = block_cb9q_info;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = P64[Sp + 8];
           _s7XV::P64 = R1;
           R1 = GHC.IO.mplusIO_closure;
           P64[Sp + 8] = _s7XV::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9q() //  [R1]
         { info_tbl: [(cb9q,
                       label: block_cb9q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cb9z; else goto cb9y;
       cb9z: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cb9y: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fAlternativeIO2_entry() //  [R2]
         { info_tbl: [(cb9A,
                       label: GHC.Base.$fAlternativeIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cb9E; else goto cb9D;
       cb9E: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cb9D: // global
           I64[Hp - 8] = some_v_s7XR_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_s7XR_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.644535752 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cmany_closure" {
     GHC.Base.$fAlternativeIO_$cmany_closure:
         const GHC.Base.$fAlternativeIO_$cmany_info;
         const 0;
 },
 sat_s7Ya_entry() //  [R1]
         { info_tbl: [(cb9X,
                       label: sat_s7Ya_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cb9Y; else goto cb9Z;
       cb9Y: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb9Z: // global
           I64[Sp - 16] = block_cb9S_info;
           _s7Y1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s7Y1::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9S() //  [R1]
         { info_tbl: [(cb9S,
                       label: block_cb9S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9S: // global
           I64[Sp] = block_cb9U_info;
           _s7Y5::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Y5::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cb9U() //  [R1]
         { info_tbl: [(cb9U,
                       label: block_cb9U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cb9U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cba3; else goto cba2;
       cba3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cba2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v_s7Y1_entry() //  [R1]
         { info_tbl: [(cba4,
                       label: many_v_s7Y1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba4: // global
           _s7Y1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cba5; else goto cba6;
       cba6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cba8; else goto cba7;
       cba8: // global
           HpAlloc = 24;
           goto cba5;
       cba5: // global
           R1 = _s7Y1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cba7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Y1::P64;
           _s7Y0::P64 = P64[_s7Y1::P64 + 16];
           I64[Hp - 16] = sat_s7Ya_info;
           P64[Hp - 8] = _s7Y0::P64;
           P64[Hp] = _s7Y1::P64;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = Hp - 15;
           R1 = GHC.IO.mplusIO_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeIO_$cmany_entry() //  [R2]
         { info_tbl: [(cba9,
                       label: GHC.Base.$fAlternativeIO_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cba9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbad; else goto cbac;
       cbad: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbac: // global
           I64[Hp - 16] = many_v_s7Y1_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.646850366 UTC

[section ""data" . GHC.Base.liftM9_closure" {
     GHC.Base.liftM9_closure:
         const GHC.Base.liftM9_info;
 },
 GHC.Base.liftM9_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbat,
                       label: GHC.Base.liftM9_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbat: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbau; else goto cbav;
       cbau: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM9_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbav: // global
           I64[Sp - 40] = block_cbai_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbai() //  [R1]
         { info_tbl: [(cbai,
                       label: block_cbai_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbai: // global
           I64[Sp] = block_cbak_info;
           _s7Yk::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Yk::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbak() //  [R1]
         { info_tbl: [(cbak,
                       label: block_cbak_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbak: // global
           I64[Sp] = block_cbam_info;
           _s7Yn::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Yn::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbam() //  [R1]
         { info_tbl: [(cbam,
                       label: block_cbam_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbam: // global
           I64[Sp] = block_cbao_info;
           _s7Yq::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Yq::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbao() //  [R1]
         { info_tbl: [(cbao,
                       label: block_cbao_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbao: // global
           I64[Sp] = block_cbaq_info;
           _s7Yt::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s7Yt::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbaq() //  [R1]
         { info_tbl: [(cbaq,
                       label: block_cbaq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbaC; else goto cbaB;
       cbaC: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbaB: // global
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R1 = Hp - 56;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.648767036 UTC

[section ""data" . GHC.Base.liftM5_$sliftM1_closure" {
     GHC.Base.liftM5_$sliftM1_closure:
         const GHC.Base.liftM5_$sliftM1_info;
 },
 GHC.Base.liftM5_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbaH,
                       label: GHC.Base.liftM5_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaH: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM9_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.651666476 UTC

[section ""data" . GHC.Base.liftM5_closure" {
     GHC.Base.liftM5_closure:
         const GHC.Base.liftM5_info;
 },
 GHC.Base.liftM5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbaL: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.liftM5_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2,
                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7YL_entry() //  [R1, R2]
         { info_tbl: [(cbbf,
                       label: sat_s7YL_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbf: // global
           _s7YJ::P64 = R2;
           _s7YL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbbg; else goto cbbh;
       cbbh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbbj; else goto cbbi;
       cbbj: // global
           HpAlloc = 64;
           goto cbbg;
       cbbg: // global
           R2 = _s7YJ::P64;
           R1 = _s7YL::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbi: // global
           _s7Yy::P64 = P64[_s7YL::P64 + 7];
           _s7Yz::P64 = P64[_s7YL::P64 + 15];
           _s7YF::P64 = P64[_s7YL::P64 + 23];
           _s7YG::P64 = P64[_s7YL::P64 + 31];
           _s7YH::P64 = P64[_s7YL::P64 + 39];
           _s7YI::P64 = P64[_s7YL::P64 + 47];
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = _s7Yz::P64;
           P64[Hp - 32] = _s7YF::P64;
           P64[Hp - 24] = _s7YG::P64;
           P64[Hp - 16] = _s7YH::P64;
           P64[Hp - 8] = _s7YI::P64;
           P64[Hp] = _s7YJ::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7YM_entry() //  [R1, R2]
         { info_tbl: [(cbbk,
                       label: sat_s7YM_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbk: // global
           _s7YI::P64 = R2;
           _s7YM::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbbl; else goto cbbm;
       cbbm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbo; else goto cbbn;
       cbbo: // global
           HpAlloc = 56;
           goto cbbl;
       cbbl: // global
           R2 = _s7YI::P64;
           R1 = _s7YM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbn: // global
           _s7Yy::P64 = P64[_s7YM::P64 + 7];
           _s7Yz::P64 = P64[_s7YM::P64 + 15];
           _s7YE::P64 = P64[_s7YM::P64 + 23];
           _s7YF::P64 = P64[_s7YM::P64 + 31];
           _s7YG::P64 = P64[_s7YM::P64 + 39];
           _s7YH::P64 = P64[_s7YM::P64 + 47];
           I64[Hp - 48] = sat_s7YL_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YF::P64;
           P64[Hp - 16] = _s7YG::P64;
           P64[Hp - 8] = _s7YH::P64;
           P64[Hp] = _s7YI::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YE::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7YN_entry() //  [R1, R2]
         { info_tbl: [(cbbp,
                       label: sat_s7YN_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbp: // global
           _s7YH::P64 = R2;
           _s7YN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbbq; else goto cbbr;
       cbbr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbt; else goto cbbs;
       cbbt: // global
           HpAlloc = 56;
           goto cbbq;
       cbbq: // global
           R2 = _s7YH::P64;
           R1 = _s7YN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbs: // global
           _s7Yy::P64 = P64[_s7YN::P64 + 7];
           _s7Yz::P64 = P64[_s7YN::P64 + 15];
           _s7YD::P64 = P64[_s7YN::P64 + 23];
           _s7YE::P64 = P64[_s7YN::P64 + 31];
           _s7YF::P64 = P64[_s7YN::P64 + 39];
           _s7YG::P64 = P64[_s7YN::P64 + 47];
           I64[Hp - 48] = sat_s7YM_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YE::P64;
           P64[Hp - 16] = _s7YF::P64;
           P64[Hp - 8] = _s7YG::P64;
           P64[Hp] = _s7YH::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YD::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7YO_entry() //  [R1, R2]
         { info_tbl: [(cbbu,
                       label: sat_s7YO_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbu: // global
           _s7YG::P64 = R2;
           _s7YO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbbv; else goto cbbw;
       cbbw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbby; else goto cbbx;
       cbby: // global
           HpAlloc = 56;
           goto cbbv;
       cbbv: // global
           R2 = _s7YG::P64;
           R1 = _s7YO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbx: // global
           _s7Yy::P64 = P64[_s7YO::P64 + 7];
           _s7Yz::P64 = P64[_s7YO::P64 + 15];
           _s7YC::P64 = P64[_s7YO::P64 + 23];
           _s7YD::P64 = P64[_s7YO::P64 + 31];
           _s7YE::P64 = P64[_s7YO::P64 + 39];
           _s7YF::P64 = P64[_s7YO::P64 + 47];
           I64[Hp - 48] = sat_s7YN_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YD::P64;
           P64[Hp - 16] = _s7YE::P64;
           P64[Hp - 8] = _s7YF::P64;
           P64[Hp] = _s7YG::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YC::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7YP_entry() //  [R1, R2]
         { info_tbl: [(cbbz,
                       label: sat_s7YP_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbz: // global
           _s7YF::P64 = R2;
           _s7YP::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbbA; else goto cbbB;
       cbbB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbD; else goto cbbC;
       cbbD: // global
           HpAlloc = 56;
           goto cbbA;
       cbbA: // global
           R2 = _s7YF::P64;
           R1 = _s7YP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbbC: // global
           _s7Yy::P64 = P64[_s7YP::P64 + 7];
           _s7Yz::P64 = P64[_s7YP::P64 + 15];
           _s7YB::P64 = P64[_s7YP::P64 + 23];
           _s7YC::P64 = P64[_s7YP::P64 + 31];
           _s7YD::P64 = P64[_s7YP::P64 + 39];
           _s7YE::P64 = P64[_s7YP::P64 + 47];
           I64[Hp - 48] = sat_s7YO_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YC::P64;
           P64[Hp - 16] = _s7YD::P64;
           P64[Hp - 8] = _s7YE::P64;
           P64[Hp] = _s7YF::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YB::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbbE,
                       label: GHC.Base.liftM5_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbE: // global
           _s7YC::P64 = R6;
           _s7YB::P64 = R5;
           _s7YA::P64 = R4;
           _s7Yz::P64 = R3;
           _s7Yy::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbbF; else goto cbbG;
       cbbG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbbI; else goto cbbH;
       cbbI: // global
           HpAlloc = 56;
           goto cbbF;
       cbbF: // global
           R1 = GHC.Base.liftM5_closure;
           P64[Sp - 40] = _s7Yy::P64;
           P64[Sp - 32] = _s7Yz::P64;
           P64[Sp - 24] = _s7YA::P64;
           P64[Sp - 16] = _s7YB::P64;
           P64[Sp - 8] = _s7YC::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cbbH: // global
           I64[Hp - 48] = sat_s7YP_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YB::P64;
           P64[Hp - 16] = _s7YC::P64;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R2 = _s7Yy::P64;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s7YA::P64;
           P64[Sp + 8] = Hp - 47;
           Sp = Sp - 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.656034448 UTC

[section ""data" . GHC.Base.liftM8_closure" {
     GHC.Base.liftM8_closure:
         const GHC.Base.liftM8_info;
 },
 GHC.Base.liftM8_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbbW,
                       label: GHC.Base.liftM8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbbX; else goto cbbY;
       cbbX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM8_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbbY: // global
           I64[Sp - 40] = block_cbbN_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbN() //  [R1]
         { info_tbl: [(cbbN,
                       label: block_cbbN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbN: // global
           I64[Sp] = block_cbbP_info;
           _s7YY::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7YY::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbP() //  [R1]
         { info_tbl: [(cbbP,
                       label: block_cbbP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbP: // global
           I64[Sp] = block_cbbR_info;
           _s7Z1::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Z1::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbR() //  [R1]
         { info_tbl: [(cbbR,
                       label: block_cbbR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbR: // global
           I64[Sp] = block_cbbT_info;
           _s7Z4::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Z4::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbbT() //  [R1]
         { info_tbl: [(cbbT,
                       label: block_cbbT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbbT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbc4; else goto cbc3;
       cbc4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbc3: // global
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R1 = Hp - 48;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.657817484 UTC

[section ""data" . GHC.Base.liftM4_$sliftM1_closure" {
     GHC.Base.liftM4_$sliftM1_closure:
         const GHC.Base.liftM4_$sliftM1_info;
 },
 GHC.Base.liftM4_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbc9,
                       label: GHC.Base.liftM4_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbc9: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM8_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.659460613 UTC

[section ""data" . GHC.Base.liftM4_closure" {
     GHC.Base.liftM4_closure:
         const GHC.Base.liftM4_info;
 },
 sat_s7Zk_entry() //  [R1, R2]
         { info_tbl: [(cbcB,
                       label: sat_s7Zk_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcB: // global
           _s7Zi::P64 = R2;
           _s7Zk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcC; else goto cbcD;
       cbcD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbcF; else goto cbcE;
       cbcF: // global
           HpAlloc = 56;
           goto cbcC;
       cbcC: // global
           R2 = _s7Zi::P64;
           R1 = _s7Zk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcE: // global
           _s7Z9::P64 = P64[_s7Zk::P64 + 7];
           _s7Za::P64 = P64[_s7Zk::P64 + 15];
           _s7Zf::P64 = P64[_s7Zk::P64 + 23];
           _s7Zg::P64 = P64[_s7Zk::P64 + 31];
           _s7Zh::P64 = P64[_s7Zk::P64 + 39];
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = _s7Za::P64;
           P64[Hp - 24] = _s7Zf::P64;
           P64[Hp - 16] = _s7Zg::P64;
           P64[Hp - 8] = _s7Zh::P64;
           P64[Hp] = _s7Zi::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7Zl_entry() //  [R1, R2]
         { info_tbl: [(cbcG,
                       label: sat_s7Zl_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcG: // global
           _s7Zh::P64 = R2;
           _s7Zl::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbcH; else goto cbcI;
       cbcI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbcK; else goto cbcJ;
       cbcK: // global
           HpAlloc = 48;
           goto cbcH;
       cbcH: // global
           R2 = _s7Zh::P64;
           R1 = _s7Zl::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcJ: // global
           _s7Z9::P64 = P64[_s7Zl::P64 + 7];
           _s7Za::P64 = P64[_s7Zl::P64 + 15];
           _s7Ze::P64 = P64[_s7Zl::P64 + 23];
           _s7Zf::P64 = P64[_s7Zl::P64 + 31];
           _s7Zg::P64 = P64[_s7Zl::P64 + 39];
           I64[Hp - 40] = sat_s7Zk_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zf::P64;
           P64[Hp - 8] = _s7Zg::P64;
           P64[Hp] = _s7Zh::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Ze::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7Zm_entry() //  [R1, R2]
         { info_tbl: [(cbcL,
                       label: sat_s7Zm_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcL: // global
           _s7Zg::P64 = R2;
           _s7Zm::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbcM; else goto cbcN;
       cbcN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbcP; else goto cbcO;
       cbcP: // global
           HpAlloc = 48;
           goto cbcM;
       cbcM: // global
           R2 = _s7Zg::P64;
           R1 = _s7Zm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcO: // global
           _s7Z9::P64 = P64[_s7Zm::P64 + 7];
           _s7Za::P64 = P64[_s7Zm::P64 + 15];
           _s7Zd::P64 = P64[_s7Zm::P64 + 23];
           _s7Ze::P64 = P64[_s7Zm::P64 + 31];
           _s7Zf::P64 = P64[_s7Zm::P64 + 39];
           I64[Hp - 40] = sat_s7Zl_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Ze::P64;
           P64[Hp - 8] = _s7Zf::P64;
           P64[Hp] = _s7Zg::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zd::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7Zn_entry() //  [R1, R2]
         { info_tbl: [(cbcQ,
                       label: sat_s7Zn_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcQ: // global
           _s7Zf::P64 = R2;
           _s7Zn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbcR; else goto cbcS;
       cbcS: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbcU; else goto cbcT;
       cbcU: // global
           HpAlloc = 48;
           goto cbcR;
       cbcR: // global
           R2 = _s7Zf::P64;
           R1 = _s7Zn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbcT: // global
           _s7Z9::P64 = P64[_s7Zn::P64 + 7];
           _s7Za::P64 = P64[_s7Zn::P64 + 15];
           _s7Zc::P64 = P64[_s7Zn::P64 + 23];
           _s7Zd::P64 = P64[_s7Zn::P64 + 31];
           _s7Ze::P64 = P64[_s7Zn::P64 + 39];
           I64[Hp - 40] = sat_s7Zm_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zd::P64;
           P64[Hp - 8] = _s7Ze::P64;
           P64[Hp] = _s7Zf::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zc::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbcV,
                       label: GHC.Base.liftM4_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbcV: // global
           _s7Zd::P64 = R6;
           _s7Zc::P64 = R5;
           _s7Zb::P64 = R4;
           _s7Za::P64 = R3;
           _s7Z9::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbcW; else goto cbcX;
       cbcX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbcZ; else goto cbcY;
       cbcZ: // global
           HpAlloc = 48;
           goto cbcW;
       cbcW: // global
           R6 = _s7Zd::P64;
           R5 = _s7Zc::P64;
           R4 = _s7Zb::P64;
           R3 = _s7Za::P64;
           R2 = _s7Z9::P64;
           R1 = GHC.Base.liftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbcY: // global
           I64[Hp - 40] = sat_s7Zn_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zc::P64;
           P64[Hp - 8] = _s7Zd::P64;
           P64[Hp] = P64[Sp];
           R2 = _s7Z9::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s7Zb::P64;
           P64[Sp] = Hp - 39;
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.662366602 UTC

[section ""data" . GHC.Base.liftM3_$sliftM1_closure" {
     GHC.Base.liftM3_$sliftM1_closure:
         const GHC.Base.liftM3_$sliftM1_info;
 },
 GHC.Base.liftM3_$sliftM1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbd4,
                       label: GHC.Base.liftM3_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbd4: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.663865714 UTC

[section ""data" . GHC.Base.liftM3_closure" {
     GHC.Base.liftM3_closure:
         const GHC.Base.liftM3_info;
 },
 sat_s7Zx_entry() //  [R1, R2]
         { info_tbl: [(cbdr,
                       label: sat_s7Zx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdr: // global
           _s7Zv::P64 = R2;
           _s7Zx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbds; else goto cbdt;
       cbdt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbdv; else goto cbdu;
       cbdv: // global
           HpAlloc = 48;
           goto cbds;
       cbds: // global
           R2 = _s7Zv::P64;
           R1 = _s7Zx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbdu: // global
           _s7Zo::P64 = P64[_s7Zx::P64 + 7];
           _s7Zp::P64 = P64[_s7Zx::P64 + 15];
           _s7Zt::P64 = P64[_s7Zx::P64 + 23];
           _s7Zu::P64 = P64[_s7Zx::P64 + 31];
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = _s7Zp::P64;
           P64[Hp - 16] = _s7Zt::P64;
           P64[Hp - 8] = _s7Zu::P64;
           P64[Hp] = _s7Zv::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7Zy_entry() //  [R1, R2]
         { info_tbl: [(cbdw,
                       label: sat_s7Zy_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdw: // global
           _s7Zu::P64 = R2;
           _s7Zy::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbdx; else goto cbdy;
       cbdy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbdA; else goto cbdz;
       cbdA: // global
           HpAlloc = 40;
           goto cbdx;
       cbdx: // global
           R2 = _s7Zu::P64;
           R1 = _s7Zy::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbdz: // global
           _s7Zo::P64 = P64[_s7Zy::P64 + 7];
           _s7Zp::P64 = P64[_s7Zy::P64 + 15];
           _s7Zs::P64 = P64[_s7Zy::P64 + 23];
           _s7Zt::P64 = P64[_s7Zy::P64 + 31];
           I64[Hp - 32] = sat_s7Zx_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zt::P64;
           P64[Hp] = _s7Zu::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zs::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7Zz_entry() //  [R1, R2]
         { info_tbl: [(cbdB,
                       label: sat_s7Zz_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdB: // global
           _s7Zt::P64 = R2;
           _s7Zz::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbdC; else goto cbdD;
       cbdD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbdF; else goto cbdE;
       cbdF: // global
           HpAlloc = 40;
           goto cbdC;
       cbdC: // global
           R2 = _s7Zt::P64;
           R1 = _s7Zz::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbdE: // global
           _s7Zo::P64 = P64[_s7Zz::P64 + 7];
           _s7Zp::P64 = P64[_s7Zz::P64 + 15];
           _s7Zr::P64 = P64[_s7Zz::P64 + 23];
           _s7Zs::P64 = P64[_s7Zz::P64 + 31];
           I64[Hp - 32] = sat_s7Zy_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zs::P64;
           P64[Hp] = _s7Zt::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zr::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbdG,
                       label: GHC.Base.liftM3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdG: // global
           _s7Zs::P64 = R6;
           _s7Zr::P64 = R5;
           _s7Zq::P64 = R4;
           _s7Zp::P64 = R3;
           _s7Zo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbdH; else goto cbdI;
       cbdI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbdK; else goto cbdJ;
       cbdK: // global
           HpAlloc = 40;
           goto cbdH;
       cbdH: // global
           R6 = _s7Zs::P64;
           R5 = _s7Zr::P64;
           R4 = _s7Zq::P64;
           R3 = _s7Zp::P64;
           R2 = _s7Zo::P64;
           R1 = GHC.Base.liftM3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdJ: // global
           I64[Hp - 32] = sat_s7Zz_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zr::P64;
           P64[Hp] = _s7Zs::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zq::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.666355486 UTC

[section ""data" . GHC.Base.liftM_$sliftM1_closure" {
     GHC.Base.liftM_$sliftM1_closure:
         const GHC.Base.liftM_$sliftM1_info;
 },
 GHC.Base.liftM_$sliftM1_entry() //  [R2, R3]
         { info_tbl: [(cbdP,
                       label: GHC.Base.liftM_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbdP: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.667478854 UTC

[section ""data" . GHC.Base.liftM_closure" {
     GHC.Base.liftM_closure:
         const GHC.Base.liftM_info;
 },
 sat_s7ZF_entry() //  [R1, R2]
         { info_tbl: [(cbe2,
                       label: sat_s7ZF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe2: // global
           _s7ZD::P64 = R2;
           _s7ZF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbe3; else goto cbe4;
       cbe4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbe6; else goto cbe5;
       cbe6: // global
           HpAlloc = 32;
           goto cbe3;
       cbe3: // global
           R2 = _s7ZD::P64;
           R1 = _s7ZF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbe5: // global
           _s7ZA::P64 = P64[_s7ZF::P64 + 7];
           _s7ZB::P64 = P64[_s7ZF::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s7ZB::P64;
           P64[Hp] = _s7ZD::P64;
           R2 = _s7ZA::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbe7,
                       label: GHC.Base.liftM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbe7: // global
           _s7ZC::P64 = R4;
           _s7ZB::P64 = R3;
           _s7ZA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbe8; else goto cbe9;
       cbe9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbeb; else goto cbea;
       cbeb: // global
           HpAlloc = 24;
           goto cbe8;
       cbe8: // global
           R4 = _s7ZC::P64;
           R3 = _s7ZB::P64;
           R2 = _s7ZA::P64;
           R1 = GHC.Base.liftM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbea: // global
           I64[Hp - 16] = sat_s7ZF_info;
           P64[Hp - 8] = _s7ZA::P64;
           P64[Hp] = _s7ZB::P64;
           R2 = _s7ZA::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7ZC::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.670115133 UTC

[section ""data" . GHC.Base.$!_closure" {
     GHC.Base.$!_closure:
         const GHC.Base.$!_info;
 },
 GHC.Base.$!_entry() //  [R2, R3]
         { info_tbl: [(cbei,
                       label: GHC.Base.$!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbei: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbej; else goto cbek;
       cbej: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbek: // global
           I64[Sp - 16] = block_cbeg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbeg() //  [R1]
         { info_tbl: [(cbeg,
                       label: block_cbeg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeg: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.671709363 UTC

[section ""data" . GHC.Base.$_closure" {
     GHC.Base.$_closure:
         const GHC.Base.$_info;
 },
 GHC.Base.$_entry() //  [R2, R3]
         { info_tbl: [(cbeq,
                       label: GHC.Base.$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeq: // global
           _s7ZJ::P64 = R2;
           R2 = R3;
           R1 = _s7ZJ::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.67260589 UTC

[section ""data" . GHC.Base.flip_closure" {
     GHC.Base.flip_closure:
         const GHC.Base.flip_info;
 },
 GHC.Base.flip_entry() //  [R2, R3, R4]
         { info_tbl: [(cbex,
                       label: GHC.Base.flip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbex: // global
           R3 = R3;
           _s7ZL::P64 = R2;
           R2 = R4;
           R1 = _s7ZL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.673508743 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>_closure" {
     GHC.Base.$fMonad(->)_$c>>_closure:
         const GHC.Base.$fMonad(->)_$c>>_info;
 },
 GHC.Base.$fMonad(->)_$c>>_entry() //  [R3, R4]
         { info_tbl: [(cbeE,
                       label: GHC.Base.$fMonad(->)_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeE: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.674357284 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*_closure" {
     GHC.Base.$fApplicative(->)_$c<*_closure:
         const GHC.Base.$fApplicative(->)_$c<*_info;
 },
 GHC.Base.$fApplicative(->)_$c<*_entry() //  [R2, R4]
         { info_tbl: [(cbeL,
                       label: GHC.Base.$fApplicative(->)_$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeL: // global
           _s7ZR::P64 = R2;
           R2 = R4;
           R1 = _s7ZR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.675626935 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>_closure" {
     GHC.Base.$fMonad(,)_$c>>_closure:
         const GHC.Base.$fMonad(,)_$c>>_info;
 },
 sat_s804_entry() //  [R1]
         { info_tbl: [(cbf8,
                       label: sat_s804_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbf8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbf9; else goto cbfa;
       cbf9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbf6_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbf6() //  [R1]
         { info_tbl: [(cbf6,
                       label: block_cbf6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbf6: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_$c>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbfe,
                       label: GHC.Base.$fMonad(,)_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbfg; else goto cbfh;
       cbfg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbfh: // global
           I64[Sp - 24] = block_cbeS_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubfn; else goto cbeT;
       ubfn: // global
           call _cbeS(R1) args: 0, res: 0, upd: 0;
       cbeT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbeS() //  [R1]
         { info_tbl: [(cbeS,
                       label: block_cbeS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeS: // global
           I64[Sp] = block_cbeX_info;
           _s7ZY::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7ZY::P64;
           if (R1 & 7 != 0) goto ubfm; else goto cbeY;
       ubfm: // global
           call _cbeX(R1) args: 0, res: 0, upd: 0;
       cbeY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbeX() //  [R1]
         { info_tbl: [(cbeX,
                       label: block_cbeX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbeX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbfl; else goto cbfk;
       cbfl: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfk: // global
           _s801::P64 = P64[R1 + 7];
           _s802::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s804_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s801::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s802::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.677997902 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*_closure" {
     GHC.Base.$fApplicative(,)_$c<*_closure:
         const GHC.Base.$fApplicative(,)_$c<*_info;
 },
 sat_s80f_entry() //  [R1]
         { info_tbl: [(cbfI,
                       label: sat_s80f_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbfJ; else goto cbfK;
       cbfJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbfK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbfG_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbfG() //  [R1]
         { info_tbl: [(cbfG,
                       label: block_cbfG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfG: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c<*_entry() //  [R2, R3, R4]
         { info_tbl: [(cbfO,
                       label: GHC.Base.$fApplicative(,)_$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbfQ; else goto cbfR;
       cbfQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbfR: // global
           I64[Sp - 24] = block_cbfs_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubfX; else goto cbft;
       ubfX: // global
           call _cbfs(R1) args: 0, res: 0, upd: 0;
       cbft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfs() //  [R1]
         { info_tbl: [(cbfs,
                       label: block_cbfs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfs: // global
           I64[Sp - 8] = block_cbfx_info;
           _s809::P64 = P64[R1 + 7];
           _s80a::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s80a::P64;
           P64[Sp + 16] = _s809::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubfW; else goto cbfy;
       ubfW: // global
           call _cbfx(R1) args: 0, res: 0, upd: 0;
       cbfy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbfx() //  [R1]
         { info_tbl: [(cbfx,
                       label: block_cbfx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbfx: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbfV; else goto cbfU;
       cbfV: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbfU: // global
           _s80c::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s80f_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s80c::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.680013795 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$c<$_closure" {
     GHC.Base.$fFunctor(,)_$c<$_closure:
         const GHC.Base.$fFunctor(,)_$c<$_info;
 },
 GHC.Base.$fFunctor(,)_$c<$_entry() //  [R2, R3]
         { info_tbl: [(cbg5,
                       label: GHC.Base.$fFunctor(,)_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbg9; else goto cbga;
       cbg9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbga: // global
           I64[Sp - 16] = block_cbg2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubge; else goto cbg3;
       ubge: // global
           call _cbg2(R1) args: 0, res: 0, upd: 0;
       cbg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbg2() //  [R1]
         { info_tbl: [(cbg2,
                       label: block_cbg2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbg2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbgd; else goto cbgc;
       cbgd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgc: // global
           _s80j::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s80j::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.681525934 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_$c<$_closure" {
     GHC.Base.$fFunctorMaybe_$c<$_closure:
         const GHC.Base.$fFunctorMaybe_$c<$_info;
 },
 GHC.Base.$fFunctorMaybe_$c<$_entry() //  [R2, R3]
         { info_tbl: [(cbgq,
                       label: GHC.Base.$fFunctorMaybe_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbgr; else goto cbgs;
       cbgr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorMaybe_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgs: // global
           I64[Sp - 16] = block_cbgj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubgC; else goto cbgk;
       ubgC: // global
           call _cbgj(R1) args: 0, res: 0, upd: 0;
       cbgk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbgj() //  [R1]
         { info_tbl: [(cbgj,
                       label: block_cbgj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgj: // global
           if (R1 & 7 == 1) goto cbgn; else goto cbgo;
       cbgn: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbgo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgB; else goto cbgA;
       cbgB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbgA: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.682944209 UTC

[section ""data" . GHC.Base.$dm<$_closure" {
     GHC.Base.$dm<$_closure:
         const GHC.Base.$dm<$_info;
 },
 sat_s80s_entry() //  [R1]
         { info_tbl: [(cbgM,
                       label: sat_s80s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgM: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$dm<$_entry() //  [R2, R3]
         { info_tbl: [(cbgP,
                       label: GHC.Base.$dm<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbgP: // global
           _s80q::P64 = R3;
           _s80p::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbgQ; else goto cbgR;
       cbgR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbgT; else goto cbgS;
       cbgT: // global
           HpAlloc = 16;
           goto cbgQ;
       cbgQ: // global
           R3 = _s80q::P64;
           R2 = _s80p::P64;
           R1 = GHC.Base.$dm<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbgS: // global
           I64[Hp - 8] = sat_s80s_info;
           P64[Hp] = _s80q::P64;
           R2 = _s80p::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.684302839 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmappend_closure" {
     GHC.Base.$fMonoid(->)_$cmappend_closure:
         const GHC.Base.$fMonoid(->)_$cmappend_info;
 },
 GHC.Base.$fMonoid(->)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbh2,
                       label: GHC.Base.$fMonoid(->)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh2: // global
           _s80w::P64 = R5;
           _s80v::P64 = R4;
           _s80u::P64 = R3;
           _s80t::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbh3; else goto cbh4;
       cbh4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbh6; else goto cbh5;
       cbh6: // global
           HpAlloc = 64;
           goto cbh3;
       cbh3: // global
           R5 = _s80w::P64;
           R4 = _s80v::P64;
           R3 = _s80u::P64;
           R2 = _s80t::P64;
           R1 = GHC.Base.$fMonoid(->)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbh5: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s80v::P64;
           P64[Hp - 32] = _s80w::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s80u::P64;
           P64[Hp] = _s80w::P64;
           I64[Sp - 24] = block_cbh0_info;
           R2 = _s80t::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbh0() //  [R1]
         { info_tbl: [(cbh0,
                       label: block_cbh0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbh0: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbgY::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbgY::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.686482396 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,)_$cmappend_info;
 },
 sat_s80N_entry() //  [R1]
         { info_tbl: [(cbhu,
                       label: sat_s80N_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbhv; else goto cbhw;
       cbhv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbhs_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbhs() //  [R1]
         { info_tbl: [(cbhs,
                       label: block_cbhs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhs: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s80L_entry() //  [R1]
         { info_tbl: [(cbhG,
                       label: sat_s80L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbhH; else goto cbhI;
       cbhH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbhI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbhE_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbhE() //  [R1]
         { info_tbl: [(cbhE,
                       label: block_cbhE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhE: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbhM,
                       label: GHC.Base.$fMonoid(,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbhO; else goto cbhP;
       cbhO: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbhP: // global
           I64[Sp - 32] = block_cbhe_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubhV; else goto cbhf;
       ubhV: // global
           call _cbhe(R1) args: 0, res: 0, upd: 0;
       cbhf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhe() //  [R1]
         { info_tbl: [(cbhe,
                       label: block_cbhe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhe: // global
           I64[Sp - 8] = block_cbhj_info;
           _s80F::P64 = P64[R1 + 7];
           _s80G::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s80G::P64;
           P64[Sp + 24] = _s80F::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubhU; else goto cbhk;
       ubhU: // global
           call _cbhj(R1) args: 0, res: 0, upd: 0;
       cbhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbhj() //  [R1]
         { info_tbl: [(cbhj,
                       label: block_cbhj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhj: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbhT; else goto cbhS;
       cbhT: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbhS: // global
           _s80I::P64 = P64[R1 + 7];
           _s80J::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s80N_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s80J::P64;
           I64[Hp - 56] = sat_s80L_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s80I::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.689991998 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_go_closure" {
     GHC.Base.$fSemigroupOrdering_go_closure:
         const GHC.Base.$fSemigroupOrdering_go_info;
 },
 GHC.Base.$fSemigroupOrdering_go_entry() //  [R2, R3]
         { info_tbl: [(cbi7,
                       label: GHC.Base.$fSemigroupOrdering_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbi7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbi8; else goto ubiy;
       cbi8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubiy: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbhX() args: 0, res: 0, upd: 0;
     }
 },
 _cbhX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbhX: // global
           I64[Sp - 8] = block_cbi0_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiA; else goto cbi1;
       ubiA: // global
           call _cbi0(R1) args: 0, res: 0, upd: 0;
       cbi1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbi0() //  [R1]
         { info_tbl: [(cbi0,
                       label: block_cbi0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbi0: // global
           _s80O::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbi4; else goto cbi5;
       cbi4: // global
           R1 = _s80O::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbi5: // global
           I64[Sp] = block_cbif_info;
           _s80R::P64 = P64[R1 + 6];
           _s80S::P64 = P64[R1 + 14];
           R1 = _s80O::P64;
           P64[Sp + 8] = _s80S::P64;
           P64[Sp + 16] = _s80R::P64;
           if (R1 & 7 != 0) goto ubiB; else goto cbih;
       ubiB: // global
           call _cbif(R1) args: 0, res: 0, upd: 0;
       cbih: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbif() //  [R1]
         { info_tbl: [(cbif,
                       label: block_cbif_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbif: // global
           _cbiw::P64 = R1 & 7;
           if (_cbiw::P64 < 3) goto ubix; else goto cbiv;
       ubix: // global
           if (_cbiw::P64 < 2) goto cbin; else goto cbir;
       cbin: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbir: // global
           _s80P::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s80P::P64;
           Sp = Sp + 8;
           call _cbhX() args: 0, res: 0, upd: 0;
       cbiv: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.691709928 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_$csconcat_closure" {
     GHC.Base.$fSemigroupOrdering_$csconcat_closure:
         const GHC.Base.$fSemigroupOrdering_$csconcat_info;
 },
 GHC.Base.$fSemigroupOrdering_$csconcat_entry() //  [R2]
         { info_tbl: [(cbiL,
                       label: GHC.Base.$fSemigroupOrdering_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbiM; else goto cbiN;
       cbiM: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbiN: // global
           I64[Sp - 8] = block_cbiI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubiR; else goto cbiJ;
       ubiR: // global
           call _cbiI(R1) args: 0, res: 0, upd: 0;
       cbiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbiI() //  [R1]
         { info_tbl: [(cbiI,
                       label: block_cbiI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiI: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupOrdering_go_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.692880607 UTC

[section ""data" . GHC.Base.._closure" {
     GHC.Base.._closure:
         const GHC.Base.._info;
 },
 GHC.Base.._entry() //  [R2, R3, R4]
         { info_tbl: [(cbiX,
                       label: GHC.Base.._info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbiX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbj1; else goto cbj0;
       cbj1: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbj0: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _s80Y::P64 = R2;
           R2 = Hp - 24;
           R1 = _s80Y::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.694025618 UTC

[section ""data" . GHC.Base.mapFB_closure" {
     GHC.Base.mapFB_closure:
         const GHC.Base.mapFB_info;
 },
 GHC.Base.mapFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbj7,
                       label: GHC.Base.mapFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbj7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbjb; else goto cbja;
       cbjb: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbja: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _s812::P64 = R2;
           R2 = Hp - 24;
           R1 = _s812::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.694989337 UTC

[section ""data" . GHC.Base.$fFunctor(->)_$c<$_closure" {
     GHC.Base.$fFunctor(->)_$c<$_closure:
         const GHC.Base.$fFunctor(->)_$c<$_info;
 },
 GHC.Base.$fFunctor(->)_$c<$_entry() //  [R2]
         { info_tbl: [(cbjg,
                       label: GHC.Base.$fFunctor(->)_$c<$_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbjg: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.695724673 UTC

[section ""data" . GHC.Base.$fFunctor(->)_closure" {
     GHC.Base.$fFunctor(->)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.._closure+3;
         const GHC.Base.$fFunctor(->)_$c<$_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.69641934 UTC

[section ""data" . GHC.Base.const_closure" {
     GHC.Base.const_closure:
         const GHC.Base.const_info;
 },
 GHC.Base.const_entry() //  [R2]
         { info_tbl: [(cbjn,
                       label: GHC.Base.const_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbjn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.69719077 UTC

[section ""data" . GHC.Base.asTypeOf_closure" {
     GHC.Base.asTypeOf_closure:
         const GHC.Base.asTypeOf_info;
 },
 GHC.Base.asTypeOf_entry() //  [R2, R3]
         { info_tbl: [(cbju,
                       label: GHC.Base.asTypeOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbju: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.698133345 UTC

[section ""data" . GHC.Base.$dm<*_closure" {
     GHC.Base.$dm<*_closure:
         const GHC.Base.$dm<*_info;
 },
 GHC.Base.$dm<*_entry() //  [R2]
         { info_tbl: [(cbjB,
                       label: GHC.Base.$dm<*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbjB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbjC; else goto cbjD;
       cbjC: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbjD: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.const_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.699170249 UTC

[section ""data" . GHC.Base.$fApplicativeIO1_closure" {
     GHC.Base.$fApplicativeIO1_closure:
         const GHC.Base.$fApplicativeIO1_info;
 },
 GHC.Base.$fApplicativeIO1_entry() //  [R2, R3]
         { info_tbl: [(cbjM,
                       label: GHC.Base.$fApplicativeIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbjM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbjN; else goto cbjO;
       cbjN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbjO: // global
           I64[Sp - 16] = block_cbjI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbjI() //  [R1]
         { info_tbl: [(cbjI,
                       label: block_cbjI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbjI: // global
           I64[Sp] = block_cbjK_info;
           _s81i::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s81i::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbjK() //  []
         { info_tbl: [(cbjK,
                       label: block_cbjK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbjK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.700228094 UTC

[section ""data" . GHC.Base.$fApplicativeIO_closure" {
     GHC.Base.$fApplicativeIO_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorIO_closure+1;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fApplicativeIO3_closure+3;
         const GHC.Base.$fApplicativeIO_$cliftA2_closure+4;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.700933863 UTC

[section ""data" . GHC.Base.breakpointCond_closure" {
     GHC.Base.breakpointCond_closure:
         const GHC.Base.breakpointCond_info;
 },
 GHC.Base.breakpointCond_entry() //  [R3]
         { info_tbl: [(cbjV,
                       label: GHC.Base.breakpointCond_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbjV: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.701781929 UTC

[section ""data" . GHC.Base.breakpoint_closure" {
     GHC.Base.breakpoint_closure:
         const GHC.Base.breakpoint_info;
 },
 GHC.Base.breakpoint_entry() //  [R2]
         { info_tbl: [(cbk2,
                       label: GHC.Base.breakpoint_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbk2: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.702603522 UTC

[section ""data" . GHC.Base.assert_closure" {
     GHC.Base.assert_closure:
         const GHC.Base.assert_info;
 },
 GHC.Base.assert_entry() //  [R2, R3]
         { info_tbl: [(cbk9,
                       label: GHC.Base.assert_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbk9: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.breakpointCond_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.703432257 UTC

[section ""data" . GHC.Base.id_closure" {
     GHC.Base.id_closure:
         const GHC.Base.id_info;
 },
 GHC.Base.id_entry() //  [R2]
         { info_tbl: [(cbkg,
                       label: GHC.Base.id_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbkg: // global
           R2 = R2;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.704962714 UTC

[section ""data" . GHC.Base.join_closure" {
     GHC.Base.join_closure:
         const GHC.Base.join_info;
 },
 GHC.Base.join_entry() //  [R2, R3]
         { info_tbl: [(cbkn,
                       label: GHC.Base.join_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbkn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbko; else goto cbkp;
       cbko: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.join_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbkp: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.706007154 UTC

[section ""data" . GHC.Base.$dm<*>_closure" {
     GHC.Base.$dm<*>_closure:
         const GHC.Base.$dm<*>_info;
 },
 GHC.Base.$dm<*>_entry() //  [R2]
         { info_tbl: [(cbku,
                       label: GHC.Base.$dm<*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbkv; else goto cbkw;
       cbkv: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbkw: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.707209678 UTC

[section ""data" . GHC.Base.$dm*>_closure" {
     GHC.Base.$dm*>_closure:
         const GHC.Base.$dm*>_info;
 },
 sat_s81w_entry() //  [R1]
         { info_tbl: [(cbkH,
                       label: sat_s81w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbkH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbkI; else goto cbkJ;
       cbkI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbkJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbkF_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbkF() //  [R1]
         { info_tbl: [(cbkF,
                       label: block_cbkF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbkF: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 8;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dm*>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbkN,
                       label: GHC.Base.$dm*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbkN: // global
           _s81u::P64 = R4;
           _s81t::P64 = R3;
           _s81s::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbkO; else goto cbkP;
       cbkP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbkR; else goto cbkQ;
       cbkR: // global
           HpAlloc = 32;
           goto cbkO;
       cbkO: // global
           R4 = _s81u::P64;
           R3 = _s81t::P64;
           R2 = _s81s::P64;
           R1 = GHC.Base.$dm*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbkQ: // global
           I64[Hp - 24] = sat_s81w_info;
           P64[Hp - 8] = _s81s::P64;
           P64[Hp] = _s81t::P64;
           R2 = _s81s::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s81u::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.708649708 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c*>_closure" {
     GHC.Base.$fApplicative(->)_$c*>_closure:
         const GHC.Base.$fApplicative(->)_$c*>_info;
 },
 GHC.Base.$fApplicative(->)_$c*>_entry() //  [R3, R4]
         { info_tbl: [(cbkW,
                       label: GHC.Base.$fApplicative(->)_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbkW: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.709635799 UTC

[section ""data" . GHC.Base.maxInt_closure" {
     GHC.Base.maxInt_closure:
         const GHC.Types.I#_con_info;
         const 9223372036854775807;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.710462222 UTC

[section ""data" . GHC.Base.minInt_closure" {
     GHC.Base.minInt_closure:
         const GHC.Types.I#_con_info;
         const (-9223372036854775808);
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.711285226 UTC

[section ""data" . GHC.Base.ord_closure" {
     GHC.Base.ord_closure:
         const GHC.Base.ord_info;
 },
 GHC.Base.ord_entry() //  [R2]
         { info_tbl: [(cbl6,
                       label: GHC.Base.ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbl6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbld; else goto cble;
       cbld: // global
           R2 = R2;
           R1 = GHC.Base.ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cble: // global
           I64[Sp - 8] = block_cbl3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubli; else goto cbl4;
       ubli: // global
           call _cbl3(R1) args: 0, res: 0, upd: 0;
       cbl4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbl3() //  [R1]
         { info_tbl: [(cbl3,
                       label: block_cbl3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbl3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cblh; else goto cblg;
       cblh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cblg: // global
           _s81D::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s81D::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.712646015 UTC

[section ""data" . GHC.Base.unsafeChr_closure" {
     GHC.Base.unsafeChr_closure:
         const GHC.Base.unsafeChr_info;
 },
 GHC.Base.unsafeChr_entry() //  [R2]
         { info_tbl: [(cblq,
                       label: GHC.Base.unsafeChr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cblq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cblx; else goto cbly;
       cblx: // global
           R2 = R2;
           R1 = GHC.Base.unsafeChr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbly: // global
           I64[Sp - 8] = block_cbln_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ublC; else goto cblo;
       ublC: // global
           call _cbln(R1) args: 0, res: 0, upd: 0;
       cblo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbln() //  [R1]
         { info_tbl: [(cbln,
                       label: block_cbln_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbln: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cblB; else goto cblA;
       cblB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cblA: // global
           _s81H::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s81H::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.713774404 UTC

[section ""data" . GHC.Base.otherwise_closure" {
     GHC.Base.otherwise_closure:
         const GHC.Types.True_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.714802167 UTC

[section ""data" . GHC.Base.until_closure" {
     GHC.Base.until_closure:
         const GHC.Base.until_info;
 },
 GHC.Base.until_entry() //  [R2, R3, R4]
         { info_tbl: [(cblJ,
                       label: GHC.Base.until_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cblJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cblK; else goto cblL;
       cblK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.until_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cblL: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cblN() args: 0, res: 0, upd: 0;
     }
 },
 _cblN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cblN: // global
           I64[Sp - 8] = block_cblP_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cblP() //  [R1]
         { info_tbl: [(cblP,
                       label: block_cblP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cblP: // global
           _s81M::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cblT; else goto cbm2;
       cblT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cblY; else goto cblX;
       cblY: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cblX: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s81M::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call _cblN() args: 0, res: 0, upd: 0;
       cbm2: // global
           R1 = _s81M::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.716679307 UTC

[section ""data" . GHC.Base.divModInt#_closure" {
     GHC.Base.divModInt#_closure:
         const GHC.Base.divModInt#_info;
 },
 GHC.Base.divModInt#_entry() //  [R2, R3]
         { info_tbl: [(cbmi,
                       label: GHC.Base.divModInt#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbmi: // global
           if (%MO_S_Le_W64(R2, 0)) goto cbmg; else goto cbmh;
       cbmg: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cbms; else goto cbmC;
       cbms: // global
           _s81Q::I64 = R3;
           (_cbmp::I64, _cbmq::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _cbmq::I64;
           R1 = _cbmp::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbmC: // global
           if (%MO_S_Le_W64(R3, 0)) goto cbmA; else goto cbmB;
       cbmA: // global
           _s81Q::I64 = R3;
           (_cbmx::I64, _cbmy::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _cbmy::I64;
           R1 = _cbmx::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbmB: // global
           _s81Q::I64 = R3;
           (_s81W::I64, _s81X::I64) = call MO_S_QuotRem W64(R2 + 1, _s81Q::I64);
           R2 = _s81X::I64 + _s81Q::I64 - 1;
           R1 = _s81W::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbmh: // global
           if (%MO_S_Ge_W64(R3, 0)) goto cbmZ; else goto cbn0;
       cbmZ: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cbmN; else goto cbmX;
       cbmN: // global
           _s81Q::I64 = R3;
           (_cbmK::I64, _cbmL::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _cbmL::I64;
           R1 = _cbmK::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbmX: // global
           if (%MO_S_Le_W64(R3, 0)) goto cbmV; else goto cbmW;
       cbmV: // global
           _s81Q::I64 = R3;
           (_cbmS::I64, _cbmT::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _cbmT::I64;
           R1 = _cbmS::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbmW: // global
           _s81Q::I64 = R3;
           (_s826::I64, _s827::I64) = call MO_S_QuotRem W64(R2 + 1, _s81Q::I64);
           R2 = _s827::I64 + _s81Q::I64 - 1;
           R1 = _s826::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbn0: // global
           _s81Q::I64 = R3;
           (_s82d::I64, _s82e::I64) = call MO_S_QuotRem W64(R2 - 1, _s81Q::I64);
           R2 = _s82e::I64 + _s81Q::I64 + 1;
           R1 = _s82d::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.719211039 UTC

[section ""data" . GHC.Base.divModInt_closure" {
     GHC.Base.divModInt_closure:
         const GHC.Base.divModInt_info;
 },
 GHC.Base.divModInt_entry() //  [R2, R3]
         { info_tbl: [(cbnF,
                       label: GHC.Base.divModInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbnF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbnJ; else goto cbnK;
       cbnJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divModInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbnK: // global
           I64[Sp - 16] = block_cbnC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpv; else goto cbnD;
       ubpv: // global
           call _cbnC(R1) args: 0, res: 0, upd: 0;
       cbnD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbnC() //  [R1]
         { info_tbl: [(cbnC,
                       label: block_cbnC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbnC: // global
           I64[Sp] = block_cbnI_info;
           _s82l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s82l::I64;
           if (R1 & 7 != 0) goto ubpu; else goto cbnM;
       ubpu: // global
           call _cbnI(R1) args: 0, res: 0, upd: 0;
       cbnM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbnI() //  [R1]
         { info_tbl: [(cbnI,
                       label: block_cbnI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbnI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbnS; else goto cbnR;
       cbnS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbnR: // global
           _s82l::I64 = I64[Sp + 8];
           _s82n::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s82l::I64, 0)) goto cbow; else goto cbpt;
       cbow: // global
           if (%MO_S_Ge_W64(_s82l::I64, 0)) goto cbo3; else goto cbou;
       cbo3: // global
           (_s82r::I64, _s82s::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82s::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82r::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbou: // global
           if (%MO_S_Le_W64(_s82n::I64, 0)) goto cboc; else goto cbot;
       cboc: // global
           (_s82x::I64, _s82y::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82y::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82x::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbot: // global
           (_s82D::I64, _s82E::I64) = call MO_S_QuotRem W64(_s82l::I64 + 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82E::I64 + _s82n::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82D::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpt: // global
           if (%MO_S_Ge_W64(_s82n::I64, 0)) goto cbpb; else goto cbps;
       cbpb: // global
           if (%MO_S_Ge_W64(_s82l::I64, 0)) goto cboI; else goto cbp9;
       cboI: // global
           (_s82N::I64, _s82O::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82O::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82N::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbp9: // global
           if (%MO_S_Le_W64(_s82n::I64, 0)) goto cboR; else goto cbp8;
       cboR: // global
           (_s82T::I64, _s82U::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82U::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82T::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbp8: // global
           (_s82Z::I64, _s830::I64) = call MO_S_QuotRem W64(_s82l::I64 + 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s830::I64 + _s82n::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82Z::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbps: // global
           (_s838::I64, _s839::I64) = call MO_S_QuotRem W64(_s82l::I64 - 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s839::I64 + _s82n::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s838::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.721949809 UTC

[section ""data" . GHC.Base.shiftL#_closure" {
     GHC.Base.shiftL#_closure:
         const GHC.Base.shiftL#_info;
 },
 GHC.Base.shiftL#_entry() //  [R2, R3]
         { info_tbl: [(cbpF,
                       label: GHC.Base.shiftL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpF: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cbpD; else goto cbpE;
       cbpD: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpE: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.723602539 UTC

[section ""data" . GHC.Base.shiftRL#_closure" {
     GHC.Base.shiftRL#_closure:
         const GHC.Base.shiftRL#_info;
 },
 GHC.Base.shiftRL#_entry() //  [R2, R3]
         { info_tbl: [(cbpT,
                       label: GHC.Base.shiftRL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpT: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cbpR; else goto cbpS;
       cbpR: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpS: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.724548069 UTC

[section ""data" . GHC.Base.iShiftL#_closure" {
     GHC.Base.iShiftL#_closure:
         const GHC.Base.iShiftL#_info;
 },
 GHC.Base.iShiftL#_entry() //  [R2, R3]
         { info_tbl: [(cbq7,
                       label: GHC.Base.iShiftL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq7: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cbq5; else goto cbq6;
       cbq5: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbq6: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.725579968 UTC

[section ""data" . GHC.Base.iShiftRA#_closure" {
     GHC.Base.iShiftRA#_closure:
         const GHC.Base.iShiftRA#_info;
 },
 GHC.Base.iShiftRA#_entry() //  [R2, R3]
         { info_tbl: [(cbql,
                       label: GHC.Base.iShiftRA#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbql: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cbqj; else goto cbqk;
       cbqj: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbqk: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cbqu; else goto cbqv;
       cbqu: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbqv: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.726530542 UTC

[section ""data" . GHC.Base.iShiftRL#_closure" {
     GHC.Base.iShiftRL#_closure:
         const GHC.Base.iShiftRL#_info;
 },
 GHC.Base.iShiftRL#_entry() //  [R2, R3]
         { info_tbl: [(cbqF,
                       label: GHC.Base.iShiftRL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqF: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cbqD; else goto cbqE;
       cbqD: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbqE: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.727418266 UTC

[section ""data" . GHC.Base.build_closure" {
     GHC.Base.build_closure:
         const GHC.Base.build_info;
 },
 GHC.Base.build_entry() //  [R2]
         { info_tbl: [(cbqO,
                       label: GHC.Base.build_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqO: // global
           R3 = GHC.Types.[]_closure+1;
           _s83v::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _s83v::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.72830902 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cpure_closure" {
     GHC.Base.$fApplicative[]_$cpure_closure:
         const GHC.Base.$fApplicative[]_$cpure_info;
 },
 GHC.Base.$fApplicative[]_$cpure_entry() //  [R2]
         { info_tbl: [(cbqW,
                       label: GHC.Base.$fApplicative[]_$cpure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr0; else goto cbqZ;
       cbr0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.72923125 UTC

[section ""data" . GHC.Base.augment_closure" {
     GHC.Base.augment_closure:
         const GHC.Base.augment_info;
 },
 GHC.Base.augment_entry() //  [R2, R3]
         { info_tbl: [(cbr5,
                       label: GHC.Base.augment_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr5: // global
           R3 = R3;
           _s83x::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _s83x::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.731496741 UTC

[section ""data" . GHC.Base.++_closure" {
     GHC.Base.++_closure:
         const GHC.Base.++_info;
 },
 sat_s83E_entry() //  [R1]
         { info_tbl: [(cbrm,
                       label: sat_s83E_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrn; else goto cbro;
       cbrn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbro: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.++_entry() //  [R2, R3]
         { info_tbl: [(cbrt,
                       label: GHC.Base.++_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbru; else goto cbrv;
       cbru: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.++_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrv: // global
           I64[Sp - 16] = block_cbrc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubrC; else goto cbrd;
       ubrC: // global
           call _cbrc(R1) args: 0, res: 0, upd: 0;
       cbrd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrc() //  [R1]
         { info_tbl: [(cbrc,
                       label: block_cbrc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrc: // global
           _s83A::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbrq; else goto cbrr;
       cbrq: // global
           R1 = _s83A::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbrr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbrB; else goto cbrA;
       cbrB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrA: // global
           _s83C::P64 = P64[R1 + 6];
           _s83D::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_s83E_info;
           P64[Hp - 32] = _s83A::P64;
           P64[Hp - 24] = _s83D::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s83C::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.foldr_closure" {
     GHC.Base.foldr_closure:
         const GHC.Base.foldr_info;
 },
 go_s83I_entry() //  [R1, R2]
         { info_tbl: [(cbrT,
                       label: go_s83I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbrU; else goto cbrV;
       cbrU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrV: // global
           I64[Sp - 32] = block_cbrM_info;
           _s83I::P64 = R1;
           _s83F::P64 = P64[R1 + 7];
           _s83G::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s83F::P64;
           P64[Sp - 16] = _s83G::P64;
           P64[Sp - 8] = _s83I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubs5; else goto cbrN;
       ubs5: // global
           call _cbrM(R1) args: 0, res: 0, upd: 0;
       cbrN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrM() //  [R1]
         { info_tbl: [(cbrM,
                       label: block_cbrM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrM: // global
           if (R1 & 7 == 1) goto cbrQ; else goto cbrR;
       cbrQ: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbrR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbs4; else goto cbs3;
       cbs4: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbs3: // global
           _s83L::P64 = P64[R1 + 6];
           _s83M::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s83M::P64;
           R3 = Hp - 24;
           R2 = _s83L::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.foldr_entry() //  [R2, R3, R4]
         { info_tbl: [(cbs6,
                       label: GHC.Base.foldr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbsa; else goto cbs9;
       cbsa: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.foldr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbs9: // global
           I64[Hp - 16] = go_s83I_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go_s83I_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.map_closure" {
     GHC.Base.map_closure:
         const GHC.Base.map_info;
 },
 sat_s83U_entry() //  [R1]
         { info_tbl: [(cbsp,
                       label: sat_s83U_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsq; else goto cbsr;
       cbsq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.map_entry() //  [R2, R3]
         { info_tbl: [(cbsw,
                       label: GHC.Base.map_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsx; else goto cbsy;
       cbsx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbsy: // global
           I64[Sp - 16] = block_cbsf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubsG; else goto cbsg;
       ubsG: // global
           call _cbsf(R1) args: 0, res: 0, upd: 0;
       cbsg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsf() //  [R1]
         { info_tbl: [(cbsf,
                       label: block_cbsf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsf: // global
           if (R1 & 7 == 1) goto cbst; else goto cbsu;
       cbst: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbsu: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbsF; else goto cbsE;
       cbsF: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsE: // global
           _s83R::P64 = P64[R1 + 6];
           _s83S::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_s83U_info;
           _s83O::P64 = P64[Sp + 8];
           P64[Hp - 64] = _s83O::P64;
           P64[Hp - 56] = _s83S::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s83O::P64;
           P64[Hp - 24] = _s83R::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.735811065 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$c<>_closure" {
     GHC.Base.$fSemigroupNonEmpty_$c<>_closure:
         const GHC.Base.$fSemigroupNonEmpty_$c<>_info;
 },
 sat_s849_entry() //  [R1]
         { info_tbl: [(cbsX,
                       label: sat_s849_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsX: // global
           _s849::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbsY; else goto cbsZ;
       cbsZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbt1; else goto cbt0;
       cbt1: // global
           HpAlloc = 72;
           goto cbsY;
       cbsY: // global
           R1 = _s849::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbt0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s849::P64;
           _s83W::P64 = P64[_s849::P64 + 16];
           _s83Z::P64 = P64[_s849::P64 + 24];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _s83W::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _s83W::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _s83Z::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupNonEmpty_$c<>_entry() //  [R2, R3]
         { info_tbl: [(cbt2,
                       label: GHC.Base.$fSemigroupNonEmpty_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbt4; else goto cbt5;
       cbt4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbt5: // global
           I64[Sp - 16] = block_cbsL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubt9; else goto cbsM;
       ubt9: // global
           call _cbsL(R1) args: 0, res: 0, upd: 0;
       cbsM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsL() //  [R1]
         { info_tbl: [(cbsL,
                       label: block_cbsL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbt8; else goto cbt7;
       cbt8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt7: // global
           _s83Y::P64 = P64[R1 + 7];
           _s83Z::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_s849_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s83Z::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _s83Y::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.738296864 UTC

[section ""data" . GHC.Base.$wpoly_go_closure" {
     GHC.Base.$wpoly_go_closure:
         const GHC.Base.$wpoly_go_info;
 },
 ds_s84g_entry() //  [R1]
         { info_tbl: [(cbtv,
                       label: ds_s84g_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbtB; else goto cbtC;
       cbtB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbts_info;
           _s84f::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s84f::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubtH; else goto cbtt;
       ubtH: // global
           call _cbts(R1) args: 0, res: 0, upd: 0;
       cbtt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbts() //  [R1]
         { info_tbl: [(cbts,
                       label: block_cbts_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbts: // global
           _s84f::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbty_info;
           R4 = _s84f::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbty() //  [R1, R2]
         { info_tbl: [(cbty,
                       label: block_cbty_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbty: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtG; else goto cbtF;
       cbtG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbtF: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s84w_entry() //  [R1]
         { info_tbl: [(cbtL,
                       label: sat_s84w_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtL: // global
           _s84w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbtM; else goto cbtN;
       cbtN: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbtP; else goto cbtO;
       cbtP: // global
           HpAlloc = 104;
           goto cbtM;
       cbtM: // global
           R1 = _s84w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s84w::P64;
           _s84b::P64 = P64[_s84w::P64 + 16];
           _s84e::P64 = P64[_s84w::P64 + 24];
           _s84f::P64 = P64[_s84w::P64 + 32];
           I64[Hp - 96] = ds_s84g_info;
           P64[Hp - 80] = _s84e::P64;
           P64[Hp - 72] = _s84f::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cbto::P64 = Hp - 96;
           P64[Hp - 48] = _cbto::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cbto::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _s84b::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$wpoly_go_entry() //  [R2, R3, R4]
         { info_tbl: [(cbtU,
                       label: GHC.Base.$wpoly_go_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtV; else goto cbtW;
       cbtV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$wpoly_go_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbtW: // global
           I64[Sp - 24] = block_cbte_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubu2; else goto cbtf;
       ubu2: // global
           call _cbte(R1) args: 0, res: 0, upd: 0;
       cbtf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbte() //  [R1]
         { info_tbl: [(cbte,
                       label: block_cbte_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbte: // global
           _s84a::P64 = P64[Sp + 8];
           _s84b::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbtR; else goto cbtS;
       cbtR: // global
           R2 = _s84b::P64;
           R1 = _s84a::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbtS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbu1; else goto cbu0;
       cbu1: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbu0: // global
           _s84e::P64 = P64[R1 + 6];
           _s84f::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_s84w_info;
           P64[Hp - 16] = _s84b::P64;
           P64[Hp - 8] = _s84e::P64;
           P64[Hp] = _s84f::P64;
           R2 = Hp - 32;
           R1 = _s84a::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.742210179 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty1_closure" {
     GHC.Base.$fSemigroupNonEmpty1_closure:
         const GHC.Base.$fSemigroupNonEmpty1_info;
 },
 GHC.Base.$fSemigroupNonEmpty1_entry() //  [R2, R3]
         { info_tbl: [(cbua,
                       label: GHC.Base.$fSemigroupNonEmpty1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbua: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbug; else goto cbuh;
       cbug: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbuh: // global
           I64[Sp - 16] = block_cbu7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubum; else goto cbu8;
       ubum: // global
           call _cbu7(R1) args: 0, res: 0, upd: 0;
       cbu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbu7() //  [R1]
         { info_tbl: [(cbu7,
                       label: block_cbu7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbu7: // global
           _s84y::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbud_info;
           R4 = _s84y::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbud() //  [R1, R2]
         { info_tbl: [(cbud,
                       label: block_cbud_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbud: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbul; else goto cbuk;
       cbul: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cbuk: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.743670341 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$csconcat_closure" {
     GHC.Base.$fSemigroupNonEmpty_$csconcat_closure:
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_info;
 },
 GHC.Base.$fSemigroupNonEmpty_$csconcat_entry() //  [R2]
         { info_tbl: [(cbuu,
                       label: GHC.Base.$fSemigroupNonEmpty_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbuv; else goto cbuw;
       cbuv: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuw: // global
           I64[Sp - 8] = block_cbur_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubuA; else goto cbus;
       ubuA: // global
           call _cbur(R1) args: 0, res: 0, upd: 0;
       cbus: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbur() //  [R1]
         { info_tbl: [(cbur,
                       label: block_cbur_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbur: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupNonEmpty1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.74476111 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_closure" {
     GHC.Base.$fSemigroupNonEmpty_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fSemigroupNonEmpty_$c<>_closure+2;
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_closure+1;
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupNonEmpty_$cstimes_closure" {
     GHC.Base.$fSemigroupNonEmpty_$cstimes_closure:
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupNonEmpty_$cstimes_entry() //  [R2]
         { info_tbl: [(cbuF,
                       label: GHC.Base.$fSemigroupNonEmpty_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuF: // global
           R3 = GHC.Base.$fSemigroupNonEmpty_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.746125223 UTC

[section ""data" . GHC.Base.$fSemigroup[]1_closure" {
     GHC.Base.$fSemigroup[]1_closure:
         const GHC.Base.$fSemigroup[]1_info;
 },
 sat_s84P_entry() //  [R1]
         { info_tbl: [(cbuW,
                       label: sat_s84P_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuW: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup[]1_entry() //  [R2, R3]
         { info_tbl: [(cbv3,
                       label: GHC.Base.$fSemigroup[]1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbv4; else goto cbv5;
       cbv4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbv5: // global
           I64[Sp - 16] = block_cbuM_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubvb; else goto cbuN;
       ubvb: // global
           call _cbuM(R1) args: 0, res: 0, upd: 0;
       cbuN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuM() //  [R1]
         { info_tbl: [(cbuM,
                       label: block_cbuM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuM: // global
           _s84K::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbv0; else goto cbv1;
       cbv0: // global
           R1 = _s84K::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbv1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbva; else goto cbv9;
       cbva: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbv9: // global
           _s84N::P64 = P64[R1 + 6];
           _s84O::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s84P_info;
           P64[Hp - 8] = _s84N::P64;
           P64[Hp] = _s84O::P64;
           R3 = Hp - 24;
           R2 = _s84K::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.74769431 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$csconcat_closure" {
     GHC.Base.$fSemigroup[]_$csconcat_closure:
         const GHC.Base.$fSemigroup[]_$csconcat_info;
 },
 GHC.Base.$fSemigroup[]_$csconcat_entry() //  [R2]
         { info_tbl: [(cbvj,
                       label: GHC.Base.$fSemigroup[]_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbvk; else goto cbvl;
       cbvk: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvl: // global
           I64[Sp - 8] = block_cbvg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvp; else goto cbvh;
       ubvp: // global
           call _cbvg(R1) args: 0, res: 0, upd: 0;
       cbvh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvg() //  [R1]
         { info_tbl: [(cbvg,
                       label: block_cbvg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvg: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.749818831 UTC

[section ""data" . GHC.Base.mapM_closure" {
     GHC.Base.mapM_closure:
         const GHC.Base.mapM_info;
 },
 z_s84X_entry() //  [R1]
         { info_tbl: [(cbvy,
                       label: z_s84X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbvz; else goto cbvA;
       cbvz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s858_entry() //  [R1, R2]
         { info_tbl: [(cbvY,
                       label: sat_s858_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvY: // global
           _s856::P64 = R2;
           _s858::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbvZ; else goto cbw0;
       cbw0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbw2; else goto cbw1;
       cbw2: // global
           HpAlloc = 24;
           goto cbvZ;
       cbvZ: // global
           R2 = _s856::P64;
           R1 = _s858::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbw1: // global
           _s84U::P64 = P64[_s858::P64 + 7];
           _s855::P64 = P64[_s858::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s855::P64;
           P64[Hp] = _s856::P64;
           R2 = _s84U::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s859_entry() //  [R1, R2]
         { info_tbl: [(cbw3,
                       label: sat_s859_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw3: // global
           _s855::P64 = R2;
           _s859::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbw4; else goto cbw5;
       cbw5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbw7; else goto cbw6;
       cbw7: // global
           HpAlloc = 24;
           goto cbw4;
       cbw4: // global
           R2 = _s855::P64;
           R1 = _s859::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbw6: // global
           _s84U::P64 = P64[_s859::P64 + 7];
           _s853::P64 = P64[_s859::P64 + 15];
           I64[Hp - 16] = sat_s858_info;
           P64[Hp - 8] = _s84U::P64;
           P64[Hp] = _s855::P64;
           R2 = _s84U::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s853::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 go_s84Y_entry() //  [R1, R2]
         { info_tbl: [(cbwc,
                       label: go_s84Y_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbwd; else goto cbwe;
       cbwd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwe: // global
           I64[Sp - 40] = block_cbvG_info;
           _s84Y::P64 = R1;
           _s84U::P64 = P64[R1 + 7];
           _s84V::P64 = P64[R1 + 15];
           _s84X::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s84U::P64;
           P64[Sp - 24] = _s84V::P64;
           P64[Sp - 16] = _s84X::P64;
           P64[Sp - 8] = _s84Y::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubwl; else goto cbvH;
       ubwl: // global
           call _cbvG(R1) args: 0, res: 0, upd: 0;
       cbvH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvG() //  [R1]
         { info_tbl: [(cbvG,
                       label: block_cbvG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvG: // global
           if (R1 & 7 == 1) goto cbw9; else goto cbwa;
       cbw9: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbwa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbwj; else goto cbwi;
       cbwj: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwi: // global
           _s851::P64 = P64[R1 + 6];
           _s852::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _s852::P64;
           I64[Hp - 48] = sat_s859_info;
           _s84U::P64 = P64[Sp + 8];
           P64[Hp - 40] = _s84U::P64;
           P64[Hp - 32] = Hp - 80;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s851::P64;
           R2 = _s84U::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 47;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.mapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbwm,
                       label: GHC.Base.mapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbwq; else goto cbwp;
       cbwq: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbwp: // global
           I64[Hp - 48] = z_s84X_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_s84Y_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R2 = R4;
           R1 = Hp - 23;
           call go_s84Y_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.752478525 UTC

[section ""data" . GHC.Base.sequence_closure" {
     GHC.Base.sequence_closure:
         const GHC.Base.sequence_info;
 },
 GHC.Base.sequence_entry() //  [R2, R3]
         { info_tbl: [(cbwv,
                       label: GHC.Base.sequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwv: // global
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call GHC.Base.mapM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.75389999 UTC

[section ""data" . GHC.Base.$dmmconcat_closure" {
     GHC.Base.$dmmconcat_closure:
         const GHC.Base.$dmmconcat_info;
 },
 z_s85d_entry() //  [R1]
         { info_tbl: [(cbwG,
                       label: z_s85d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwH; else goto cbwI;
       cbwH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s85e_entry() //  [R1, R2]
         { info_tbl: [(cbwV,
                       label: go_s85e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbwW; else goto cbwX;
       cbwW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwX: // global
           I64[Sp - 32] = block_cbwO_info;
           _s85e::P64 = R1;
           _s85b::P64 = P64[R1 + 7];
           _s85d::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s85b::P64;
           P64[Sp - 16] = _s85d::P64;
           P64[Sp - 8] = _s85e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubx7; else goto cbwP;
       ubx7: // global
           call _cbwO(R1) args: 0, res: 0, upd: 0;
       cbwP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwO() //  [R1]
         { info_tbl: [(cbwO,
                       label: block_cbwO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwO: // global
           if (R1 & 7 == 1) goto cbwS; else goto cbwT;
       cbwS: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbwT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbx5; else goto cbx4;
       cbx5: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbx4: // global
           _s85h::P64 = P64[R1 + 6];
           _s85i::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s85i::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s85h::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$dmmconcat_entry() //  [R2, R3]
         { info_tbl: [(cbx8,
                       label: GHC.Base.$dmmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbxc; else goto cbxb;
       cbxc: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbxb: // global
           I64[Hp - 40] = z_s85d_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85e_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s85e_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.756444222 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmconcat_closure" {
     GHC.Base.$fMonoid(->)_$cmconcat_closure:
         const GHC.Base.$fMonoid(->)_$cmconcat_info;
 },
 lvl3_s85n_entry() //  [R1]
         { info_tbl: [(cbxl,
                       label: lvl3_s85n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbxl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbxm; else goto cbxn;
       cbxm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbxn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup_s85o_entry() //  [R1]
         { info_tbl: [(cbxs,
                       label: $dSemigroup_s85o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbxs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbxt; else goto cbxu;
       cbxt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbxu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s85p_entry() //  [R1, R2, R3]
         { info_tbl: [(cbxH,
                       label: go_s85p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbxH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbxI; else goto cbxJ;
       cbxI: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbxJ: // global
           I64[Sp - 40] = block_cbxA_info;
           _s85p::P64 = R1;
           _s85n::P64 = P64[R1 + 6];
           _s85o::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _s85n::P64;
           P64[Sp - 24] = _s85o::P64;
           P64[Sp - 16] = _s85p::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubxU; else goto cbxB;
       ubxU: // global
           call _cbxA(R1) args: 0, res: 0, upd: 0;
       cbxB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbxA() //  [R1]
         { info_tbl: [(cbxA,
                       label: block_cbxA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbxA: // global
           if (R1 & 7 == 1) goto cbxE; else goto cbxF;
       cbxE: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbxF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbxR; else goto cbxQ;
       cbxR: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbxQ: // global
           _s85t::P64 = P64[R1 + 6];
           _s85u::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = _s85u::P64;
           _s85r::P64 = P64[Sp + 32];
           P64[Hp - 32] = _s85r::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s85t::P64;
           P64[Hp] = _s85r::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(->)_$cmconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(cbxV,
                       label: GHC.Base.$fMonoid(->)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbxV: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbxZ; else goto cbxY;
       cbxZ: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbxY: // global
           I64[Hp - 64] = lvl3_s85n_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = $dSemigroup_s85o_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85p_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           _s85l::P64 = R3;
           R3 = R4;
           R2 = _s85l::P64;
           R1 = Hp - 14;
           call go_s85p_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.759629704 UTC

[section ""data" . GHC.Base.$fMonoidIO1_closure" {
     GHC.Base.$fMonoidIO1_closure:
         const GHC.Base.$fMonoidIO1_info;
 },
 $dSemigroup_s85A_entry() //  [R1]
         { info_tbl: [(cby8,
                       label: $dSemigroup_s85A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cby8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cby9; else goto cbya;
       cby9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbya: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl3_s85B_entry() //  [R1]
         { info_tbl: [(cbyf,
                       label: lvl3_s85B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbyg; else goto cbyh;
       cbyg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbyh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s85O_entry() //  [R1]
         { info_tbl: [(cbyB,
                       label: sat_s85O_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbyC; else goto cbyD;
       cbyC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbyD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s85C_entry() //  [R1, R2]
         { info_tbl: [(cbyI,
                       label: go_s85C_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbyJ; else goto cbyK;
       cbyJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbyK: // global
           I64[Sp - 32] = block_cbyn_info;
           _s85C::P64 = R1;
           _s85A::P64 = P64[R1 + 6];
           _s85B::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _s85A::P64;
           P64[Sp - 16] = _s85B::P64;
           P64[Sp - 8] = _s85C::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubyS; else goto cbyo;
       ubyS: // global
           call _cbyn(R1) args: 0, res: 0, upd: 0;
       cbyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbyn() //  [R1]
         { info_tbl: [(cbyn,
                       label: block_cbyn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyn: // global
           if (R1 & 7 == 1) goto cbyF; else goto cbyG;
       cbyF: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbyG: // global
           I64[Sp] = block_cbyt_info;
           _s85H::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s85H::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbyt() //  [R1]
         { info_tbl: [(cbyt,
                       label: block_cbyt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyt: // global
           I64[Sp] = block_cbyv_info;
           R2 = P64[Sp + 16];
           _s85K::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s85K::P64;
           call go_s85C_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbyv() //  [R1]
         { info_tbl: [(cbyv,
                       label: block_cbyv_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbyR; else goto cbyQ;
       cbyR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbyQ: // global
           I64[Hp - 32] = sat_s85O_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoidIO1_entry() //  [R2, R3]
         { info_tbl: [(cbyT,
                       label: GHC.Base.$fMonoidIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyT: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbyX; else goto cbyW;
       cbyX: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbyW: // global
           I64[Hp - 64] = $dSemigroup_s85A_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl3_s85B_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85C_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 14;
           call go_s85C_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.76375702 UTC

[section ""data" . GHC.Base.$fMonoidIO_closure" {
     GHC.Base.$fMonoidIO_closure:
         const GHC.Base.$fMonoidIO_info;
         const 0;
 },
 sat_s85V_entry() //  [R1, R2]
         { info_tbl: [(cbz7,
                       label: sat_s85V_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s85U_entry() //  [R1, R2, R3]
         { info_tbl: [(cbzf,
                       label: sat_s85U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoidIO_$cmappend_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s85S_entry() //  [R1]
         { info_tbl: [(cbzr,
                       label: sat_s85S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzs; else goto cbzt;
       cbzs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s85T_entry() //  [R1]
         { info_tbl: [(cbzu,
                       label: sat_s85T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbzy; else goto cbzx;
       cbzy: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbzx: // global
           _s85P::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s85S_info;
           P64[Hp] = _s85P::P64;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s85Q_entry() //  [R1]
         { info_tbl: [(cbzD,
                       label: sat_s85Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzE; else goto cbzF;
       cbzE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoidIO_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidIO_entry() //  [R2]
         { info_tbl: [(cbzH,
                       label: GHC.Base.$fMonoidIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzH: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cbzL; else goto cbzK;
       cbzL: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzK: // global
           I64[Hp - 104] = sat_s85V_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s85U_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s85T_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s85Q_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.765969391 UTC

[section ""data" . GHC.Base.$fFunctor[]_$c<$_closure" {
     GHC.Base.$fFunctor[]_$c<$_closure:
         const GHC.Base.$fFunctor[]_$c<$_info;
 },
 sat_s85Z_entry() //  [R1]
         { info_tbl: [(cbzV,
                       label: sat_s85Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzV: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fFunctor[]_$c<$_entry() //  [R2, R3]
         { info_tbl: [(cbzY,
                       label: GHC.Base.$fFunctor[]_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbA2; else goto cbA1;
       cbA2: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor[]_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbA1: // global
           I64[Hp - 8] = sat_s85Z_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.767486832 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$c<$_closure" {
     GHC.Base.$fFunctorNonEmpty_$c<$_closure:
         const GHC.Base.$fFunctorNonEmpty_$c<$_info;
 },
 sat_s866_entry() //  [R1]
         { info_tbl: [(cbAl,
                       label: sat_s866_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAl: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s867_entry() //  [R1]
         { info_tbl: [(cbAo,
                       label: sat_s867_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbAp; else goto cbAq;
       cbAp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbAb_info;
           _s860::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s860::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubAu; else goto cbAc;
       ubAu: // global
           call _cbAb(R1) args: 0, res: 0, upd: 0;
       cbAc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAb() //  [R1]
         { info_tbl: [(cbAb,
                       label: block_cbAb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAt; else goto cbAs;
       cbAt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbAs: // global
           _s864::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s866_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _s864::P64;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fFunctorNonEmpty_$c<$_entry() //  [R2, R3]
         { info_tbl: [(cbAw,
                       label: GHC.Base.$fFunctorNonEmpty_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbAA; else goto cbAz;
       cbAA: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAz: // global
           I64[Hp - 48] = sat_s867_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.769016609 UTC

[section ""data" . GHC.Base.$fFunctor[]_closure" {
     GHC.Base.$fFunctor[]_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.770349723 UTC

[section ""data" . GHC.Base.$fMonad[]_$c>>=_closure" {
     GHC.Base.$fMonad[]_$c>>=_closure:
         const GHC.Base.$fMonad[]_$c>>=_info;
 },
 sat_s86g_entry() //  [R1]
         { info_tbl: [(cbAU,
                       label: sat_s86g_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAU: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s86a_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86a_entry() //  [R1, R2]
         { info_tbl: [(cbB1,
                       label: go_s86a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbB2; else goto cbB3;
       cbB2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbB3: // global
           I64[Sp - 24] = block_cbAK_info;
           _s86a::P64 = R1;
           _s869::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s869::P64;
           P64[Sp - 8] = _s86a::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubBe; else goto cbAL;
       ubBe: // global
           call _cbAK(R1) args: 0, res: 0, upd: 0;
       cbAL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAK() //  [R1]
         { info_tbl: [(cbAK,
                       label: block_cbAK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAK: // global
           if (R1 & 7 == 1) goto cbAY; else goto cbAZ;
       cbAY: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbAZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbB9; else goto cbB8;
       cbB9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbB8: // global
           _s86d::P64 = P64[R1 + 6];
           _s86e::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s86g_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s86e::P64;
           _s869::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbB6_info;
           R2 = _s86d::P64;
           R1 = _s869::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB6() //  [R1]
         { info_tbl: [(cbB6,
                       label: block_cbB6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB6: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonad[]_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cbBf,
                       label: GHC.Base.$fMonad[]_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbBj; else goto cbBi;
       cbBj: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad[]_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbBi: // global
           I64[Hp - 8] = go_s86a_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86a_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.772183783 UTC

[section ""data" . GHC.Base.=<<_$s=<<_closure" {
     GHC.Base.=<<_$s=<<_closure:
         const GHC.Base.=<<_$s=<<_info;
 },
 GHC.Base.=<<_$s=<<_entry() //  [R2, R3]
         { info_tbl: [(cbBo,
                       label: GHC.Base.=<<_$s=<<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBo: // global
           _s86i::P64 = R3;
           R3 = R2;
           R2 = _s86i::P64;
           call GHC.Base.$fMonad[]_$c>>=_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.773334955 UTC

[section ""data" . GHC.Base.=<<_closure" {
     GHC.Base.=<<_closure:
         const GHC.Base.=<<_info;
 },
 GHC.Base.=<<_entry() //  [R2, R3, R4]
         { info_tbl: [(cbBv,
                       label: GHC.Base.=<<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbBw; else goto cbBx;
       cbBw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.=<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbBx: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.774578944 UTC

[section ""data" . poly_go_r7PI_closure" {
     poly_go_r7PI_closure:
         const poly_go_r7PI_info;
 },
 sat_s86q_entry() //  [R1]
         { info_tbl: [(cbBM,
                       label: sat_s86q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBM: // global
           R2 = P64[R1 + 16];
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 poly_go_r7PI_entry() //  [R2]
         { info_tbl: [(cbBT,
                       label: poly_go_r7PI_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbBU; else goto cbBV;
       cbBU: // global
           R2 = R2;
           R1 = poly_go_r7PI_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbBV: // global
           I64[Sp - 8] = block_cbBC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubC1; else goto cbBD;
       ubC1: // global
           call _cbBC(R1) args: 0, res: 0, upd: 0;
       cbBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbBC() //  [R1]
         { info_tbl: [(cbBC,
                       label: block_cbBC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBC: // global
           if (R1 & 7 == 1) goto cbBQ; else goto cbBR;
       cbBQ: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbBR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbC0; else goto cbBZ;
       cbC0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbBZ: // global
           _s86o::P64 = P64[R1 + 6];
           _s86p::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_s86q_info;
           P64[Hp] = _s86p::P64;
           R3 = Hp - 16;
           R2 = _s86o::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.775928681 UTC

[section ""data" . GHC.Base.$fMonoid[]_$cmconcat_closure" {
     GHC.Base.$fMonoid[]_$cmconcat_closure:
         const GHC.Base.$fMonoid[]_$cmconcat_info;
 },
 GHC.Base.$fMonoid[]_$cmconcat_entry() //  [R2]
         { info_tbl: [(cbC6,
                       label: GHC.Base.$fMonoid[]_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbC6: // global
           R2 = R2;
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.777626654 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*>_closure" {
     GHC.Base.$fApplicative[]_$c<*>_closure:
         const GHC.Base.$fApplicative[]_$c<*>_info;
 },
 go1_s86A_entry() //  [R1, R2]
         { info_tbl: [(cbCB,
                       label: go1_s86A_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbCB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbCC; else goto cbCD;
       cbCC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbCD: // global
           I64[Sp - 32] = block_cbCu_info;
           _s86A::P64 = R1;
           _s86x::P64 = P64[R1 + 7];
           _s86z::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s86x::P64;
           P64[Sp - 16] = _s86z::P64;
           P64[Sp - 8] = _s86A::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubCP; else goto cbCv;
       ubCP: // global
           call _cbCu(R1) args: 0, res: 0, upd: 0;
       cbCv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbCu() //  [R1]
         { info_tbl: [(cbCu,
                       label: block_cbCu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbCu: // global
           if (R1 & 7 == 1) goto cbCy; else goto cbCz;
       cbCy: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbCz: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbCO; else goto cbCN;
       cbCO: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbCN: // global
           _s86D::P64 = P64[R1 + 6];
           _s86E::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = _s86E::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s86D::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86u_entry() //  [R1, R2]
         { info_tbl: [(cbCU,
                       label: go_s86u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbCU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbCV; else goto cbCW;
       cbCV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbCW: // global
           I64[Sp - 24] = block_cbCi_info;
           _s86u::P64 = R1;
           _s86t::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s86t::P64;
           P64[Sp - 8] = _s86u::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubD2; else goto cbCj;
       ubD2: // global
           call _cbCi(R1) args: 0, res: 0, upd: 0;
       cbCj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbCi() //  [R1]
         { info_tbl: [(cbCi,
                       label: block_cbCi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbCi: // global
           if (R1 & 7 == 1) goto cbCR; else goto cbCS;
       cbCR: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbCS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbD1; else goto cbD0;
       cbD1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbD0: // global
           _s86x::P64 = P64[R1 + 6];
           _s86y::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s86y::P64;
           I64[Hp - 16] = go1_s86A_info;
           P64[Hp - 8] = _s86x::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s86A_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(cbD3,
                       label: GHC.Base.$fApplicative[]_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbD3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbD7; else goto cbD6;
       cbD7: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbD6: // global
           I64[Hp - 8] = go_s86u_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86u_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.781817449 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cliftA2_closure" {
     GHC.Base.$fApplicative[]_$cliftA2_closure:
         const GHC.Base.$fApplicative[]_$cliftA2_info;
 },
 go1_s86Q_entry() //  [R1, R2]
         { info_tbl: [(cbDA,
                       label: go1_s86Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbDB; else goto cbDC;
       cbDB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDC: // global
           I64[Sp - 40] = block_cbDt_info;
           _s86Q::P64 = R1;
           _s86H::P64 = P64[R1 + 7];
           _s86N::P64 = P64[R1 + 15];
           _s86P::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s86H::P64;
           P64[Sp - 24] = _s86N::P64;
           P64[Sp - 16] = _s86P::P64;
           P64[Sp - 8] = _s86Q::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubDO; else goto cbDu;
       ubDO: // global
           call _cbDt(R1) args: 0, res: 0, upd: 0;
       cbDu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDt() //  [R1]
         { info_tbl: [(cbDt,
                       label: block_cbDt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDt: // global
           if (R1 & 7 == 1) goto cbDx; else goto cbDy;
       cbDx: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbDy: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbDN; else goto cbDM;
       cbDN: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDM: // global
           _s86T::P64 = P64[R1 + 6];
           _s86U::P64 = P64[R1 + 14];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = _s86U::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s86T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86K_entry() //  [R1, R2]
         { info_tbl: [(cbDT,
                       label: go_s86K_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbDU; else goto cbDV;
       cbDU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDV: // global
           I64[Sp - 32] = block_cbDh_info;
           _s86K::P64 = R1;
           _s86H::P64 = P64[R1 + 7];
           _s86J::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s86H::P64;
           P64[Sp - 16] = _s86J::P64;
           P64[Sp - 8] = _s86K::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubE1; else goto cbDi;
       ubE1: // global
           call _cbDh(R1) args: 0, res: 0, upd: 0;
       cbDi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDh() //  [R1]
         { info_tbl: [(cbDh,
                       label: block_cbDh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDh: // global
           if (R1 & 7 == 1) goto cbDQ; else goto cbDR;
       cbDQ: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbDR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbE0; else goto cbDZ;
       cbE0: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDZ: // global
           _s86N::P64 = P64[R1 + 6];
           _s86O::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _s86O::P64;
           I64[Hp - 24] = go1_s86Q_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s86N::P64;
           P64[Hp] = Hp - 56;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call go1_s86Q_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbE2,
                       label: GHC.Base.$fApplicative[]_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbE6; else goto cbE5;
       cbE6: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbE5: // global
           I64[Hp - 16] = go_s86K_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = R3;
           R1 = Hp - 15;
           call go_s86K_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.784238671 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*_closure" {
     GHC.Base.$fApplicative[]_$c<*_closure:
         const GHC.Base.$fApplicative[]_$c<*_info;
 },
 GHC.Base.$fApplicative[]_$c<*_entry() //  [R2, R3]
         { info_tbl: [(cbEb,
                       label: GHC.Base.$fApplicative[]_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEb: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.const_closure+2;
           call GHC.Base.$fApplicative[]_$cliftA2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.785685587 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c*>_closure" {
     GHC.Base.$fApplicative[]_$c*>_closure:
         const GHC.Base.$fApplicative[]_$c*>_info;
 },
 sat_s874_entry() //  [R1]
         { info_tbl: [(cbEx,
                       label: sat_s874_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEx: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s86Z_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86Z_entry() //  [R1, R2]
         { info_tbl: [(cbEE,
                       label: go_s86Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbEF; else goto cbEG;
       cbEF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbEG: // global
           I64[Sp - 24] = block_cbEn_info;
           _s86Z::P64 = R1;
           _s86Y::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s86Y::P64;
           P64[Sp - 8] = _s86Z::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubEM; else goto cbEo;
       ubEM: // global
           call _cbEn(R1) args: 0, res: 0, upd: 0;
       cbEo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEn() //  [R1]
         { info_tbl: [(cbEn,
                       label: block_cbEn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEn: // global
           if (R1 & 7 == 1) goto cbEB; else goto cbEC;
       cbEB: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbEC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbEL; else goto cbEK;
       cbEL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEK: // global
           _s873::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s874_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s873::P64;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$c*>_entry() //  [R2, R3]
         { info_tbl: [(cbEN,
                       label: GHC.Base.$fApplicative[]_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbER; else goto cbEQ;
       cbER: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbEQ: // global
           I64[Hp - 8] = go_s86Z_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86Z_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.787242137 UTC

[section ""data" . GHC.Base.$fApplicative[]_closure" {
     GHC.Base.$fApplicative[]_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor[]_closure+1;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fApplicative[]_$c<*>_closure+2;
         const GHC.Base.$fApplicative[]_$cliftA2_closure+3;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.788366018 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$cfmap_closure" {
     GHC.Base.$fFunctorNonEmpty_$cfmap_closure:
         const GHC.Base.$fFunctorNonEmpty_$cfmap_info;
 },
 sat_s87f_entry() //  [R1]
         { info_tbl: [(cbF3,
                       label: sat_s87f_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbF3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbF4; else goto cbF5;
       cbF4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbF5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbF0_info;
           _s875::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s875::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubF9; else goto cbF1;
       ubF9: // global
           call _cbF0(R1) args: 0, res: 0, upd: 0;
       cbF1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbF0() //  [R1]
         { info_tbl: [(cbF0,
                       label: block_cbF0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbF0: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s87b_entry() //  [R1]
         { info_tbl: [(cbFf,
                       label: sat_s87b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbFf: // global
           _s87b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbFg; else goto cbFh;
       cbFh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbFj; else goto cbFi;
       cbFj: // global
           HpAlloc = 24;
           goto cbFg;
       cbFg: // global
           R1 = _s87b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbFi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87b::P64;
           _s875::P64 = P64[_s87b::P64 + 16];
           _s876::P64 = P64[_s87b::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s876::P64;
           R2 = Hp - 16;
           R1 = _s875::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fFunctorNonEmpty_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(cbFl,
                       label: GHC.Base.$fFunctorNonEmpty_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbFl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbFp; else goto cbFo;
       cbFp: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbFo: // global
           I64[Hp - 80] = sat_s87f_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s87b_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.790198075 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_closure" {
     GHC.Base.$fFunctorNonEmpty_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorNonEmpty_$cfmap_closure+2;
         const GHC.Base.$fFunctorNonEmpty_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.790785485 UTC

[section ""data" . GHC.Base.$fAlternative[]1_closure" {
     GHC.Base.$fAlternative[]1_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.792553734 UTC

[section ""data" . GHC.Base.$fAlternative[]_$csome_closure" {
     GHC.Base.$fAlternative[]_$csome_closure:
         const GHC.Base.$fAlternative[]_$csome_info;
 },
 ys_s87i_entry() //  [R1]
         { info_tbl: [(cbFC,
                       label: ys_s87i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbFC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbFD; else goto cbFE;
       cbFD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbFE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_s87p_entry() //  [R1, R2]
         { info_tbl: [(cbG3,
                       label: go1_s87p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbG3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbG4; else goto cbG5;
       cbG4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbG5: // global
           I64[Sp - 32] = block_cbFW_info;
           _s87p::P64 = R1;
           _s87m::P64 = P64[R1 + 7];
           _s87o::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s87m::P64;
           P64[Sp - 16] = _s87o::P64;
           P64[Sp - 8] = _s87p::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubGh; else goto cbFX;
       ubGh: // global
           call _cbFW(R1) args: 0, res: 0, upd: 0;
       cbFX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbFW() //  [R1]
         { info_tbl: [(cbFW,
                       label: block_cbFW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbFW: // global
           if (R1 & 7 == 1) goto cbG0; else goto cbG1;
       cbG0: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbG1: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbGg; else goto cbGf;
       cbGg: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbGf: // global
           _s87s::P64 = P64[R1 + 6];
           _s87t::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s87t::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s87s::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s87j_entry() //  [R1, R2]
         { info_tbl: [(cbGm,
                       label: go_s87j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbGn; else goto cbGo;
       cbGn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGo: // global
           I64[Sp - 24] = block_cbFK_info;
           _s87j::P64 = R1;
           _s87i::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87i::P64;
           P64[Sp - 8] = _s87j::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubGu; else goto cbFL;
       ubGu: // global
           call _cbFK(R1) args: 0, res: 0, upd: 0;
       cbFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbFK() //  [R1]
         { info_tbl: [(cbFK,
                       label: block_cbFK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbFK: // global
           if (R1 & 7 == 1) goto cbGj; else goto cbGk;
       cbGj: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbGk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbGt; else goto cbGs;
       cbGt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbGs: // global
           _s87m::P64 = P64[R1 + 6];
           _s87n::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s87n::P64;
           I64[Hp - 16] = go1_s87p_info;
           P64[Hp - 8] = _s87m::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s87p_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 some_v_s87h_entry() //  [R1]
         { info_tbl: [(cbGv,
                       label: some_v_s87h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGv: // global
           _s87h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbGw; else goto cbGx;
       cbGx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbGz; else goto cbGy;
       cbGz: // global
           HpAlloc = 40;
           goto cbGw;
       cbGw: // global
           R1 = _s87h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbGy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87h::P64;
           _s87g::P64 = P64[_s87h::P64 + 16];
           I64[Hp - 32] = ys_s87i_info;
           P64[Hp - 16] = _s87h::P64;
           I64[Hp - 8] = go_s87j_info;
           P64[Hp] = Hp - 32;
           R2 = _s87g::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_s87j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternative[]_$csome_entry() //  [R2]
         { info_tbl: [(cbGA,
                       label: GHC.Base.$fAlternative[]_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbGE; else goto cbGD;
       cbGE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbGD: // global
           I64[Hp - 16] = some_v_s87h_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.797512629 UTC

[section ""data" . GHC.Base.$fAlternative[]_$cmany_closure" {
     GHC.Base.$fAlternative[]_$cmany_closure:
         const GHC.Base.$fAlternative[]_$cmany_info;
 },
 go1_s87E_entry() //  [R1, R2]
         { info_tbl: [(cbHb,
                       label: go1_s87E_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbHc; else goto cbHd;
       cbHc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHd: // global
           I64[Sp - 32] = block_cbH4_info;
           _s87E::P64 = R1;
           _s87B::P64 = P64[R1 + 7];
           _s87D::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s87B::P64;
           P64[Sp - 16] = _s87D::P64;
           P64[Sp - 8] = _s87E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubHp; else goto cbH5;
       ubHp: // global
           call _cbH4(R1) args: 0, res: 0, upd: 0;
       cbH5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbH4() //  [R1]
         { info_tbl: [(cbH4,
                       label: block_cbH4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbH4: // global
           if (R1 & 7 == 1) goto cbH8; else goto cbH9;
       cbH8: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbH9: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbHo; else goto cbHn;
       cbHo: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbHn: // global
           _s87H::P64 = P64[R1 + 6];
           _s87I::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s87I::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s87H::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s87y_entry() //  [R1, R2]
         { info_tbl: [(cbHu,
                       label: go_s87y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbHv; else goto cbHw;
       cbHv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHw: // global
           I64[Sp - 24] = block_cbGS_info;
           _s87y::P64 = R1;
           _s87x::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87x::P64;
           P64[Sp - 8] = _s87y::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubHC; else goto cbGT;
       ubHC: // global
           call _cbGS(R1) args: 0, res: 0, upd: 0;
       cbGT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbGS() //  [R1]
         { info_tbl: [(cbGS,
                       label: block_cbGS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbGS: // global
           if (R1 & 7 == 1) goto cbHr; else goto cbHs;
       cbHr: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbHs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbHB; else goto cbHA;
       cbHB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbHA: // global
           _s87B::P64 = P64[R1 + 6];
           _s87C::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s87C::P64;
           I64[Hp - 16] = go1_s87E_info;
           P64[Hp - 8] = _s87B::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s87E_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v_s87x_entry() //  [R1]
         { info_tbl: [(cbHF,
                       label: many_v_s87x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHF: // global
           _s87x::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbHG; else goto cbHH;
       cbHH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbHJ; else goto cbHI;
       cbHJ: // global
           HpAlloc = 16;
           goto cbHG;
       cbHG: // global
           R1 = _s87x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbHI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87x::P64;
           _s87w::P64 = P64[_s87x::P64 + 16];
           I64[Hp - 8] = go_s87y_info;
           P64[Hp] = _s87x::P64;
           I64[Sp - 24] = block_cbHD_info;
           R2 = _s87w::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_s87y_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbHD() //  [R1]
         { info_tbl: [(cbHD,
                       label: block_cbHD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHD: // global
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternative[]_$cmany_entry() //  [R2]
         { info_tbl: [(cbHN,
                       label: GHC.Base.$fAlternative[]_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbHN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbHR; else goto cbHQ;
       cbHR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbHQ: // global
           I64[Hp - 16] = many_v_s87x_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.800173164 UTC

[section ""data" . GHC.Base.$fAlternative[]_closure" {
     GHC.Base.$fAlternative[]_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fAlternative[]_$csome_closure+1;
         const GHC.Base.$fAlternative[]_$cmany_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.802130701 UTC

[section ""data" . GHC.Base.$w$c>>=_closure" {
     GHC.Base.$w$c>>=_closure:
         const GHC.Base.$w$c>>=_info;
 },
 ds_s87O_entry() //  [R1]
         { info_tbl: [(cbI1,
                       label: ds_s87O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbI1: // global
           _s87O::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbI2; else goto cbI3;
       cbI3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbI5; else goto cbI4;
       cbI5: // global
           HpAlloc = 24;
           goto cbI2;
       cbI2: // global
           R1 = _s87O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbI4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87O::P64;
           _s87M::P64 = P64[_s87O::P64 + 16];
           _s87N::P64 = P64[_s87O::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s87M::P64;
           R2 = Hp - 16;
           R1 = _s87N::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s88i_entry() //  [R1]
         { info_tbl: [(cbIE,
                       label: sat_s88i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbIE: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s883_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s883_entry() //  [R1, R2]
         { info_tbl: [(cbIL,
                       label: go_s883_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbIL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbIM; else goto cbIN;
       cbIM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbIN: // global
           I64[Sp - 24] = block_cbIt_info;
           _s883::P64 = R1;
           _s87N::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87N::P64;
           P64[Sp - 8] = _s883::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubIW; else goto cbIu;
       ubIW: // global
           call _cbIt(R1) args: 0, res: 0, upd: 0;
       cbIu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbIt() //  [R1]
         { info_tbl: [(cbIt,
                       label: block_cbIt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbIt: // global
           if (R1 & 7 == 1) goto cbII; else goto cbIJ;
       cbII: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbIJ: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbIV; else goto cbIU;
       cbIV: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbIU: // global
           _s886::P64 = P64[R1 + 6];
           _s887::P64 = P64[R1 + 14];
           I64[Hp - 128] = stg_ap_2_upd_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _s886::P64;
           I64[Hp - 96] = sat_s88i_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s887::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cbIz::P64 = Hp - 128;
           P64[Hp - 48] = _cbIz::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cbIz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 96;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s88j_entry() //  [R1]
         { info_tbl: [(cbIX,
                       label: sat_s88j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbIX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbIY; else goto cbIZ;
       cbIY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbIZ: // global
           I64[Sp - 16] = block_cbIj_info;
           _s87N::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s87N::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubJ3; else goto cbIk;
       ubJ3: // global
           call _cbIj(R1) args: 0, res: 0, upd: 0;
       cbIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbIj() //  [R1]
         { info_tbl: [(cbIj,
                       label: block_cbIj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbIj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbJ2; else goto cbJ1;
       cbJ2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbJ1: // global
           _s882::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_s883_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _s882::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_s883_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s88k_entry() //  [R1]
         { info_tbl: [(cbJ4,
                       label: sat_s88k_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJ4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbJ5; else goto cbJ6;
       cbJ5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJ6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbIa_info;
           _s87M::P64 = P64[R1 + 16];
           _s87N::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _s87M::P64;
           P64[Sp - 24] = _s87N::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubJa; else goto cbIb;
       ubJa: // global
           call _cbIa(R1) args: 0, res: 0, upd: 0;
       cbIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbIa() //  [R1]
         { info_tbl: [(cbIa,
                       label: block_cbIa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbIa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbJ9; else goto cbJ8;
       cbJ9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbJ8: // global
           _s87Z::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s88j_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 24;
           R2 = _s87Z::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$w$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cbJc,
                       label: GHC.Base.$w$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJc: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbJg; else goto cbJf;
       cbJg: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJf: // global
           I64[Hp - 88] = ds_s87O_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s88k_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _cbHW::P64 = Hp - 88;
           P64[Hp - 24] = _cbHW::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cbHW::P64;
           R2 = Hp - 56;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.805686289 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>=_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>=_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>=_info;
 },
 GHC.Base.$fMonadNonEmpty_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cbJo,
                       label: GHC.Base.$fMonadNonEmpty_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbJp; else goto cbJq;
       cbJp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJq: // global
           I64[Sp - 8] = block_cbJl_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbJl() //  [R1, R2]
         { info_tbl: [(cbJl,
                       label: block_cbJl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJt; else goto cbJs;
       cbJt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cbJs: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.807117659 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>_info;
 },
 sat_s88t_entry() //  [R1]
         { info_tbl: [(cbJD,
                       label: sat_s88t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJD: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonadNonEmpty_$c>>_entry() //  [R2, R3]
         { info_tbl: [(cbJJ,
                       label: GHC.Base.$fMonadNonEmpty_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJJ: // global
           _s88r::P64 = R3;
           _s88q::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbJK; else goto cbJL;
       cbJL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbJN; else goto cbJM;
       cbJN: // global
           HpAlloc = 16;
           goto cbJK;
       cbJK: // global
           R3 = _s88r::P64;
           R2 = _s88q::P64;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbJM: // global
           I64[Hp - 8] = sat_s88t_info;
           P64[Hp] = _s88r::P64;
           I64[Sp - 8] = block_cbJG_info;
           R3 = Hp - 7;
           R2 = _s88q::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbJG() //  [R1, R2]
         { info_tbl: [(cbJG,
                       label: block_cbJG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbJQ; else goto cbJP;
       cbJQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cbJP: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.808509425 UTC

[section ""data" . GHC.Base.<**>1_closure" {
     GHC.Base.<**>1_closure:
         const GHC.Base.<**>1_info;
 },
 GHC.Base.<**>1_entry() //  [R2, R3]
         { info_tbl: [(cbJV,
                       label: GHC.Base.<**>1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbJV: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.809326247 UTC

[section ""data" . GHC.Base.<**>_closure" {
     GHC.Base.<**>_closure:
         const GHC.Base.<**>_info;
 },
 GHC.Base.<**>_entry() //  [R2]
         { info_tbl: [(cbK2,
                       label: GHC.Base.<**>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbK2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbK3; else goto cbK4;
       cbK3: // global
           R2 = R2;
           R1 = GHC.Base.<**>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbK4: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.<**>1_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.810472666 UTC

[section ""data" . GHC.Base.$dmliftA2_closure" {
     GHC.Base.$dmliftA2_closure:
         const GHC.Base.$dmliftA2_info;
 },
 sat_s88E_entry() //  [R1]
         { info_tbl: [(cbKf,
                       label: sat_s88E_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbKg; else goto cbKh;
       cbKg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbKd_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbKd() //  [R1]
         { info_tbl: [(cbKd,
                       label: block_cbKd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKd: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbKl,
                       label: GHC.Base.$dmliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKl: // global
           _s88C::P64 = R4;
           _s88B::P64 = R3;
           _s88A::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbKm; else goto cbKn;
       cbKn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbKp; else goto cbKo;
       cbKp: // global
           HpAlloc = 40;
           goto cbKm;
       cbKm: // global
           R4 = _s88C::P64;
           R3 = _s88B::P64;
           R2 = _s88A::P64;
           R1 = GHC.Base.$dmliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbKo: // global
           I64[Hp - 32] = sat_s88E_info;
           P64[Hp - 16] = _s88A::P64;
           P64[Hp - 8] = _s88B::P64;
           P64[Hp] = _s88C::P64;
           R2 = _s88A::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.812508798 UTC

[section ""data" . GHC.Base.$dmsome_closure" {
     GHC.Base.$dmsome_closure:
         const GHC.Base.$dmsome_info;
 },
 sat_s88J_entry() //  [R1]
         { info_tbl: [(cbKK,
                       label: sat_s88J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbKL; else goto cbKM;
       cbKL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s88K_entry() //  [R1]
         { info_tbl: [(cbKN,
                       label: sat_s88K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKN: // global
           _s88K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbKO; else goto cbKP;
       cbKP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbKR; else goto cbKQ;
       cbKR: // global
           HpAlloc = 24;
           goto cbKO;
       cbKO: // global
           R1 = _s88K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s88K::P64;
           _s88F::P64 = P64[_s88K::P64 + 16];
           _s88H::P64 = P64[_s88K::P64 + 24];
           _s88I::P64 = P64[_s88K::P64 + 32];
           I64[Hp - 16] = sat_s88J_info;
           P64[Hp] = _s88I::P64;
           R2 = _s88F::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s88H::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 some_v_s88H_entry() //  [R1]
         { info_tbl: [(cbKS,
                       label: some_v_s88H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbKT; else goto cbKU;
       cbKT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbKU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cbKy_info;
           _s88F::P64 = P64[R1 + 16];
           R2 = _s88F::P64;
           P64[Sp - 40] = _s88F::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbKy() //  [R1]
         { info_tbl: [(cbKy,
                       label: block_cbKy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbKX; else goto cbKW;
       cbKX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbKW: // global
           I64[Hp - 32] = sat_s88K_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 32;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmsome_entry() //  [R2, R3]
         { info_tbl: [(cbKY,
                       label: GHC.Base.$dmsome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbKY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbL2; else goto cbL1;
       cbL2: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbL1: // global
           I64[Hp - 24] = some_v_s88H_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.815942329 UTC

[section ""data" . GHC.Base.$dmmany_closure" {
     GHC.Base.$dmmany_closure:
         const GHC.Base.$dmmany_info;
 },
 $dApplicative_s88O_entry() //  [R1]
         { info_tbl: [(cbLf,
                       label: $dApplicative_s88O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbLg; else goto cbLh;
       cbLg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s88Q_entry() //  [R1]
         { info_tbl: [(cbLm,
                       label: sat_s88Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbLn; else goto cbLo;
       cbLn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s88P_entry() //  [R1]
         { info_tbl: [(cbLt,
                       label: sat_s88P_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbLu; else goto cbLv;
       cbLu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 many_v_s88N_entry() //  [R1]
         { info_tbl: [(cbLw,
                       label: many_v_s88N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLw: // global
           _s88N::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbLx; else goto cbLy;
       cbLy: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbLA; else goto cbLz;
       cbLA: // global
           HpAlloc = 88;
           goto cbLx;
       cbLx: // global
           R1 = _s88N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbLz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s88N::P64;
           _s88L::P64 = P64[_s88N::P64 + 16];
           _s88M::P64 = P64[_s88N::P64 + 24];
           I64[Hp - 80] = $dApplicative_s88O_info;
           P64[Hp - 64] = _s88L::P64;
           I64[Hp - 56] = sat_s88Q_info;
           _cbLb::P64 = Hp - 80;
           P64[Hp - 40] = _cbLb::P64;
           I64[Hp - 32] = sat_s88P_info;
           P64[Hp - 16] = _s88M::P64;
           P64[Hp - 8] = _s88N::P64;
           P64[Hp] = _cbLb::P64;
           R2 = _s88L::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmmany_entry() //  [R2, R3]
         { info_tbl: [(cbLB,
                       label: GHC.Base.$dmmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbLF; else goto cbLE;
       cbLF: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbLE: // global
           I64[Hp - 24] = many_v_s88N_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.818649099 UTC

[section ""data" . GHC.Base.$w$csconcat3_closure" {
     GHC.Base.$w$csconcat3_closure:
         const GHC.Base.$w$csconcat3_info;
 },
 sat_s894_entry() //  [R1, R2]
         { info_tbl: [(cbM3,
                       label: sat_s894_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbM3: // global
           _s891::P64 = R2;
           _s894::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cbM4; else goto cbM5;
       cbM5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbM7; else goto cbM6;
       cbM7: // global
           HpAlloc = 64;
           goto cbM4;
       cbM4: // global
           R2 = _s891::P64;
           R1 = _s894::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbM6: // global
           _s88R::P64 = P64[_s894::P64 + 7];
           _s88V::P64 = P64[_s894::P64 + 15];
           _s890::P64 = P64[_s894::P64 + 23];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s890::P64;
           P64[Hp - 32] = _s891::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s88V::P64;
           P64[Hp] = _s891::P64;
           R2 = _s88R::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 go_s88U_entry() //  [R1, R2, R3]
         { info_tbl: [(cbMc,
                       label: go_s88U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbMd; else goto cbMe;
       cbMd: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbMe: // global
           I64[Sp - 32] = block_cbLP_info;
           _s88U::P64 = R1;
           _s88R::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s88R::P64;
           P64[Sp - 16] = _s88U::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubMk; else goto cbLQ;
       ubMk: // global
           call _cbLP(R1) args: 0, res: 0, upd: 0;
       cbLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbLP() //  [R1]
         { info_tbl: [(cbLP,
                       label: block_cbLP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbLP: // global
           _s88V::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cbM9; else goto cbMa;
       cbM9: // global
           R1 = _s88V::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbMa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbMj; else goto cbMi;
       cbMj: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbMi: // global
           _s88Y::P64 = P64[R1 + 6];
           _s88Z::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _s88Y::P64;
           P64[Hp - 32] = _s88Z::P64;
           I64[Hp - 24] = sat_s894_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s88V::P64;
           P64[Hp] = Hp - 64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat3_entry() //  [R2, R3, R4]
         { info_tbl: [(cbMl,
                       label: GHC.Base.$w$csconcat3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbMp; else goto cbMo;
       cbMp: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbMo: // global
           I64[Hp - 8] = go_s88U_info;
           P64[Hp] = R2;
           _s88S::P64 = R3;
           R3 = R4;
           R2 = _s88S::P64;
           R1 = Hp - 6;
           call go_s88U_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.820816021 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$csconcat_closure" {
     GHC.Base.$fSemigroup(->)_$csconcat_closure:
         const GHC.Base.$fSemigroup(->)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(->)_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(cbMx,
                       label: GHC.Base.$fSemigroup(->)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbMy; else goto cbMz;
       cbMy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbMz: // global
           I64[Sp - 16] = block_cbMu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubMD; else goto cbMv;
       ubMD: // global
           call _cbMu(R1) args: 0, res: 0, upd: 0;
       cbMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbMu() //  [R1]
         { info_tbl: [(cbMu,
                       label: block_cbMu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMu: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.822864172 UTC

[section ""data" . GHC.Base.$w$csconcat_closure" {
     GHC.Base.$w$csconcat_closure:
         const GHC.Base.$w$csconcat_info;
 },
 sat_s89t_entry() //  [R1]
         { info_tbl: [(cbN4,
                       label: sat_s89t_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbN4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbN5; else goto cbN6;
       cbN5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbN6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s89s_entry() //  [R1]
         { info_tbl: [(cbNb,
                       label: sat_s89s_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbNc; else goto cbNd;
       cbNc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbNd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s89f_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbNi,
                       label: $wgo_s89f_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNi: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbNj; else goto cbNk;
       cbNj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNk: // global
           I64[Sp - 48] = block_cbMN_info;
           _s89f::P64 = R1;
           _s89a::P64 = P64[R1 + 5];
           _s89b::P64 = P64[R1 + 13];
           R1 = R4;
           P64[Sp - 40] = _s89a::P64;
           P64[Sp - 32] = _s89b::P64;
           P64[Sp - 24] = _s89f::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ubNt; else goto cbMO;
       ubNt: // global
           call _cbMN(R1) args: 0, res: 0, upd: 0;
       cbMO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbMN() //  [R1]
         { info_tbl: [(cbMN,
                       label: block_cbMN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMN: // global
           if (R1 & 7 == 1) goto cbNf; else goto cbNg;
       cbNf: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cbNg: // global
           I64[Sp - 8] = block_cbMT_info;
           _s89l::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s89l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNs; else goto cbMU;
       ubNs: // global
           call _cbMT(R1) args: 0, res: 0, upd: 0;
       cbMU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbMT() //  [R1]
         { info_tbl: [(cbMT,
                       label: block_cbMT_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMT: // global
           _s89l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbMY_info;
           R4 = _s89l::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           Sp = Sp + 8;
           call $wgo_s89f_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbMY() //  [R1, R2]
         { info_tbl: [(cbMY,
                       label: block_cbMY_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbMY: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbNr; else goto cbNq;
       cbNr: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cbNq: // global
           I64[Hp - 72] = sat_s89t_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s89s_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbNu,
                       label: GHC.Base.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNy; else goto cbNx;
       cbNy: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNx: // global
           I64[Hp - 16] = $wgo_s89f_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _s89c::P64 = R4;
           R4 = R6;
           R3 = R5;
           R2 = _s89c::P64;
           R1 = Hp - 13;
           call $wgo_s89f_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.825778367 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,)_$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(cbNG,
                       label: GHC.Base.$fSemigroup(,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbNR; else goto cbNS;
       cbNR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbNS: // global
           I64[Sp - 24] = block_cbND_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubNZ; else goto cbNE;
       ubNZ: // global
           call _cbND(R1) args: 0, res: 0, upd: 0;
       cbNE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbND() //  [R1]
         { info_tbl: [(cbND,
                       label: block_cbND_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbND: // global
           I64[Sp - 8] = block_cbNJ_info;
           _s89z::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s89z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubNY; else goto cbNK;
       ubNY: // global
           call _cbNJ(R1) args: 0, res: 0, upd: 0;
       cbNK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbNJ() //  [R1]
         { info_tbl: [(cbNJ,
                       label: block_cbNJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNJ: // global
           _s89v::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cbNO_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s89v::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Base.$w$csconcat_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbNO() //  [R1, R2]
         { info_tbl: [(cbNO,
                       label: block_cbNO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbNO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbNX; else goto cbNW;
       cbNX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cbNW: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.827963674 UTC

[section ""data" . GHC.Base.$dmsconcat_closure" {
     GHC.Base.$dmsconcat_closure:
         const GHC.Base.$dmsconcat_info;
 },
 go_s89L_entry() //  [R1, R2, R3]
         { info_tbl: [(cbOl,
                       label: go_s89L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbOm; else goto cbOn;
       cbOm: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOn: // global
           I64[Sp - 32] = block_cbOe_info;
           _s89L::P64 = R1;
           _s89G::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s89G::P64;
           P64[Sp - 16] = _s89L::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubOx; else goto cbOf;
       ubOx: // global
           call _cbOe(R1) args: 0, res: 0, upd: 0;
       cbOf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbOe() //  [R1]
         { info_tbl: [(cbOe,
                       label: block_cbOe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOe: // global
           _s89M::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cbOi; else goto cbOj;
       cbOi: // global
           R1 = _s89M::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbOj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbOv; else goto cbOu;
       cbOv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOu: // global
           _s89P::P64 = P64[R1 + 6];
           _s89Q::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s89P::P64;
           P64[Hp] = _s89Q::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s89M::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$dmsconcat_entry() //  [R2, R3]
         { info_tbl: [(cbOy,
                       label: GHC.Base.$dmsconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbOz; else goto cbOA;
       cbOz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbOA: // global
           I64[Sp - 16] = block_cbO4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubOE; else goto cbO5;
       ubOE: // global
           call _cbO4(R1) args: 0, res: 0, upd: 0;
       cbO5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbO4() //  [R1]
         { info_tbl: [(cbO4,
                       label: block_cbO4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbO4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbOD; else goto cbOC;
       cbOD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbOC: // global
           _s89J::P64 = P64[R1 + 7];
           _s89K::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_s89L_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _s89K::P64;
           R2 = _s89J::P64;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call go_s89L_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.829925745 UTC

[section ""data" . GHC.Base.$dmstimes_closure" {
     GHC.Base.$dmstimes_closure:
         const GHC.Base.$dmstimes_info;
         const 0;
 },
 GHC.Base.$dmstimes_entry() //  [R2, R3]
         { info_tbl: [(cbOJ,
                       label: GHC.Base.$dmstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOJ: // global
           _s89T::P64 = R3;
           R3 = R2;
           R2 = _s89T::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.830806853 UTC

[section ""data" . GHC.Base.$dmmappend_closure" {
     GHC.Base.$dmmappend_closure:
         const GHC.Base.$dmmappend_info;
 },
 GHC.Base.$dmmappend_entry() //  [R2]
         { info_tbl: [(cbOS,
                       label: GHC.Base.$dmmappend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbOT; else goto cbOU;
       cbOT: // global
           R2 = R2;
           R1 = GHC.Base.$dmmappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbOU: // global
           I64[Sp - 8] = block_cbOQ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbOQ() //  [R1]
         { info_tbl: [(cbOQ,
                       label: block_cbOQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbOQ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.832735474 UTC

[section ""data" . GHC.Base.$dm>>_closure" {
     GHC.Base.$dm>>_closure:
         const GHC.Base.$dm>>_info;
 },
 sat_s8a0_entry() //  [R1]
         { info_tbl: [(cbP7,
                       label: sat_s8a0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbP7: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$dm>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cbPa,
                       label: GHC.Base.$dm>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPa: // global
           _s89Y::P64 = R4;
           _s89X::P64 = R3;
           _s89W::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbPb; else goto cbPc;
       cbPc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbPe; else goto cbPd;
       cbPe: // global
           HpAlloc = 16;
           goto cbPb;
       cbPb: // global
           R4 = _s89Y::P64;
           R3 = _s89X::P64;
           R2 = _s89W::P64;
           R1 = GHC.Base.$dm>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbPd: // global
           I64[Hp - 8] = sat_s8a0_info;
           P64[Hp] = _s89Y::P64;
           R2 = _s89W::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s89X::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.833985164 UTC

[section ""data" . GHC.Base.$dmreturn_closure" {
     GHC.Base.$dmreturn_closure:
         const GHC.Base.$dmreturn_info;
 },
 GHC.Base.$dmreturn_entry() //  [R2]
         { info_tbl: [(cbPl,
                       label: GHC.Base.$dmreturn_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbPm; else goto cbPn;
       cbPm: // global
           R2 = R2;
           R1 = GHC.Base.$dmreturn_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPn: // global
           I64[Sp - 8] = block_cbPj_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPj() //  [R1]
         { info_tbl: [(cbPj,
                       label: block_cbPj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPj: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.834983466 UTC

[section ""data" . GHC.Base.$dmfail_closure" {
     GHC.Base.$dmfail_closure:
         const GHC.Base.$dmfail_info;
         const 0;
 },
 GHC.Base.$dmfail_entry() //  [R3]
         { info_tbl: [(cbPv,
                       label: GHC.Base.$dmfail_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPv: // global
           R2 = R3;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.835828415 UTC

[section ""data" . GHC.Base.$dmmzero_closure" {
     GHC.Base.$dmmzero_closure:
         const GHC.Base.$dmmzero_info;
 },
 GHC.Base.$dmmzero_entry() //  [R2]
         { info_tbl: [(cbPE,
                       label: GHC.Base.$dmmzero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbPF; else goto cbPG;
       cbPF: // global
           R2 = R2;
           R1 = GHC.Base.$dmmzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPG: // global
           I64[Sp - 8] = block_cbPC_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPC() //  [R1]
         { info_tbl: [(cbPC,
                       label: block_cbPC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPC: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.836851106 UTC

[section ""data" . GHC.Base.$dmmplus_closure" {
     GHC.Base.$dmmplus_closure:
         const GHC.Base.$dmmplus_info;
 },
 GHC.Base.$dmmplus_entry() //  [R2]
         { info_tbl: [(cbPQ,
                       label: GHC.Base.$dmmplus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbPR; else goto cbPS;
       cbPR: // global
           R2 = R2;
           R1 = GHC.Base.$dmmplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbPS: // global
           I64[Sp - 8] = block_cbPO_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbPO() //  [R1]
         { info_tbl: [(cbPO,
                       label: block_cbPO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbPO: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.838448235 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c==_closure" {
     GHC.Base.$fEqMaybe_$c==_closure:
         const GHC.Base.$fEqMaybe_$c==_info;
 },
 GHC.Base.$fEqMaybe_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQ7,
                       label: GHC.Base.$fEqMaybe_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbQ8; else goto cbQ9;
       cbQ8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbQ9: // global
           I64[Sp - 24] = block_cbQ0_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubQK; else goto cbQ1;
       ubQK: // global
           call _cbQ0(R1) args: 0, res: 0, upd: 0;
       cbQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQ0() //  [R1]
         { info_tbl: [(cbQ0,
                       label: block_cbQ0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQ0: // global
           _s8ab::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbQ4; else goto cbQ5;
       cbQ4: // global
           I64[Sp + 16] = block_cbQc_info;
           R1 = _s8ab::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubQI; else goto cbQe;
       ubQI: // global
           call _cbQc(R1) args: 0, res: 0, upd: 0;
       cbQe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbQ5: // global
           I64[Sp] = block_cbQr_info;
           _s8af::P64 = P64[R1 + 6];
           R1 = _s8ab::P64;
           P64[Sp + 16] = _s8af::P64;
           if (R1 & 7 != 0) goto ubQJ; else goto cbQt;
       ubQJ: // global
           call _cbQr(R1) args: 0, res: 0, upd: 0;
       cbQt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQc() //  [R1]
         { info_tbl: [(cbQc,
                       label: block_cbQc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQc: // global
           if (R1 & 7 == 1) goto cbQk; else goto ubQH;
       cbQk: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ubQH: // global
           Sp = Sp + 8;
           call _cbQz() args: 0, res: 0, upd: 0;
     }
 },
 _cbQr() //  [R1]
         { info_tbl: [(cbQr,
                       label: block_cbQr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQr: // global
           if (R1 & 7 == 1) goto ubQG; else goto cbQD;
       ubQG: // global
           Sp = Sp + 24;
           call _cbQz() args: 0, res: 0, upd: 0;
       cbQD: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cbQz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQz: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.840711652 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c/=_closure" {
     GHC.Base.$fEqMaybe_$c/=_closure:
         const GHC.Base.$fEqMaybe_$c/=_info;
 },
 GHC.Base.$fEqMaybe_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(cbQY,
                       label: GHC.Base.$fEqMaybe_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbQZ; else goto cbR0;
       cbQZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbR0: // global
           I64[Sp - 24] = block_cbQR_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubRQ; else goto cbQS;
       ubRQ: // global
           call _cbQR(R1) args: 0, res: 0, upd: 0;
       cbQS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbQR() //  [R1]
         { info_tbl: [(cbQR,
                       label: block_cbQR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbQR: // global
           _s8ak::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbQV; else goto cbQW;
       cbQV: // global
           I64[Sp + 16] = block_cbR3_info;
           R1 = _s8ak::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubRO; else goto cbR5;
       ubRO: // global
           call _cbR3(R1) args: 0, res: 0, upd: 0;
       cbR5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbQW: // global
           I64[Sp] = block_cbRi_info;
           _s8ao::P64 = P64[R1 + 6];
           R1 = _s8ak::P64;
           P64[Sp + 16] = _s8ao::P64;
           if (R1 & 7 != 0) goto ubRP; else goto cbRk;
       ubRP: // global
           call _cbRi(R1) args: 0, res: 0, upd: 0;
       cbRk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbR3() //  [R1]
         { info_tbl: [(cbR3,
                       label: block_cbR3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbR3: // global
           if (R1 & 7 == 1) goto ubRM; else goto ubRN;
       ubRM: // global
           Sp = Sp + 8;
           call _cbRF() args: 0, res: 0, upd: 0;
       ubRN: // global
           Sp = Sp + 8;
           call _cbRB() args: 0, res: 0, upd: 0;
     }
 },
 _cbRi() //  [R1]
         { info_tbl: [(cbRi,
                       label: block_cbRi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRi: // global
           if (R1 & 7 == 1) goto ubRJ; else goto cbRv;
       ubRJ: // global
           Sp = Sp + 24;
           call _cbRB() args: 0, res: 0, upd: 0;
       cbRv: // global
           _s8ao::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbRt_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8ao::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbRt() //  [R1]
         { info_tbl: [(cbRt,
                       label: block_cbRt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRt: // global
           if (R1 & 7 == 1) goto ubRK; else goto ubRL;
       ubRK: // global
           Sp = Sp + 8;
           call _cbRB() args: 0, res: 0, upd: 0;
       ubRL: // global
           Sp = Sp + 8;
           call _cbRF() args: 0, res: 0, upd: 0;
     }
 },
 _cbRB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRB: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbRF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbRF: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.842969661 UTC

[section ""data" . GHC.Base.$fEqMaybe_closure" {
     GHC.Base.$fEqMaybe_closure:
         const GHC.Base.$fEqMaybe_info;
 },
 sat_s8au_entry() //  [R1, R2, R3]
         { info_tbl: [(cbS5,
                       label: sat_s8au_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbS5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8at_entry() //  [R1, R2, R3]
         { info_tbl: [(cbSd,
                       label: sat_s8at_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fEqMaybe_entry() //  [R2]
         { info_tbl: [(cbSh,
                       label: GHC.Base.$fEqMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbSl; else goto cbSk;
       cbSl: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSk: // global
           I64[Hp - 48] = sat_s8au_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8at_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.844461277 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cp1Ord_closure" {
     GHC.Base.$fOrdMaybe_$cp1Ord_closure:
         const GHC.Base.$fOrdMaybe_$cp1Ord_info;
 },
 sat_s8aw_entry() //  [R1]
         { info_tbl: [(cbSu,
                       label: sat_s8aw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbSv; else goto cbSw;
       cbSv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbSw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdMaybe_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cbSx,
                       label: GHC.Base.$fOrdMaybe_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbSB; else goto cbSA;
       cbSB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbSA: // global
           I64[Hp - 16] = sat_s8aw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqMaybe_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.846014009 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$ccompare_closure" {
     GHC.Base.$fOrdMaybe_$ccompare_closure:
         const GHC.Base.$fOrdMaybe_$ccompare_info;
 },
 GHC.Base.$fOrdMaybe_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(cbSN,
                       label: GHC.Base.$fOrdMaybe_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbSO; else goto cbSP;
       cbSO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSP: // global
           I64[Sp - 24] = block_cbSG_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubTo; else goto cbSH;
       ubTo: // global
           call _cbSG(R1) args: 0, res: 0, upd: 0;
       cbSH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSG() //  [R1]
         { info_tbl: [(cbSG,
                       label: block_cbSG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSG: // global
           _s8az::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbSK; else goto cbSL;
       cbSK: // global
           I64[Sp + 16] = block_cbSS_info;
           R1 = _s8az::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubTm; else goto cbSU;
       ubTm: // global
           call _cbSS(R1) args: 0, res: 0, upd: 0;
       cbSU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbSL: // global
           I64[Sp] = block_cbT7_info;
           _s8aD::P64 = P64[R1 + 6];
           R1 = _s8az::P64;
           P64[Sp + 16] = _s8aD::P64;
           if (R1 & 7 != 0) goto ubTn; else goto cbT9;
       ubTn: // global
           call _cbT7(R1) args: 0, res: 0, upd: 0;
       cbT9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbSS() //  [R1]
         { info_tbl: [(cbSS,
                       label: block_cbSS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbSS: // global
           if (R1 & 7 == 1) goto cbT0; else goto cbT4;
       cbT0: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbT4: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbT7() //  [R1]
         { info_tbl: [(cbT7,
                       label: block_cbT7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbT7: // global
           if (R1 & 7 == 1) goto cbTf; else goto cbTj;
       cbTf: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbTj: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.848168267 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<_closure" {
     GHC.Base.$fOrdMaybe_$c<_closure:
         const GHC.Base.$fOrdMaybe_$c<_info;
 },
 GHC.Base.$fOrdMaybe_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(cbTA,
                       label: GHC.Base.$fOrdMaybe_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbTB; else goto cbTC;
       cbTB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbTC: // global
           I64[Sp - 24] = block_cbTt_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubUd; else goto cbTu;
       ubUd: // global
           call _cbTt(R1) args: 0, res: 0, upd: 0;
       cbTu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTt() //  [R1]
         { info_tbl: [(cbTt,
                       label: block_cbTt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTt: // global
           _s8aI::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbTx; else goto cbTy;
       cbTx: // global
           I64[Sp + 16] = block_cbTF_info;
           R1 = _s8aI::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubUb; else goto cbTH;
       ubUb: // global
           call _cbTF(R1) args: 0, res: 0, upd: 0;
       cbTH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbTy: // global
           I64[Sp] = block_cbTU_info;
           _s8aM::P64 = P64[R1 + 6];
           R1 = _s8aI::P64;
           P64[Sp + 16] = _s8aM::P64;
           if (R1 & 7 != 0) goto ubUc; else goto cbTW;
       ubUc: // global
           call _cbTU(R1) args: 0, res: 0, upd: 0;
       cbTW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbTF() //  [R1]
         { info_tbl: [(cbTF,
                       label: block_cbTF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTF: // global
           if (R1 & 7 == 1) goto ubUa; else goto cbTR;
       ubUa: // global
           Sp = Sp + 8;
           call _cbU2() args: 0, res: 0, upd: 0;
       cbTR: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbTU() //  [R1]
         { info_tbl: [(cbTU,
                       label: block_cbTU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbTU: // global
           if (R1 & 7 == 1) goto ubU9; else goto cbU6;
       ubU9: // global
           Sp = Sp + 24;
           call _cbU2() args: 0, res: 0, upd: 0;
       cbU6: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cbU2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbU2: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.851248984 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<=_closure" {
     GHC.Base.$fOrdMaybe_$c<=_closure:
         const GHC.Base.$fOrdMaybe_$c<=_info;
 },
 GHC.Base.$fOrdMaybe_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(cbUr,
                       label: GHC.Base.$fOrdMaybe_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbUs; else goto cbUt;
       cbUs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbUt: // global
           I64[Sp - 24] = block_cbUk_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubVj; else goto cbUl;
       ubVj: // global
           call _cbUk(R1) args: 0, res: 0, upd: 0;
       cbUl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUk() //  [R1]
         { info_tbl: [(cbUk,
                       label: block_cbUk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUk: // global
           _s8aQ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbUo; else goto cbUp;
       cbUo: // global
           I64[Sp + 16] = block_cbUw_info;
           R1 = _s8aQ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubVh; else goto cbUy;
       ubVh: // global
           call _cbUw(R1) args: 0, res: 0, upd: 0;
       cbUy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbUp: // global
           I64[Sp] = block_cbUL_info;
           _s8aV::P64 = P64[R1 + 6];
           R1 = _s8aQ::P64;
           P64[Sp + 16] = _s8aV::P64;
           if (R1 & 7 != 0) goto ubVi; else goto cbUN;
       ubVi: // global
           call _cbUL(R1) args: 0, res: 0, upd: 0;
       cbUN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbUw() //  [R1]
         { info_tbl: [(cbUw,
                       label: block_cbUw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUw: // global
           if (R1 & 7 == 1) goto ubVf; else goto ubVg;
       ubVf: // global
           Sp = Sp + 8;
           call _cbV4() args: 0, res: 0, upd: 0;
       ubVg: // global
           Sp = Sp + 8;
           call _cbV8() args: 0, res: 0, upd: 0;
     }
 },
 _cbUL() //  [R1]
         { info_tbl: [(cbUL,
                       label: block_cbUL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUL: // global
           if (R1 & 7 == 1) goto ubVc; else goto cbUY;
       ubVc: // global
           Sp = Sp + 24;
           call _cbV4() args: 0, res: 0, upd: 0;
       cbUY: // global
           _s8aV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbUW_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8aV::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbUW() //  [R1]
         { info_tbl: [(cbUW,
                       label: block_cbUW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbUW: // global
           if (R1 & 7 == 1) goto ubVd; else goto ubVe;
       ubVd: // global
           Sp = Sp + 8;
           call _cbV4() args: 0, res: 0, upd: 0;
       ubVe: // global
           Sp = Sp + 8;
           call _cbV8() args: 0, res: 0, upd: 0;
     }
 },
 _cbV4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV4: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbV8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbV8: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.853712775 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmax_closure" {
     GHC.Base.$fOrdMaybe_$cmax_closure:
         const GHC.Base.$fOrdMaybe_$cmax_info;
 },
 GHC.Base.$fOrdMaybe_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(cbVA,
                       label: GHC.Base.$fOrdMaybe_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbVB; else goto cbVC;
       cbVB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbVC: // global
           I64[Sp - 24] = block_cbVt_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubWb; else goto cbVu;
       ubWb: // global
           call _cbVt(R1) args: 0, res: 0, upd: 0;
       cbVu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbVt() //  [R1]
         { info_tbl: [(cbVt,
                       label: block_cbVt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVt: // global
           _s8b0::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbVx; else goto cbVy;
       cbVx: // global
           R1 = _s8b0::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbVy: // global
           I64[Sp - 8] = block_cbVI_info;
           _s8b2::P64 = R1;
           _s8b3::P64 = P64[R1 + 6];
           R1 = _s8b0::P64;
           P64[Sp] = _s8b3::P64;
           P64[Sp + 16] = _s8b2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubWa; else goto cbVK;
       ubWa: // global
           call _cbVI(R1) args: 0, res: 0, upd: 0;
       cbVK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbVI() //  [R1]
         { info_tbl: [(cbVI,
                       label: block_cbVI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVI: // global
           if (R1 & 7 == 1) goto ubW8; else goto cbVV;
       ubW8: // global
           Sp = Sp + 24;
           call _cbW1() args: 0, res: 0, upd: 0;
       cbVV: // global
           _s8b3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbVT_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s8b3::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbVT() //  [R1]
         { info_tbl: [(cbVT,
                       label: block_cbVT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbVT: // global
           if (R1 & 7 == 1) goto ubW9; else goto cbW5;
       ubW9: // global
           Sp = Sp + 16;
           call _cbW1() args: 0, res: 0, upd: 0;
       cbW5: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbW1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbW1: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.85591636 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmin_closure" {
     GHC.Base.$fOrdMaybe_$cmin_closure:
         const GHC.Base.$fOrdMaybe_$cmin_info;
 },
 GHC.Base.$fOrdMaybe_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(cbWp,
                       label: GHC.Base.$fOrdMaybe_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbWp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbWq; else goto cbWr;
       cbWq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbWr: // global
           I64[Sp - 24] = block_cbWi_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubX5; else goto cbWj;
       ubX5: // global
           call _cbWi(R1) args: 0, res: 0, upd: 0;
       cbWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbWi() //  [R1]
         { info_tbl: [(cbWi,
                       label: block_cbWi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbWi: // global
           _s8b8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbWm; else goto cbWn;
       cbWm: // global
           I64[Sp + 16] = block_cbWu_info;
           R1 = _s8b8::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubX3; else goto cbWw;
       ubX3: // global
           call _cbWu() args: 0, res: 0, upd: 0;
       cbWw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbWn: // global
           I64[Sp - 8] = block_cbWD_info;
           _s8ba::P64 = R1;
           _s8bc::P64 = P64[R1 + 6];
           R1 = _s8b8::P64;
           P64[Sp] = _s8bc::P64;
           P64[Sp + 16] = _s8ba::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubX4; else goto cbWF;
       ubX4: // global
           call _cbWD(R1) args: 0, res: 0, upd: 0;
       cbWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbWu() //  []
         { info_tbl: [(cbWu,
                       label: block_cbWu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbWu: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbWD() //  [R1]
         { info_tbl: [(cbWD,
                       label: block_cbWD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbWD: // global
           if (R1 & 7 == 1) goto cbWL; else goto cbWQ;
       cbWL: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbWQ: // global
           _s8bc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbWO_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s8bc::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbWO() //  [R1]
         { info_tbl: [(cbWO,
                       label: block_cbWO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbWO: // global
           if (R1 & 7 == 1) goto cbWW; else goto cbX0;
       cbWW: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbX0: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.858384205 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c>=_closure" {
     GHC.Base.$fOrdMaybe_$c>=_closure:
         const GHC.Base.$fOrdMaybe_$c>=_info;
 },
 GHC.Base.$fOrdMaybe_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXh,
                       label: GHC.Base.$fOrdMaybe_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXi; else goto cbXj;
       cbXi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXj: // global
           I64[Sp - 24] = block_cbXa_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubY9; else goto cbXb;
       ubY9: // global
           call _cbXa(R1) args: 0, res: 0, upd: 0;
       cbXb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXa() //  [R1]
         { info_tbl: [(cbXa,
                       label: block_cbXa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXa: // global
           _s8bi::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbXe; else goto cbXf;
       cbXe: // global
           I64[Sp + 16] = block_cbXm_info;
           R1 = _s8bi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubY7; else goto cbXo;
       ubY7: // global
           call _cbXm(R1) args: 0, res: 0, upd: 0;
       cbXo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbXf: // global
           I64[Sp] = block_cbXB_info;
           _s8bm::P64 = P64[R1 + 6];
           R1 = _s8bi::P64;
           P64[Sp + 16] = _s8bm::P64;
           if (R1 & 7 != 0) goto ubY8; else goto cbXD;
       ubY8: // global
           call _cbXB(R1) args: 0, res: 0, upd: 0;
       cbXD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXm() //  [R1]
         { info_tbl: [(cbXm,
                       label: block_cbXm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXm: // global
           if (R1 & 7 == 1) goto ubY5; else goto ubY6;
       ubY5: // global
           Sp = Sp + 8;
           call _cbXU() args: 0, res: 0, upd: 0;
       ubY6: // global
           Sp = Sp + 8;
           call _cbXY() args: 0, res: 0, upd: 0;
     }
 },
 _cbXB() //  [R1]
         { info_tbl: [(cbXB,
                       label: block_cbXB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXB: // global
           if (R1 & 7 == 1) goto ubY2; else goto cbXO;
       ubY2: // global
           Sp = Sp + 24;
           call _cbXU() args: 0, res: 0, upd: 0;
       cbXO: // global
           _s8bm::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbXM_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8bm::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbXM() //  [R1]
         { info_tbl: [(cbXM,
                       label: block_cbXM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXM: // global
           if (R1 & 7 == 1) goto ubY3; else goto ubY4;
       ubY3: // global
           Sp = Sp + 8;
           call _cbXU() args: 0, res: 0, upd: 0;
       ubY4: // global
           Sp = Sp + 8;
           call _cbXY() args: 0, res: 0, upd: 0;
     }
 },
 _cbXU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXU: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbXY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXY: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.861492486 UTC

[section ""data" . GHC.Base.$fOrdMaybe_closure" {
     GHC.Base.$fOrdMaybe_closure:
         const GHC.Base.$fOrdMaybe_info;
 },
 sat_s8bA_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYo,
                       label: sat_s8bA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYo: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bz_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYw,
                       label: sat_s8bz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8by_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYE,
                       label: sat_s8by_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bx_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYM,
                       label: sat_s8bx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYM: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bu_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYU,
                       label: sat_s8bu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bt_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZ2,
                       label: sat_s8bt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bs_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZa,
                       label: sat_s8bs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZa: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8br_entry() //  [R1]
         { info_tbl: [(cbZh,
                       label: sat_s8br_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZi; else goto cbZj;
       cbZi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdMaybe_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdMaybe_entry() //  [R2]
         { info_tbl: [(cbZl,
                       label: GHC.Base.$fOrdMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZl: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cbZp; else goto cbZo;
       cbZp: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZo: // global
           I64[Hp - 200] = sat_s8bA_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s8bz_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8by_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s8bx_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s8bu_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s8bt_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8bs_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8br_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.864691788 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c/=_closure" {
     GHC.Base.$fEqNonEmpty_$c/=_closure:
         const GHC.Base.$fEqNonEmpty_$c/=_info;
 },
 GHC.Base.$fEqNonEmpty_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZx,
                       label: GHC.Base.$fEqNonEmpty_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZx: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbZB; else goto cbZC;
       cbZB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZC: // global
           I64[Sp - 24] = block_cbZu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc0a; else goto cbZv;
       uc0a: // global
           call _cbZu(R1) args: 0, res: 0, upd: 0;
       cbZv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZu() //  [R1]
         { info_tbl: [(cbZu,
                       label: block_cbZu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZu: // global
           I64[Sp - 8] = block_cbZA_info;
           _s8bF::P64 = P64[R1 + 7];
           _s8bG::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8bG::P64;
           P64[Sp + 16] = _s8bF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc09; else goto cbZE;
       uc09: // global
           call _cbZA(R1) args: 0, res: 0, upd: 0;
       cbZE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZA() //  [R1]
         { info_tbl: [(cbZA,
                       label: block_cbZA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZA: // global
           I64[Sp] = block_cbZI_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbZI() //  [R1]
         { info_tbl: [(cbZI,
                       label: block_cbZI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZI: // global
           if (R1 & 7 == 1) goto uc07; else goto cbZU;
       uc07: // global
           Sp = Sp + 32;
           call _cc00() args: 0, res: 0, upd: 0;
       cbZU: // global
           _s8bJ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cbZS_info;
           R4 = _s8bJ::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZS() //  [R1]
         { info_tbl: [(cbZS,
                       label: block_cbZS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZS: // global
           if (R1 & 7 == 1) goto uc08; else goto cc04;
       uc08: // global
           Sp = Sp + 8;
           call _cc00() args: 0, res: 0, upd: 0;
       cc04: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc00() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc00: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.866904276 UTC

[section ""data" . GHC.Base.$w$c==_closure" {
     GHC.Base.$w$c==_closure:
         const GHC.Base.$w$c==_info;
 },
 GHC.Base.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc0n,
                       label: GHC.Base.$w$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0n: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc0o; else goto cc0p;
       cc0o: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0p: // global
           I64[Sp - 32] = block_cc0h_info;
           _s8bM::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8bM::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc0h() //  [R1]
         { info_tbl: [(cc0h,
                       label: block_cc0h_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0h: // global
           if (R1 & 7 == 1) goto cc0k; else goto cc0l;
       cc0k: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc0l: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.869160821 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c==_closure" {
     GHC.Base.$fEqNonEmpty_$c==_closure:
         const GHC.Base.$fEqNonEmpty_$c==_info;
 },
 GHC.Base.$fEqNonEmpty_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(cc0D,
                       label: GHC.Base.$fEqNonEmpty_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc0H; else goto cc0I;
       cc0H: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0I: // global
           I64[Sp - 24] = block_cc0A_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc0Q; else goto cc0B;
       uc0Q: // global
           call _cc0A(R1) args: 0, res: 0, upd: 0;
       cc0B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0A() //  [R1]
         { info_tbl: [(cc0A,
                       label: block_cc0A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0A: // global
           I64[Sp - 8] = block_cc0G_info;
           _s8bW::P64 = P64[R1 + 7];
           _s8bX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8bX::P64;
           P64[Sp + 16] = _s8bW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc0P; else goto cc0K;
       uc0P: // global
           call _cc0G(R1) args: 0, res: 0, upd: 0;
       cc0K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0G() //  [R1]
         { info_tbl: [(cc0G,
                       label: block_cc0G_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0G: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c==_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.87148918 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_closure" {
     GHC.Base.$fEqNonEmpty_closure:
         const GHC.Base.$fEqNonEmpty_info;
 },
 sat_s8c3_entry() //  [R1, R2, R3]
         { info_tbl: [(cc10,
                       label: sat_s8c3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc10: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c/=_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8c2_entry() //  [R1, R2, R3]
         { info_tbl: [(cc18,
                       label: sat_s8c2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc18: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c==_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fEqNonEmpty_entry() //  [R2]
         { info_tbl: [(cc1c,
                       label: GHC.Base.$fEqNonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1c: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc1g; else goto cc1f;
       cc1g: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1f: // global
           I64[Hp - 48] = sat_s8c3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8c2_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.872957919 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cp1Ord_closure" {
     GHC.Base.$fOrdNonEmpty_$cp1Ord_closure:
         const GHC.Base.$fOrdNonEmpty_$cp1Ord_info;
 },
 sat_s8c5_entry() //  [R1]
         { info_tbl: [(cc1p,
                       label: sat_s8c5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1q; else goto cc1r;
       cc1q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdNonEmpty_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cc1s,
                       label: GHC.Base.$fOrdNonEmpty_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc1w; else goto cc1v;
       cc1w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1v: // global
           I64[Hp - 16] = sat_s8c5_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqNonEmpty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.874334315 UTC

[section ""data" . GHC.Base.$w$ccompare_closure" {
     GHC.Base.$w$ccompare_closure:
         const GHC.Base.$w$ccompare_info;
 },
 GHC.Base.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc1I,
                       label: GHC.Base.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1I: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc1J; else goto cc1K;
       cc1J: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1K: // global
           I64[Sp - 32] = block_cc1B_info;
           _s8c6::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8c6::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc1B() //  [R1]
         { info_tbl: [(cc1B,
                       label: block_cc1B_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1B: // global
           _cc1H::P64 = R1 & 7;
           if (_cc1H::P64 < 3) goto uc1U; else goto cc1G;
       uc1U: // global
           if (_cc1H::P64 < 2) goto cc1E; else goto cc1F;
       cc1E: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc1F: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
       cc1G: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.875856239 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$ccompare_closure" {
     GHC.Base.$fOrdNonEmpty_$ccompare_closure:
         const GHC.Base.$fOrdNonEmpty_$ccompare_info;
 },
 GHC.Base.$fOrdNonEmpty_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(cc22,
                       label: GHC.Base.$fOrdNonEmpty_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc22: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc26; else goto cc27;
       cc26: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc27: // global
           I64[Sp - 24] = block_cc1Z_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc2f; else goto cc20;
       uc2f: // global
           call _cc1Z(R1) args: 0, res: 0, upd: 0;
       cc20: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1Z() //  [R1]
         { info_tbl: [(cc1Z,
                       label: block_cc1Z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Z: // global
           I64[Sp - 8] = block_cc25_info;
           _s8cg::P64 = P64[R1 + 7];
           _s8ch::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8ch::P64;
           P64[Sp + 16] = _s8cg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2e; else goto cc29;
       uc2e: // global
           call _cc25(R1) args: 0, res: 0, upd: 0;
       cc29: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc25() //  [R1]
         { info_tbl: [(cc25,
                       label: block_cc25_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc25: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.877473999 UTC

[section ""data" . GHC.Base.$w$c<_closure" {
     GHC.Base.$w$c<_closure:
         const GHC.Base.$w$c<_info;
 },
 GHC.Base.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc2r,
                       label: GHC.Base.$w$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2r: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc2s; else goto cc2t;
       cc2s: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2t: // global
           I64[Sp - 32] = block_cc2k_info;
           _s8cl::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8cl::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc2k() //  [R1]
         { info_tbl: [(cc2k,
                       label: block_cc2k_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2k: // global
           _cc2q::P64 = R1 & 7;
           if (_cc2q::P64 < 3) goto uc2D; else goto cc2p;
       uc2D: // global
           if (_cc2q::P64 < 2) goto cc2n; else goto cc2o;
       cc2n: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc2o: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       cc2p: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.878973052 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<_closure" {
     GHC.Base.$fOrdNonEmpty_$c<_closure:
         const GHC.Base.$fOrdNonEmpty_$c<_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(cc2L,
                       label: GHC.Base.$fOrdNonEmpty_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2P; else goto cc2Q;
       cc2P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Q: // global
           I64[Sp - 24] = block_cc2I_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc2Y; else goto cc2J;
       uc2Y: // global
           call _cc2I(R1) args: 0, res: 0, upd: 0;
       cc2J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2I() //  [R1]
         { info_tbl: [(cc2I,
                       label: block_cc2I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2I: // global
           I64[Sp - 8] = block_cc2O_info;
           _s8cv::P64 = P64[R1 + 7];
           _s8cw::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8cw::P64;
           P64[Sp + 16] = _s8cv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2X; else goto cc2S;
       uc2X: // global
           call _cc2O(R1) args: 0, res: 0, upd: 0;
       cc2S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2O() //  [R1]
         { info_tbl: [(cc2O,
                       label: block_cc2O_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2O: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.880745286 UTC

[section ""data" . GHC.Base.$w$c<=_closure" {
     GHC.Base.$w$c<=_closure:
         const GHC.Base.$w$c<=_info;
 },
 GHC.Base.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc3a,
                       label: GHC.Base.$w$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3a: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc3b; else goto cc3c;
       cc3b: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc3c: // global
           I64[Sp - 32] = block_cc33_info;
           _s8cA::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R5;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _s8cA::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc33() //  [R1]
         { info_tbl: [(cc33,
                       label: block_cc33_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc33: // global
           _cc39::P64 = R1 & 7;
           if (_cc39::P64 < 3) goto uc3y; else goto uc3z;
       uc3y: // global
           if (_cc39::P64 < 2) goto uc3A; else goto cc37;
       uc3A: // global
           Sp = Sp + 32;
           call _cc3t() args: 0, res: 0, upd: 0;
       cc37: // global
           _s8cE::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cc3i_info;
           R4 = P64[Sp + 16];
           R3 = _s8cE::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       uc3z: // global
           Sp = Sp + 32;
           call _cc38() args: 0, res: 0, upd: 0;
     }
 },
 _cc3i() //  [R1]
         { info_tbl: [(cc3i,
                       label: block_cc3i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3i: // global
           if (R1 & 7 == 1) goto uc3B; else goto uc3C;
       uc3B: // global
           Sp = Sp + 8;
           call _cc3t() args: 0, res: 0, upd: 0;
       uc3C: // global
           Sp = Sp + 8;
           call _cc38() args: 0, res: 0, upd: 0;
     }
 },
 _cc3t() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3t: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc38() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc38: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.882763531 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<=_closure" {
     GHC.Base.$fOrdNonEmpty_$c<=_closure:
         const GHC.Base.$fOrdNonEmpty_$c<=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(cc3O,
                       label: GHC.Base.$fOrdNonEmpty_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc3S; else goto cc3T;
       cc3S: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc3T: // global
           I64[Sp - 24] = block_cc3L_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc41; else goto cc3M;
       uc41: // global
           call _cc3L(R1) args: 0, res: 0, upd: 0;
       cc3M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc3L() //  [R1]
         { info_tbl: [(cc3L,
                       label: block_cc3L_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3L: // global
           I64[Sp - 8] = block_cc3R_info;
           _s8cL::P64 = P64[R1 + 7];
           _s8cM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8cM::P64;
           P64[Sp + 16] = _s8cL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc40; else goto cc3V;
       uc40: // global
           call _cc3R(R1) args: 0, res: 0, upd: 0;
       cc3V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc3R() //  [R1]
         { info_tbl: [(cc3R,
                       label: block_cc3R_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3R: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.884764569 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmax_closure" {
     GHC.Base.$fOrdNonEmpty_$cmax_closure:
         const GHC.Base.$fOrdNonEmpty_$cmax_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(cc49,
                       label: GHC.Base.$fOrdNonEmpty_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc49: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cc4d; else goto cc4e;
       cc4d: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4e: // global
           I64[Sp - 24] = block_cc46_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc4T; else goto cc47;
       uc4T: // global
           call _cc46(R1) args: 0, res: 0, upd: 0;
       cc47: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc46() //  [R1]
         { info_tbl: [(cc46,
                       label: block_cc46_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc46: // global
           I64[Sp - 16] = block_cc4c_info;
           _s8cT::P64 = R1;
           _s8cU::P64 = P64[R1 + 7];
           _s8cV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8cV::P64;
           P64[Sp] = _s8cU::P64;
           P64[Sp + 16] = _s8cT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4S; else goto cc4g;
       uc4S: // global
           call _cc4c(R1) args: 0, res: 0, upd: 0;
       cc4g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4c() //  [R1]
         { info_tbl: [(cc4c,
                       label: block_cc4c_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4c: // global
           I64[Sp - 8] = block_cc4k_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc4k() //  [R1]
         { info_tbl: [(cc4k,
                       label: block_cc4k_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4k: // global
           _cc4L::P64 = R1 & 7;
           if (_cc4L::P64 < 3) goto uc4N; else goto uc4O;
       uc4N: // global
           if (_cc4L::P64 < 2) goto uc4P; else goto cc4w;
       uc4P: // global
           Sp = Sp + 40;
           call _cc4G() args: 0, res: 0, upd: 0;
       cc4w: // global
           _s8cV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cc4u_info;
           R4 = _s8cV::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       uc4O: // global
           Sp = Sp + 24;
           call _cc4K() args: 0, res: 0, upd: 0;
     }
 },
 _cc4u() //  [R1]
         { info_tbl: [(cc4u,
                       label: block_cc4u_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4u: // global
           if (R1 & 7 == 1) goto uc4Q; else goto uc4R;
       uc4Q: // global
           Sp = Sp + 24;
           call _cc4G() args: 0, res: 0, upd: 0;
       uc4R: // global
           Sp = Sp + 8;
           call _cc4K() args: 0, res: 0, upd: 0;
     }
 },
 _cc4G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4G: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc4K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4K: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.888137303 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmin_closure" {
     GHC.Base.$fOrdNonEmpty_$cmin_closure:
         const GHC.Base.$fOrdNonEmpty_$cmin_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(cc55,
                       label: GHC.Base.$fOrdNonEmpty_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc55: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cc59; else goto cc5a;
       cc59: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5a: // global
           I64[Sp - 24] = block_cc52_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc5P; else goto cc53;
       uc5P: // global
           call _cc52(R1) args: 0, res: 0, upd: 0;
       cc53: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc52() //  [R1]
         { info_tbl: [(cc52,
                       label: block_cc52_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc52: // global
           I64[Sp - 16] = block_cc58_info;
           _s8d4::P64 = R1;
           _s8d5::P64 = P64[R1 + 7];
           _s8d6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8d6::P64;
           P64[Sp] = _s8d5::P64;
           P64[Sp + 16] = _s8d4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5O; else goto cc5c;
       uc5O: // global
           call _cc58(R1) args: 0, res: 0, upd: 0;
       cc5c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc58() //  [R1]
         { info_tbl: [(cc58,
                       label: block_cc58_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc58: // global
           I64[Sp - 8] = block_cc5g_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc5g() //  [R1]
         { info_tbl: [(cc5g,
                       label: block_cc5g_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5g: // global
           _cc5H::P64 = R1 & 7;
           if (_cc5H::P64 < 3) goto uc5J; else goto uc5K;
       uc5J: // global
           if (_cc5H::P64 < 2) goto uc5L; else goto cc5s;
       uc5L: // global
           Sp = Sp + 24;
           call _cc5C() args: 0, res: 0, upd: 0;
       cc5s: // global
           _s8d6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cc5q_info;
           R4 = _s8d6::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       uc5K: // global
           Sp = Sp + 40;
           call _cc5G() args: 0, res: 0, upd: 0;
     }
 },
 _cc5q() //  [R1]
         { info_tbl: [(cc5q,
                       label: block_cc5q_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5q: // global
           if (R1 & 7 == 1) goto uc5M; else goto uc5N;
       uc5M: // global
           Sp = Sp + 8;
           call _cc5C() args: 0, res: 0, upd: 0;
       uc5N: // global
           Sp = Sp + 24;
           call _cc5G() args: 0, res: 0, upd: 0;
     }
 },
 _cc5C() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5C: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc5G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5G: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.890552043 UTC

[section ""data" . GHC.Base.$w$c>=_closure" {
     GHC.Base.$w$c>=_closure:
         const GHC.Base.$w$c>=_info;
 },
 GHC.Base.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc65,
                       label: GHC.Base.$w$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc65: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cc66; else goto cc67;
       cc66: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc67: // global
           I64[Sp - 32] = block_cc5Y_info;
           _s8dc::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8dc::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc5Y() //  [R1]
         { info_tbl: [(cc5Y,
                       label: block_cc5Y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Y: // global
           _cc64::P64 = R1 & 7;
           if (_cc64::P64 < 3) goto uc6t; else goto uc6u;
       uc6t: // global
           if (_cc64::P64 < 2) goto uc6v; else goto cc62;
       uc6v: // global
           Sp = Sp + 32;
           call _cc6o() args: 0, res: 0, upd: 0;
       cc62: // global
           _s8dg::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cc6d_info;
           R4 = _s8dg::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       uc6u: // global
           Sp = Sp + 32;
           call _cc63() args: 0, res: 0, upd: 0;
     }
 },
 _cc6d() //  [R1]
         { info_tbl: [(cc6d,
                       label: block_cc6d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6d: // global
           if (R1 & 7 == 1) goto uc6w; else goto uc6x;
       uc6w: // global
           Sp = Sp + 8;
           call _cc6o() args: 0, res: 0, upd: 0;
       uc6x: // global
           Sp = Sp + 8;
           call _cc63() args: 0, res: 0, upd: 0;
     }
 },
 _cc6o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6o: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cc63() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc63: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.892323044 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c>=_closure" {
     GHC.Base.$fOrdNonEmpty_$c>=_closure:
         const GHC.Base.$fOrdNonEmpty_$c>=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cc6J,
                       label: GHC.Base.$fOrdNonEmpty_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6J: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc6N; else goto cc6O;
       cc6N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6O: // global
           I64[Sp - 24] = block_cc6G_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc6W; else goto cc6H;
       uc6W: // global
           call _cc6G(R1) args: 0, res: 0, upd: 0;
       cc6H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6G() //  [R1]
         { info_tbl: [(cc6G,
                       label: block_cc6G_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6G: // global
           I64[Sp - 8] = block_cc6M_info;
           _s8dn::P64 = P64[R1 + 7];
           _s8do::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8do::P64;
           P64[Sp + 16] = _s8dn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc6V; else goto cc6Q;
       uc6V: // global
           call _cc6M(R1) args: 0, res: 0, upd: 0;
       cc6Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6M() //  [R1]
         { info_tbl: [(cc6M,
                       label: block_cc6M_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6M: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c>=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.89466032 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_closure" {
     GHC.Base.$fOrdNonEmpty_closure:
         const GHC.Base.$fOrdNonEmpty_info;
 },
 sat_s8dC_entry() //  [R1, R2, R3]
         { info_tbl: [(cc76,
                       label: sat_s8dC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc76: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmin_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dB_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7e,
                       label: sat_s8dB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7e: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmax_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dA_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7m,
                       label: sat_s8dA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7m: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c>=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dz_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7u,
                       label: sat_s8dz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7u: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dw_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7C,
                       label: sat_s8dw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7C: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dv_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7K,
                       label: sat_s8dv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7K: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8du_entry() //  [R1, R2, R3]
         { info_tbl: [(cc7S,
                       label: sat_s8du_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7S: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$ccompare_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dt_entry() //  [R1]
         { info_tbl: [(cc7Z,
                       label: sat_s8dt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc7Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc80; else goto cc81;
       cc80: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc81: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdNonEmpty_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdNonEmpty_entry() //  [R2]
         { info_tbl: [(cc83,
                       label: GHC.Base.$fOrdNonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc83: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cc87; else goto cc86;
       cc87: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc86: // global
           I64[Hp - 200] = sat_s8dC_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s8dB_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8dA_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s8dz_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s8dw_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s8dv_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8du_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8dt_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.897047565 UTC

[section ""data" . GHC.Base.$fMonadIO_$cfail_closure" {
     GHC.Base.$fMonadIO_$cfail_closure:
         const GHC.Base.$fMonadIO_$cfail_info;
         const 0;
 },
 GHC.Base.$fMonadIO_$cfail_entry() //  [R2]
         { info_tbl: [(cc8c,
                       label: GHC.Base.$fMonadIO_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8c: // global
           R2 = R2;
           R1 = GHC.IO.failIO_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.897851416 UTC

[section ""data" . GHC.Base.$fMonadIO_closure" {
     GHC.Base.$fMonadIO_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fMonadIO1_closure+3;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fMonadIO_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.898548806 UTC

[section ""data" . GHC.Base.$fMonad[]_$cfail_closure" {
     GHC.Base.$fMonad[]_$cfail_closure:
         const GHC.Base.$fMonad[]_$cfail_info;
 },
 GHC.Base.$fMonad[]_$cfail_entry() //  []
         { info_tbl: [(cc8j,
                       label: GHC.Base.$fMonad[]_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8j: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.899296915 UTC

[section ""data" . GHC.Base.$fMonad[]_closure" {
     GHC.Base.$fMonad[]_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Base.$fMonad[]_$c>>=_closure+2;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fMonad[]_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.899930501 UTC

[section ""data" . GHC.Base.$fMonadPlus[]_closure" {
     GHC.Base.$fMonadPlus[]_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternative[]_closure+1;
         const GHC.Base.$fMonad[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.900849406 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$c>>=_closure" {
     GHC.Base.$fMonadMaybe_$c>>=_closure:
         const GHC.Base.$fMonadMaybe_$c>>=_info;
 },
 GHC.Base.$fMonadMaybe_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cc8x,
                       label: GHC.Base.$fMonadMaybe_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc8y; else goto cc8z;
       cc8y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadMaybe_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8z: // global
           I64[Sp - 16] = block_cc8q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc8G; else goto cc8r;
       uc8G: // global
           call _cc8q(R1) args: 0, res: 0, upd: 0;
       cc8r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc8q() //  [R1]
         { info_tbl: [(cc8q,
                       label: block_cc8q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8q: // global
           if (R1 & 7 == 1) goto cc8u; else goto cc8v;
       cc8u: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc8v: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.902851348 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$cfail_closure" {
     GHC.Base.$fMonadMaybe_$cfail_closure:
         const GHC.Base.$fMonadMaybe_$cfail_info;
 },
 GHC.Base.$fMonadMaybe_$cfail_entry() //  []
         { info_tbl: [(cc8L,
                       label: GHC.Base.$fMonadMaybe_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8L: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.903722577 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>=_closure" {
     GHC.Base.$fMonad(->)_$c>>=_closure:
         const GHC.Base.$fMonad(->)_$c>>=_info;
 },
 GHC.Base.$fMonad(->)_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cc8T,
                       label: GHC.Base.$fMonad(->)_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc8T: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc8X; else goto cc8W;
       cc8X: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(->)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc8W: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _s8dL::P64 = R3;
           R3 = R4;
           R2 = Hp - 24;
           R1 = _s8dL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.905180595 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>=_closure" {
     GHC.Base.$fMonad(,)_$c>>=_closure:
         const GHC.Base.$fMonad(,)_$c>>=_info;
 },
 sat_s8dY_entry() //  [R1]
         { info_tbl: [(cc9h,
                       label: sat_s8dY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc9h: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc9i; else goto cc9j;
       cc9i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc9j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc9f_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc9f() //  [R1]
         { info_tbl: [(cc9f,
                       label: block_cc9f_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc9f: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cc9n,
                       label: GHC.Base.$fMonad(,)_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc9n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc9p; else goto cc9q;
       cc9p: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc9q: // global
           I64[Sp - 24] = block_cc92_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc9v; else goto cc93;
       uc9v: // global
           call _cc92(R1) args: 0, res: 0, upd: 0;
       cc93: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc92() //  [R1]
         { info_tbl: [(cc92,
                       label: block_cc92_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc92: // global
           I64[Sp] = block_cc97_info;
           R2 = P64[R1 + 15];
           _s8dS::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8dS::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc97() //  [R1]
         { info_tbl: [(cc97,
                       label: block_cc97_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc97: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc9u; else goto cc9t;
       cc9u: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc9t: // global
           _s8dV::P64 = P64[R1 + 7];
           _s8dW::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s8dY_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s8dV::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s8dW::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.907500101 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*>_closure" {
     GHC.Base.$fApplicative(,)_$c<*>_closure:
         const GHC.Base.$fApplicative(,)_$c<*>_info;
 },
 sat_s8e9_entry() //  [R1]
         { info_tbl: [(cc9R,
                       label: sat_s8e9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc9R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc9S; else goto cc9T;
       cc9S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc9T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc9P_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc9P() //  [R1]
         { info_tbl: [(cc9P,
                       label: block_cc9P_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc9P: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(cc9X,
                       label: GHC.Base.$fApplicative(,)_$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc9X: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc9Z; else goto cca0;
       cc9Z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cca0: // global
           I64[Sp - 24] = block_cc9A_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uca6; else goto cc9B;
       uca6: // global
           call _cc9A(R1) args: 0, res: 0, upd: 0;
       cc9B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc9A() //  [R1]
         { info_tbl: [(cc9A,
                       label: block_cc9A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc9A: // global
           I64[Sp - 8] = block_cc9F_info;
           _s8e3::P64 = P64[R1 + 7];
           _s8e4::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8e4::P64;
           P64[Sp + 16] = _s8e3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uca5; else goto cc9G;
       uca5: // global
           call _cc9F(R1) args: 0, res: 0, upd: 0;
       cc9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc9F() //  [R1]
         { info_tbl: [(cc9F,
                       label: block_cc9F_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc9F: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cca4; else goto cca3;
       cca4: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cca3: // global
           _s8e6::P64 = P64[R1 + 7];
           _s8e7::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8e7::P64;
           I64[Hp - 56] = sat_s8e9_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s8e6::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.910037357 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c*>_closure" {
     GHC.Base.$fApplicative(,)_$c*>_closure:
         const GHC.Base.$fApplicative(,)_$c*>_info;
 },
 sat_s8el_entry() //  [R1]
         { info_tbl: [(ccar,
                       label: sat_s8el_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccar: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccas; else goto ccat;
       ccas: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccat: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccap_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccap() //  [R1]
         { info_tbl: [(ccap,
                       label: block_ccap_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccap: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c*>_entry() //  [R2, R3, R4]
         { info_tbl: [(ccax,
                       label: GHC.Base.$fApplicative(,)_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccax: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccaz; else goto ccaA;
       ccaz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccaA: // global
           I64[Sp - 24] = block_ccab_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucaG; else goto ccac;
       ucaG: // global
           call _ccab(R1) args: 0, res: 0, upd: 0;
       ccac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccab() //  [R1]
         { info_tbl: [(ccab,
                       label: block_ccab_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccab: // global
           I64[Sp] = block_ccag_info;
           _s8ef::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8ef::P64;
           if (R1 & 7 != 0) goto ucaF; else goto ccah;
       ucaF: // global
           call _ccag(R1) args: 0, res: 0, upd: 0;
       ccah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccag() //  [R1]
         { info_tbl: [(ccag,
                       label: block_ccag_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccag: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccaE; else goto ccaD;
       ccaE: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccaD: // global
           _s8ei::P64 = P64[R1 + 7];
           _s8ej::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s8el_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s8ei::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s8ej::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.912363986 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$cliftA2_closure" {
     GHC.Base.$fApplicative(,)_$cliftA2_closure:
         const GHC.Base.$fApplicative(,)_$cliftA2_info;
 },
 sat_s8ex_entry() //  [R1]
         { info_tbl: [(ccb2,
                       label: sat_s8ex_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccb2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccb3; else goto ccb4;
       ccb3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccb4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccb0_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccb0() //  [R1]
         { info_tbl: [(ccb0,
                       label: block_ccb0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccb0: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccb8,
                       label: GHC.Base.$fApplicative(,)_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccb8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccba; else goto ccbb;
       ccba: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccbb: // global
           I64[Sp - 32] = block_ccaL_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucbh; else goto ccaM;
       ucbh: // global
           call _ccaL(R1) args: 0, res: 0, upd: 0;
       ccaM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccaL() //  [R1]
         { info_tbl: [(ccaL,
                       label: block_ccaL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccaL: // global
           I64[Sp - 8] = block_ccaQ_info;
           _s8er::P64 = P64[R1 + 7];
           _s8es::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8es::P64;
           P64[Sp + 24] = _s8er::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucbg; else goto ccaR;
       ucbg: // global
           call _ccaQ(R1) args: 0, res: 0, upd: 0;
       ccaR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccaQ() //  [R1]
         { info_tbl: [(ccaQ,
                       label: block_ccaQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccaQ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccbf; else goto ccbe;
       ccbf: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccbe: // global
           _s8eu::P64 = P64[R1 + 7];
           _s8ev::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8ev::P64;
           I64[Hp - 56] = sat_s8ex_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8eu::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.914936038 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmempty_info;
 },
 sat_s8eI_entry() //  [R1]
         { info_tbl: [(ccbq,
                       label: sat_s8eI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccbq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccbr; else goto ccbs;
       ccbr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccbs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eH_entry() //  [R1]
         { info_tbl: [(ccbx,
                       label: sat_s8eH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccbx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccby; else goto ccbz;
       ccby: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccbz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eG_entry() //  [R1]
         { info_tbl: [(ccbE,
                       label: sat_s8eG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccbE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccbF; else goto ccbG;
       ccbF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccbG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eF_entry() //  [R1]
         { info_tbl: [(ccbL,
                       label: sat_s8eF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccbL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccbM; else goto ccbN;
       ccbM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccbN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eE_entry() //  [R1]
         { info_tbl: [(ccbS,
                       label: sat_s8eE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccbS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccbT; else goto ccbU;
       ccbT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccbU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cmempty_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccbW,
                       label: GHC.Base.$fMonoid(,,,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccbW: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccc0; else goto ccbZ;
       ccc0: // global
           HpAlloc = 168;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmempty_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccbZ: // global
           I64[Hp - 160] = sat_s8eI_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_s8eH_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_s8eG_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8eF_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8eE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.917565194 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,)_$cmempty_info;
 },
 sat_s8eQ_entry() //  [R1]
         { info_tbl: [(ccc9,
                       label: sat_s8eQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccc9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccca; else goto cccb;
       ccca: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eP_entry() //  [R1]
         { info_tbl: [(cccg,
                       label: sat_s8eP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccch; else goto ccci;
       ccch: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccci: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eO_entry() //  [R1]
         { info_tbl: [(cccn,
                       label: sat_s8eO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccco; else goto cccp;
       ccco: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eN_entry() //  [R1]
         { info_tbl: [(cccu,
                       label: sat_s8eN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccv; else goto cccw;
       cccv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_$cmempty_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cccy,
                       label: GHC.Base.$fMonoid(,,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccy: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cccC; else goto cccB;
       cccC: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmempty_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cccB: // global
           I64[Hp - 128] = sat_s8eQ_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8eP_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_s8eO_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s8eN_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.9206703 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,)_$cmempty_info;
 },
 sat_s8eW_entry() //  [R1]
         { info_tbl: [(cccL,
                       label: sat_s8eW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccM; else goto cccN;
       cccM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eV_entry() //  [R1]
         { info_tbl: [(cccS,
                       label: sat_s8eV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cccT; else goto cccU;
       cccT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cccU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eU_entry() //  [R1]
         { info_tbl: [(cccZ,
                       label: sat_s8eU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cccZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccd0; else goto ccd1;
       ccd0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccd1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmempty_entry() //  [R2, R3, R4]
         { info_tbl: [(ccd3,
                       label: GHC.Base.$fMonoid(,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccd3: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccd7; else goto ccd6;
       ccd7: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmempty_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccd6: // global
           I64[Hp - 96] = sat_s8eW_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s8eV_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s8eU_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.92262672 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,)_$cmempty_info;
 },
 sat_s8f0_entry() //  [R1]
         { info_tbl: [(ccdg,
                       label: sat_s8f0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdh; else goto ccdi;
       ccdh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eZ_entry() //  [R1]
         { info_tbl: [(ccdn,
                       label: sat_s8eZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdo; else goto ccdp;
       ccdo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cmempty_entry() //  [R2, R3]
         { info_tbl: [(ccdr,
                       label: GHC.Base.$fMonoid(,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdr: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccdv; else goto ccdu;
       ccdv: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccdu: // global
           I64[Hp - 64] = sat_s8f0_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_s8eZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.925723756 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,)_$cmconcat_info;
 },
 $dSemigroup_s8f4_entry() //  [R1]
         { info_tbl: [(ccdE,
                       label: $dSemigroup_s8f4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdF; else goto ccdG;
       ccdF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup1_s8f5_entry() //  [R1]
         { info_tbl: [(ccdL,
                       label: $dSemigroup1_s8f5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdM; else goto ccdN;
       ccdM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8f6_entry() //  [R1]
         { info_tbl: [(ccdS,
                       label: z_s8f6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccdT; else goto ccdU;
       ccdT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccdU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8f7_entry() //  [R1]
         { info_tbl: [(ccdZ,
                       label: z1_s8f7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccdZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cce0; else goto cce1;
       cce0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cce1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8fl_entry() //  [R1]
         { info_tbl: [(ccer,
                       label: sat_s8fl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccer: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cces; else goto ccet;
       cces: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccet: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8fk_entry() //  [R1]
         { info_tbl: [(ccey,
                       label: sat_s8fk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccey: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccez; else goto cceA;
       ccez: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cceA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8f9_entry() //  [R1, R2]
         { info_tbl: [(cceF,
                       label: go_s8f9_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cceG; else goto cceH;
       cceG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cceH: // global
           I64[Sp - 40] = block_cce8_info;
           _s8f9::P64 = R1;
           _s8f4::P64 = P64[R1 + 7];
           _s8f5::P64 = P64[R1 + 15];
           _s8f8::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s8f4::P64;
           P64[Sp - 24] = _s8f5::P64;
           P64[Sp - 16] = _s8f8::P64;
           P64[Sp - 8] = _s8f9::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uceR; else goto cce9;
       uceR: // global
           call _cce8(R1) args: 0, res: 0, upd: 0;
       cce9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cce8() //  [R1]
         { info_tbl: [(cce8,
                       label: block_cce8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cce8: // global
           if (R1 & 7 == 1) goto cceC; else goto cceD;
       cceC: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cceD: // global
           I64[Sp] = block_ccee_info;
           _s8fd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _s8fd::P64;
           if (R1 & 7 != 0) goto uceQ; else goto ccef;
       uceQ: // global
           call _ccee(R1) args: 0, res: 0, upd: 0;
       ccef: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccee() //  [R1]
         { info_tbl: [(ccee,
                       label: block_ccee_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccee: // global
           I64[Sp] = block_ccej_info;
           R2 = P64[Sp + 24];
           _s8ff::P64 = P64[R1 + 7];
           _s8fg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _s8fg::P64;
           P64[Sp + 32] = _s8ff::P64;
           call go_s8f9_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccej() //  [R1]
         { info_tbl: [(ccej,
                       label: block_ccej_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccej: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cceP; else goto cceO;
       cceP: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cceO: // global
           _s8fi::P64 = P64[R1 + 7];
           _s8fj::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s8fl_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = _s8fj::P64;
           I64[Hp - 56] = sat_s8fk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8fi::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,)_$cmconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(cceS,
                       label: GHC.Base.$fMonoid(,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cceS: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cceW; else goto cceV;
       cceW: // global
           HpAlloc = 152;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cceV: // global
           I64[Hp - 144] = $dSemigroup_s8f4_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = $dSemigroup1_s8f5_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = z_s8f6_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = z1_s8f7_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = Hp - 96;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = go_s8f9_info;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 47;
           R2 = R4;
           R1 = Hp - 23;
           call go_s8f9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.929129485 UTC

[section ""data" . GHC.Base.$fMonoid()_$cmconcat_closure" {
     GHC.Base.$fMonoid()_$cmconcat_closure:
         const GHC.Base.$fMonoid()_$cmconcat_info;
 },
 GHC.Base.$fMonoid()_$cmconcat_entry() //  []
         { info_tbl: [(ccf1,
                       label: GHC.Base.$fMonoid()_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf1: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.930472281 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$c<>_closure" {
     GHC.Base.$fMonoidMaybe_$c<>_closure:
         const GHC.Base.$fMonoidMaybe_$c<>_info;
 },
 sat_s8fu_entry() //  [R1]
         { info_tbl: [(ccfo,
                       label: sat_s8fu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccfp; else goto ccfq;
       ccfp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccfq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidMaybe_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(ccfv,
                       label: GHC.Base.$fMonoidMaybe_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccfw; else goto ccfx;
       ccfw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccfx: // global
           I64[Sp - 24] = block_ccf8_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucfM; else goto ccf9;
       ucfM: // global
           call _ccf8(R1) args: 0, res: 0, upd: 0;
       ccf9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccf8() //  [R1]
         { info_tbl: [(ccf8,
                       label: block_ccf8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccf8: // global
           _s8fp::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccfs; else goto ccft;
       ccfs: // global
           R1 = _s8fp::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccft: // global
           I64[Sp - 8] = block_ccfe_info;
           _s8fq::P64 = R1;
           _s8fr::P64 = P64[R1 + 6];
           R1 = _s8fp::P64;
           P64[Sp] = _s8fr::P64;
           P64[Sp + 16] = _s8fq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucfL; else goto ccff;
       ucfL: // global
           call _ccfe(R1) args: 0, res: 0, upd: 0;
       ccff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfe() //  [R1]
         { info_tbl: [(ccfe,
                       label: block_ccfe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfe: // global
           if (R1 & 7 == 1) goto ccfE; else goto ccfG;
       ccfE: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccfG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccfJ; else goto ccfI;
       ccfJ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccfI: // global
           _s8ft::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8fu_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8ft::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.933286501 UTC

[section ""data" . GHC.Base.$w$csconcat5_closure" {
     GHC.Base.$w$csconcat5_closure:
         const GHC.Base.$w$csconcat5_info;
 },
 sat_s8fI_entry() //  [R1]
         { info_tbl: [(ccgh,
                       label: sat_s8fI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccgi; else goto ccgj;
       ccgi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccgj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8fy_entry() //  [R1, R2, R3]
         { info_tbl: [(ccgo,
                       label: go_s8fy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccgp; else goto ucgL;
       ccgp: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ucgL: // global
           P64[Sp - 24] = R1;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _ccfT() args: 0, res: 0, upd: 0;
     }
 },
 _ccfT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfT: // global
           _s8fv::P64 = P64[P64[Sp] + 6];
           I64[Sp - 8] = block_ccfW_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8fv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgN; else goto ccfX;
       ucgN: // global
           call _ccfW(R1) args: 0, res: 0, upd: 0;
       ccfX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccfW() //  [R1]
         { info_tbl: [(ccfW,
                       label: block_ccfW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccfW: // global
           _s8fz::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccgl; else goto ccgm;
       ccgl: // global
           R1 = _s8fz::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccgm: // global
           I64[Sp - 8] = block_ccg2_info;
           _s8fC::P64 = P64[R1 + 6];
           _s8fD::P64 = P64[R1 + 14];
           R1 = _s8fz::P64;
           P64[Sp] = _s8fD::P64;
           P64[Sp + 16] = _s8fC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucgO; else goto ccg3;
       ucgO: // global
           call _ccg2(R1) args: 0, res: 0, upd: 0;
       ccg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg2() //  [R1]
         { info_tbl: [(ccg2,
                       label: block_ccg2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg2: // global
           _s8fC::P64 = P64[Sp + 24];
           _s8fD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccgx; else goto ccgz;
       ccgx: // global
           P64[Sp + 24] = _s8fC::P64;
           P64[Sp + 32] = _s8fD::P64;
           Sp = Sp + 16;
           call _ccfT() args: 0, res: 0, upd: 0;
       ccgz: // global
           I64[Sp + 8] = block_ccg8_info;
           R3 = _s8fD::P64;
           R2 = _s8fC::P64;
           _s8fE::P64 = R1;
           _s8fF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8fF::P64;
           P64[Sp + 24] = _s8fE::P64;
           Sp = Sp + 8;
           call go_s8fy_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccg8() //  [R1]
         { info_tbl: [(ccg8,
                       label: block_ccg8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccg8: // global
           if (R1 & 7 == 1) goto ccgD; else goto ccgF;
       ccgD: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccgF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccgI; else goto ccgH;
       ccgI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccgH: // global
           _s8fH::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8fI_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8fH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat5_entry() //  [R2, R3, R4]
         { info_tbl: [(ccgR,
                       label: GHC.Base.$w$csconcat5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccgR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccgV; else goto ccgU;
       ccgV: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccgU: // global
           I64[Hp - 8] = go_s8fy_info;
           P64[Hp] = R2;
           _s8fw::P64 = R3;
           R3 = R4;
           R2 = _s8fw::P64;
           R1 = Hp - 6;
           call go_s8fy_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.935987944 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_$csconcat_closure" {
     GHC.Base.$fSemigroupMaybe_$csconcat_closure:
         const GHC.Base.$fSemigroupMaybe_$csconcat_info;
 },
 GHC.Base.$fSemigroupMaybe_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(cch3,
                       label: GHC.Base.$fSemigroupMaybe_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cch4; else goto cch5;
       cch4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cch5: // global
           I64[Sp - 16] = block_cch0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uch9; else goto cch1;
       uch9: // global
           call _cch0(R1) args: 0, res: 0, upd: 0;
       cch1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cch0() //  [R1]
         { info_tbl: [(cch0,
                       label: block_cch0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cch0: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat5_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.938591419 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_closure" {
     GHC.Base.$fSemigroupMaybe_closure:
         const GHC.Base.$fSemigroupMaybe_info;
         const 0;
 },
 sat_s8fS_entry() //  [R1, R2]
         { info_tbl: [(cchj,
                       label: sat_s8fS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchj: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8fQ_entry() //  [R1, R2]
         { info_tbl: [(cchr,
                       label: sat_s8fQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchr: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupMaybe_$csconcat_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8fP_entry() //  [R1, R2, R3]
         { info_tbl: [(cchz,
                       label: sat_s8fP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroupMaybe_entry() //  [R2]
         { info_tbl: [(cchD,
                       label: GHC.Base.$fSemigroupMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cchH; else goto cchG;
       cchH: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cchG: // global
           I64[Hp - 72] = sat_s8fS_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8fQ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8fP_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.94091097 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$cmconcat_closure" {
     GHC.Base.$fMonoidMaybe_$cmconcat_closure:
         const GHC.Base.$fMonoidMaybe_$cmconcat_info;
 },
 sat_s8g4_entry() //  [R1]
         { info_tbl: [(ccic,
                       label: sat_s8g4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccic: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccid; else goto ccie;
       ccid: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccie: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8fV_entry() //  [R1, R2]
         { info_tbl: [(ccij,
                       label: go_s8fV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccij: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccik; else goto uciG;
       ccik: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uciG: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cchO() args: 0, res: 0, upd: 0;
     }
 },
 _cchO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchO: // global
           _s8fT::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cchR_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8fT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uciI; else goto cchS;
       uciI: // global
           call _cchR(R1) args: 0, res: 0, upd: 0;
       cchS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchR() //  [R1]
         { info_tbl: [(cchR,
                       label: block_cchR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchR: // global
           if (R1 & 7 == 1) goto ccig; else goto ccih;
       ccig: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccih: // global
           I64[Sp - 8] = block_cchX_info;
           _s8fZ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8fZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uciJ; else goto cchY;
       uciJ: // global
           call _cchX(R1) args: 0, res: 0, upd: 0;
       cchY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cchX() //  [R1]
         { info_tbl: [(cchX,
                       label: block_cchX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cchX: // global
           _s8fZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccis; else goto cciu;
       ccis: // global
           P64[Sp + 24] = _s8fZ::P64;
           Sp = Sp + 16;
           call _cchO() args: 0, res: 0, upd: 0;
       cciu: // global
           I64[Sp] = block_cci3_info;
           R2 = _s8fZ::P64;
           _s8g0::P64 = R1;
           _s8g1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _s8g1::P64;
           P64[Sp + 16] = _s8g0::P64;
           call go_s8fV_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cci3() //  [R1]
         { info_tbl: [(cci3,
                       label: block_cci3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cci3: // global
           if (R1 & 7 == 1) goto cciy; else goto cciA;
       cciy: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cciA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cciD; else goto cciC;
       cciD: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cciC: // global
           _s8g3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8g4_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8g3::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoidMaybe_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(cciM,
                       label: GHC.Base.$fMonoidMaybe_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cciM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cciQ; else goto cciP;
       cciQ: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cciP: // global
           I64[Hp - 8] = go_s8fV_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s8fV_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.943731044 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_closure" {
     GHC.Base.$fMonoidMaybe_closure:
         const GHC.Base.$fMonoidMaybe_info;
         const 0;
 },
 sat_s8g8_entry() //  [R1, R2]
         { info_tbl: [(ccj0,
                       label: sat_s8g8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoidMaybe_$cmconcat_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8g7_entry() //  [R1, R2, R3]
         { info_tbl: [(ccj8,
                       label: sat_s8g7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccj8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8g6_entry() //  [R1]
         { info_tbl: [(ccjf,
                       label: sat_s8g6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjg; else goto ccjh;
       ccjg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccjh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidMaybe_entry() //  [R2]
         { info_tbl: [(ccjj,
                       label: GHC.Base.$fMonoidMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjj: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccjn; else goto ccjm;
       ccjn: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccjm: // global
           I64[Hp - 88] = sat_s8g8_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s8g7_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8g6_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.94549114 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_$c<>_closure" {
     GHC.Base.$fMonoidOrdering_$c<>_closure:
         const GHC.Base.$fMonoidOrdering_$c<>_info;
 },
 GHC.Base.$fMonoidOrdering_$c<>_entry() //  [R2, R3]
         { info_tbl: [(ccjA,
                       label: GHC.Base.$fMonoidOrdering_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccjB; else goto ccjC;
       ccjB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccjC: // global
           I64[Sp - 16] = block_ccjs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucjN; else goto ccjt;
       ucjN: // global
           call _ccjs(R1) args: 0, res: 0, upd: 0;
       ccjt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjs() //  [R1]
         { info_tbl: [(ccjs,
                       label: block_ccjs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjs: // global
           _ccjz::P64 = R1 & 7;
           if (_ccjz::P64 < 3) goto ucjM; else goto ccjy;
       ucjM: // global
           if (_ccjz::P64 < 2) goto ccjw; else goto ccjx;
       ccjw: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccjx: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccjy: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.947074638 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_go_closure" {
     GHC.Base.$fMonoidOrdering_go_closure:
         const GHC.Base.$fMonoidOrdering_go_info;
 },
 GHC.Base.$fMonoidOrdering_go_entry() //  [R2]
         { info_tbl: [(ccjZ,
                       label: GHC.Base.$fMonoidOrdering_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cck0; else goto uckq;
       cck0: // global
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uckq: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _ccjP() args: 0, res: 0, upd: 0;
     }
 },
 _ccjP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjP: // global
           _s8gc::P64 = P64[Sp];
           I64[Sp] = block_ccjS_info;
           R1 = _s8gc::P64;
           if (R1 & 7 != 0) goto ucks; else goto ccjT;
       ucks: // global
           call _ccjS(R1) args: 0, res: 0, upd: 0;
       ccjT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccjS() //  [R1]
         { info_tbl: [(ccjS,
                       label: block_ccjS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccjS: // global
           if (R1 & 7 == 1) goto ccjW; else goto ccjX;
       ccjW: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccjX: // global
           I64[Sp - 8] = block_cck7_info;
           _s8gf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8gf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uckt; else goto cck9;
       uckt: // global
           call _cck7(R1) args: 0, res: 0, upd: 0;
       cck9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cck7() //  [R1]
         { info_tbl: [(cck7,
                       label: block_cck7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cck7: // global
           _ccko::P64 = R1 & 7;
           if (_ccko::P64 < 3) goto uckp; else goto cckn;
       uckp: // global
           if (_ccko::P64 < 2) goto cckf; else goto cckj;
       cckf: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cckj: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _ccjP() args: 0, res: 0, upd: 0;
       cckn: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.948631297 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_closure" {
     GHC.Base.$fSemigroupOrdering_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fSemigroupOrdering_$csconcat_closure+1;
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fMonoidOrdering_closure" {
     GHC.Base.$fMonoidOrdering_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroupOrdering_closure+1;
         const GHC.Types.EQ_closure+2;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fMonoidOrdering_go_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupOrdering_$cstimes_closure" {
     GHC.Base.$fSemigroupOrdering_$cstimes_closure:
         const GHC.Base.$fSemigroupOrdering_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupOrdering_$cstimes_entry() //  [R2]
         { info_tbl: [(cckA,
                       label: GHC.Base.$fSemigroupOrdering_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckA: // global
           R3 = GHC.Base.$fMonoidOrdering_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.95080119 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,,)_$c<>_info;
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckE: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8gF_entry() //  [R1]
         { info_tbl: [(cckW,
                       label: sat_s8gF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cckX; else goto cckY;
       cckX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cckY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gE_entry() //  [R1]
         { info_tbl: [(ccl3,
                       label: sat_s8gE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccl3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccl4; else goto ccl5;
       ccl4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccl5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gD_entry() //  [R1]
         { info_tbl: [(ccla,
                       label: sat_s8gD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccla: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cclb; else goto cclc;
       cclb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gC_entry() //  [R1]
         { info_tbl: [(cclh,
                       label: sat_s8gC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccli; else goto cclj;
       ccli: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gB_entry() //  [R1]
         { info_tbl: [(cclo,
                       label: sat_s8gB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cclp; else goto cclq;
       cclp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cclq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cclr,
                       label: GHC.Base.$fMonoid(,,,,)_$c<>_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclr: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cclt; else goto cclu;
       cclt: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$c<>_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cclu: // global
           I64[Sp - 40] = block_cckI_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uclA; else goto cckJ;
       uclA: // global
           call _cckI(R1) args: 0, res: 0, upd: 0;
       cckJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckI() //  [R1]
         { info_tbl: [(cckI,
                       label: block_cckI_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckI: // global
           I64[Sp - 32] = block_cckN_info;
           _s8gq::P64 = P64[R1 + 7];
           _s8gr::P64 = P64[R1 + 15];
           _s8gs::P64 = P64[R1 + 23];
           _s8gt::P64 = P64[R1 + 31];
           _s8gu::P64 = P64[R1 + 39];
           R1 = P64[Sp + 48];
           P64[Sp - 24] = _s8gs::P64;
           P64[Sp - 16] = _s8gt::P64;
           P64[Sp - 8] = _s8gu::P64;
           P64[Sp] = _s8gr::P64;
           P64[Sp + 48] = _s8gq::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uclz; else goto cckO;
       uclz: // global
           call _cckN(R1) args: 0, res: 0, upd: 0;
       cckO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cckN() //  [R1]
         { info_tbl: [(cckN,
                       label: block_cckN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cckN: // global
           Hp = Hp + 248;
           if (Hp > HpLim) (likely: False) goto ccly; else goto cclx;
       ccly: // global
           HpAlloc = 248;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cclx: // global
           _s8gw::P64 = P64[R1 + 7];
           _s8gx::P64 = P64[R1 + 15];
           _s8gy::P64 = P64[R1 + 23];
           _s8gz::P64 = P64[R1 + 31];
           _s8gA::P64 = P64[R1 + 39];
           I64[Hp - 240] = sat_s8gF_info;
           P64[Hp - 224] = P64[Sp + 64];
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _s8gA::P64;
           I64[Hp - 200] = sat_s8gE_info;
           P64[Hp - 184] = P64[Sp + 56];
           P64[Hp - 176] = P64[Sp + 16];
           P64[Hp - 168] = _s8gz::P64;
           I64[Hp - 160] = sat_s8gD_info;
           P64[Hp - 144] = P64[Sp + 48];
           P64[Hp - 136] = P64[Sp + 8];
           P64[Hp - 128] = _s8gy::P64;
           I64[Hp - 120] = sat_s8gC_info;
           P64[Hp - 104] = P64[Sp + 40];
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = _s8gx::P64;
           I64[Hp - 80] = sat_s8gB_info;
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = _s8gw::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 160;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 240;
           R1 = Hp - 39;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.957160227 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$csconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$csconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$csconcat_info;
 },
 sat_s8hl_entry() //  [R1]
         { info_tbl: [(ccmd,
                       label: sat_s8hl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccmd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccme; else goto ccmf;
       ccme: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccmf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hk_entry() //  [R1]
         { info_tbl: [(ccmk,
                       label: sat_s8hk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccmk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccml; else goto ccmm;
       ccml: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccmm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hj_entry() //  [R1]
         { info_tbl: [(ccmr,
                       label: sat_s8hj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccmr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccms; else goto ccmt;
       ccms: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccmt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hi_entry() //  [R1]
         { info_tbl: [(ccmy,
                       label: sat_s8hi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccmy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccmz; else goto ccmA;
       ccmz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccmA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hh_entry() //  [R1]
         { info_tbl: [(ccmF,
                       label: sat_s8hh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccmF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccmG; else goto ccmH;
       ccmG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccmH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s8gV_entry() //  [R1, R2, R3, R4, R5, R6]
         { info_tbl: [(ccmM,
                       label: $wgo_s8gV_info
                       rep:HeapRep 5 ptrs { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccmM: // global
           if ((Sp + -120) < SpLim) (likely: False) goto ccmN; else goto ccmO;
       ccmN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ccmO: // global
           I64[Sp - 88] = block_cclU_info;
           _s8gV::P64 = R1;
           _s8gG::P64 = P64[R1 + 2];
           _s8gH::P64 = P64[R1 + 10];
           _s8gI::P64 = P64[R1 + 18];
           _s8gJ::P64 = P64[R1 + 26];
           _s8gK::P64 = P64[R1 + 34];
           R1 = P64[Sp];
           P64[Sp - 80] = _s8gH::P64;
           P64[Sp - 72] = _s8gI::P64;
           P64[Sp - 64] = _s8gJ::P64;
           P64[Sp - 56] = _s8gK::P64;
           P64[Sp - 48] = _s8gV::P64;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = _s8gG::P64;
           Sp = Sp - 88;
           if (R1 & 7 != 0) goto ucmZ; else goto cclV;
       ucmZ: // global
           call _cclU(R1) args: 0, res: 0, upd: 0;
       cclV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclU() //  [R1]
         { info_tbl: [(cclU,
                       label: block_cclU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclU: // global
           if (R1 & 7 == 1) goto ccmJ; else goto ccmK;
       ccmJ: // global
           R5 = P64[Sp + 80];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccmK: // global
           I64[Sp - 8] = block_ccm0_info;
           _s8h4::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8h4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucmX; else goto ccm1;
       ucmX: // global
           call _ccm0(R1) args: 0, res: 0, upd: 0;
       ccm1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccm0() //  [R1]
         { info_tbl: [(ccm0,
                       label: block_ccm0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccm0: // global
           _s8h4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccm5_info;
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp] = _s8h4::P64;
           call $wgo_s8gV_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 _ccm5() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(ccm5,
                       label: block_ccm5_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccm5: // global
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R2;
           P64[Sp + 40] = R1;
           Sp = Sp - 32;
           call _ccm6() args: 0, res: 0, upd: 0;
     }
 },
 _ccm6() //  []
         { info_tbl: [(ccm6,
                       label: block_ccm6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccm6: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto ccmV; else goto ccmU;
       ccmV: // global
           HpAlloc = 200;
           I64[Sp] = block_ccm6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccmU: // global
           I64[Hp - 192] = sat_s8hl_info;
           P64[Hp - 176] = P64[Sp + 64];
           P64[Hp - 168] = P64[Sp + 112];
           P64[Hp - 160] = P64[Sp + 24];
           I64[Hp - 152] = sat_s8hk_info;
           P64[Hp - 136] = P64[Sp + 56];
           P64[Hp - 128] = P64[Sp + 104];
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = sat_s8hj_info;
           P64[Hp - 96] = P64[Sp + 48];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = sat_s8hi_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 32];
           I64[Hp - 32] = sat_s8hh_info;
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 80];
           P64[Hp] = P64[Sp + 72];
           R5 = Hp - 192;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccn0,
                       label: GHC.Base.$fMonoid(,,,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccn0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccn6; else goto ccn7;
       ccn6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ccn7: // global
           I64[Sp - 40] = block_cclF_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucnh; else goto cclG;
       ucnh: // global
           call _cclF(R1) args: 0, res: 0, upd: 0;
       cclG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclF() //  [R1]
         { info_tbl: [(cclF,
                       label: block_cclF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclF: // global
           I64[Sp - 8] = block_cclK_info;
           _s8gO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8gO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucng; else goto cclL;
       ucng: // global
           call _cclK(R1) args: 0, res: 0, upd: 0;
       cclL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cclK() //  [R1]
         { info_tbl: [(cclK,
                       label: block_cclK_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cclK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccnb; else goto ccna;
       ccnb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccna: // global
           _s8gQ::P64 = P64[R1 + 7];
           _s8gR::P64 = P64[R1 + 15];
           _s8gS::P64 = P64[R1 + 23];
           _s8gT::P64 = P64[R1 + 31];
           _s8gU::P64 = P64[R1 + 39];
           I64[Hp - 40] = $wgo_s8gV_info;
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 48] = block_ccn1_info;
           R6 = _s8gU::P64;
           R5 = _s8gT::P64;
           R4 = _s8gS::P64;
           R3 = _s8gR::P64;
           R2 = _s8gQ::P64;
           R1 = Hp - 34;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call $wgo_s8gV_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 _ccn1() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(ccn1,
                       label: block_ccn1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccn1: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call _ccn2() args: 0, res: 0, upd: 0;
     }
 },
 _ccn2() //  []
         { info_tbl: [(ccn2,
                       label: block_ccn2_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccn2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccne; else goto ccnd;
       ccne: // global
           HpAlloc = 48;
           I64[Sp] = block_ccn2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccnd: // global
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.963564807 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cstimes_closure" {
     GHC.Base.$fMonoid(,,,,)_$cstimes_closure:
         const GHC.Base.$fMonoid(,,,,)_$cstimes_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccnk: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8hK_entry() //  [R1]
         { info_tbl: [(ccnx,
                       label: sat_s8hK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccnx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccny; else goto ccnz;
       ccny: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccnz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hJ_entry() //  [R1]
         { info_tbl: [(ccnE,
                       label: sat_s8hJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccnE: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccnF; else goto ccnG;
       ccnF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccnG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hI_entry() //  [R1]
         { info_tbl: [(ccnL,
                       label: sat_s8hI_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccnL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccnM; else goto ccnN;
       ccnM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccnN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hH_entry() //  [R1]
         { info_tbl: [(ccnS,
                       label: sat_s8hH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccnS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccnT; else goto ccnU;
       ccnT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccnU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hG_entry() //  [R1]
         { info_tbl: [(ccnZ,
                       label: sat_s8hG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccnZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cco0; else goto cco1;
       cco0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cco1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cco2,
                       label: GHC.Base.$fMonoid(,,,,)_$cstimes_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cco2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cco4; else goto cco5;
       cco4: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cco5: // global
           I64[Sp - 40] = block_ccno_info;
           R1 = P64[Sp + 16];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 16] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uco9; else goto ccnp;
       uco9: // global
           call _ccno(R1) args: 0, res: 0, upd: 0;
       ccnp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccno() //  [R1]
         { info_tbl: [(ccno,
                       label: block_ccno_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccno: // global
           Hp = Hp + 288;
           if (Hp > HpLim) (likely: False) goto cco8; else goto cco7;
       cco8: // global
           HpAlloc = 288;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cco7: // global
           _s8hB::P64 = P64[R1 + 7];
           _s8hC::P64 = P64[R1 + 15];
           _s8hD::P64 = P64[R1 + 23];
           _s8hE::P64 = P64[R1 + 31];
           _s8hF::P64 = P64[R1 + 39];
           I64[Hp - 280] = sat_s8hK_info;
           P64[Hp - 264] = P64[Sp + 32];
           _s8hx::P64 = P64[Sp + 40];
           P64[Hp - 256] = _s8hx::P64;
           _s8hy::P64 = P64[Sp + 48];
           P64[Hp - 248] = _s8hy::P64;
           P64[Hp - 240] = _s8hF::P64;
           I64[Hp - 232] = sat_s8hJ_info;
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _s8hx::P64;
           P64[Hp - 200] = _s8hy::P64;
           P64[Hp - 192] = _s8hE::P64;
           I64[Hp - 184] = sat_s8hI_info;
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _s8hx::P64;
           P64[Hp - 152] = _s8hy::P64;
           P64[Hp - 144] = _s8hD::P64;
           I64[Hp - 136] = sat_s8hH_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8hx::P64;
           P64[Hp - 104] = _s8hy::P64;
           P64[Hp - 96] = _s8hC::P64;
           I64[Hp - 88] = sat_s8hG_info;
           P64[Hp - 72] = P64[Sp + 56];
           P64[Hp - 64] = _s8hx::P64;
           P64[Hp - 56] = _s8hy::P64;
           P64[Hp - 48] = _s8hB::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 88;
           P64[Hp - 24] = Hp - 136;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 280;
           R1 = Hp - 39;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.967330234 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,,)_closure" {
     GHC.Base.$fSemigroup(,,,,)_closure:
         const GHC.Base.$fSemigroup(,,,,)_info;
 },
 sat_s8hS_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccoj,
                       label: sat_s8hS_info
                       rep:HeapRep 5 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccok; else goto ccol;
       ccok: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccol: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8hR_entry() //  [R1, R2]
         { info_tbl: [(ccor,
                       label: sat_s8hR_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccor: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccos; else goto ccot;
       ccos: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccot: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_s8hQ_entry() //  [R1, R2, R3]
         { info_tbl: [(ccoz,
                       label: sat_s8hQ_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoA; else goto ccoB;
       ccoA: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoB: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccoD,
                       label: GHC.Base.$fSemigroup(,,,,)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoD: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccoH; else goto ccoG;
       ccoH: // global
           HpAlloc = 176;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoG: // global
           I64[Hp - 168] = sat_s8hS_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = sat_s8hR_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_s8hQ_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 165;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.97167588 UTC

[section ""data" . GHC.Base.$w$cp1Monoid1_closure" {
     GHC.Base.$w$cp1Monoid1_closure:
         const GHC.Base.$w$cp1Monoid1_info;
 },
 sat_s8ie_entry() //  [R1]
         { info_tbl: [(ccoQ,
                       label: sat_s8ie_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoR; else goto ccoS;
       ccoR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8id_entry() //  [R1]
         { info_tbl: [(ccoX,
                       label: sat_s8id_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoY; else goto ccoZ;
       ccoY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ic_entry() //  [R1]
         { info_tbl: [(ccp4,
                       label: sat_s8ic_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp5; else goto ccp6;
       ccp5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccp6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ib_entry() //  [R1]
         { info_tbl: [(ccpb,
                       label: sat_s8ib_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpc; else goto ccpd;
       ccpc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ia_entry() //  [R1]
         { info_tbl: [(ccpi,
                       label: sat_s8ia_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpj; else goto ccpk;
       ccpj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8if_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccpq,
                       label: sat_s8if_info
                       rep:HeapRep 5 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpr; else goto ccps;
       ccpr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccps: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8i8_entry() //  [R1]
         { info_tbl: [(ccpx,
                       label: sat_s8i8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpy; else goto ccpz;
       ccpy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i7_entry() //  [R1]
         { info_tbl: [(ccpE,
                       label: sat_s8i7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpF; else goto ccpG;
       ccpF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i6_entry() //  [R1]
         { info_tbl: [(ccpL,
                       label: sat_s8i6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpM; else goto ccpN;
       ccpM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i5_entry() //  [R1]
         { info_tbl: [(ccpS,
                       label: sat_s8i5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpT; else goto ccpU;
       ccpT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i4_entry() //  [R1]
         { info_tbl: [(ccpZ,
                       label: sat_s8i4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccq0; else goto ccq1;
       ccq0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccq1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i9_entry() //  [R1, R2]
         { info_tbl: [(ccq7,
                       label: sat_s8i9_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccq7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccq8; else goto ccq9;
       ccq8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccq9: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_s8i2_entry() //  [R1]
         { info_tbl: [(ccqe,
                       label: sat_s8i2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccqe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccqf; else goto ccqg;
       ccqf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccqg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i1_entry() //  [R1]
         { info_tbl: [(ccql,
                       label: sat_s8i1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccql: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccqm; else goto ccqn;
       ccqm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccqn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i0_entry() //  [R1]
         { info_tbl: [(ccqs,
                       label: sat_s8i0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccqs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccqt; else goto ccqu;
       ccqt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccqu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8hZ_entry() //  [R1]
         { info_tbl: [(ccqz,
                       label: sat_s8hZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccqz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccqA; else goto ccqB;
       ccqA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccqB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8hY_entry() //  [R1]
         { info_tbl: [(ccqG,
                       label: sat_s8hY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccqG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccqH; else goto ccqI;
       ccqH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccqI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i3_entry() //  [R1, R2, R3]
         { info_tbl: [(ccqO,
                       label: sat_s8i3_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccqO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccqP; else goto ccqQ;
       ccqP: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccqQ: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cp1Monoid1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccqR,
                       label: GHC.Base.$w$cp1Monoid1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccqR: // global
           Hp = Hp + 504;
           if (Hp > HpLim) (likely: False) goto ccqV; else goto ccqU;
       ccqV: // global
           HpAlloc = 504;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccqU: // global
           I64[Hp - 496] = sat_s8ie_info;
           P64[Hp - 480] = R6;
           I64[Hp - 472] = sat_s8id_info;
           P64[Hp - 456] = R5;
           I64[Hp - 448] = sat_s8ic_info;
           P64[Hp - 432] = R4;
           I64[Hp - 424] = sat_s8ib_info;
           P64[Hp - 408] = R3;
           I64[Hp - 400] = sat_s8ia_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s8if_info;
           P64[Hp - 368] = Hp - 400;
           P64[Hp - 360] = Hp - 424;
           P64[Hp - 352] = Hp - 448;
           P64[Hp - 344] = Hp - 472;
           P64[Hp - 336] = Hp - 496;
           I64[Hp - 328] = sat_s8i8_info;
           P64[Hp - 312] = R6;
           I64[Hp - 304] = sat_s8i7_info;
           P64[Hp - 288] = R5;
           I64[Hp - 280] = sat_s8i6_info;
           P64[Hp - 264] = R4;
           I64[Hp - 256] = sat_s8i5_info;
           P64[Hp - 240] = R3;
           I64[Hp - 232] = sat_s8i4_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s8i9_info;
           P64[Hp - 200] = Hp - 232;
           P64[Hp - 192] = Hp - 256;
           P64[Hp - 184] = Hp - 280;
           P64[Hp - 176] = Hp - 304;
           P64[Hp - 168] = Hp - 328;
           I64[Hp - 160] = sat_s8i2_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_s8i1_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_s8i0_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8hZ_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8hY_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8i3_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R3 = Hp - 373;
           R2 = Hp - 207;
           R1 = Hp - 38;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.978206851 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccr3,
                       label: GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccr3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccr4; else goto ccr5;
       ccr4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccr5: // global
           I64[Sp - 8] = block_ccr0_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccr0() //  [R1, R2, R3]
         { info_tbl: [(ccr0,
                       label: block_ccr0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccr0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccr8; else goto ccr7;
       ccr8: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ccr7: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.979571257 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccrf,
                       label: GHC.Base.$fMonoid(,,,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccrf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccrg; else goto ccrh;
       ccrg: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccrh: // global
           I64[Sp - 8] = block_ccrd_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccrd() //  [R1]
         { info_tbl: [(ccrd,
                       label: block_ccrd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccrd: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.982082492 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmconcat_info;
 },
 k_s8iD_entry() //  [R1]
         { info_tbl: [(ccru,
                       label: k_s8iD_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccru: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccrv; else goto ccrw;
       ccrv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccrw: // global
           I64[Sp - 8] = block_ccrr_info;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccrr() //  [R1, R2, R3]
         { info_tbl: [(ccrr,
                       label: block_ccrr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccrr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccrz; else goto ccry;
       ccrz: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ccry: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 k1_s8iI_entry() //  [R1]
         { info_tbl: [(ccrE,
                       label: k1_s8iI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccrE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccrF; else goto ccrG;
       ccrF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccrG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8iJ_entry() //  [R1]
         { info_tbl: [(ccrL,
                       label: z_s8iJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccrL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccrM; else goto ccrN;
       ccrM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccrN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8iK_entry() //  [R1]
         { info_tbl: [(ccrS,
                       label: z1_s8iK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccrS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccrT; else goto ccrU;
       ccrT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccrU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_s8iL_entry() //  [R1]
         { info_tbl: [(ccrZ,
                       label: z2_s8iL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccrZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccs0; else goto ccs1;
       ccs0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccs1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z3_s8iM_entry() //  [R1]
         { info_tbl: [(ccs6,
                       label: z3_s8iM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccs6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccs7; else goto ccs8;
       ccs7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccs8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z4_s8iN_entry() //  [R1]
         { info_tbl: [(ccsd,
                       label: z4_s8iN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccsd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccse; else goto ccsf;
       ccse: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccsf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8iP_entry() //  [R1, R2]
         { info_tbl: [(ccst,
                       label: go_s8iP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccst: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccsu; else goto ccsv;
       ccsu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccsv: // global
           I64[Sp - 32] = block_ccsm_info;
           _s8iP::P64 = R1;
           _s8iI::P64 = P64[R1 + 7];
           _s8iO::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s8iI::P64;
           P64[Sp - 16] = _s8iO::P64;
           P64[Sp - 8] = _s8iP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucsF; else goto ccsn;
       ucsF: // global
           call _ccsm(R1) args: 0, res: 0, upd: 0;
       ccsn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccsm() //  [R1]
         { info_tbl: [(ccsm,
                       label: block_ccsm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccsm: // global
           if (R1 & 7 == 1) goto ccsq; else goto ccsr;
       ccsq: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccsr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccsE; else goto ccsD;
       ccsE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccsD: // global
           _s8iS::P64 = P64[R1 + 6];
           _s8iT::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s8iT::P64;
           R3 = Hp - 24;
           R2 = _s8iS::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cmconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccsG,
                       label: GHC.Base.$fMonoid(,,,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccsG: // global
           Hp = Hp + 272;
           if (Hp > HpLim) (likely: False) goto ccsK; else goto ccsJ;
       ccsK: // global
           HpAlloc = 272;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccsJ: // global
           I64[Hp - 264] = k_s8iD_info;
           P64[Hp - 248] = R2;
           P64[Hp - 240] = R3;
           P64[Hp - 232] = R4;
           P64[Hp - 224] = R5;
           P64[Hp - 216] = R6;
           I64[Hp - 208] = k1_s8iI_info;
           P64[Hp - 192] = Hp - 264;
           I64[Hp - 184] = z_s8iJ_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = z1_s8iK_info;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = z2_s8iL_info;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = z3_s8iM_info;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = z4_s8iN_info;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = (,,,,)_con_info;
           P64[Hp - 56] = Hp - 184;
           P64[Hp - 48] = Hp - 160;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = go_s8iP_info;
           P64[Hp - 8] = Hp - 208;
           P64[Hp] = Hp - 63;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.986425583 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_closure" {
     GHC.Base.$fMonoid(,,,,)_closure:
         const GHC.Base.$fMonoid(,,,,)_info;
 },
 sat_s8j3_entry() //  [R1]
         { info_tbl: [(ccsT,
                       label: sat_s8j3_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccsT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccsU; else goto ccsV;
       ccsU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccsV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j2_entry() //  [R1]
         { info_tbl: [(cct0,
                       label: sat_s8j2_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cct0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cct1; else goto cct2;
       cct1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cct2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmappend_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j1_entry() //  [R1]
         { info_tbl: [(cct7,
                       label: sat_s8j1_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cct7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cct8; else goto cct9;
       cct8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cct9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmempty_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j0_entry() //  [R1]
         { info_tbl: [(ccte,
                       label: sat_s8j0_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccte: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cctf; else goto cctg;
       cctf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cctg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccti,
                       label: GHC.Base.$fMonoid(,,,,)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccti: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cctm; else goto cctl;
       cctm: // global
           HpAlloc = 264;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cctl: // global
           I64[Hp - 256] = sat_s8j3_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           P64[Hp - 224] = R4;
           P64[Hp - 216] = R5;
           P64[Hp - 208] = R6;
           I64[Hp - 200] = sat_s8j2_info;
           P64[Hp - 184] = R2;
           P64[Hp - 176] = R3;
           P64[Hp - 168] = R4;
           P64[Hp - 160] = R5;
           P64[Hp - 152] = R6;
           I64[Hp - 144] = sat_s8j1_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           P64[Hp - 104] = R5;
           P64[Hp - 96] = R6;
           I64[Hp - 88] = sat_s8j0_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 256;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.990609483 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,)_$c<>_info;
 },
 sat_s8jn_entry() //  [R1]
         { info_tbl: [(cctF,
                       label: sat_s8jn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cctF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cctG; else goto cctH;
       cctG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cctH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jm_entry() //  [R1]
         { info_tbl: [(cctM,
                       label: sat_s8jm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cctM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cctN; else goto cctO;
       cctN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cctO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jl_entry() //  [R1]
         { info_tbl: [(cctT,
                       label: sat_s8jl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cctT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cctU; else goto cctV;
       cctU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cctV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jk_entry() //  [R1]
         { info_tbl: [(ccu0,
                       label: sat_s8jk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccu0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccu1; else goto ccu2;
       ccu1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccu2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccu3,
                       label: GHC.Base.$fMonoid(,,,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccu3: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccu5; else goto ccu6;
       ccu5: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ccu6: // global
           I64[Sp - 40] = block_cctr_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucuc; else goto ccts;
       ucuc: // global
           call _cctr(R1) args: 0, res: 0, upd: 0;
       ccts: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cctr() //  [R1]
         { info_tbl: [(cctr,
                       label: block_cctr_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cctr: // global
           I64[Sp - 24] = block_cctw_info;
           _s8jb::P64 = P64[R1 + 7];
           _s8jc::P64 = P64[R1 + 15];
           _s8jd::P64 = P64[R1 + 23];
           _s8je::P64 = P64[R1 + 31];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _s8jd::P64;
           P64[Sp - 8] = _s8je::P64;
           P64[Sp] = _s8jc::P64;
           P64[Sp + 40] = _s8jb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucub; else goto cctx;
       ucub: // global
           call _cctw(R1) args: 0, res: 0, upd: 0;
       cctx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cctw() //  [R1]
         { info_tbl: [(cctw,
                       label: block_cctw_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cctw: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto ccua; else goto ccu9;
       ccua: // global
           HpAlloc = 200;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccu9: // global
           _s8jg::P64 = P64[R1 + 7];
           _s8jh::P64 = P64[R1 + 15];
           _s8ji::P64 = P64[R1 + 23];
           _s8jj::P64 = P64[R1 + 31];
           I64[Hp - 192] = sat_s8jn_info;
           P64[Hp - 176] = P64[Sp + 56];
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _s8jj::P64;
           I64[Hp - 152] = sat_s8jm_info;
           P64[Hp - 136] = P64[Sp + 48];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = _s8ji::P64;
           I64[Hp - 112] = sat_s8jl_info;
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = _s8jh::P64;
           I64[Hp - 72] = sat_s8jk_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = _s8jg::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.994840692 UTC

[section ""data" . GHC.Base.$w$csconcat2_closure" {
     GHC.Base.$w$csconcat2_closure:
         const GHC.Base.$w$csconcat2_info;
 },
 GHC.Base.$w$csconcat2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccue: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_s8jT_entry() //  [R1]
         { info_tbl: [(ccuE,
                       label: sat_s8jT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccuE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccuF; else goto ccuG;
       ccuF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccuG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jS_entry() //  [R1]
         { info_tbl: [(ccuL,
                       label: sat_s8jS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccuL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccuM; else goto ccuN;
       ccuM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccuN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jR_entry() //  [R1]
         { info_tbl: [(ccuS,
                       label: sat_s8jR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccuS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccuT; else goto ccuU;
       ccuT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccuU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jQ_entry() //  [R1]
         { info_tbl: [(ccuZ,
                       label: sat_s8jQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccuZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccv0; else goto ccv1;
       ccv0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccv1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s8jx_entry() //  [R1, R2, R3, R4, R5, R6]
         { info_tbl: [(ccv6,
                       label: $wgo_s8jx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccv6: // global
           if ((Sp + -88) < SpLim) (likely: False) goto ccv7; else goto ccv8;
       ccv7: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccv8: // global
           I64[Sp - 80] = block_ccun_info;
           _s8jx::P64 = R1;
           _s8jo::P64 = P64[R1 + 3];
           _s8jp::P64 = P64[R1 + 11];
           _s8jq::P64 = P64[R1 + 19];
           _s8jr::P64 = P64[R1 + 27];
           R1 = R6;
           P64[Sp - 72] = _s8jo::P64;
           P64[Sp - 64] = _s8jp::P64;
           P64[Sp - 56] = _s8jq::P64;
           P64[Sp - 48] = _s8jr::P64;
           P64[Sp - 40] = _s8jx::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto ucvh; else goto ccuo;
       ucvh: // global
           call _ccun(R1) args: 0, res: 0, upd: 0;
       ccuo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccun() //  [R1]
         { info_tbl: [(ccun,
                       label: block_ccun_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccun: // global
           if (R1 & 7 == 1) goto ccv3; else goto ccv4;
       ccv3: // global
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccv4: // global
           I64[Sp - 8] = block_ccut_info;
           _s8jF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8jF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucvg; else goto ccuu;
       ucvg: // global
           call _ccut(R1) args: 0, res: 0, upd: 0;
       ccuu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccut() //  [R1]
         { info_tbl: [(ccut,
                       label: block_ccut_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccut: // global
           _s8jF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccuy_info;
           R6 = _s8jF::P64;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           Sp = Sp + 8;
           call $wgo_s8jx_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccuy() //  [R1, R2, R3, R4]
         { info_tbl: [(ccuy,
                       label: block_ccuy_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccuy: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccvf; else goto ccve;
       ccvf: // global
           HpAlloc = 160;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ccve: // global
           I64[Hp - 152] = sat_s8jT_info;
           P64[Hp - 136] = P64[Sp + 32];
           P64[Hp - 128] = P64[Sp + 72];
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_s8jS_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8jR_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8jQ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccvi,
                       label: GHC.Base.$w$csconcat2_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccvi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccvm; else goto ccvl;
       ccvm: // global
           HpAlloc = 40;
           R1 = GHC.Base.$w$csconcat2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       ccvl: // global
           I64[Hp - 32] = $wgo_s8jx_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _s8js::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _s8js::P64;
           R1 = Hp - 27;
           Sp = Sp + 32;
           call $wgo_s8jx_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:43.998968545 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,,)_$csconcat_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(ccvu,
                       label: GHC.Base.$fSemigroup(,,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccvu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccvF; else goto ccvG;
       ccvF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccvG: // global
           I64[Sp - 40] = block_ccvr_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucvN; else goto ccvs;
       ucvN: // global
           call _ccvr(R1) args: 0, res: 0, upd: 0;
       ccvs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccvr() //  [R1]
         { info_tbl: [(ccvr,
                       label: block_ccvr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccvr: // global
           I64[Sp - 8] = block_ccvx_info;
           _s8k1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8k1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucvM; else goto ccvy;
       ucvM: // global
           call _ccvx(R1) args: 0, res: 0, upd: 0;
       ccvy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccvx() //  [R1]
         { info_tbl: [(ccvx,
                       label: block_ccvx_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccvx: // global
           _s8jX::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_ccvC_info;
           R6 = P64[R1 + 7];
           R5 = _s8jX::P64;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           _s8k1::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _s8k1::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 _ccvC() //  [R1, R2, R3, R4]
         { info_tbl: [(ccvC,
                       label: block_ccvC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccvC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccvL; else goto ccvK;
       ccvL: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ccvK: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.001727657 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,,)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccvP: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8kr_entry() //  [R1]
         { info_tbl: [(ccw2,
                       label: sat_s8kr_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccw2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccw3; else goto ccw4;
       ccw3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccw4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8kq_entry() //  [R1]
         { info_tbl: [(ccw9,
                       label: sat_s8kq_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccw9: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccwa; else goto ccwb;
       ccwa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccwb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8kp_entry() //  [R1]
         { info_tbl: [(ccwg,
                       label: sat_s8kp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccwg: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccwh; else goto ccwi;
       ccwh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccwi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8ko_entry() //  [R1]
         { info_tbl: [(ccwn,
                       label: sat_s8ko_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccwn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccwo; else goto ccwp;
       ccwo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccwp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccwq,
                       label: GHC.Base.$fSemigroup(,,,)_$cstimes_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccwq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccws; else goto ccwt;
       ccws: // global
           R1 = GHC.Base.$fSemigroup(,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ccwt: // global
           I64[Sp - 40] = block_ccvT_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucwx; else goto ccvU;
       ucwx: // global
           call _ccvT(R1) args: 0, res: 0, upd: 0;
       ccvU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccvT() //  [R1]
         { info_tbl: [(ccvT,
                       label: block_ccvT_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccvT: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ccww; else goto ccwv;
       ccww: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccwv: // global
           _s8kk::P64 = P64[R1 + 7];
           _s8kl::P64 = P64[R1 + 15];
           _s8km::P64 = P64[R1 + 23];
           _s8kn::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_s8kr_info;
           P64[Hp - 208] = P64[Sp + 24];
           _s8kg::P64 = P64[Sp + 32];
           P64[Hp - 200] = _s8kg::P64;
           _s8kh::P64 = P64[Sp + 40];
           P64[Hp - 192] = _s8kh::P64;
           P64[Hp - 184] = _s8kn::P64;
           I64[Hp - 176] = sat_s8kq_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _s8kg::P64;
           P64[Hp - 144] = _s8kh::P64;
           P64[Hp - 136] = _s8km::P64;
           I64[Hp - 128] = sat_s8kp_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _s8kg::P64;
           P64[Hp - 96] = _s8kh::P64;
           P64[Hp - 88] = _s8kl::P64;
           I64[Hp - 80] = sat_s8ko_info;
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = _s8kg::P64;
           P64[Hp - 48] = _s8kh::P64;
           P64[Hp - 40] = _s8kk::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.005217781 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_closure" {
     GHC.Base.$fSemigroup(,,,)_closure:
         const GHC.Base.$fSemigroup(,,,)_info;
 },
 sat_s8ky_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccwH,
                       label: sat_s8ky_info
                       rep:HeapRep 4 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccwH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccwI; else goto ccwJ;
       ccwI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccwJ: // global
           R6 = R2;
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8kx_entry() //  [R1, R2]
         { info_tbl: [(ccwP,
                       label: sat_s8kx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccwP: // global
           R6 = R2;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,,)_$csconcat_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8kw_entry() //  [R1, R2, R3]
         { info_tbl: [(ccwX,
                       label: sat_s8kw_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccwX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccwY; else goto ccwZ;
       ccwY: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccwZ: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccx1,
                       label: GHC.Base.$fSemigroup(,,,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccx1: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccx5; else goto ccx4;
       ccx5: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccx4: // global
           I64[Hp - 144] = sat_s8ky_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8kx_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_s8kw_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 62;
           P64[Hp - 8] = Hp - 103;
           P64[Hp] = Hp - 141;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.011018751 UTC

[section ""data" . GHC.Base.$w$cp1Monoid_closure" {
     GHC.Base.$w$cp1Monoid_closure:
         const GHC.Base.$w$cp1Monoid_info;
 },
 w4_s8l1_entry() //  [R1]
         { info_tbl: [(ccxe,
                       label: w4_s8l1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccxe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccxf; else goto ccxg;
       ccxf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccxg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_s8l2_entry() //  [R1]
         { info_tbl: [(ccxl,
                       label: w5_s8l2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccxl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccxm; else goto ccxn;
       ccxm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccxn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_s8l3_entry() //  [R1]
         { info_tbl: [(ccxs,
                       label: w6_s8l3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccxs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccxt; else goto ccxu;
       ccxt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccxu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_s8l4_entry() //  [R1]
         { info_tbl: [(ccxz,
                       label: w7_s8l4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccxz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccxA; else goto ccxB;
       ccxA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccxB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lg_entry() //  [R1]
         { info_tbl: [(ccxQ,
                       label: sat_s8lg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccxQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccxR; else goto ccxS;
       ccxR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccxS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8lf_entry() //  [R1]
         { info_tbl: [(ccxX,
                       label: sat_s8lf_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccxX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccxY; else goto ccxZ;
       ccxY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccxZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8le_entry() //  [R1]
         { info_tbl: [(ccy4,
                       label: sat_s8le_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccy4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccy5; else goto ccy6;
       ccy5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccy6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8ld_entry() //  [R1]
         { info_tbl: [(ccyb,
                       label: sat_s8ld_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccyc; else goto ccyd;
       ccyc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8lh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccye,
                       label: sat_s8lh_info
                       rep:HeapRep 4 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccye: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccyg; else goto ccyh;
       ccyg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyh: // global
           I64[Sp - 56] = block_ccxH_info;
           _s8l1::P64 = P64[R1 + 5];
           _s8l2::P64 = P64[R1 + 13];
           _s8l3::P64 = P64[R1 + 21];
           _s8l4::P64 = P64[R1 + 29];
           R1 = R4;
           P64[Sp - 48] = _s8l1::P64;
           P64[Sp - 40] = _s8l2::P64;
           P64[Sp - 32] = _s8l3::P64;
           P64[Sp - 24] = _s8l4::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ucyl; else goto ccxI;
       ucyl: // global
           call _ccxH(R1) args: 0, res: 0, upd: 0;
       ccxI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccxH() //  [R1]
         { info_tbl: [(ccxH,
                       label: block_ccxH_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccxH: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ccyk; else goto ccyj;
       ccyk: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccyj: // global
           _s8l9::P64 = P64[R1 + 7];
           _s8la::P64 = P64[R1 + 15];
           _s8lb::P64 = P64[R1 + 23];
           _s8lc::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_s8lg_info;
           P64[Hp - 208] = P64[Sp + 8];
           _s8l5::P64 = P64[Sp + 40];
           P64[Hp - 200] = _s8l5::P64;
           _s8l6::P64 = P64[Sp + 48];
           P64[Hp - 192] = _s8l6::P64;
           P64[Hp - 184] = _s8lc::P64;
           I64[Hp - 176] = sat_s8lf_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _s8l5::P64;
           P64[Hp - 144] = _s8l6::P64;
           P64[Hp - 136] = _s8lb::P64;
           I64[Hp - 128] = sat_s8le_info;
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = _s8l5::P64;
           P64[Hp - 96] = _s8l6::P64;
           P64[Hp - 88] = _s8la::P64;
           I64[Hp - 80] = sat_s8ld_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _s8l5::P64;
           P64[Hp - 48] = _s8l6::P64;
           P64[Hp - 40] = _s8l9::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 w4_s8kI_entry() //  [R1]
         { info_tbl: [(ccyq,
                       label: w4_s8kI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyr; else goto ccys;
       ccyr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccys: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_s8kJ_entry() //  [R1]
         { info_tbl: [(ccyx,
                       label: w5_s8kJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyy; else goto ccyz;
       ccyy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_s8kK_entry() //  [R1]
         { info_tbl: [(ccyE,
                       label: w6_s8kK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyF; else goto ccyG;
       ccyF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_s8kL_entry() //  [R1]
         { info_tbl: [(ccyL,
                       label: w7_s8kL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyM; else goto ccyN;
       ccyM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8l0_entry() //  [R1, R2]
         { info_tbl: [(ccyW,
                       label: sat_s8l0_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccz7; else goto ccz8;
       ccz7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccz8: // global
           I64[Sp - 40] = block_ccyT_info;
           _s8kI::P64 = P64[R1 + 7];
           _s8kJ::P64 = P64[R1 + 15];
           _s8kK::P64 = P64[R1 + 23];
           _s8kL::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _s8kI::P64;
           P64[Sp - 24] = _s8kJ::P64;
           P64[Sp - 16] = _s8kK::P64;
           P64[Sp - 8] = _s8kL::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uczf; else goto ccyU;
       uczf: // global
           call _ccyT(R1) args: 0, res: 0, upd: 0;
       ccyU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyT() //  [R1]
         { info_tbl: [(ccyT,
                       label: block_ccyT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyT: // global
           I64[Sp - 8] = block_ccyZ_info;
           _s8kP::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8kP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucze; else goto ccz0;
       ucze: // global
           call _ccyZ(R1) args: 0, res: 0, upd: 0;
       ccz0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyZ() //  [R1]
         { info_tbl: [(ccyZ,
                       label: block_ccyZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyZ: // global
           _s8kL::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_ccz4_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = _s8kL::P64;
           _s8kP::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _s8kP::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 _ccz4() //  [R1, R2, R3, R4]
         { info_tbl: [(ccz4,
                       label: block_ccz4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cczd; else goto cczc;
       cczd: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cczc: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8kG_entry() //  [R1]
         { info_tbl: [(cczk,
                       label: sat_s8kG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczl; else goto cczm;
       cczl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kF_entry() //  [R1]
         { info_tbl: [(cczr,
                       label: sat_s8kF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczs; else goto cczt;
       cczs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kE_entry() //  [R1]
         { info_tbl: [(cczy,
                       label: sat_s8kE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczz; else goto cczA;
       cczz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kD_entry() //  [R1]
         { info_tbl: [(cczF,
                       label: sat_s8kD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczG; else goto cczH;
       cczG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kH_entry() //  [R1, R2, R3]
         { info_tbl: [(cczN,
                       label: sat_s8kH_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczO; else goto cczP;
       cczO: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczP: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cczQ,
                       label: GHC.Base.$w$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczQ: // global
           Hp = Hp + 408;
           if (Hp > HpLim) (likely: False) goto cczU; else goto cczT;
       cczU: // global
           HpAlloc = 408;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cczT: // global
           I64[Hp - 400] = w4_s8l1_info;
           P64[Hp - 384] = R5;
           I64[Hp - 376] = w5_s8l2_info;
           P64[Hp - 360] = R4;
           I64[Hp - 352] = w6_s8l3_info;
           P64[Hp - 336] = R3;
           I64[Hp - 328] = w7_s8l4_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s8lh_info;
           P64[Hp - 296] = Hp - 400;
           P64[Hp - 288] = Hp - 376;
           P64[Hp - 280] = Hp - 352;
           P64[Hp - 272] = Hp - 328;
           I64[Hp - 264] = w4_s8kI_info;
           P64[Hp - 248] = R5;
           I64[Hp - 240] = w5_s8kJ_info;
           P64[Hp - 224] = R4;
           I64[Hp - 216] = w6_s8kK_info;
           P64[Hp - 200] = R3;
           I64[Hp - 192] = w7_s8kL_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8l0_info;
           P64[Hp - 160] = Hp - 264;
           P64[Hp - 152] = Hp - 240;
           P64[Hp - 144] = Hp - 216;
           P64[Hp - 136] = Hp - 192;
           I64[Hp - 128] = sat_s8kG_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8kF_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_s8kE_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s8kD_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8kH_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R3 = Hp - 301;
           R2 = Hp - 167;
           R1 = Hp - 30;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.018408475 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccA2,
                       label: GHC.Base.$fMonoid(,,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccA3; else goto ccA4;
       ccA3: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccA4: // global
           I64[Sp - 8] = block_cczZ_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _cczZ() //  [R1, R2, R3]
         { info_tbl: [(cczZ,
                       label: block_cczZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccA7; else goto ccA6;
       ccA7: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ccA6: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.019700844 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccAe,
                       label: GHC.Base.$fMonoid(,,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAf; else goto ccAg;
       ccAf: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAg: // global
           I64[Sp - 8] = block_ccAc_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccAc() //  [R1]
         { info_tbl: [(ccAc,
                       label: block_ccAc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAc: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.022219267 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,)_$cmconcat_info;
 },
 k_s8lC_entry() //  [R1]
         { info_tbl: [(ccAt,
                       label: k_s8lC_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAu; else goto ccAv;
       ccAu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAv: // global
           I64[Sp - 8] = block_ccAq_info;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccAq() //  [R1, R2, R3]
         { info_tbl: [(ccAq,
                       label: block_ccAq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccAy; else goto ccAx;
       ccAy: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ccAx: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 k1_s8lH_entry() //  [R1]
         { info_tbl: [(ccAD,
                       label: k1_s8lH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAE; else goto ccAF;
       ccAE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8lI_entry() //  [R1]
         { info_tbl: [(ccAK,
                       label: z_s8lI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAL; else goto ccAM;
       ccAL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8lJ_entry() //  [R1]
         { info_tbl: [(ccAR,
                       label: z1_s8lJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAS; else goto ccAT;
       ccAS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_s8lK_entry() //  [R1]
         { info_tbl: [(ccAY,
                       label: z2_s8lK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAZ; else goto ccB0;
       ccAZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z3_s8lL_entry() //  [R1]
         { info_tbl: [(ccB5,
                       label: z3_s8lL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB6; else goto ccB7;
       ccB6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8lN_entry() //  [R1, R2]
         { info_tbl: [(ccBl,
                       label: go_s8lN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccBm; else goto ccBn;
       ccBm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccBn: // global
           I64[Sp - 32] = block_ccBe_info;
           _s8lN::P64 = R1;
           _s8lH::P64 = P64[R1 + 7];
           _s8lM::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s8lH::P64;
           P64[Sp - 16] = _s8lM::P64;
           P64[Sp - 8] = _s8lN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucBx; else goto ccBf;
       ucBx: // global
           call _ccBe(R1) args: 0, res: 0, upd: 0;
       ccBf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBe() //  [R1]
         { info_tbl: [(ccBe,
                       label: block_ccBe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBe: // global
           if (R1 & 7 == 1) goto ccBi; else goto ccBj;
       ccBi: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccBj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccBw; else goto ccBv;
       ccBw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccBv: // global
           _s8lQ::P64 = P64[R1 + 6];
           _s8lR::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s8lR::P64;
           R3 = Hp - 24;
           R2 = _s8lQ::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccBy,
                       label: GHC.Base.$fMonoid(,,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBy: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ccBC; else goto ccBB;
       ccBC: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccBB: // global
           I64[Hp - 224] = k_s8lC_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = k1_s8lH_info;
           P64[Hp - 160] = Hp - 224;
           I64[Hp - 152] = z_s8lI_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = z1_s8lJ_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = z2_s8lK_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = z3_s8lL_info;
           P64[Hp - 64] = R5;
           I64[Hp - 56] = (,,,)_con_info;
           P64[Hp - 48] = Hp - 152;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 104;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = go_s8lN_info;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.027101731 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_closure" {
     GHC.Base.$fMonoid(,,,)_closure:
         const GHC.Base.$fMonoid(,,,)_info;
 },
 sat_s8m0_entry() //  [R1]
         { info_tbl: [(ccBL,
                       label: sat_s8m0_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBM; else goto ccBN;
       ccBM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmconcat_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lZ_entry() //  [R1]
         { info_tbl: [(ccBS,
                       label: sat_s8lZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBT; else goto ccBU;
       ccBT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmappend_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lY_entry() //  [R1]
         { info_tbl: [(ccBZ,
                       label: sat_s8lY_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC0; else goto ccC1;
       ccC0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmempty_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lX_entry() //  [R1]
         { info_tbl: [(ccC6,
                       label: sat_s8lX_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccC6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC7; else goto ccC8;
       ccC7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccCa,
                       label: GHC.Base.$fMonoid(,,,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCa: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ccCe; else goto ccCd;
       ccCe: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCd: // global
           I64[Hp - 224] = sat_s8m0_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = sat_s8lZ_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           I64[Hp - 128] = sat_s8lY_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           I64[Hp - 80] = sat_s8lX_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.030053542 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,)_$c<>_info;
 },
 sat_s8mg_entry() //  [R1]
         { info_tbl: [(ccCx,
                       label: sat_s8mg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCy; else goto ccCz;
       ccCy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8mf_entry() //  [R1]
         { info_tbl: [(ccCE,
                       label: sat_s8mf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCF; else goto ccCG;
       ccCF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8me_entry() //  [R1]
         { info_tbl: [(ccCL,
                       label: sat_s8me_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCM; else goto ccCN;
       ccCM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccCO,
                       label: GHC.Base.$fMonoid(,,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCO: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccCQ; else goto ccCR;
       ccCQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCR: // global
           I64[Sp - 40] = block_ccCj_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucCX; else goto ccCk;
       ucCX: // global
           call _ccCj(R1) args: 0, res: 0, upd: 0;
       ccCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccCj() //  [R1]
         { info_tbl: [(ccCj,
                       label: block_ccCj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCj: // global
           I64[Sp - 16] = block_ccCo_info;
           _s8m7::P64 = P64[R1 + 7];
           _s8m8::P64 = P64[R1 + 15];
           _s8m9::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _s8m9::P64;
           P64[Sp] = _s8m8::P64;
           P64[Sp + 32] = _s8m7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucCW; else goto ccCp;
       ucCW: // global
           call _ccCo(R1) args: 0, res: 0, upd: 0;
       ccCp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccCo() //  [R1]
         { info_tbl: [(ccCo,
                       label: block_ccCo_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCo: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccCV; else goto ccCU;
       ccCV: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccCU: // global
           _s8mb::P64 = P64[R1 + 7];
           _s8mc::P64 = P64[R1 + 15];
           _s8md::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8mg_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8md::P64;
           I64[Hp - 104] = sat_s8mf_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s8mc::P64;
           I64[Hp - 64] = sat_s8me_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8mb::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.033731009 UTC

[section ""data" . GHC.Base.$w$csconcat1_closure" {
     GHC.Base.$w$csconcat1_closure:
         const GHC.Base.$w$csconcat1_info;
 },
 GHC.Base.$w$csconcat1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCZ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8mG_entry() //  [R1]
         { info_tbl: [(ccDp,
                       label: sat_s8mG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDq; else goto ccDr;
       ccDq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8mF_entry() //  [R1]
         { info_tbl: [(ccDw,
                       label: sat_s8mF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDx; else goto ccDy;
       ccDx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8mE_entry() //  [R1]
         { info_tbl: [(ccDD,
                       label: sat_s8mE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccDE; else goto ccDF;
       ccDE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccDF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s8mo_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(ccDK,
                       label: $wgo_s8mo_info
                       rep:HeapRep 3 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDK: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccDL; else goto ccDM;
       ccDL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDM: // global
           I64[Sp - 64] = block_ccD8_info;
           _s8mo::P64 = R1;
           _s8mh::P64 = P64[R1 + 4];
           _s8mi::P64 = P64[R1 + 12];
           _s8mj::P64 = P64[R1 + 20];
           R1 = R5;
           P64[Sp - 56] = _s8mh::P64;
           P64[Sp - 48] = _s8mi::P64;
           P64[Sp - 40] = _s8mj::P64;
           P64[Sp - 32] = _s8mo::P64;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ucDV; else goto ccD9;
       ucDV: // global
           call _ccD8(R1) args: 0, res: 0, upd: 0;
       ccD9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccD8() //  [R1]
         { info_tbl: [(ccD8,
                       label: block_ccD8_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccD8: // global
           if (R1 & 7 == 1) goto ccDH; else goto ccDI;
       ccDH: // global
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccDI: // global
           I64[Sp - 8] = block_ccDe_info;
           _s8mv::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8mv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucDU; else goto ccDf;
       ucDU: // global
           call _ccDe(R1) args: 0, res: 0, upd: 0;
       ccDf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDe() //  [R1]
         { info_tbl: [(ccDe,
                       label: block_ccDe_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDe: // global
           _s8mv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccDj_info;
           R5 = _s8mv::P64;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wgo_s8mo_entry(R5, R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccDj() //  [R1, R2, R3]
         { info_tbl: [(ccDj,
                       label: block_ccDj_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDj: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccDT; else goto ccDS;
       ccDT: // global
           HpAlloc = 120;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ccDS: // global
           I64[Hp - 112] = sat_s8mG_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 56];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8mF_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8mE_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccDW,
                       label: GHC.Base.$w$csconcat1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccDW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccE0; else goto ccDZ;
       ccE0: // global
           HpAlloc = 32;
           R1 = GHC.Base.$w$csconcat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ccDZ: // global
           I64[Hp - 24] = $wgo_s8mo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _s8mk::P64 = R5;
           R5 = P64[Sp + 8];
           R4 = P64[Sp];
           R3 = R6;
           R2 = _s8mk::P64;
           R1 = Hp - 20;
           Sp = Sp + 16;
           call $wgo_s8mo_entry(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.037334963 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,)_$csconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccE8,
                       label: GHC.Base.$fSemigroup(,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEj; else goto ccEk;
       ccEj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$csconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEk: // global
           I64[Sp - 32] = block_ccE5_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucEr; else goto ccE6;
       ucEr: // global
           call _ccE5(R1) args: 0, res: 0, upd: 0;
       ccE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccE5() //  [R1]
         { info_tbl: [(ccE5,
                       label: block_ccE5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccE5: // global
           I64[Sp - 8] = block_ccEb_info;
           _s8mN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8mN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucEq; else goto ccEc;
       ucEq: // global
           call _ccEb(R1) args: 0, res: 0, upd: 0;
       ccEc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEb() //  [R1]
         { info_tbl: [(ccEb,
                       label: block_ccEb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEb: // global
           _s8mJ::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_ccEg_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = _s8mJ::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 24, res: 8, upd: 8;
     }
 },
 _ccEg() //  [R1, R2, R3]
         { info_tbl: [(ccEg,
                       label: block_ccEg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccEp; else goto ccEo;
       ccEp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ccEo: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.039925215 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,)_$cmappend_info;
 },
 sat_s8ne_entry() //  [R1]
         { info_tbl: [(ccEM,
                       label: sat_s8ne_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEN; else goto ccEO;
       ccEN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccEO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEK_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccEK() //  [R1]
         { info_tbl: [(ccEK,
                       label: block_ccEK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEK: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8nc_entry() //  [R1]
         { info_tbl: [(ccEY,
                       label: sat_s8nc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccEZ; else goto ccF0;
       ccEZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccF0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccEW_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccEW() //  [R1]
         { info_tbl: [(ccEW,
                       label: block_ccEW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEW: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8na_entry() //  [R1]
         { info_tbl: [(ccFa,
                       label: sat_s8na_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccFa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccFb; else goto ccFc;
       ccFb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccFc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccF8_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccF8() //  [R1]
         { info_tbl: [(ccF8,
                       label: block_ccF8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccF8: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccFg,
                       label: GHC.Base.$fMonoid(,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccFg: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccFi; else goto ccFj;
       ccFi: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccFj: // global
           I64[Sp - 40] = block_ccEw_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucFp; else goto ccEx;
       ucFp: // global
           call _ccEw(R1) args: 0, res: 0, upd: 0;
       ccEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEw() //  [R1]
         { info_tbl: [(ccEw,
                       label: block_ccEw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEw: // global
           I64[Sp - 16] = block_ccEB_info;
           _s8n2::P64 = P64[R1 + 7];
           _s8n3::P64 = P64[R1 + 15];
           _s8n4::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _s8n4::P64;
           P64[Sp] = _s8n3::P64;
           P64[Sp + 32] = _s8n2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucFo; else goto ccEC;
       ucFo: // global
           call _ccEB(R1) args: 0, res: 0, upd: 0;
       ccEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEB() //  [R1]
         { info_tbl: [(ccEB,
                       label: block_ccEB_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEB: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccFn; else goto ccFm;
       ccFn: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccFm: // global
           _s8n6::P64 = P64[R1 + 7];
           _s8n7::P64 = P64[R1 + 15];
           _s8n8::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8ne_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8n8::P64;
           I64[Hp - 104] = sat_s8nc_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s8n7::P64;
           I64[Hp - 64] = sat_s8na_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8n6::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.045165267 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,)_$cmconcat_info;
 },
 $dSemigroup_s8nj_entry() //  [R1]
         { info_tbl: [(ccFy,
                       label: $dSemigroup_s8nj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccFy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccFz; else goto ccFA;
       ccFz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccFA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup1_s8nk_entry() //  [R1]
         { info_tbl: [(ccFF,
                       label: $dSemigroup1_s8nk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccFF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccFG; else goto ccFH;
       ccFG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccFH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup2_s8nl_entry() //  [R1]
         { info_tbl: [(ccFM,
                       label: $dSemigroup2_s8nl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccFM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccFN; else goto ccFO;
       ccFN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccFO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8nm_entry() //  [R1]
         { info_tbl: [(ccFT,
                       label: z_s8nm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccFT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccFU; else goto ccFV;
       ccFU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccFV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8nn_entry() //  [R1]
         { info_tbl: [(ccG0,
                       label: z1_s8nn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccG0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccG1; else goto ccG2;
       ccG1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccG2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_s8no_entry() //  [R1]
         { info_tbl: [(ccG7,
                       label: z2_s8no_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccG7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccG8; else goto ccG9;
       ccG8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccG9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8nF_entry() //  [R1]
         { info_tbl: [(ccGz,
                       label: sat_s8nF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccGz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccGA; else goto ccGB;
       ccGA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccGB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8nE_entry() //  [R1]
         { info_tbl: [(ccGG,
                       label: sat_s8nE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccGG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccGH; else goto ccGI;
       ccGH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccGI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8nD_entry() //  [R1]
         { info_tbl: [(ccGN,
                       label: sat_s8nD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccGN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccGO; else goto ccGP;
       ccGO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccGP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8nq_entry() //  [R1, R2]
         { info_tbl: [(ccGU,
                       label: go_s8nq_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccGU: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccGV; else goto ccGW;
       ccGV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccGW: // global
           I64[Sp - 48] = block_ccGg_info;
           _s8nq::P64 = R1;
           _s8nj::P64 = P64[R1 + 7];
           _s8nk::P64 = P64[R1 + 15];
           _s8nl::P64 = P64[R1 + 23];
           _s8np::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _s8nj::P64;
           P64[Sp - 32] = _s8nk::P64;
           P64[Sp - 24] = _s8nl::P64;
           P64[Sp - 16] = _s8np::P64;
           P64[Sp - 8] = _s8nq::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucH6; else goto ccGh;
       ucH6: // global
           call _ccGg(R1) args: 0, res: 0, upd: 0;
       ccGh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccGg() //  [R1]
         { info_tbl: [(ccGg,
                       label: block_ccGg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccGg: // global
           if (R1 & 7 == 1) goto ccGR; else goto ccGS;
       ccGR: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccGS: // global
           I64[Sp] = block_ccGm_info;
           _s8nu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 32] = _s8nu::P64;
           if (R1 & 7 != 0) goto ucH5; else goto ccGn;
       ucH5: // global
           call _ccGm(R1) args: 0, res: 0, upd: 0;
       ccGn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccGm() //  [R1]
         { info_tbl: [(ccGm,
                       label: block_ccGm_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccGm: // global
           I64[Sp - 8] = block_ccGr_info;
           R2 = P64[Sp + 32];
           _s8nw::P64 = P64[R1 + 7];
           _s8nx::P64 = P64[R1 + 15];
           _s8ny::P64 = P64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp] = _s8ny::P64;
           P64[Sp + 32] = _s8nx::P64;
           P64[Sp + 40] = _s8nw::P64;
           Sp = Sp - 8;
           call go_s8nq_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccGr() //  [R1]
         { info_tbl: [(ccGr,
                       label: block_ccGr_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccGr: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccH4; else goto ccH3;
       ccH4: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccH3: // global
           _s8nA::P64 = P64[R1 + 7];
           _s8nB::P64 = P64[R1 + 15];
           _s8nC::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8nF_info;
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8nC::P64;
           I64[Hp - 104] = sat_s8nE_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = _s8nB::P64;
           I64[Hp - 64] = sat_s8nD_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8nA::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccH7,
                       label: GHC.Base.$fMonoid(,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccH7: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto ccHb; else goto ccHa;
       ccHb: // global
           HpAlloc = 216;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccHa: // global
           I64[Hp - 208] = $dSemigroup_s8nj_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = $dSemigroup1_s8nk_info;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = $dSemigroup2_s8nl_info;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = z_s8nm_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = z1_s8nn_info;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = z2_s8no_info;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = (,,)_con_info;
           P64[Hp - 56] = Hp - 136;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 88;
           I64[Hp - 32] = go_s8nq_info;
           P64[Hp - 24] = Hp - 208;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 160;
           P64[Hp] = Hp - 63;
           R2 = R5;
           R1 = Hp - 31;
           call go_s8nq_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.05026258 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,)_$cstimes_info;
 },
 sat_s8nS_entry() //  [R1]
         { info_tbl: [(ccHp,
                       label: sat_s8nS_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHp: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccHq; else goto ccHr;
       ccHq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8nR_entry() //  [R1]
         { info_tbl: [(ccHw,
                       label: sat_s8nR_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccHx; else goto ccHy;
       ccHx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8nQ_entry() //  [R1]
         { info_tbl: [(ccHD,
                       label: sat_s8nQ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccHE; else goto ccHF;
       ccHE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccHG,
                       label: GHC.Base.$fSemigroup(,,)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccHI; else goto ccHJ;
       ccHI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ccHJ: // global
           I64[Sp - 40] = block_ccHg_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucHN; else goto ccHh;
       ucHN: // global
           call _ccHg(R1) args: 0, res: 0, upd: 0;
       ccHh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccHg() //  [R1]
         { info_tbl: [(ccHg,
                       label: block_ccHg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHg: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccHM; else goto ccHL;
       ccHM: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccHL: // global
           _s8nN::P64 = P64[R1 + 7];
           _s8nO::P64 = P64[R1 + 15];
           _s8nP::P64 = P64[R1 + 23];
           I64[Hp - 168] = sat_s8nS_info;
           P64[Hp - 152] = P64[Sp + 16];
           _s8nJ::P64 = P64[Sp + 24];
           P64[Hp - 144] = _s8nJ::P64;
           _s8nK::P64 = P64[Sp + 32];
           P64[Hp - 136] = _s8nK::P64;
           P64[Hp - 128] = _s8nP::P64;
           I64[Hp - 120] = sat_s8nR_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = _s8nJ::P64;
           P64[Hp - 88] = _s8nK::P64;
           P64[Hp - 80] = _s8nO::P64;
           I64[Hp - 72] = sat_s8nQ_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = _s8nJ::P64;
           P64[Hp - 40] = _s8nK::P64;
           P64[Hp - 32] = _s8nN::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 168;
           R1 = Hp - 23;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.052981543 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_closure" {
     GHC.Base.$fSemigroup(,,)_closure:
         const GHC.Base.$fSemigroup(,,)_info;
 },
 sat_s8nY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccHX,
                       label: sat_s8nY_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccHY; else goto ccHZ;
       ccHY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccHZ: // global
           R6 = R3;
           R5 = R2;
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fSemigroup(,,)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_s8nX_entry() //  [R1, R2]
         { info_tbl: [(ccI5,
                       label: sat_s8nX_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI5: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,)_$csconcat_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8nW_entry() //  [R1, R2, R3]
         { info_tbl: [(ccId,
                       label: sat_s8nW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccId: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$c<>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,)_entry() //  [R2, R3, R4]
         { info_tbl: [(ccIh,
                       label: GHC.Base.$fSemigroup(,,)_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIh: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccIl; else goto ccIk;
       ccIl: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccIk: // global
           I64[Hp - 120] = sat_s8nY_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8nX_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_s8nW_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 117;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.055192209 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,)_$cp1Monoid_info;
 },
 sat_s8o4_entry() //  [R1]
         { info_tbl: [(ccIu,
                       label: sat_s8o4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIv; else goto ccIw;
       ccIv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8o3_entry() //  [R1]
         { info_tbl: [(ccIB,
                       label: sat_s8o3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIC; else goto ccID;
       ccIC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccID: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8o2_entry() //  [R1]
         { info_tbl: [(ccII,
                       label: sat_s8o2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccII: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIJ; else goto ccIK;
       ccIJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cp1Monoid_entry() //  [R2, R3, R4]
         { info_tbl: [(ccIL,
                       label: GHC.Base.$fMonoid(,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccIP; else goto ccIO;
       ccIP: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccIO: // global
           I64[Hp - 64] = sat_s8o4_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s8o3_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8o2_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,,)_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.057448958 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_closure" {
     GHC.Base.$fMonoid(,,)_closure:
         const GHC.Base.$fMonoid(,,)_info;
 },
 sat_s8ob_entry() //  [R1, R2]
         { info_tbl: [(ccIZ,
                       label: sat_s8ob_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIZ: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,,)_$cmconcat_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oa_entry() //  [R1, R2, R3]
         { info_tbl: [(ccJ7,
                       label: sat_s8oa_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ7: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$cmappend_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8o9_entry() //  [R1]
         { info_tbl: [(ccJe,
                       label: sat_s8o9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJf; else goto ccJg;
       ccJf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cmempty_entry(R4,
                                                     R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8o8_entry() //  [R1]
         { info_tbl: [(ccJl,
                       label: sat_s8o8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJm; else goto ccJn;
       ccJm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cp1Monoid_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_entry() //  [R2, R3, R4]
         { info_tbl: [(ccJp,
                       label: GHC.Base.$fMonoid(,,)_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJp: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ccJt; else goto ccJs;
       ccJt: // global
           HpAlloc = 184;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJs: // global
           I64[Hp - 176] = sat_s8ob_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           P64[Hp - 152] = R4;
           I64[Hp - 144] = sat_s8oa_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_s8o9_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s8o8_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 142;
           P64[Hp] = Hp - 175;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.06082875 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$c<>_closure" {
     GHC.Base.$fSemigroup(,)_$c<>_closure:
         const GHC.Base.$fSemigroup(,)_$c<>_info;
 },
 sat_s8on_entry() //  [R1]
         { info_tbl: [(ccJM,
                       label: sat_s8on_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccJN; else goto ccJO;
       ccJN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8om_entry() //  [R1]
         { info_tbl: [(ccJT,
                       label: sat_s8om_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccJU; else goto ccJV;
       ccJU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,)_$c<>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccJW,
                       label: GHC.Base.$fSemigroup(,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccJY; else goto ccJZ;
       ccJY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJZ: // global
           I64[Sp - 32] = block_ccJy_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucK5; else goto ccJz;
       ucK5: // global
           call _ccJy(R1) args: 0, res: 0, upd: 0;
       ccJz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJy() //  [R1]
         { info_tbl: [(ccJy,
                       label: block_ccJy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJy: // global
           I64[Sp - 8] = block_ccJD_info;
           _s8oh::P64 = P64[R1 + 7];
           _s8oi::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8oi::P64;
           P64[Sp + 24] = _s8oh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucK4; else goto ccJE;
       ucK4: // global
           call _ccJD(R1) args: 0, res: 0, upd: 0;
       ccJE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJD() //  [R1]
         { info_tbl: [(ccJD,
                       label: block_ccJD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccK3; else goto ccK2;
       ccK3: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccK2: // global
           _s8ok::P64 = P64[R1 + 7];
           _s8ol::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s8on_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8ol::P64;
           I64[Hp - 56] = sat_s8om_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8ok::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.063391146 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,)_$cstimes_info;
 },
 sat_s8ox_entry() //  [R1]
         { info_tbl: [(ccKj,
                       label: sat_s8ox_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccKk; else goto ccKl;
       ccKk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8ow_entry() //  [R1]
         { info_tbl: [(ccKq,
                       label: sat_s8ow_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccKr; else goto ccKs;
       ccKr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccKt,
                       label: GHC.Base.$fSemigroup(,)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccKv; else goto ccKw;
       ccKv: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccKw: // global
           I64[Sp - 40] = block_ccKa_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucKA; else goto ccKb;
       ucKA: // global
           call _ccKa(R1) args: 0, res: 0, upd: 0;
       ccKb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccKa() //  [R1]
         { info_tbl: [(ccKa,
                       label: block_ccKa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKa: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKz; else goto ccKy;
       ccKz: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKy: // global
           _s8ou::P64 = P64[R1 + 7];
           _s8ov::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_s8ox_info;
           P64[Hp - 96] = P64[Sp + 16];
           _s8oq::P64 = P64[Sp + 24];
           P64[Hp - 88] = _s8oq::P64;
           _s8or::P64 = P64[Sp + 32];
           P64[Hp - 80] = _s8or::P64;
           P64[Hp - 72] = _s8ov::P64;
           I64[Hp - 64] = sat_s8ow_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _s8oq::P64;
           P64[Hp - 32] = _s8or::P64;
           P64[Hp - 24] = _s8ou::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.065741283 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_closure" {
     GHC.Base.$fSemigroup(,)_closure:
         const GHC.Base.$fSemigroup(,)_info;
 },
 sat_s8oC_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccKK,
                       label: sat_s8oC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKK: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oB_entry() //  [R1, R2]
         { info_tbl: [(ccKS,
                       label: sat_s8oB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKS: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,)_$csconcat_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oA_entry() //  [R1, R2, R3]
         { info_tbl: [(ccL0,
                       label: sat_s8oA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroup(,)_$c<>_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,)_entry() //  [R2, R3]
         { info_tbl: [(ccL4,
                       label: GHC.Base.$fSemigroup(,)_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL4: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccL8; else goto ccL7;
       ccL8: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccL7: // global
           I64[Hp - 96] = sat_s8oC_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8oB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s8oA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 46;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 93;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.067565808 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,)_$cp1Monoid_info;
 },
 sat_s8oG_entry() //  [R1]
         { info_tbl: [(ccLh,
                       label: sat_s8oG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLi; else goto ccLj;
       ccLi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccLj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oF_entry() //  [R1]
         { info_tbl: [(ccLo,
                       label: sat_s8oF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLp; else goto ccLq;
       ccLp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccLq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cp1Monoid_entry() //  [R2, R3]
         { info_tbl: [(ccLr,
                       label: GHC.Base.$fMonoid(,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccLv; else goto ccLu;
       ccLv: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccLu: // global
           I64[Hp - 40] = sat_s8oG_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8oF_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,)_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.069476199 UTC

[section ""data" . GHC.Base.$fMonoid(,)_closure" {
     GHC.Base.$fMonoid(,)_closure:
         const GHC.Base.$fMonoid(,)_info;
 },
 sat_s8oM_entry() //  [R1, R2]
         { info_tbl: [(ccLF,
                       label: sat_s8oM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLF: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,)_$cmconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oL_entry() //  [R1, R2, R3]
         { info_tbl: [(ccLN,
                       label: sat_s8oL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLN: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,)_$cmappend_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oK_entry() //  [R1]
         { info_tbl: [(ccLU,
                       label: sat_s8oK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLV; else goto ccLW;
       ccLV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccLW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cmempty_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oJ_entry() //  [R1]
         { info_tbl: [(ccM1,
                       label: sat_s8oJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccM2; else goto ccM3;
       ccM2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccM3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cp1Monoid_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_entry() //  [R2, R3]
         { info_tbl: [(ccM5,
                       label: GHC.Base.$fMonoid(,)_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM5: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccM9; else goto ccM8;
       ccM9: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccM8: // global
           I64[Hp - 144] = sat_s8oM_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_s8oL_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_s8oK_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8oJ_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 143;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.071332217 UTC

[section ""data" . GHC.Base.$fMonoid()_$c<>_closure" {
     GHC.Base.$fMonoid()_$c<>_closure:
         const GHC.Base.$fMonoid()_$c<>_info;
 },
 GHC.Base.$fMonoid()_$c<>_entry() //  []
         { info_tbl: [(ccMe,
                       label: GHC.Base.$fMonoid()_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMe: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.072103036 UTC

[section ""data" . GHC.Base.$fSemigroup()_$csconcat_closure" {
     GHC.Base.$fSemigroup()_$csconcat_closure:
         const GHC.Base.$fSemigroup()_$csconcat_info;
 },
 GHC.Base.$fSemigroup()_$csconcat_entry() //  []
         { info_tbl: [(ccMl,
                       label: GHC.Base.$fSemigroup()_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMl: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.072885815 UTC

[section ""data" . GHC.Base.$fSemigroup()_$cstimes_closure" {
     GHC.Base.$fSemigroup()_$cstimes_closure:
         const GHC.Base.$fSemigroup()_$cstimes_info;
 },
 GHC.Base.$fSemigroup()_$cstimes_entry() //  []
         { info_tbl: [(ccMs,
                       label: GHC.Base.$fSemigroup()_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMs: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.073628919 UTC

[section ""data" . GHC.Base.$fSemigroup()_closure" {
     GHC.Base.$fSemigroup()_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fSemigroup()_$csconcat_closure+1;
         const GHC.Base.$fSemigroup()_$cstimes_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.074928629 UTC

[section ""data" . GHC.Base.$fMonoid()_closure" {
     GHC.Base.$fMonoid()_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup()_closure+1;
         const GHC.Tuple.()_closure+1;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fMonoid()_$cmconcat_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.075706333 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$c<>_closure" {
     GHC.Base.$fSemigroup(->)_$c<>_closure:
         const GHC.Base.$fSemigroup(->)_$c<>_info;
 },
 GHC.Base.$fSemigroup(->)_$c<>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccMB,
                       label: GHC.Base.$fSemigroup(->)_$c<>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMB: // global
           _s8oW::P64 = R5;
           _s8oV::P64 = R4;
           _s8oU::P64 = R3;
           _s8oT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMC; else goto ccMD;
       ccMD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccMF; else goto ccME;
       ccMF: // global
           HpAlloc = 64;
           goto ccMC;
       ccMC: // global
           R5 = _s8oW::P64;
           R4 = _s8oV::P64;
           R3 = _s8oU::P64;
           R2 = _s8oT::P64;
           R1 = GHC.Base.$fSemigroup(->)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccME: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s8oV::P64;
           P64[Hp - 32] = _s8oW::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s8oU::P64;
           P64[Hp] = _s8oW::P64;
           R2 = _s8oT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.076863424 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$cstimes_closure" {
     GHC.Base.$fSemigroup(->)_$cstimes_closure:
         const GHC.Base.$fSemigroup(->)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(->)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccML,
                       label: GHC.Base.$fSemigroup(->)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccML: // global
           _s8p3::P64 = R6;
           _s8p2::P64 = R5;
           _s8p1::P64 = R4;
           _s8p0::P64 = R3;
           _s8oZ::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto ccMM; else goto ccMN;
       ccMN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccMP; else goto ccMO;
       ccMP: // global
           HpAlloc = 32;
           goto ccMM;
       ccMM: // global
           R6 = _s8p3::P64;
           R5 = _s8p2::P64;
           R4 = _s8p1::P64;
           R3 = _s8p0::P64;
           R2 = _s8oZ::P64;
           R1 = GHC.Base.$fSemigroup(->)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccMO: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s8p2::P64;
           P64[Hp] = _s8p3::P64;
           R2 = _s8oZ::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s8p0::P64;
           P64[Sp - 16] = _s8p1::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.078527447 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_closure" {
     GHC.Base.$fSemigroup(->)_closure:
         const GHC.Base.$fSemigroup(->)_info;
 },
 sat_s8p8_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(ccMZ,
                       label: sat_s8p8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMZ: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8p7_entry() //  [R1, R2]
         { info_tbl: [(ccN7,
                       label: sat_s8p7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8p6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccNf,
                       label: sat_s8p6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNf: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(->)_entry() //  [R2]
         { info_tbl: [(ccNj,
                       label: GHC.Base.$fSemigroup(->)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccNn; else goto ccNm;
       ccNn: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNm: // global
           I64[Hp - 72] = sat_s8p8_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8p7_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8p6_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.080190614 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(->)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(->)_$cp1Monoid_info;
 },
 sat_s8pa_entry() //  [R1]
         { info_tbl: [(ccNw,
                       label: sat_s8pa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNx; else goto ccNy;
       ccNx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(->)_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(ccNz,
                       label: GHC.Base.$fMonoid(->)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccND; else goto ccNC;
       ccND: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNC: // global
           I64[Hp - 16] = sat_s8pa_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(->)_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.081938453 UTC

[section ""data" . GHC.Base.$fMonoid(->)_closure" {
     GHC.Base.$fMonoid(->)_closure:
         const GHC.Base.$fMonoid(->)_info;
 },
 lvl3_s8pc_entry() //  [R1]
         { info_tbl: [(ccNM,
                       label: lvl3_s8pc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNN; else goto ccNO;
       ccNN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ph_entry() //  [R1, R2, R3]
         { info_tbl: [(ccNU,
                       label: sat_s8ph_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccO2,
                       label: sat_s8pg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccO2: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pf_entry() //  [R1]
         { info_tbl: [(ccOa,
                       label: sat_s8pf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccOa: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pd_entry() //  [R1]
         { info_tbl: [(ccOh,
                       label: sat_s8pd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccOh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccOi; else goto ccOj;
       ccOi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccOj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(->)_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(->)_entry() //  [R2]
         { info_tbl: [(ccOl,
                       label: GHC.Base.$fMonoid(->)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccOl: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccOp; else goto ccOo;
       ccOp: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccOo: // global
           I64[Hp - 128] = lvl3_s8pc_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8ph_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8pg_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s8pf_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_s8pd_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.083820644 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$cstimes_closure" {
     GHC.Base.$fSemigroup[]_$cstimes_closure:
         const GHC.Base.$fSemigroup[]_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroup[]_$cstimes_entry() //  [R2]
         { info_tbl: [(ccOu,
                       label: GHC.Base.$fSemigroup[]_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccOu: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.08455216 UTC

[section ""data" . GHC.Base.$fSemigroup[]_closure" {
     GHC.Base.$fSemigroup[]_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fSemigroup[]_$csconcat_closure+1;
         const GHC.Base.$fSemigroup[]_$cstimes_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.085118434 UTC

[section ""data" . GHC.Base.$fMonoid[]_closure" {
     GHC.Base.$fMonoid[]_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fMonoid[]_$cmconcat_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.085900054 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cpure_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cpure_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cpure_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cpure_entry() //  [R2]
         { info_tbl: [(ccOC,
                       label: GHC.Base.$fApplicativeNonEmpty_$cpure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccOC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccOG; else goto ccOF;
       ccOG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccOF: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.08736664 UTC

[section ""data" . GHC.Base.$w$cliftA2_closure" {
     GHC.Base.$w$cliftA2_closure:
         const GHC.Base.$w$cliftA2_info;
 },
 sat_s8pq_entry() //  [R1, R2]
         { info_tbl: [(ccOX,
                       label: sat_s8pq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccOX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccP1; else goto ccP0;
       ccP1: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccP0: // global
           _s8pk::P64 = P64[R1 + 7];
           _s8pn::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _s8pk::P64;
           P64[Hp - 32] = _s8pn::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pu_entry() //  [R1, R2]
         { info_tbl: [(ccP5,
                       label: sat_s8pu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccP5: // global
           _s8pn::P64 = R2;
           _s8pu::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccP6; else goto ccP7;
       ccP7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccP9; else goto ccP8;
       ccP9: // global
           HpAlloc = 24;
           goto ccP6;
       ccP6: // global
           R2 = _s8pn::P64;
           R1 = _s8pu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccP8: // global
           _s8pk::P64 = P64[_s8pu::P64 + 7];
           _s8pm::P64 = P64[_s8pu::P64 + 15];
           I64[Hp - 16] = sat_s8pq_info;
           P64[Hp - 8] = _s8pk::P64;
           P64[Hp] = _s8pn::P64;
           I64[Sp - 8] = block_ccP2_info;
           R3 = Hp - 15;
           R2 = _s8pm::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccP2() //  [R1, R2]
         { info_tbl: [(ccP2,
                       label: block_ccP2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccP2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccPc; else goto ccPb;
       ccPc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccPb: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccPd,
                       label: GHC.Base.$w$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccPd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccPh; else goto ccPg;
       ccPh: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccPg: // global
           I64[Hp - 16] = sat_s8pu_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _s8pl::P64 = R3;
           R3 = Hp - 15;
           R2 = _s8pl::P64;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.089429768 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccPp,
                       label: GHC.Base.$fApplicativeNonEmpty_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccPp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccPq; else goto ccPr;
       ccPq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccPr: // global
           I64[Sp - 8] = block_ccPm_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cliftA2_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccPm() //  [R1, R2]
         { info_tbl: [(ccPm,
                       label: block_ccPm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccPm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccPu; else goto ccPt;
       ccPu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccPt: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.091769786 UTC

[section ""data" . GHC.Base.$w$c<*_closure" {
     GHC.Base.$w$c<*_closure:
         const GHC.Base.$w$c<*_info;
 },
 sat_s8pG_entry() //  [R1]
         { info_tbl: [(ccPK,
                       label: sat_s8pG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccPK: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pK_entry() //  [R1, R2]
         { info_tbl: [(ccPQ,
                       label: sat_s8pK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccPQ: // global
           _s8pD::P64 = R2;
           _s8pK::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccPR; else goto ccPS;
       ccPS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccPU; else goto ccPT;
       ccPU: // global
           HpAlloc = 40;
           goto ccPR;
       ccPR: // global
           R2 = _s8pD::P64;
           R1 = _s8pK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccPT: // global
           _s8pC::P64 = P64[_s8pK::P64 + 7];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _s8pD::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = sat_s8pG_info;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_ccPN_info;
           R3 = Hp - 7;
           R2 = _s8pC::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccPN() //  [R1, R2]
         { info_tbl: [(ccPN,
                       label: block_ccPN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccPN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccPX; else goto ccPW;
       ccPX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccPW: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$c<*_entry() //  [R2, R3]
         { info_tbl: [(ccPY,
                       label: GHC.Base.$w$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccPY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccQ2; else goto ccQ1;
       ccQ2: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccQ1: // global
           I64[Hp - 8] = sat_s8pK_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.093670969 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*_entry() //  [R2, R3]
         { info_tbl: [(ccQa,
                       label: GHC.Base.$fApplicativeNonEmpty_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccQa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccQb; else goto ccQc;
       ccQb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccQc: // global
           I64[Sp - 8] = block_ccQ7_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccQ7() //  [R1, R2]
         { info_tbl: [(ccQ7,
                       label: block_ccQ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccQ7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccQf; else goto ccQe;
       ccQf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccQe: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.095297377 UTC

[section ""data" . GHC.Base.$w$c<*>_closure" {
     GHC.Base.$w$c<*>_closure:
         const GHC.Base.$w$c<*>_info;
 },
 sat_s8pV_entry() //  [R1, R2]
         { info_tbl: [(ccQw,
                       label: sat_s8pV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccQw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccQA; else goto ccQz;
       ccQA: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccQz: // global
           _s8pS::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s8pS::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pZ_entry() //  [R1, R2]
         { info_tbl: [(ccQE,
                       label: sat_s8pZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccQE: // global
           _s8pS::P64 = R2;
           _s8pZ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccQF; else goto ccQG;
       ccQG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccQI; else goto ccQH;
       ccQI: // global
           HpAlloc = 16;
           goto ccQF;
       ccQF: // global
           R2 = _s8pS::P64;
           R1 = _s8pZ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccQH: // global
           _s8pR::P64 = P64[_s8pZ::P64 + 7];
           I64[Hp - 8] = sat_s8pV_info;
           P64[Hp] = _s8pS::P64;
           I64[Sp - 8] = block_ccQB_info;
           R3 = Hp - 7;
           R2 = _s8pR::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccQB() //  [R1, R2]
         { info_tbl: [(ccQB,
                       label: block_ccQB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccQB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccQL; else goto ccQK;
       ccQL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccQK: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$c<*>_entry() //  [R2, R3]
         { info_tbl: [(ccQM,
                       label: GHC.Base.$w$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccQM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccQQ; else goto ccQP;
       ccQQ: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccQP: // global
           I64[Hp - 8] = sat_s8pZ_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.097196361 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(ccQY,
                       label: GHC.Base.$fApplicativeNonEmpty_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccQY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccQZ; else goto ccR0;
       ccQZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccR0: // global
           I64[Sp - 8] = block_ccQV_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccQV() //  [R1, R2]
         { info_tbl: [(ccQV,
                       label: block_ccQV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccQV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccR3; else goto ccR2;
       ccR3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccR2: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.098324578 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty1_closure" {
     GHC.Base.$fApplicativeNonEmpty1_closure:
         const GHC.Base.$fApplicativeNonEmpty1_info;
 },
 GHC.Base.$fApplicativeNonEmpty1_entry() //  [R3]
         { info_tbl: [(ccR8,
                       label: GHC.Base.$fApplicativeNonEmpty1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccR8: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.099469427 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c*>_info;
 },
 sat_s8qc_entry() //  [R1]
         { info_tbl: [(ccRm,
                       label: sat_s8qc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccRm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccRn; else goto ccRo;
       ccRn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccRo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccRj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucRs; else goto ccRk;
       ucRs: // global
           call _ccRj(R1) args: 0, res: 0, upd: 0;
       ccRk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccRj() //  [R1]
         { info_tbl: [(ccRj,
                       label: block_ccRj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccRj: // global
           R3 = P64[R1 + 15];
           R2 = GHC.Base.$fApplicativeNonEmpty1_closure+2;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicativeNonEmpty_$c*>_entry() //  [R2, R3]
         { info_tbl: [(ccRx,
                       label: GHC.Base.$fApplicativeNonEmpty_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccRx: // global
           _s8q8::P64 = R3;
           _s8q7::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccRy; else goto ccRz;
       ccRz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccRB; else goto ccRA;
       ccRB: // global
           HpAlloc = 48;
           goto ccRy;
       ccRy: // global
           R3 = _s8q8::P64;
           R2 = _s8q7::P64;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccRA: // global
           I64[Hp - 40] = sat_s8qc_info;
           P64[Hp - 24] = _s8q7::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = GHC.Base.breakpoint_closure+1;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_ccRu_info;
           R3 = _s8q8::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccRu() //  [R1, R2]
         { info_tbl: [(ccRu,
                       label: block_ccRu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccRu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccRE; else goto ccRD;
       ccRE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccRD: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.101027976 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_closure" {
     GHC.Base.$fApplicativeNonEmpty_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeNonEmpty_$c*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.101759104 UTC

[section ""data" . lvl_r7PJ_closure" {
     lvl_r7PJ_closure:
         const lvl_r7PJ_info;
         const 0;
 },
 lvl_r7PJ_entry() //  [R2]
         { info_tbl: [(ccRJ,
                       label: lvl_r7PJ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccRJ: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.102461928 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_closure" {
     GHC.Base.$fMonadNonEmpty_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeNonEmpty_closure+1;
         const GHC.Base.$fMonadNonEmpty_$c>>=_closure+2;
         const GHC.Base.$fMonadNonEmpty_$c>>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const lvl_r7PJ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.103083044 UTC

[section ""cstring" . GHC.Base.$fAlternativeIO4_bytes" {
     GHC.Base.$fAlternativeIO4_bytes:
         I8[] [109,122,101,114,111]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.103826951 UTC

[section ""data" . GHC.Base.$fAlternativeIO3_closure" {
     GHC.Base.$fAlternativeIO3_closure:
         const GHC.Base.$fAlternativeIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO3_entry() //  [R1]
         { info_tbl: [(ccRS,
                       label: GHC.Base.$fAlternativeIO3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccRS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccRT; else goto ccRU;
       ccRT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccRU: // global
           (_ccRP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccRP::I64 == 0) goto ccRR; else goto ccRQ;
       ccRR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccRQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccRP::I64;
           R2 = GHC.Base.$fAlternativeIO4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.104896458 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cempty_closure" {
     GHC.Base.$fAlternativeIO_$cempty_closure:
         const GHC.Base.$fAlternativeIO_$cempty_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO_$cempty_entry() //  [R1]
         { info_tbl: [(ccS1,
                       label: GHC.Base.$fAlternativeIO_$cempty_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccS1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccS2; else goto ccS3;
       ccS2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccS3: // global
           (_ccRY::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccRY::I64 == 0) goto ccS0; else goto ccRZ;
       ccS0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccRZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccRY::I64;
           R2 = GHC.Base.$fAlternativeIO3_closure;
           R1 = GHC.IO.failIO_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.105832582 UTC

[section ""data" . GHC.Base.$fAlternativeIO_closure" {
     GHC.Base.$fAlternativeIO_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure+2;
         const GHC.Base.$fAlternativeIO_$cmany_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.10642515 UTC

[section ""data" . GHC.Base.$fMonadPlusIO_closure" {
     GHC.Base.$fMonadPlusIO_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeIO_closure+1;
         const GHC.Base.$fMonadIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.107844993 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$c<|>_closure" {
     GHC.Base.$fAlternativeMaybe_$c<|>_closure:
         const GHC.Base.$fAlternativeMaybe_$c<|>_info;
 },
 GHC.Base.$fAlternativeMaybe_$c<|>_entry() //  [R2, R3]
         { info_tbl: [(ccSf,
                       label: GHC.Base.$fAlternativeMaybe_$c<|>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccSf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccSg; else goto ccSh;
       ccSg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$c<|>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccSh: // global
           I64[Sp - 16] = block_ccS8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucSo; else goto ccS9;
       ucSo: // global
           call _ccS8(R1) args: 0, res: 0, upd: 0;
       ccS9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccS8() //  [R1]
         { info_tbl: [(ccS8,
                       label: block_ccS8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccS8: // global
           if (R1 & 7 == 1) goto ccSc; else goto ccSd;
       ccSc: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccSd: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.109643183 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cliftA2_closure" {
     GHC.Base.$fApplicativeMaybe_$cliftA2_closure:
         const GHC.Base.$fApplicativeMaybe_$cliftA2_info;
 },
 GHC.Base.$fApplicativeMaybe_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(ccSA,
                       label: GHC.Base.$fApplicativeMaybe_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccSA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccSB; else goto ccSC;
       ccSB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccSC: // global
           I64[Sp - 24] = block_ccSt_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucT4; else goto ccSu;
       ucT4: // global
           call _ccSt(R1) args: 0, res: 0, upd: 0;
       ccSu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccSt() //  [R1]
         { info_tbl: [(ccSt,
                       label: block_ccSt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccSt: // global
           if (R1 & 7 == 1) goto ucT0; else goto ccSy;
       ucT0: // global
           Sp = Sp + 24;
           call _ccSQ() args: 0, res: 0, upd: 0;
       ccSy: // global
           I64[Sp] = block_ccSI_info;
           _s8qq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8qq::P64;
           if (R1 & 7 != 0) goto ucT2; else goto ccSK;
       ucT2: // global
           call _ccSI(R1) args: 0, res: 0, upd: 0;
       ccSK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccSI() //  [R1]
         { info_tbl: [(ccSI,
                       label: block_ccSI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccSI: // global
           if (R1 & 7 == 1) goto ucT1; else goto ccSV;
       ucT1: // global
           Sp = Sp + 24;
           call _ccSQ() args: 0, res: 0, upd: 0;
       ccSV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccSY; else goto ccSX;
       ccSY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccSX: // global
           _s8qs::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _s8qs::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccSQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccSQ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.111412132 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c*>_entry() //  [R2, R3]
         { info_tbl: [(ccTh,
                       label: GHC.Base.$fApplicativeMaybe_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccTh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccTi; else goto ccTj;
       ccTi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccTj: // global
           I64[Sp - 16] = block_ccTa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucTq; else goto ccTb;
       ucTq: // global
           call _ccTa(R1) args: 0, res: 0, upd: 0;
       ccTb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccTa() //  [R1]
         { info_tbl: [(ccTa,
                       label: block_ccTa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccTa: // global
           if (R1 & 7 == 1) goto ccTe; else goto ccTf;
       ccTe: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccTf: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.112602266 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*>_closure" {
     GHC.Base.$fApplicative(->)_$c<*>_closure:
         const GHC.Base.$fApplicative(->)_$c<*>_info;
 },
 GHC.Base.$fApplicative(->)_$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(ccTw,
                       label: GHC.Base.$fApplicative(->)_$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccTw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccTA; else goto ccTz;
       ccTA: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccTz: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 24;
           _s8qy::P64 = R2;
           R2 = R4;
           R1 = _s8qy::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.113723422 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$cliftA2_closure" {
     GHC.Base.$fApplicative(->)_$cliftA2_closure:
         const GHC.Base.$fApplicative(->)_$cliftA2_info;
 },
 GHC.Base.$fApplicative(->)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccTH,
                       label: GHC.Base.$fApplicative(->)_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccTH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccTL; else goto ccTK;
       ccTL: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccTK: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _s8qC::P64 = R2;
           R2 = Hp - 24;
           R1 = _s8qC::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.11462646 UTC

[section ""data" . GHC.Base.$fApplicative(->)_closure" {
     GHC.Base.$fApplicative(->)_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor(->)_closure+1;
         const GHC.Base.const_closure+2;
         const GHC.Base.$fApplicative(->)_$c<*>_closure+3;
         const GHC.Base.$fApplicative(->)_$cliftA2_closure+4;
         const GHC.Base.$fApplicative(->)_$c*>_closure+3;
         const GHC.Base.$fApplicative(->)_$c<*_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.115297463 UTC

[section ""data" . lvl1_r7PK_closure" {
     lvl1_r7PK_closure:
         const lvl1_r7PK_info;
         const 0;
 },
 lvl1_r7PK_entry() //  [R2]
         { info_tbl: [(ccTQ,
                       label: lvl1_r7PK_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccTQ: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.116013815 UTC

[section ""data" . GHC.Base.$fMonad(->)_closure" {
     GHC.Base.$fMonad(->)_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative(->)_closure+1;
         const GHC.Base.$fMonad(->)_$c>>=_closure+3;
         const GHC.Base.$fMonad(->)_$c>>_closure+3;
         const GHC.Base.const_closure+2;
         const lvl1_r7PK_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.116960191 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cfmap_closure" {
     GHC.Base.$fApplicativeMaybe_$cfmap_closure:
         const GHC.Base.$fApplicativeMaybe_$cfmap_info;
 },
 GHC.Base.$fApplicativeMaybe_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(ccU4,
                       label: GHC.Base.$fApplicativeMaybe_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccU4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccU5; else goto ccU6;
       ccU5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccU6: // global
           I64[Sp - 16] = block_ccTX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucUh; else goto ccTY;
       ucUh: // global
           call _ccTX(R1) args: 0, res: 0, upd: 0;
       ccTY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccTX() //  [R1]
         { info_tbl: [(ccTX,
                       label: block_ccTX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccTX: // global
           if (R1 & 7 == 1) goto ccU1; else goto ccU2;
       ccU1: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccU2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccUg; else goto ccUf;
       ccUg: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccUf: // global
           _s8qM::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8qM::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.118131225 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_closure" {
     GHC.Base.$fFunctorMaybe_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.118966212 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(ccUt,
                       label: GHC.Base.$fApplicativeMaybe_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccUt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccUu; else goto ccUv;
       ccUu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccUv: // global
           I64[Sp - 16] = block_ccUm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucUC; else goto ccUn;
       ucUC: // global
           call _ccUm(R1) args: 0, res: 0, upd: 0;
       ccUn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccUm() //  [R1]
         { info_tbl: [(ccUm,
                       label: block_ccUm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccUm: // global
           if (R1 & 7 == 1) goto ccUq; else goto ccUr;
       ccUq: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccUr: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.120059871 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_closure" {
     GHC.Base.$fApplicativeMaybe_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorMaybe_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.120654732 UTC

[section ""data" . GHC.Base.$fMonadMaybe_closure" {
     GHC.Base.$fMonadMaybe_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.121502178 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_closure" {
     GHC.Base.$fAlternativeMaybe_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const GHC.Base.$fAlternativeMaybe_$csome_closure+1;
         const GHC.Base.$fAlternativeMaybe_$cmany_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.12212268 UTC

[section ""data" . GHC.Base.$fMonadPlusMaybe_closure" {
     GHC.Base.$fMonadPlusMaybe_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.123976877 UTC

[section ""data" . GHC.Base.liftA3_$sliftA3_closure" {
     GHC.Base.liftA3_$sliftA3_closure:
         const GHC.Base.liftA3_$sliftA3_info;
 },
 GHC.Base.liftA3_$sliftA3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccUO,
                       label: GHC.Base.liftA3_$sliftA3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccUO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccUP; else goto ccUQ;
       ccUP: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA3_$sliftA3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccUQ: // global
           I64[Sp - 32] = block_ccUH_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucVw; else goto ccUI;
       ucVw: // global
           call _ccUH(R1) args: 0, res: 0, upd: 0;
       ccUI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccUH() //  [R1]
         { info_tbl: [(ccUH,
                       label: block_ccUH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccUH: // global
           if (R1 & 7 == 1) goto ucVr; else goto ccUM;
       ucVr: // global
           Sp = Sp + 32;
           call _ccVg() args: 0, res: 0, upd: 0;
       ccUM: // global
           I64[Sp] = block_ccUW_info;
           _s8qX::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8qX::P64;
           if (R1 & 7 != 0) goto ucVu; else goto ccUY;
       ucVu: // global
           call _ccUW(R1) args: 0, res: 0, upd: 0;
       ccUY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccUW() //  [R1]
         { info_tbl: [(ccUW,
                       label: block_ccUW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccUW: // global
           if (R1 & 7 == 1) goto ucVs; else goto ccV9;
       ucVs: // global
           Sp = Sp + 32;
           call _ccVg() args: 0, res: 0, upd: 0;
       ccV9: // global
           I64[Sp] = block_ccV7_info;
           _s8qZ::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s8qZ::P64;
           if (R1 & 7 != 0) goto ucVx; else goto ccVa;
       ucVx: // global
           call _ccV7(R1) args: 0, res: 0, upd: 0;
       ccVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccV7() //  [R1]
         { info_tbl: [(ccV7,
                       label: block_ccV7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccV7: // global
           if (R1 & 7 == 1) goto ucVt; else goto ccVl;
       ucVt: // global
           Sp = Sp + 32;
           call _ccVg() args: 0, res: 0, upd: 0;
       ccVl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccVo; else goto ccVn;
       ccVo: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccVn: // global
           _s8r1::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s8r1::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccVg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccVg: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.126131897 UTC

[section ""data" . GHC.Base.liftA3_closure" {
     GHC.Base.liftA3_closure:
         const GHC.Base.liftA3_info;
 },
 sat_s8r8_entry() //  [R1]
         { info_tbl: [(ccVI,
                       label: sat_s8r8_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccVI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccVJ; else goto ccVK;
       ccVJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccVK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.liftA3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccVL,
                       label: GHC.Base.liftA3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccVL: // global
           _s8r7::P64 = R6;
           _s8r6::P64 = R5;
           _s8r5::P64 = R4;
           _s8r4::P64 = R3;
           _s8r3::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto ccVM; else goto ccVN;
       ccVN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccVP; else goto ccVO;
       ccVP: // global
           HpAlloc = 48;
           goto ccVM;
       ccVM: // global
           R6 = _s8r7::P64;
           R5 = _s8r6::P64;
           R4 = _s8r5::P64;
           R3 = _s8r4::P64;
           R2 = _s8r3::P64;
           R1 = GHC.Base.liftA3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccVO: // global
           I64[Hp - 40] = sat_s8r8_info;
           P64[Hp - 24] = _s8r3::P64;
           P64[Hp - 16] = _s8r4::P64;
           P64[Hp - 8] = _s8r5::P64;
           P64[Hp] = _s8r6::P64;
           R2 = _s8r3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = _s8r7::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.127520618 UTC

[section ""data" . GHC.Base.liftA_$sliftA_closure" {
     GHC.Base.liftA_$sliftA_closure:
         const GHC.Base.liftA_$sliftA_info;
 },
 GHC.Base.liftA_$sliftA_entry() //  [R2, R3]
         { info_tbl: [(ccVU,
                       label: GHC.Base.liftA_$sliftA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccVU: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.128538547 UTC

[section ""data" . GHC.Base.liftA_closure" {
     GHC.Base.liftA_closure:
         const GHC.Base.liftA_info;
 },
 sat_s8rc_entry() //  [R1]
         { info_tbl: [(ccW5,
                       label: sat_s8rc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccW5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccW6; else goto ccW7;
       ccW6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccW7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Base.liftA_entry() //  [R2, R3, R4]
         { info_tbl: [(ccW8,
                       label: GHC.Base.liftA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccW8: // global
           _s8rb::P64 = R4;
           _s8ra::P64 = R3;
           _s8r9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto ccW9; else goto ccWa;
       ccWa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccWc; else goto ccWb;
       ccWc: // global
           HpAlloc = 32;
           goto ccW9;
       ccW9: // global
           R4 = _s8rb::P64;
           R3 = _s8ra::P64;
           R2 = _s8r9::P64;
           R1 = GHC.Base.liftA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccWb: // global
           I64[Hp - 24] = sat_s8rc_info;
           P64[Hp - 8] = _s8r9::P64;
           P64[Hp] = _s8ra::P64;
           R2 = _s8r9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s8rb::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.130067228 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$cfmap_closure" {
     GHC.Base.$fFunctor(,)_$cfmap_closure:
         const GHC.Base.$fFunctor(,)_$cfmap_info;
 },
 GHC.Base.$fFunctor(,)_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(ccWk,
                       label: GHC.Base.$fFunctor(,)_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccWk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccWp; else goto ccWq;
       ccWp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccWq: // global
           I64[Sp - 16] = block_ccWh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucWu; else goto ccWi;
       ucWu: // global
           call _ccWh(R1) args: 0, res: 0, upd: 0;
       ccWi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccWh() //  [R1]
         { info_tbl: [(ccWh,
                       label: block_ccWh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccWh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccWt; else goto ccWs;
       ccWt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccWs: // global
           _s8rg::P64 = P64[R1 + 7];
           _s8rh::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s8rh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rg::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.131245698 UTC

[section ""data" . GHC.Base.$fFunctor(,)_closure" {
     GHC.Base.$fFunctor(,)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctor(,)_$cfmap_closure+2;
         const GHC.Base.$fFunctor(,)_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.132689135 UTC

[section ""data" . GHC.Base.$fApplicative(,)_closure" {
     GHC.Base.$fApplicative(,)_closure:
         const GHC.Base.$fApplicative(,)_info;
 },
 lvl3_s8rk_entry() //  [R1]
         { info_tbl: [(ccWD,
                       label: lvl3_s8rk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccWD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccWE; else goto ccWF;
       ccWE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8rq_entry() //  [R1, R2, R3]
         { info_tbl: [(ccWL,
                       label: sat_s8rq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccWL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rp_entry() //  [R1, R2, R3]
         { info_tbl: [(ccWT,
                       label: sat_s8rp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccWT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c*>_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ro_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ccX1,
                       label: sat_s8ro_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccX1: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fApplicative(,)_$cliftA2_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rn_entry() //  [R1, R2, R3]
         { info_tbl: [(ccX9,
                       label: sat_s8rn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccX9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*>_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rm_entry() //  [R1, R2]
         { info_tbl: [(ccXi,
                       label: sat_s8rm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccXi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccXm; else goto ccXl;
       ccXm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccXl: // global
           _s8rk::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rk::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative(,)_entry() //  [R2]
         { info_tbl: [(ccXo,
                       label: GHC.Base.$fApplicative(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccXo: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccXs; else goto ccXr;
       ccXs: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccXr: // global
           I64[Hp - 152] = lvl3_s8rk_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s8rq_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s8rp_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s8ro_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s8rn_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s8rm_info;
           P64[Hp - 56] = Hp - 152;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = GHC.Base.$fFunctor(,)_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 93;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 126;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.134850136 UTC

[section ""data" . lvl2_r7PL_closure" {
     lvl2_r7PL_closure:
         const lvl2_r7PL_info;
         const 0;
 },
 lvl2_r7PL_entry() //  [R2]
         { info_tbl: [(ccXx,
                       label: lvl2_r7PL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccXx: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.136338325 UTC

[section ""data" . GHC.Base.$fMonad(,)_closure" {
     GHC.Base.$fMonad(,)_closure:
         const GHC.Base.$fMonad(,)_info;
         const 0;
 },
 lvl3_s8rt_entry() //  [R1]
         { info_tbl: [(ccXI,
                       label: lvl3_s8rt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccXI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccXJ; else goto ccXK;
       ccXJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccXK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ry_entry() //  [R1, R2]
         { info_tbl: [(ccXR,
                       label: sat_s8ry_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccXR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccXV; else goto ccXU;
       ccXV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccXU: // global
           _s8rt::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rt::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rw_entry() //  [R1, R2, R3]
         { info_tbl: [(ccY1,
                       label: sat_s8rw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccY1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rv_entry() //  [R1, R2, R3]
         { info_tbl: [(ccY9,
                       label: sat_s8rv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccY9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>=_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ru_entry() //  [R1]
         { info_tbl: [(ccYg,
                       label: sat_s8ru_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccYh; else goto ccYi;
       ccYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fApplicative(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_entry() //  [R2]
         { info_tbl: [(ccYk,
                       label: GHC.Base.$fMonad(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccYk: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccYo; else goto ccYn;
       ccYo: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccYn: // global
           I64[Hp - 136] = lvl3_s8rt_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s8ry_info;
           P64[Hp - 104] = Hp - 136;
           I64[Hp - 96] = sat_s8rw_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s8rv_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s8ru_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl2_r7PL_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.139216095 UTC

[section ""data" . GHC.Base.C:Monad_closure" {
     GHC.Base.C:Monad_closure:
         const GHC.Base.C:Monad_info;
 },
 GHC.Base.C:Monad_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccYu,
                       label: GHC.Base.C:Monad_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccYu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccYy; else goto ccYx;
       ccYy: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monad_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccYx: // global
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.140269782 UTC

[section ""data" . GHC.Base.C:Functor_closure" {
     GHC.Base.C:Functor_closure:
         const GHC.Base.C:Functor_info;
 },
 GHC.Base.C:Functor_entry() //  [R2, R3]
         { info_tbl: [(ccYE,
                       label: GHC.Base.C:Functor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccYE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccYI; else goto ccYH;
       ccYI: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Functor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccYH: // global
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.141677723 UTC

[section ""data" . GHC.Base.C:Applicative_closure" {
     GHC.Base.C:Applicative_closure:
         const GHC.Base.C:Applicative_info;
 },
 GHC.Base.C:Applicative_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccYO,
                       label: GHC.Base.C:Applicative_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccYO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccYS; else goto ccYR;
       ccYS: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Applicative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ccYR: // global
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.142782078 UTC

[section ""data" . GHC.Base.C:Semigroup_closure" {
     GHC.Base.C:Semigroup_closure:
         const GHC.Base.C:Semigroup_info;
 },
 GHC.Base.C:Semigroup_entry() //  [R2, R3, R4]
         { info_tbl: [(ccYY,
                       label: GHC.Base.C:Semigroup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccYY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccZ2; else goto ccZ1;
       ccZ2: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Semigroup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccZ1: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.143808108 UTC

[section ""data" . GHC.Base.C:Monoid_closure" {
     GHC.Base.C:Monoid_closure:
         const GHC.Base.C:Monoid_info;
 },
 GHC.Base.C:Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccZ8,
                       label: GHC.Base.C:Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccZ8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccZc; else goto ccZb;
       ccZc: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccZb: // global
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.144653482 UTC

[section ""data" . GHC.Base.Nothing_closure" {
     GHC.Base.Nothing_closure:
         const GHC.Base.Nothing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.145354607 UTC

[section ""data" . GHC.Base.Just_closure" {
     GHC.Base.Just_closure:
         const GHC.Base.Just_info;
 },
 GHC.Base.Just_entry() //  [R2]
         { info_tbl: [(ccZi,
                       label: GHC.Base.Just_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccZi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccZm; else goto ccZl;
       ccZm: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.Just_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccZl: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.146331126 UTC

[section ""data" . GHC.Base.O_closure" {
     GHC.Base.O_closure:
         const GHC.Base.O_info;
 },
 GHC.Base.O_entry() //  [R2]
         { info_tbl: [(ccZs,
                       label: GHC.Base.O_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccZs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccZw; else goto ccZv;
       ccZw: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.O_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccZv: // global
           I64[Hp - 8] = GHC.Base.O_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.14729994 UTC

[section ""data" . GHC.Base.:|_closure" {
     GHC.Base.:|_closure:
         const GHC.Base.:|_info;
 },
 GHC.Base.:|_entry() //  [R2, R3]
         { info_tbl: [(ccZC,
                       label: GHC.Base.:|_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccZC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccZG; else goto ccZF;
       ccZG: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.:|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccZF: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.148329876 UTC

[section ""data" . GHC.Base.C:MonadPlus_closure" {
     GHC.Base.C:MonadPlus_closure:
         const GHC.Base.C:MonadPlus_info;
 },
 GHC.Base.C:MonadPlus_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ccZM,
                       label: GHC.Base.C:MonadPlus_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccZM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccZQ; else goto ccZP;
       ccZQ: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:MonadPlus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccZP: // global
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.149417469 UTC

[section ""data" . GHC.Base.C:Alternative_closure" {
     GHC.Base.C:Alternative_closure:
         const GHC.Base.C:Alternative_info;
 },
 GHC.Base.C:Alternative_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccZW,
                       label: GHC.Base.C:Alternative_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccZW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cd00; else goto ccZZ;
       cd00: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Alternative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccZZ: // global
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.150337397 UTC

[GHC.Base.C:Monad_con_entry() //  [R1]
         { info_tbl: [(cd01,
                       label: GHC.Base.C:Monad_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd01: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.151083351 UTC

[GHC.Base.C:Functor_con_entry() //  [R1]
         { info_tbl: [(cd03,
                       label: GHC.Base.C:Functor_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,70,117,110,99,116,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd03: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.151813911 UTC

[GHC.Base.C:Applicative_con_entry() //  [R1]
         { info_tbl: [(cd05,
                       label: GHC.Base.C:Applicative_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,112,112,108,105,99,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd05: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.152527489 UTC

[GHC.Base.C:Semigroup_con_entry() //  [R1]
         { info_tbl: [(cd07,
                       label: GHC.Base.C:Semigroup_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,83,101,109,105,103,114,111,117,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd07: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.153572481 UTC

[GHC.Base.C:Monoid_con_entry() //  [R1]
         { info_tbl: [(cd09,
                       label: GHC.Base.C:Monoid_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,111,105,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd09: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.154906822 UTC

[GHC.Base.Nothing_con_entry() //  [R1]
         { info_tbl: [(cd0b,
                       label: GHC.Base.Nothing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,78,111,116,104,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0b: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.155619719 UTC

[GHC.Base.Just_con_entry() //  [R1]
         { info_tbl: [(cd0d,
                       label: GHC.Base.Just_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,74,117,115,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0d: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.156331279 UTC

[GHC.Base.O_con_entry() //  [R1]
         { info_tbl: [(cd0f,
                       label: GHC.Base.O_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,79]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0f: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.157050599 UTC

[GHC.Base.:|_con_entry() //  [R1]
         { info_tbl: [(cd0h,
                       label: GHC.Base.:|_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,58,124]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0h: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.157795913 UTC

[GHC.Base.C:MonadPlus_con_entry() //  [R1]
         { info_tbl: [(cd0j,
                       label: GHC.Base.C:MonadPlus_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0j: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.158480114 UTC

[GHC.Base.C:Alternative_con_entry() //  [R1]
         { info_tbl: [(cd0l,
                       label: GHC.Base.C:Alternative_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,108,116,101,114,110,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0l: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.159150411 UTC

[section ""relreadonly" . S8R0_srt" {
     S8R0_srt:
         const GHC.Base.$fSemigroupIO_$cstimes_closure;
         const GHC.Base.$fSemigroupIO_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const GHC.Base.$fMonoidIO_$cp1Monoid_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure;
         const GHC.Base.$fAlternativeIO_$cmany_closure;
         const GHC.Base.$fSemigroupNonEmpty_closure;
         const GHC.Base.$fMonoidIO_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.failIO_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const GHC.Base.$fSemigroupMaybe_closure;
         const GHC.Base.$fMonoidMaybe_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const GHC.Base.$fAlternativeIO3_closure;
         const GHC.Base.$fMonad(,)_closure;
         const lvl2_r7PL_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.160042641 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:54:44.161529132 UTC

[section ""data" . GHC.Base.$p1Monad_closure" {
     GHC.Base.$p1Monad_closure:
         const GHC.Base.$p1Monad_info;
 },
 GHC.Base.$p1Monad_entry() //  [R2]
         { info_tbl: [(cd0u,
                       label: GHC.Base.$p1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd0v; else goto cd0w;
       cd0v: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd0w: // global
           I64[Sp - 8] = block_cd0r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud0A; else goto cd0s;
       ud0A: // global
           call _cd0r(R1) args: 0, res: 0, upd: 0;
       cd0s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd0r() //  [R1]
         { info_tbl: [(cd0r,
                       label: block_cd0r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0r: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.167041382 UTC

[section ""data" . GHC.Base.>>=_closure" {
     GHC.Base.>>=_closure:
         const GHC.Base.>>=_info;
 },
 GHC.Base.>>=_entry() //  [R2]
         { info_tbl: [(cd0T,
                       label: GHC.Base.>>=_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd0U; else goto cd0V;
       cd0U: // global
           R2 = R2;
           R1 = GHC.Base.>>=_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd0V: // global
           I64[Sp - 8] = block_cd0Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud0Z; else goto cd0R;
       ud0Z: // global
           call _cd0Q(R1) args: 0, res: 0, upd: 0;
       cd0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd0Q() //  [R1]
         { info_tbl: [(cd0Q,
                       label: block_cd0Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd0Q: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.172950675 UTC

[section ""data" . GHC.Base.>>_closure" {
     GHC.Base.>>_closure:
         const GHC.Base.>>_info;
 },
 GHC.Base.>>_entry() //  [R2]
         { info_tbl: [(cd1g,
                       label: GHC.Base.>>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd1g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd1h; else goto cd1i;
       cd1h: // global
           R2 = R2;
           R1 = GHC.Base.>>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd1i: // global
           I64[Sp - 8] = block_cd1d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud1m; else goto cd1e;
       ud1m: // global
           call _cd1d(R1) args: 0, res: 0, upd: 0;
       cd1e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd1d() //  [R1]
         { info_tbl: [(cd1d,
                       label: block_cd1d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd1d: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.178335399 UTC

[section ""data" . GHC.Base.return_closure" {
     GHC.Base.return_closure:
         const GHC.Base.return_info;
 },
 GHC.Base.return_entry() //  [R2]
         { info_tbl: [(cd1D,
                       label: GHC.Base.return_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd1D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd1E; else goto cd1F;
       cd1E: // global
           R2 = R2;
           R1 = GHC.Base.return_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd1F: // global
           I64[Sp - 8] = block_cd1A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud1J; else goto cd1B;
       ud1J: // global
           call _cd1A(R1) args: 0, res: 0, upd: 0;
       cd1B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd1A() //  [R1]
         { info_tbl: [(cd1A,
                       label: block_cd1A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd1A: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.184323635 UTC

[section ""data" . GHC.Base.fail_closure" {
     GHC.Base.fail_closure:
         const GHC.Base.fail_info;
 },
 GHC.Base.fail_entry() //  [R2]
         { info_tbl: [(cd20,
                       label: GHC.Base.fail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd20: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd21; else goto cd22;
       cd21: // global
           R2 = R2;
           R1 = GHC.Base.fail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd22: // global
           I64[Sp - 8] = block_cd1X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud26; else goto cd1Y;
       ud26: // global
           call _cd1X(R1) args: 0, res: 0, upd: 0;
       cd1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd1X() //  [R1]
         { info_tbl: [(cd1X,
                       label: block_cd1X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd1X: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.189665711 UTC

[section ""data" . GHC.Base.fmap_closure" {
     GHC.Base.fmap_closure:
         const GHC.Base.fmap_info;
 },
 GHC.Base.fmap_entry() //  [R2]
         { info_tbl: [(cd2n,
                       label: GHC.Base.fmap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd2n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd2o; else goto cd2p;
       cd2o: // global
           R2 = R2;
           R1 = GHC.Base.fmap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd2p: // global
           I64[Sp - 8] = block_cd2k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud2t; else goto cd2l;
       ud2t: // global
           call _cd2k(R1) args: 0, res: 0, upd: 0;
       cd2l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd2k() //  [R1]
         { info_tbl: [(cd2k,
                       label: block_cd2k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd2k: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.194921316 UTC

[section ""data" . GHC.Base.<$_closure" {
     GHC.Base.<$_closure:
         const GHC.Base.<$_info;
 },
 GHC.Base.<$_entry() //  [R2]
         { info_tbl: [(cd2K,
                       label: GHC.Base.<$_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd2K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd2L; else goto cd2M;
       cd2L: // global
           R2 = R2;
           R1 = GHC.Base.<$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd2M: // global
           I64[Sp - 8] = block_cd2H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud2Q; else goto cd2I;
       ud2Q: // global
           call _cd2H(R1) args: 0, res: 0, upd: 0;
       cd2I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd2H() //  [R1]
         { info_tbl: [(cd2H,
                       label: block_cd2H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd2H: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.2005469 UTC

[section ""data" . GHC.Base.$p1Applicative_closure" {
     GHC.Base.$p1Applicative_closure:
         const GHC.Base.$p1Applicative_info;
 },
 GHC.Base.$p1Applicative_entry() //  [R2]
         { info_tbl: [(cd37,
                       label: GHC.Base.$p1Applicative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd37: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd38; else goto cd39;
       cd38: // global
           R2 = R2;
           R1 = GHC.Base.$p1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd39: // global
           I64[Sp - 8] = block_cd34_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud3d; else goto cd35;
       ud3d: // global
           call _cd34(R1) args: 0, res: 0, upd: 0;
       cd35: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd34() //  [R1]
         { info_tbl: [(cd34,
                       label: block_cd34_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd34: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.205741564 UTC

[section ""data" . GHC.Base.pure_closure" {
     GHC.Base.pure_closure:
         const GHC.Base.pure_info;
 },
 GHC.Base.pure_entry() //  [R2]
         { info_tbl: [(cd3w,
                       label: GHC.Base.pure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd3w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd3x; else goto cd3y;
       cd3x: // global
           R2 = R2;
           R1 = GHC.Base.pure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd3y: // global
           I64[Sp - 8] = block_cd3t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud3C; else goto cd3u;
       ud3C: // global
           call _cd3t(R1) args: 0, res: 0, upd: 0;
       cd3u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd3t() //  [R1]
         { info_tbl: [(cd3t,
                       label: block_cd3t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd3t: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.210965119 UTC

[section ""data" . GHC.Base.<*>_closure" {
     GHC.Base.<*>_closure:
         const GHC.Base.<*>_info;
 },
 GHC.Base.<*>_entry() //  [R2]
         { info_tbl: [(cd3T,
                       label: GHC.Base.<*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd3T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd3U; else goto cd3V;
       cd3U: // global
           R2 = R2;
           R1 = GHC.Base.<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd3V: // global
           I64[Sp - 8] = block_cd3Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud3Z; else goto cd3R;
       ud3Z: // global
           call _cd3Q(R1) args: 0, res: 0, upd: 0;
       cd3R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd3Q() //  [R1]
         { info_tbl: [(cd3Q,
                       label: block_cd3Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd3Q: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.217000134 UTC

[section ""data" . GHC.Base.liftA2_closure" {
     GHC.Base.liftA2_closure:
         const GHC.Base.liftA2_info;
 },
 GHC.Base.liftA2_entry() //  [R2]
         { info_tbl: [(cd4g,
                       label: GHC.Base.liftA2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd4g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd4h; else goto cd4i;
       cd4h: // global
           R2 = R2;
           R1 = GHC.Base.liftA2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd4i: // global
           I64[Sp - 8] = block_cd4d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud4m; else goto cd4e;
       ud4m: // global
           call _cd4d(R1) args: 0, res: 0, upd: 0;
       cd4e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd4d() //  [R1]
         { info_tbl: [(cd4d,
                       label: block_cd4d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd4d: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.222134829 UTC

[section ""data" . GHC.Base.*>_closure" {
     GHC.Base.*>_closure:
         const GHC.Base.*>_info;
 },
 GHC.Base.*>_entry() //  [R2]
         { info_tbl: [(cd4D,
                       label: GHC.Base.*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd4D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd4E; else goto cd4F;
       cd4E: // global
           R2 = R2;
           R1 = GHC.Base.*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd4F: // global
           I64[Sp - 8] = block_cd4A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud4J; else goto cd4B;
       ud4J: // global
           call _cd4A(R1) args: 0, res: 0, upd: 0;
       cd4B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd4A() //  [R1]
         { info_tbl: [(cd4A,
                       label: block_cd4A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd4A: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.227486625 UTC

[section ""data" . GHC.Base.<*_closure" {
     GHC.Base.<*_closure:
         const GHC.Base.<*_info;
 },
 GHC.Base.<*_entry() //  [R2]
         { info_tbl: [(cd50,
                       label: GHC.Base.<*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd50: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd51; else goto cd52;
       cd51: // global
           R2 = R2;
           R1 = GHC.Base.<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd52: // global
           I64[Sp - 8] = block_cd4X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud56; else goto cd4Y;
       ud56: // global
           call _cd4X(R1) args: 0, res: 0, upd: 0;
       cd4Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd4X() //  [R1]
         { info_tbl: [(cd4X,
                       label: block_cd4X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd4X: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.233818096 UTC

[section ""data" . GHC.Base.<>_closure" {
     GHC.Base.<>_closure:
         const GHC.Base.<>_info;
 },
 GHC.Base.<>_entry() //  [R2]
         { info_tbl: [(cd5n,
                       label: GHC.Base.<>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd5n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd5o; else goto cd5p;
       cd5o: // global
           R2 = R2;
           R1 = GHC.Base.<>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd5p: // global
           I64[Sp - 8] = block_cd5k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud5t; else goto cd5l;
       ud5t: // global
           call _cd5k(R1) args: 0, res: 0, upd: 0;
       cd5l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd5k() //  [R1]
         { info_tbl: [(cd5k,
                       label: block_cd5k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd5k: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.239894236 UTC

[section ""data" . GHC.Base.sconcat_closure" {
     GHC.Base.sconcat_closure:
         const GHC.Base.sconcat_info;
 },
 GHC.Base.sconcat_entry() //  [R2]
         { info_tbl: [(cd5K,
                       label: GHC.Base.sconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd5K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd5L; else goto cd5M;
       cd5L: // global
           R2 = R2;
           R1 = GHC.Base.sconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd5M: // global
           I64[Sp - 8] = block_cd5H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud5Q; else goto cd5I;
       ud5Q: // global
           call _cd5H(R1) args: 0, res: 0, upd: 0;
       cd5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd5H() //  [R1]
         { info_tbl: [(cd5H,
                       label: block_cd5H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd5H: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.245578354 UTC

[section ""data" . GHC.Base.stimes_closure" {
     GHC.Base.stimes_closure:
         const GHC.Base.stimes_info;
 },
 GHC.Base.stimes_entry() //  [R2]
         { info_tbl: [(cd67,
                       label: GHC.Base.stimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd67: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd68; else goto cd69;
       cd68: // global
           R2 = R2;
           R1 = GHC.Base.stimes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd69: // global
           I64[Sp - 8] = block_cd64_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud6d; else goto cd65;
       ud6d: // global
           call _cd64(R1) args: 0, res: 0, upd: 0;
       cd65: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd64() //  [R1]
         { info_tbl: [(cd64,
                       label: block_cd64_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd64: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.250697353 UTC

[section ""data" . GHC.Base.$p1Monoid_closure" {
     GHC.Base.$p1Monoid_closure:
         const GHC.Base.$p1Monoid_info;
 },
 GHC.Base.$p1Monoid_entry() //  [R2]
         { info_tbl: [(cd6u,
                       label: GHC.Base.$p1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd6u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd6v; else goto cd6w;
       cd6v: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd6w: // global
           I64[Sp - 8] = block_cd6r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud6A; else goto cd6s;
       ud6A: // global
           call _cd6r(R1) args: 0, res: 0, upd: 0;
       cd6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd6r() //  [R1]
         { info_tbl: [(cd6r,
                       label: block_cd6r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd6r: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.256058166 UTC

[section ""data" . GHC.Base.mempty_closure" {
     GHC.Base.mempty_closure:
         const GHC.Base.mempty_info;
 },
 GHC.Base.mempty_entry() //  [R2]
         { info_tbl: [(cd6T,
                       label: GHC.Base.mempty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd6T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd6U; else goto cd6V;
       cd6U: // global
           R2 = R2;
           R1 = GHC.Base.mempty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd6V: // global
           I64[Sp - 8] = block_cd6Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud6Z; else goto cd6R;
       ud6Z: // global
           call _cd6Q(R1) args: 0, res: 0, upd: 0;
       cd6R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd6Q() //  [R1]
         { info_tbl: [(cd6Q,
                       label: block_cd6Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd6Q: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.261663278 UTC

[section ""data" . GHC.Base.mappend_closure" {
     GHC.Base.mappend_closure:
         const GHC.Base.mappend_info;
 },
 GHC.Base.mappend_entry() //  [R2]
         { info_tbl: [(cd7g,
                       label: GHC.Base.mappend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd7g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd7h; else goto cd7i;
       cd7h: // global
           R2 = R2;
           R1 = GHC.Base.mappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd7i: // global
           I64[Sp - 8] = block_cd7d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud7m; else goto cd7e;
       ud7m: // global
           call _cd7d(R1) args: 0, res: 0, upd: 0;
       cd7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd7d() //  [R1]
         { info_tbl: [(cd7d,
                       label: block_cd7d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd7d: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.266890158 UTC

[section ""data" . GHC.Base.mconcat_closure" {
     GHC.Base.mconcat_closure:
         const GHC.Base.mconcat_info;
 },
 GHC.Base.mconcat_entry() //  [R2]
         { info_tbl: [(cd7D,
                       label: GHC.Base.mconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd7D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd7E; else goto cd7F;
       cd7E: // global
           R2 = R2;
           R1 = GHC.Base.mconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd7F: // global
           I64[Sp - 8] = block_cd7A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud7J; else goto cd7B;
       ud7J: // global
           call _cd7A(R1) args: 0, res: 0, upd: 0;
       cd7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd7A() //  [R1]
         { info_tbl: [(cd7A,
                       label: block_cd7A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd7A: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.272556322 UTC

[section ""data" . GHC.Base.$p1MonadPlus_closure" {
     GHC.Base.$p1MonadPlus_closure:
         const GHC.Base.$p1MonadPlus_info;
 },
 GHC.Base.$p1MonadPlus_entry() //  [R2]
         { info_tbl: [(cd80,
                       label: GHC.Base.$p1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd80: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd81; else goto cd82;
       cd81: // global
           R2 = R2;
           R1 = GHC.Base.$p1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd82: // global
           I64[Sp - 8] = block_cd7X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud86; else goto cd7Y;
       ud86: // global
           call _cd7X(R1) args: 0, res: 0, upd: 0;
       cd7Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd7X() //  [R1]
         { info_tbl: [(cd7X,
                       label: block_cd7X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd7X: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.277846999 UTC

[section ""data" . GHC.Base.$p2MonadPlus_closure" {
     GHC.Base.$p2MonadPlus_closure:
         const GHC.Base.$p2MonadPlus_info;
 },
 GHC.Base.$p2MonadPlus_entry() //  [R2]
         { info_tbl: [(cd8p,
                       label: GHC.Base.$p2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd8p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd8q; else goto cd8r;
       cd8q: // global
           R2 = R2;
           R1 = GHC.Base.$p2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd8r: // global
           I64[Sp - 8] = block_cd8m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud8v; else goto cd8n;
       ud8v: // global
           call _cd8m(R1) args: 0, res: 0, upd: 0;
       cd8n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd8m() //  [R1]
         { info_tbl: [(cd8m,
                       label: block_cd8m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd8m: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.283517402 UTC

[section ""data" . GHC.Base.mzero_closure" {
     GHC.Base.mzero_closure:
         const GHC.Base.mzero_info;
 },
 GHC.Base.mzero_entry() //  [R2]
         { info_tbl: [(cd8O,
                       label: GHC.Base.mzero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd8O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd8P; else goto cd8Q;
       cd8P: // global
           R2 = R2;
           R1 = GHC.Base.mzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd8Q: // global
           I64[Sp - 8] = block_cd8L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud8U; else goto cd8M;
       ud8U: // global
           call _cd8L(R1) args: 0, res: 0, upd: 0;
       cd8M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd8L() //  [R1]
         { info_tbl: [(cd8L,
                       label: block_cd8L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd8L: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.289004715 UTC

[section ""data" . GHC.Base.mplus_closure" {
     GHC.Base.mplus_closure:
         const GHC.Base.mplus_info;
 },
 GHC.Base.mplus_entry() //  [R2]
         { info_tbl: [(cd9b,
                       label: GHC.Base.mplus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd9b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd9c; else goto cd9d;
       cd9c: // global
           R2 = R2;
           R1 = GHC.Base.mplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd9d: // global
           I64[Sp - 8] = block_cd98_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud9h; else goto cd99;
       ud9h: // global
           call _cd98(R1) args: 0, res: 0, upd: 0;
       cd99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd98() //  [R1]
         { info_tbl: [(cd98,
                       label: block_cd98_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd98: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.29435976 UTC

[section ""data" . GHC.Base.$p1Alternative_closure" {
     GHC.Base.$p1Alternative_closure:
         const GHC.Base.$p1Alternative_info;
 },
 GHC.Base.$p1Alternative_entry() //  [R2]
         { info_tbl: [(cd9y,
                       label: GHC.Base.$p1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd9y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd9z; else goto cd9A;
       cd9z: // global
           R2 = R2;
           R1 = GHC.Base.$p1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd9A: // global
           I64[Sp - 8] = block_cd9v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud9E; else goto cd9w;
       ud9E: // global
           call _cd9v(R1) args: 0, res: 0, upd: 0;
       cd9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd9v() //  [R1]
         { info_tbl: [(cd9v,
                       label: block_cd9v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd9v: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.300643728 UTC

[section ""data" . GHC.Base.empty_closure" {
     GHC.Base.empty_closure:
         const GHC.Base.empty_info;
 },
 GHC.Base.empty_entry() //  [R2]
         { info_tbl: [(cd9X,
                       label: GHC.Base.empty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd9X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd9Y; else goto cd9Z;
       cd9Y: // global
           R2 = R2;
           R1 = GHC.Base.empty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd9Z: // global
           I64[Sp - 8] = block_cd9U_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uda3; else goto cd9V;
       uda3: // global
           call _cd9U(R1) args: 0, res: 0, upd: 0;
       cd9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cd9U() //  [R1]
         { info_tbl: [(cd9U,
                       label: block_cd9U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cd9U: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.306487843 UTC

[section ""data" . GHC.Base.<|>_closure" {
     GHC.Base.<|>_closure:
         const GHC.Base.<|>_info;
 },
 GHC.Base.<|>_entry() //  [R2]
         { info_tbl: [(cdak,
                       label: GHC.Base.<|>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdak: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdal; else goto cdam;
       cdal: // global
           R2 = R2;
           R1 = GHC.Base.<|>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdam: // global
           I64[Sp - 8] = block_cdah_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udaq; else goto cdai;
       udaq: // global
           call _cdah(R1) args: 0, res: 0, upd: 0;
       cdai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdah() //  [R1]
         { info_tbl: [(cdah,
                       label: block_cdah_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdah: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.311704368 UTC

[section ""data" . GHC.Base.some_closure" {
     GHC.Base.some_closure:
         const GHC.Base.some_info;
 },
 GHC.Base.some_entry() //  [R2]
         { info_tbl: [(cdaH,
                       label: GHC.Base.some_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdaH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdaI; else goto cdaJ;
       cdaI: // global
           R2 = R2;
           R1 = GHC.Base.some_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdaJ: // global
           I64[Sp - 8] = block_cdaE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udaN; else goto cdaF;
       udaN: // global
           call _cdaE(R1) args: 0, res: 0, upd: 0;
       cdaF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdaE() //  [R1]
         { info_tbl: [(cdaE,
                       label: block_cdaE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdaE: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.317470213 UTC

[section ""data" . GHC.Base.many_closure" {
     GHC.Base.many_closure:
         const GHC.Base.many_info;
 },
 GHC.Base.many_entry() //  [R2]
         { info_tbl: [(cdb4,
                       label: GHC.Base.many_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdb4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdb5; else goto cdb6;
       cdb5: // global
           R2 = R2;
           R1 = GHC.Base.many_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdb6: // global
           I64[Sp - 8] = block_cdb1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udba; else goto cdb2;
       udba: // global
           call _cdb1(R1) args: 0, res: 0, upd: 0;
       cdb2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdb1() //  [R1]
         { info_tbl: [(cdb1,
                       label: block_cdb1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdb1: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.323372441 UTC

[section ""data" . GHC.Base.eqString_closure" {
     GHC.Base.eqString_closure:
         const GHC.Base.eqString_info;
 },
 GHC.Base.eqString_entry() //  [R2, R3]
         { info_tbl: [(cdbv,
                       label: GHC.Base.eqString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdbv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdbw; else goto udcl;
       cdbw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.eqString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udcl: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdbl() args: 0, res: 0, upd: 0;
     }
 },
 _cdbl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdbl: // global
           _s7SQ::P64 = P64[Sp];
           I64[Sp] = block_cdbo_info;
           R1 = _s7SQ::P64;
           if (R1 & 7 != 0) goto udcq; else goto cdbp;
       udcq: // global
           call _cdbo(R1) args: 0, res: 0, upd: 0;
       cdbp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdbo() //  [R1]
         { info_tbl: [(cdbo,
                       label: block_cdbo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdbo: // global
           _s7SR::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdbs; else goto cdbt;
       cdbs: // global
           I64[Sp + 8] = block_cdbA_info;
           R1 = _s7SR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udcr; else goto cdbC;
       udcr: // global
           call _cdbA(R1) args: 0, res: 0, upd: 0;
       cdbC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdbt: // global
           I64[Sp - 8] = block_cdbP_info;
           _s7SW::P64 = P64[R1 + 6];
           _s7SX::P64 = P64[R1 + 14];
           R1 = _s7SR::P64;
           P64[Sp] = _s7SX::P64;
           P64[Sp + 8] = _s7SW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udcs; else goto cdbR;
       udcs: // global
           call _cdbP(R1) args: 0, res: 0, upd: 0;
       cdbR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdbA() //  [R1]
         { info_tbl: [(cdbA,
                       label: block_cdbA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdbA: // global
           if (R1 & 7 == 1) goto cdbI; else goto udcp;
       cdbI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udcp: // global
           Sp = Sp + 8;
           call _cdch() args: 0, res: 0, upd: 0;
     }
 },
 _cdbP() //  [R1]
         { info_tbl: [(cdbP,
                       label: block_cdbP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdbP: // global
           if (R1 & 7 == 1) goto udcm; else goto cdc7;
       udcm: // global
           Sp = Sp + 24;
           call _cdch() args: 0, res: 0, upd: 0;
       cdc7: // global
           I64[Sp - 8] = block_cdc0_info;
           _s7SZ::P64 = P64[R1 + 6];
           _s7T0::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _s7T0::P64;
           P64[Sp + 16] = _s7SZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udcv; else goto cdc1;
       udcv: // global
           call _cdc0(R1) args: 0, res: 0, upd: 0;
       cdc1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdc0() //  [R1]
         { info_tbl: [(cdc0,
                       label: block_cdc0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdc0: // global
           I64[Sp] = block_cdc5_info;
           _s7T2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7T2::I64;
           if (R1 & 7 != 0) goto udcx; else goto cdc9;
       udcx: // global
           call _cdc5(R1) args: 0, res: 0, upd: 0;
       cdc9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdc5() //  [R1]
         { info_tbl: [(cdc5,
                       label: block_cdc5_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdc5: // global
           if (I64[Sp + 24] == I64[R1 + 7]) goto cdci; else goto udcn;
       cdci: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cdbl() args: 0, res: 0, upd: 0;
       udcn: // global
           Sp = Sp + 32;
           call _cdch() args: 0, res: 0, upd: 0;
     }
 },
 _cdch() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdch: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.338903062 UTC

[section ""data" . GHC.Base.when2_closure" {
     GHC.Base.when2_closure:
         const GHC.Base.when2_info;
 },
 GHC.Base.when2_entry() //  [R2, R3]
         { info_tbl: [(cddp,
                       label: GHC.Base.when2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cddp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cddq; else goto cddr;
       cddq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cddr: // global
           I64[Sp - 16] = block_cddi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uddy; else goto cddj;
       uddy: // global
           call _cddi(R1) args: 0, res: 0, upd: 0;
       cddj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cddi() //  [R1]
         { info_tbl: [(cddi,
                       label: block_cddi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cddi: // global
           if (R1 & 7 == 1) goto cddm; else goto cddn;
       cddm: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cddn: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.34446981 UTC

[section ""data" . GHC.Base.when_$swhen1_closure" {
     GHC.Base.when_$swhen1_closure:
         const GHC.Base.when_$swhen1_info;
 },
 GHC.Base.when_$swhen1_entry() //  [R2, R3]
         { info_tbl: [(cddP,
                       label: GHC.Base.when_$swhen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cddP: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.when2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.348219075 UTC

[section ""data" . GHC.Base.$fFunctorIO2_closure" {
     GHC.Base.$fFunctorIO2_closure:
         const GHC.Base.$fFunctorIO2_info;
 },
 GHC.Base.$fFunctorIO2_entry() //  [R2, R3]
         { info_tbl: [(cde3,
                       label: GHC.Base.$fFunctorIO2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cde3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cde4; else goto cde5;
       cde4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cde5: // global
           I64[Sp - 16] = block_cde0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cde0() //  [R1]
         { info_tbl: [(cde0,
                       label: block_cde0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cde0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cde8; else goto cde7;
       cde8: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cde7: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.354065115 UTC

[section ""data" . GHC.Base.$fFunctorIO1_closure" {
     GHC.Base.$fFunctorIO1_closure:
         const GHC.Base.$fFunctorIO1_info;
 },
 GHC.Base.$fFunctorIO1_entry() //  [R2, R3]
         { info_tbl: [(cdep,
                       label: GHC.Base.$fFunctorIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdeq; else goto cder;
       cdeq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cder: // global
           I64[Sp - 16] = block_cden_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cden() //  []
         { info_tbl: [(cden,
                       label: block_cden_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cden: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.359005983 UTC

[section ""data" . GHC.Base.$fFunctorIO_closure" {
     GHC.Base.$fFunctorIO_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorIO2_closure+3;
         const GHC.Base.$fFunctorIO1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.361084278 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe1_closure" {
     GHC.Base.$fAlternativeMaybe1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.363681566 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$cmany_closure" {
     GHC.Base.$fAlternativeMaybe_$cmany_closure:
         const GHC.Base.$fAlternativeMaybe_$cmany_info;
 },
 many_v_s7To_entry() //  [R1]
         { info_tbl: [(cdeT,
                       label: many_v_s7To_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdeT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdeU; else goto cdeV;
       cdeU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdeV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdeM_info;
           _s7To::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s7To::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udfn; else goto cdeN;
       udfn: // global
           call _cdeM(R1) args: 0, res: 0, upd: 0;
       cdeN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdeM() //  [R1]
         { info_tbl: [(cdeM,
                       label: block_cdeM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdeM: // global
           if (R1 & 7 == 1) goto udfj; else goto cdeR;
       udfj: // global
           Sp = Sp + 16;
           call _cdf9() args: 0, res: 0, upd: 0;
       cdeR: // global
           I64[Sp] = block_cdf1_info;
           _s7Tq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Tq::P64;
           if (R1 & 7 != 0) goto udfl; else goto cdf3;
       udfl: // global
           call _cdf1(R1) args: 0, res: 0, upd: 0;
       cdf3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdf1() //  [R1]
         { info_tbl: [(cdf1,
                       label: block_cdf1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdf1: // global
           if (R1 & 7 == 1) goto udfk; else goto cdfe;
       udfk: // global
           Sp = Sp + 16;
           call _cdf9() args: 0, res: 0, upd: 0;
       cdfe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdfh; else goto cdfg;
       cdfh: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdfg: // global
           _s7Ts::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7Ts::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cdf9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdf9: // global
           R1 = GHC.Base.$fAlternativeMaybe1_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$cmany_entry() //  [R2]
         { info_tbl: [(cdfp,
                       label: GHC.Base.$fAlternativeMaybe_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdfp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdft; else goto cdfs;
       cdft: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdfs: // global
           I64[Hp - 16] = many_v_s7To_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.37514456 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$csome_closure" {
     GHC.Base.$fAlternativeMaybe_$csome_closure:
         const GHC.Base.$fAlternativeMaybe_$csome_info;
 },
 some_v_s7Tv_entry() //  [R1]
         { info_tbl: [(cdgb,
                       label: some_v_s7Tv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdgb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdgc; else goto cdgd;
       cdgc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdgd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdg4_info;
           _s7Tv::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s7Tv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udgG; else goto cdg5;
       udgG: // global
           call _cdg4(R1) args: 0, res: 0, upd: 0;
       cdg5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdg4() //  [R1]
         { info_tbl: [(cdg4,
                       label: block_cdg4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdg4: // global
           if (R1 & 7 == 1) goto cdg8; else goto cdg9;
       cdg8: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdg9: // global
           I64[Sp] = block_cdgj_info;
           _s7Tx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Tx::P64;
           if (R1 & 7 != 0) goto udgF; else goto cdgl;
       udgF: // global
           call _cdgj(R1) args: 0, res: 0, upd: 0;
       cdgl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdgj() //  [R1]
         { info_tbl: [(cdgj,
                       label: block_cdgj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdgj: // global
           _s7Tx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdgs; else goto cdgA;
       cdgs: // global
           Hp = Hp + 40;
           _s7Ty::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdgD; else goto cdgu;
       cdgu: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _s7Tx::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdgA: // global
           Hp = Hp + 40;
           _s7Ty::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdgD; else goto cdgC;
       cdgD: // global
           HpAlloc = 40;
           R1 = _s7Ty::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdgC: // global
           _s7TA::P64 = P64[_s7Ty::P64 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _s7Tx::P64;
           P64[Hp - 16] = _s7TA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$csome_entry() //  [R2]
         { info_tbl: [(cdgH,
                       label: GHC.Base.$fAlternativeMaybe_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdgH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdgL; else goto cdgK;
       cdgL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdgK: // global
           I64[Hp - 16] = some_v_s7Tv_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.3866993 UTC

[section ""data" . GHC.Base.ap_$sap_closure" {
     GHC.Base.ap_$sap_closure:
         const GHC.Base.ap_$sap_info;
 },
 GHC.Base.ap_$sap_entry() //  [R2, R3]
         { info_tbl: [(cdho,
                       label: GHC.Base.ap_$sap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdho: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdhp; else goto cdhq;
       cdhp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap_$sap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdhq: // global
           I64[Sp - 16] = block_cdhh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udhS; else goto cdhi;
       udhS: // global
           call _cdhh(R1) args: 0, res: 0, upd: 0;
       cdhi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdhh() //  [R1]
         { info_tbl: [(cdhh,
                       label: block_cdhh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdhh: // global
           if (R1 & 7 == 1) goto udhO; else goto cdhm;
       udhO: // global
           Sp = Sp + 16;
           call _cdhE() args: 0, res: 0, upd: 0;
       cdhm: // global
           I64[Sp] = block_cdhw_info;
           _s7TF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7TF::P64;
           if (R1 & 7 != 0) goto udhQ; else goto cdhy;
       udhQ: // global
           call _cdhw(R1) args: 0, res: 0, upd: 0;
       cdhy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdhw() //  [R1]
         { info_tbl: [(cdhw,
                       label: block_cdhw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdhw: // global
           if (R1 & 7 == 1) goto udhP; else goto cdhJ;
       udhP: // global
           Sp = Sp + 16;
           call _cdhE() args: 0, res: 0, upd: 0;
       cdhJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdhM; else goto cdhL;
       cdhM: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdhL: // global
           _s7TH::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7TH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdhE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdhE: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.397143948 UTC

[section ""data" . GHC.Base.liftM5_$sliftM5_closure" {
     GHC.Base.liftM5_$sliftM5_closure:
         const GHC.Base.liftM5_$sliftM5_info;
 },
 GHC.Base.liftM5_$sliftM5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdis,
                       label: GHC.Base.liftM5_$sliftM5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdis: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdit; else goto cdiu;
       cdit: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM5_$sliftM5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdiu: // global
           I64[Sp - 40] = block_cdil_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udjC; else goto cdim;
       udjC: // global
           call _cdil(R1) args: 0, res: 0, upd: 0;
       cdim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdil() //  [R1]
         { info_tbl: [(cdil,
                       label: block_cdil_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdil: // global
           if (R1 & 7 == 1) goto udjv; else goto cdiq;
       udjv: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdiq: // global
           I64[Sp] = block_cdiA_info;
           _s7TQ::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7TQ::P64;
           if (R1 & 7 != 0) goto udjA; else goto cdiC;
       udjA: // global
           call _cdiA(R1) args: 0, res: 0, upd: 0;
       cdiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdiA() //  [R1]
         { info_tbl: [(cdiA,
                       label: block_cdiA_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdiA: // global
           if (R1 & 7 == 1) goto udjw; else goto cdiN;
       udjw: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdiN: // global
           I64[Sp] = block_cdiL_info;
           _s7TS::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7TS::P64;
           if (R1 & 7 != 0) goto udjD; else goto cdiO;
       udjD: // global
           call _cdiL(R1) args: 0, res: 0, upd: 0;
       cdiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdiL() //  [R1]
         { info_tbl: [(cdiL,
                       label: block_cdiL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdiL: // global
           if (R1 & 7 == 1) goto udjx; else goto cdiZ;
       udjx: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdiZ: // global
           I64[Sp] = block_cdiX_info;
           _s7TU::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7TU::P64;
           if (R1 & 7 != 0) goto udjF; else goto cdj0;
       udjF: // global
           call _cdiX(R1) args: 0, res: 0, upd: 0;
       cdj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdiX() //  [R1]
         { info_tbl: [(cdiX,
                       label: block_cdiX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdiX: // global
           if (R1 & 7 == 1) goto udjy; else goto cdjb;
       udjy: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdjb: // global
           I64[Sp] = block_cdj9_info;
           _s7TW::P64 = P64[R1 + 6];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s7TW::P64;
           if (R1 & 7 != 0) goto udjH; else goto cdjc;
       udjH: // global
           call _cdj9(R1) args: 0, res: 0, upd: 0;
       cdjc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdj9() //  [R1]
         { info_tbl: [(cdj9,
                       label: block_cdj9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdj9: // global
           if (R1 & 7 == 1) goto udjz; else goto cdjn;
       udjz: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdjn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdjq; else goto cdjp;
       cdjq: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdjp: // global
           _s7TY::P64 = P64[R1 + 6];
           I64[Hp - 72] = stg_ap_6_upd_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = _s7TY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 72;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdji() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdji: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.413010164 UTC

[section ""data" . GHC.Base.liftM4_$sliftM4_closure" {
     GHC.Base.liftM4_$sliftM4_closure:
         const GHC.Base.liftM4_$sliftM4_info;
 },
 GHC.Base.liftM4_$sliftM4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdkE,
                       label: GHC.Base.liftM4_$sliftM4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdkE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdkF; else goto cdkG;
       cdkF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM4_$sliftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdkG: // global
           I64[Sp - 40] = block_cdkx_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udlA; else goto cdky;
       udlA: // global
           call _cdkx(R1) args: 0, res: 0, upd: 0;
       cdky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdkx() //  [R1]
         { info_tbl: [(cdkx,
                       label: block_cdkx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdkx: // global
           if (R1 & 7 == 1) goto udlu; else goto cdkC;
       udlu: // global
           Sp = Sp + 40;
           call _cdli() args: 0, res: 0, upd: 0;
       cdkC: // global
           I64[Sp] = block_cdkM_info;
           _s7U6::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7U6::P64;
           if (R1 & 7 != 0) goto udly; else goto cdkO;
       udly: // global
           call _cdkM(R1) args: 0, res: 0, upd: 0;
       cdkO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdkM() //  [R1]
         { info_tbl: [(cdkM,
                       label: block_cdkM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdkM: // global
           if (R1 & 7 == 1) goto udlv; else goto cdkZ;
       udlv: // global
           Sp = Sp + 40;
           call _cdli() args: 0, res: 0, upd: 0;
       cdkZ: // global
           I64[Sp] = block_cdkX_info;
           _s7U8::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7U8::P64;
           if (R1 & 7 != 0) goto udlB; else goto cdl0;
       udlB: // global
           call _cdkX(R1) args: 0, res: 0, upd: 0;
       cdl0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdkX() //  [R1]
         { info_tbl: [(cdkX,
                       label: block_cdkX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdkX: // global
           if (R1 & 7 == 1) goto udlw; else goto cdlb;
       udlw: // global
           Sp = Sp + 40;
           call _cdli() args: 0, res: 0, upd: 0;
       cdlb: // global
           I64[Sp] = block_cdl9_info;
           _s7Ua::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Ua::P64;
           if (R1 & 7 != 0) goto udlD; else goto cdlc;
       udlD: // global
           call _cdl9(R1) args: 0, res: 0, upd: 0;
       cdlc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdl9() //  [R1]
         { info_tbl: [(cdl9,
                       label: block_cdl9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdl9: // global
           if (R1 & 7 == 1) goto udlx; else goto cdln;
       udlx: // global
           Sp = Sp + 40;
           call _cdli() args: 0, res: 0, upd: 0;
       cdln: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdlq; else goto cdlp;
       cdlq: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdlp: // global
           _s7Uc::P64 = P64[R1 + 6];
           I64[Hp - 64] = stg_ap_5_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = _s7Uc::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdli() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdli: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.427147236 UTC

[section ""data" . GHC.Base.liftM3_$sliftM3_closure" {
     GHC.Base.liftM3_$sliftM3_closure:
         const GHC.Base.liftM3_$sliftM3_info;
 },
 GHC.Base.liftM3_$sliftM3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdmt,
                       label: GHC.Base.liftM3_$sliftM3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdmt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdmu; else goto cdmv;
       cdmu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM3_$sliftM3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdmv: // global
           I64[Sp - 32] = block_cdmm_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udnb; else goto cdmn;
       udnb: // global
           call _cdmm(R1) args: 0, res: 0, upd: 0;
       cdmn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdmm() //  [R1]
         { info_tbl: [(cdmm,
                       label: block_cdmm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdmm: // global
           if (R1 & 7 == 1) goto udn6; else goto cdmr;
       udn6: // global
           Sp = Sp + 32;
           call _cdmV() args: 0, res: 0, upd: 0;
       cdmr: // global
           I64[Sp] = block_cdmB_info;
           _s7Uj::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Uj::P64;
           if (R1 & 7 != 0) goto udn9; else goto cdmD;
       udn9: // global
           call _cdmB(R1) args: 0, res: 0, upd: 0;
       cdmD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdmB() //  [R1]
         { info_tbl: [(cdmB,
                       label: block_cdmB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdmB: // global
           if (R1 & 7 == 1) goto udn7; else goto cdmO;
       udn7: // global
           Sp = Sp + 32;
           call _cdmV() args: 0, res: 0, upd: 0;
       cdmO: // global
           I64[Sp] = block_cdmM_info;
           _s7Ul::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Ul::P64;
           if (R1 & 7 != 0) goto udnc; else goto cdmP;
       udnc: // global
           call _cdmM(R1) args: 0, res: 0, upd: 0;
       cdmP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdmM() //  [R1]
         { info_tbl: [(cdmM,
                       label: block_cdmM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdmM: // global
           if (R1 & 7 == 1) goto udn8; else goto cdn0;
       udn8: // global
           Sp = Sp + 32;
           call _cdmV() args: 0, res: 0, upd: 0;
       cdn0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdn3; else goto cdn2;
       cdn3: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdn2: // global
           _s7Un::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s7Un::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdmV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdmV: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.439375406 UTC

[section ""data" . GHC.Base.liftM2_$sliftM2_closure" {
     GHC.Base.liftM2_$sliftM2_closure:
         const GHC.Base.liftM2_$sliftM2_info;
 },
 GHC.Base.liftM2_$sliftM2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdnV,
                       label: GHC.Base.liftM2_$sliftM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdnV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdnW; else goto cdnX;
       cdnW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM2_$sliftM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdnX: // global
           I64[Sp - 24] = block_cdnO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udop; else goto cdnP;
       udop: // global
           call _cdnO(R1) args: 0, res: 0, upd: 0;
       cdnP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdnO() //  [R1]
         { info_tbl: [(cdnO,
                       label: block_cdnO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdnO: // global
           if (R1 & 7 == 1) goto udol; else goto cdnT;
       udol: // global
           Sp = Sp + 24;
           call _cdob() args: 0, res: 0, upd: 0;
       cdnT: // global
           I64[Sp] = block_cdo3_info;
           _s7Ut::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Ut::P64;
           if (R1 & 7 != 0) goto udon; else goto cdo5;
       udon: // global
           call _cdo3(R1) args: 0, res: 0, upd: 0;
       cdo5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdo3() //  [R1]
         { info_tbl: [(cdo3,
                       label: block_cdo3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdo3: // global
           if (R1 & 7 == 1) goto udom; else goto cdog;
       udom: // global
           Sp = Sp + 24;
           call _cdob() args: 0, res: 0, upd: 0;
       cdog: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdoj; else goto cdoi;
       cdoj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdoi: // global
           _s7Uv::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _s7Uv::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdob() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdob: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.448309054 UTC

[section ""data" . GHC.Base.liftM_$sliftM_closure" {
     GHC.Base.liftM_$sliftM_closure:
         const GHC.Base.liftM_$sliftM_info;
 },
 GHC.Base.liftM_$sliftM_entry() //  [R2, R3]
         { info_tbl: [(cdp0,
                       label: GHC.Base.liftM_$sliftM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdp0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdp1; else goto cdp2;
       cdp1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM_$sliftM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdp2: // global
           I64[Sp - 16] = block_cdoT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udpd; else goto cdoU;
       udpd: // global
           call _cdoT(R1) args: 0, res: 0, upd: 0;
       cdoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdoT() //  [R1]
         { info_tbl: [(cdoT,
                       label: block_cdoT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdoT: // global
           if (R1 & 7 == 1) goto cdoX; else goto cdoY;
       cdoX: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdoY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdpc; else goto cdpb;
       cdpc: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpb: // global
           _s7UA::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7UA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.454907061 UTC

[section ""data" . GHC.Base.when1_closure" {
     GHC.Base.when1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.456913817 UTC

[section ""data" . GHC.Base.when_$swhen_closure" {
     GHC.Base.when_$swhen_closure:
         const GHC.Base.when_$swhen_info;
 },
 GHC.Base.when_$swhen_entry() //  [R2, R3]
         { info_tbl: [(cdpF,
                       label: GHC.Base.when_$swhen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpG; else goto cdpH;
       cdpG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_$swhen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpH: // global
           I64[Sp - 16] = block_cdpy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udpO; else goto cdpz;
       udpO: // global
           call _cdpy(R1) args: 0, res: 0, upd: 0;
       cdpz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpy() //  [R1]
         { info_tbl: [(cdpy,
                       label: block_cdpy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpy: // global
           if (R1 & 7 == 1) goto cdpC; else goto cdpD;
       cdpC: // global
           R1 = GHC.Base.when1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdpD: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.462857497 UTC

[section ""data" . GHC.Base.when_closure" {
     GHC.Base.when_closure:
         const GHC.Base.when_info;
 },
 GHC.Base.when_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqe,
                       label: GHC.Base.when_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqf; else goto cdqg;
       cdqf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqg: // global
           I64[Sp - 24] = block_cdq7_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqn; else goto cdq8;
       udqn: // global
           call _cdq7(R1) args: 0, res: 0, upd: 0;
       cdq8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdq7() //  [R1]
         { info_tbl: [(cdq7,
                       label: block_cdq7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq7: // global
           if (R1 & 7 == 1) goto cdqb; else goto cdqc;
       cdqb: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cdqc: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.469718672 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*_entry() //  [R2, R3]
         { info_tbl: [(cdqK,
                       label: GHC.Base.$fApplicativeMaybe_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqL; else goto cdqM;
       cdqL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqM: // global
           I64[Sp - 16] = block_cdqD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udra; else goto cdqE;
       udra: // global
           call _cdqD(R1) args: 0, res: 0, upd: 0;
       cdqE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqD() //  [R1]
         { info_tbl: [(cdqD,
                       label: block_cdqD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqD: // global
           if (R1 & 7 == 1) goto udr6; else goto cdqI;
       udr6: // global
           Sp = Sp + 16;
           call _cdr0() args: 0, res: 0, upd: 0;
       cdqI: // global
           I64[Sp] = block_cdqS_info;
           _s7UL::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7UL::P64;
           if (R1 & 7 != 0) goto udr8; else goto cdqU;
       udr8: // global
           call _cdqS(R1) args: 0, res: 0, upd: 0;
       cdqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqS() //  [R1]
         { info_tbl: [(cdqS,
                       label: block_cdqS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqS: // global
           if (R1 & 7 == 1) goto udr7; else goto cdr4;
       udr7: // global
           Sp = Sp + 16;
           call _cdr0() args: 0, res: 0, upd: 0;
       cdr4: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdr0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr0: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.47787705 UTC

[section ""cstring" . GHC.Base.$tc'O3_bytes" {
     GHC.Base.$tc'O3_bytes:
         I8[] [39,79]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.479580327 UTC

[section ""data" . GHC.Base.$tc'O2_closure" {
     GHC.Base.$tc'O2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'O3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.481727094 UTC

[section ""cstring" . GHC.Base.$tcOpaque2_bytes" {
     GHC.Base.$tcOpaque2_bytes:
         I8[] [79,112,97,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.483356945 UTC

[section ""data" . GHC.Base.$tcOpaque1_closure" {
     GHC.Base.$tcOpaque1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcOpaque2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.48497724 UTC

[section ""cstring" . GHC.Base.$tcMonadPlus2_bytes" {
     GHC.Base.$tcMonadPlus2_bytes:
         I8[] [77,111,110,97,100,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.48667533 UTC

[section ""data" . GHC.Base.$tcMonadPlus1_closure" {
     GHC.Base.$tcMonadPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonadPlus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.488303795 UTC

[section ""cstring" . GHC.Base.$tcMonad2_bytes" {
     GHC.Base.$tcMonad2_bytes:
         I8[] [77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.490284401 UTC

[section ""data" . GHC.Base.$tcMonad1_closure" {
     GHC.Base.$tcMonad1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonad2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.491921236 UTC

[section ""cstring" . GHC.Base.$tc'C:Monoid3_bytes" {
     GHC.Base.$tc'C:Monoid3_bytes:
         I8[] [39,67,58,77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.493704992 UTC

[section ""data" . GHC.Base.$tc'C:Monoid2_closure" {
     GHC.Base.$tc'C:Monoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'C:Monoid3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.4956894 UTC

[section ""cstring" . GHC.Base.$tcMonoid3_bytes" {
     GHC.Base.$tcMonoid3_bytes:
         I8[] [77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.497309943 UTC

[section ""data" . GHC.Base.$tcMonoid2_closure" {
     GHC.Base.$tcMonoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonoid3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.498941692 UTC

[section ""cstring" . GHC.Base.$tcSemigroup2_bytes" {
     GHC.Base.$tcSemigroup2_bytes:
         I8[] [83,101,109,105,103,114,111,117,112]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.500462929 UTC

[section ""data" . GHC.Base.$tcSemigroup1_closure" {
     GHC.Base.$tcSemigroup1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcSemigroup2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.502223913 UTC

[section ""cstring" . GHC.Base.$tc':|3_bytes" {
     GHC.Base.$tc':|3_bytes:
         I8[] [39,58,124]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.503869868 UTC

[section ""data" . GHC.Base.$tc':|2_closure" {
     GHC.Base.$tc':|2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc':|3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.505590593 UTC

[section ""cstring" . GHC.Base.$tcNonEmpty2_bytes" {
     GHC.Base.$tcNonEmpty2_bytes:
         I8[] [78,111,110,69,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.507646476 UTC

[section ""data" . GHC.Base.$tcNonEmpty1_closure" {
     GHC.Base.$tcNonEmpty1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcNonEmpty2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.509628817 UTC

[section ""cstring" . GHC.Base.$tcAlternative3_bytes" {
     GHC.Base.$tcAlternative3_bytes:
         I8[] [65,108,116,101,114,110,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.511250993 UTC

[section ""data" . GHC.Base.$tcAlternative2_closure" {
     GHC.Base.$tcAlternative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcAlternative3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.512914804 UTC

[section ""cstring" . GHC.Base.$tcApplicative2_bytes" {
     GHC.Base.$tcApplicative2_bytes:
         I8[] [65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.514599468 UTC

[section ""data" . GHC.Base.$tcApplicative1_closure" {
     GHC.Base.$tcApplicative1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcApplicative2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.516258933 UTC

[section ""cstring" . GHC.Base.$tcFunctor2_bytes" {
     GHC.Base.$tcFunctor2_bytes:
         I8[] [70,117,110,99,116,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.517918586 UTC

[section ""data" . GHC.Base.$tcFunctor1_closure" {
     GHC.Base.$tcFunctor1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcFunctor2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.51964471 UTC

[section ""cstring" . GHC.Base.$tc'Just3_bytes" {
     GHC.Base.$tc'Just3_bytes:
         I8[] [39,74,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.521669094 UTC

[section ""data" . GHC.Base.$tc'Just2_closure" {
     GHC.Base.$tc'Just2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Just3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.523275438 UTC

[section ""cstring" . GHC.Base.$tc'Nothing3_bytes" {
     GHC.Base.$tc'Nothing3_bytes:
         I8[] [39,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.524956025 UTC

[section ""data" . GHC.Base.$tc'Nothing2_closure" {
     GHC.Base.$tc'Nothing2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Nothing3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.5266021 UTC

[section ""cstring" . GHC.Base.$tcMaybe2_bytes" {
     GHC.Base.$tcMaybe2_bytes:
         I8[] [77,97,121,98,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.528272723 UTC

[section ""data" . GHC.Base.$tcMaybe1_closure" {
     GHC.Base.$tcMaybe1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMaybe2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.530339617 UTC

[section ""data" . $krep_r7Pr_closure" {
     $krep_r7Pr_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.532072513 UTC

[section ""data" . $krep1_r7Ps_closure" {
     $krep1_r7Ps_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.534216015 UTC

[section ""data" . $krep2_r7Pt_closure" {
     $krep2_r7Pt_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep1_r7Ps_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.535880988 UTC

[section ""data" . $krep3_r7Pu_closure" {
     $krep3_r7Pu_closure:
         const :_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.537620584 UTC

[section ""data" . $krep4_r7Pv_closure" {
     $krep4_r7Pv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.539291319 UTC

[section ""data" . $krep5_r7Pw_closure" {
     $krep5_r7Pw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.541008279 UTC

[section ""data" . $krep6_r7Px_closure" {
     $krep6_r7Px_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.542764322 UTC

[section ""data" . GHC.Base.$tcMonoid1_closure" {
     GHC.Base.$tcMonoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.54449648 UTC

[section ""data" . GHC.Base.$tcAlternative1_closure" {
     GHC.Base.$tcAlternative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.546616376 UTC

[section ""cstring" . GHC.Base.$trModule2_bytes" {
     GHC.Base.$trModule2_bytes:
         I8[] [71,72,67,46,66,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.548290608 UTC

[section ""data" . GHC.Base.$trModule1_closure" {
     GHC.Base.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.550061387 UTC

[section ""cstring" . GHC.Base.$trModule4_bytes" {
     GHC.Base.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.551809713 UTC

[section ""data" . GHC.Base.$trModule3_closure" {
     GHC.Base.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.55410576 UTC

[section ""data" . GHC.Base.$trModule_closure" {
     GHC.Base.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Base.$trModule3_closure+1;
         const GHC.Base.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.555751345 UTC

[section ""data" . GHC.Base.$tcMaybe_closure" {
     GHC.Base.$tcMaybe_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMaybe1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 625655543500963593;
         const 6391758309165051762;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.557649987 UTC

[section ""data" . GHC.Base.$tc'Nothing1_closure" {
     GHC.Base.$tc'Nothing1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.559753011 UTC

[section ""data" . GHC.Base.$tc'Just1_closure" {
     GHC.Base.$tc'Just1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.562082334 UTC

[section ""data" . GHC.Base.$tc'Nothing_closure" {
     GHC.Base.$tc'Nothing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Nothing2_closure+1;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 14633289528184412192;
         const 12773126156421542470;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.563912303 UTC

[section ""data" . GHC.Base.$tc'Just_closure" {
     GHC.Base.$tc'Just_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Just2_closure+1;
         const GHC.Base.$tc'Just1_closure+4;
         const 5794512144280699493;
         const 9434423460978218117;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.565742531 UTC

[section ""data" . GHC.Base.$tcFunctor_closure" {
     GHC.Base.$tcFunctor_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcFunctor1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 211182333006544237;
         const 5556320544348084514;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.567610228 UTC

[section ""data" . GHC.Base.$tcApplicative_closure" {
     GHC.Base.$tcApplicative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcApplicative1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 12705055220831243597;
         const 2963353171490466073;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.569370839 UTC

[section ""data" . GHC.Base.$tcAlternative_closure" {
     GHC.Base.$tcAlternative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcAlternative2_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 1073491102990665358;
         const 14320772755704808948;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.571202272 UTC

[section ""data" . GHC.Base.$tcNonEmpty_closure" {
     GHC.Base.$tcNonEmpty_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcNonEmpty1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13207016872645468285;
         const 3455542966739695982;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.574082891 UTC

[section ""data" . $krep7_r7Py_closure" {
     $krep7_r7Py_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcNonEmpty_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.575743573 UTC

[section ""data" . $krep8_r7Pz_closure" {
     $krep8_r7Pz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep7_r7Py_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.577471212 UTC

[section ""data" . GHC.Base.$tc':|1_closure" {
     GHC.Base.$tc':|1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep8_r7Pz_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.579143839 UTC

[section ""data" . GHC.Base.$tc':|_closure" {
     GHC.Base.$tc':|_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc':|2_closure+1;
         const GHC.Base.$tc':|1_closure+4;
         const 9440832435183810765;
         const 3053237465234607583;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.580961865 UTC

[section ""data" . GHC.Base.$tcSemigroup_closure" {
     GHC.Base.$tcSemigroup_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcSemigroup1_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 16195352186364298277;
         const 3285685594139281062;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.582749657 UTC

[section ""data" . $krep9_r7PA_closure" {
     $krep9_r7PA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcSemigroup_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.584464565 UTC

[section ""data" . GHC.Base.$tcMonoid_closure" {
     GHC.Base.$tcMonoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonoid2_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 13838560045895743776;
         const 1291018260833769143;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.586732528 UTC

[section ""data" . $krep10_r7PB_closure" {
     $krep10_r7PB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMonoid_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.588465313 UTC

[section ""data" . $krep11_r7PC_closure" {
     $krep11_r7PC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r7Pw_closure+4;
         const $krep10_r7PB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.59035977 UTC

[section ""data" . $krep12_r7PD_closure" {
     $krep12_r7PD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r7Pt_closure+4;
         const $krep11_r7PC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.592018286 UTC

[section ""data" . $krep13_r7PE_closure" {
     $krep13_r7PE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep12_r7PD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.593740805 UTC

[section ""data" . GHC.Base.$tc'C:Monoid1_closure" {
     GHC.Base.$tc'C:Monoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r7PA_closure+1;
         const $krep13_r7PE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.59538066 UTC

[section ""data" . GHC.Base.$tc'C:Monoid_closure" {
     GHC.Base.$tc'C:Monoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'C:Monoid2_closure+1;
         const GHC.Base.$tc'C:Monoid1_closure+4;
         const 16099296089107510343;
         const 5895832073319104984;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.597145124 UTC

[section ""data" . GHC.Base.$tcMonad_closure" {
     GHC.Base.$tcMonad_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonad1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 3168880480603756299;
         const 8398240611646296094;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.599034619 UTC

[section ""data" . GHC.Base.$tcMonadPlus_closure" {
     GHC.Base.$tcMonadPlus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonadPlus1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 14115673251620372550;
         const 14155357326069389390;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.6013099 UTC

[section ""data" . GHC.Base.$tcOpaque_closure" {
     GHC.Base.$tcOpaque_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcOpaque1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9339725405829241186;
         const 15550233501624900571;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.603035037 UTC

[section ""data" . $krep14_r7PF_closure" {
     $krep14_r7PF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcOpaque_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.604809559 UTC

[section ""data" . GHC.Base.$tc'O1_closure" {
     GHC.Base.$tc'O1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep14_r7PF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.606950672 UTC

[section ""data" . GHC.Base.$tc'O_closure" {
     GHC.Base.$tc'O_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'O2_closure+1;
         const GHC.Base.$tc'O1_closure+4;
         const 12551274612394834805;
         const 13000664474148134329;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.609444289 UTC

[section ""data" . GHC.Base.quotRemInt_closure" {
     GHC.Base.quotRemInt_closure:
         const GHC.Base.quotRemInt_info;
 },
 GHC.Base.quotRemInt_entry() //  [R2, R3]
         { info_tbl: [(cdsP,
                       label: GHC.Base.quotRemInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdt0; else goto cdt1;
       cdt0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotRemInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdt1: // global
           I64[Sp - 16] = block_cdsM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udt7; else goto cdsN;
       udt7: // global
           call _cdsM(R1) args: 0, res: 0, upd: 0;
       cdsN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsM() //  [R1]
         { info_tbl: [(cdsM,
                       label: block_cdsM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsM: // global
           I64[Sp] = block_cdsS_info;
           _s7US::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7US::I64;
           if (R1 & 7 != 0) goto udt6; else goto cdsT;
       udt6: // global
           call _cdsS(R1) args: 0, res: 0, upd: 0;
       cdsT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsS() //  [R1]
         { info_tbl: [(cdsS,
                       label: block_cdsS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdt5; else goto cdt4;
       cdt5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdt4: // global
           (_s7UW::I64, _s7UX::I64) = call MO_S_QuotRem W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7UX::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s7UW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.618415407 UTC

[section ""data" . GHC.Base.modInt_closure" {
     GHC.Base.modInt_closure:
         const GHC.Base.modInt_info;
 },
 GHC.Base.modInt_entry() //  [R2, R3]
         { info_tbl: [(cdtv,
                       label: GHC.Base.modInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtI; else goto cdtJ;
       cdtI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.modInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtJ: // global
           I64[Sp - 16] = block_cdts_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udtQ; else goto cdtt;
       udtQ: // global
           call _cdts(R1) args: 0, res: 0, upd: 0;
       cdtt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdts() //  [R1]
         { info_tbl: [(cdts,
                       label: block_cdts_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdts: // global
           I64[Sp] = block_cdty_info;
           _s7V3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7V3::I64;
           if (R1 & 7 != 0) goto udtP; else goto cdtz;
       udtP: // global
           call _cdty(R1) args: 0, res: 0, upd: 0;
       cdtz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdty() //  [R1]
         { info_tbl: [(cdty,
                       label: block_cdty_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdty: // global
           _s7V3::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cdtD_info;
           R3 = I64[R1 + 7];
           R2 = _s7V3::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdtD() //  [R1]
         { info_tbl: [(cdtD,
                       label: block_cdtD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdtD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdtO; else goto cdtN;
       cdtO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdtN: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.627707414 UTC

[section ""data" . GHC.Base.divInt_closure" {
     GHC.Base.divInt_closure:
         const GHC.Base.divInt_info;
 },
 GHC.Base.divInt_entry() //  [R2, R3]
         { info_tbl: [(cduf,
                       label: GHC.Base.divInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdus; else goto cdut;
       cdus: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdut: // global
           I64[Sp - 16] = block_cduc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uduA; else goto cdud;
       uduA: // global
           call _cduc(R1) args: 0, res: 0, upd: 0;
       cdud: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduc() //  [R1]
         { info_tbl: [(cduc,
                       label: block_cduc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduc: // global
           I64[Sp] = block_cdui_info;
           _s7Va::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Va::I64;
           if (R1 & 7 != 0) goto uduz; else goto cduj;
       uduz: // global
           call _cdui(R1) args: 0, res: 0, upd: 0;
       cduj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdui() //  [R1]
         { info_tbl: [(cdui,
                       label: block_cdui_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdui: // global
           _s7Va::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cdun_info;
           R3 = I64[R1 + 7];
           R2 = _s7Va::I64;
           Sp = Sp + 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdun() //  [R1]
         { info_tbl: [(cdun,
                       label: block_cdun_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdun: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduy; else goto cdux;
       cduy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdux: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.637743406 UTC

[section ""data" . GHC.Base.remInt_closure" {
     GHC.Base.remInt_closure:
         const GHC.Base.remInt_info;
 },
 GHC.Base.remInt_entry() //  [R2, R3]
         { info_tbl: [(cduZ,
                       label: GHC.Base.remInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvb; else goto cdvc;
       cdvb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.remInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvc: // global
           I64[Sp - 16] = block_cduW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvi; else goto cduX;
       udvi: // global
           call _cduW(R1) args: 0, res: 0, upd: 0;
       cduX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cduW() //  [R1]
         { info_tbl: [(cduW,
                       label: block_cduW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cduW: // global
           I64[Sp] = block_cdv2_info;
           _s7Vh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Vh::I64;
           if (R1 & 7 != 0) goto udvh; else goto cdv3;
       udvh: // global
           call _cdv2(R1) args: 0, res: 0, upd: 0;
       cdv3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdv2() //  [R1]
         { info_tbl: [(cdv2,
                       label: block_cdv2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdv2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvg; else goto cdvf;
       cdvg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvf: // global
           _s7Vk::I64 = %MO_S_Rem_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Vk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.646342379 UTC

[section ""data" . GHC.Base.quotInt_closure" {
     GHC.Base.quotInt_closure:
         const GHC.Base.quotInt_info;
 },
 GHC.Base.quotInt_entry() //  [R2, R3]
         { info_tbl: [(cdvE,
                       label: GHC.Base.quotInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQ; else goto cdvR;
       cdvQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvR: // global
           I64[Sp - 16] = block_cdvB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvX; else goto cdvC;
       udvX: // global
           call _cdvB(R1) args: 0, res: 0, upd: 0;
       cdvC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvB() //  [R1]
         { info_tbl: [(cdvB,
                       label: block_cdvB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvB: // global
           I64[Sp] = block_cdvH_info;
           _s7Vo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Vo::I64;
           if (R1 & 7 != 0) goto udvW; else goto cdvI;
       udvW: // global
           call _cdvH(R1) args: 0, res: 0, upd: 0;
       cdvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdvH() //  [R1]
         { info_tbl: [(cdvH,
                       label: block_cdvH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdvH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvV; else goto cdvU;
       cdvV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvU: // global
           _s7Vr::I64 = %MO_S_Quot_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Vr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.654062771 UTC

[section ""data" . GHC.Base.getTag_closure" {
     GHC.Base.getTag_closure:
         const GHC.Base.getTag_info;
 },
 GHC.Base.getTag_entry() //  [R2]
         { info_tbl: [(cdwj,
                       label: GHC.Base.getTag_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdwj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdwk; else goto cdwl;
       cdwk: // global
           R2 = R2;
           R1 = GHC.Base.getTag_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdwl: // global
           I64[Sp - 8] = block_cdwg_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdwg() //  [R1]
         { info_tbl: [(cdwg,
                       label: block_cdwg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdwg: // global
           R1 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.659796596 UTC

[section ""data" . GHC.Base.$fMonadIO1_closure" {
     GHC.Base.$fMonadIO1_closure:
         const GHC.Base.$fMonadIO1_info;
 },
 GHC.Base.$fMonadIO1_entry() //  [R2, R3]
         { info_tbl: [(cdwF,
                       label: GHC.Base.$fMonadIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdwF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdwG; else goto cdwH;
       cdwG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdwH: // global
           I64[Sp - 16] = block_cdwD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdwD() //  [R1]
         { info_tbl: [(cdwD,
                       label: block_cdwD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdwD: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.665031572 UTC

[section ""data" . GHC.Base.bindIO_closure" {
     GHC.Base.bindIO_closure:
         const GHC.Base.bindIO_info;
 },
 GHC.Base.bindIO_entry() //  [R2, R3]
         { info_tbl: [(cdwV,
                       label: GHC.Base.bindIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdwV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fMonadIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.668714515 UTC

[section ""data" . GHC.Base.$fApplicativeIO2_closure" {
     GHC.Base.$fApplicativeIO2_closure:
         const GHC.Base.$fApplicativeIO2_info;
 },
 GHC.Base.$fApplicativeIO2_entry() //  [R2, R3]
         { info_tbl: [(cdx8,
                       label: GHC.Base.$fApplicativeIO2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdx8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdx9; else goto cdxa;
       cdx9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdxa: // global
           I64[Sp - 16] = block_cdx6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdx6() //  []
         { info_tbl: [(cdx6,
                       label: block_cdx6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdx6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.674322503 UTC

[section ""data" . GHC.Base.thenIO_closure" {
     GHC.Base.thenIO_closure:
         const GHC.Base.thenIO_info;
 },
 GHC.Base.thenIO_entry() //  [R2, R3]
         { info_tbl: [(cdxo,
                       label: GHC.Base.thenIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdxo: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeIO2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.677595798 UTC

[section ""data" . GHC.Base.unIO1_closure" {
     GHC.Base.unIO1_closure:
         const GHC.Base.unIO1_info;
 },
 GHC.Base.unIO1_entry() //  [R2]
         { info_tbl: [(cdxz,
                       label: GHC.Base.unIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdxz: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.680680868 UTC

[section ""data" . GHC.Base.unIO_closure" {
     GHC.Base.unIO_closure:
         const GHC.Base.unIO_info;
 },
 GHC.Base.unIO_entry() //  [R2]
         { info_tbl: [(cdxK,
                       label: GHC.Base.unIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdxK: // global
           R2 = R2;
           call GHC.Base.unIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.683910235 UTC

[section ""data" . GHC.Base.$fApplicativeIO4_closure" {
     GHC.Base.$fApplicativeIO4_closure:
         const GHC.Base.$fApplicativeIO4_info;
 },
 GHC.Base.$fApplicativeIO4_entry() //  [R2]
         { info_tbl: [(cdxV,
                       label: GHC.Base.$fApplicativeIO4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdxV: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.687675503 UTC

[section ""data" . GHC.Base.returnIO_closure" {
     GHC.Base.returnIO_closure:
         const GHC.Base.returnIO_info;
 },
 GHC.Base.returnIO_entry() //  [R2]
         { info_tbl: [(cdy7,
                       label: GHC.Base.returnIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdy7: // global
           R2 = R2;
           call GHC.Base.$fApplicativeIO4_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.691387021 UTC

[section ""data" . GHC.Base.$fApplicativeIO3_closure" {
     GHC.Base.$fApplicativeIO3_closure:
         const GHC.Base.$fApplicativeIO3_info;
 },
 GHC.Base.$fApplicativeIO3_entry() //  [R2, R3]
         { info_tbl: [(cdyn,
                       label: GHC.Base.$fApplicativeIO3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdyo; else goto cdyp;
       cdyo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyp: // global
           I64[Sp - 16] = block_cdyi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyi() //  [R1]
         { info_tbl: [(cdyi,
                       label: block_cdyi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyi: // global
           I64[Sp] = block_cdyk_info;
           _s7VN::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7VN::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyk() //  [R1]
         { info_tbl: [(cdyk,
                       label: block_cdyk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdyt; else goto cdys;
       cdyt: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdys: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.698418777 UTC

[section ""data" . GHC.Base.liftA_$sliftA1_closure" {
     GHC.Base.liftA_$sliftA1_closure:
         const GHC.Base.liftA_$sliftA1_info;
 },
 GHC.Base.liftA_$sliftA1_entry() //  [R2, R3]
         { info_tbl: [(cdyL,
                       label: GHC.Base.liftA_$sliftA1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyL: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.702361058 UTC

[section ""data" . GHC.Base.ap1_closure" {
     GHC.Base.ap1_closure:
         const GHC.Base.ap1_info;
 },
 GHC.Base.ap1_entry() //  [R2, R3]
         { info_tbl: [(cdz1,
                       label: GHC.Base.ap1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdz1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdz2; else goto cdz3;
       cdz2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz3: // global
           I64[Sp - 16] = block_cdyW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyW() //  [R1]
         { info_tbl: [(cdyW,
                       label: block_cdyW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyW: // global
           I64[Sp] = block_cdyY_info;
           _s7VX::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7VX::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdyY() //  [R1]
         { info_tbl: [(cdyY,
                       label: block_cdyY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdyY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdz7; else goto cdz6;
       cdz7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdz6: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.709629898 UTC

[section ""data" . GHC.Base.ap_$sap1_closure" {
     GHC.Base.ap_$sap1_closure:
         const GHC.Base.ap_$sap1_info;
 },
 GHC.Base.ap_$sap1_entry() //  [R2, R3]
         { info_tbl: [(cdzp,
                       label: GHC.Base.ap_$sap1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzp: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.ap1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.713304847 UTC

[section ""data" . GHC.Base.ap_closure" {
     GHC.Base.ap_closure:
         const GHC.Base.ap_info;
 },
 sat_s7W8_entry() //  [R1, R2]
         { info_tbl: [(cdzL,
                       label: sat_s7W8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzL: // global
           _s7W6::P64 = R2;
           _s7W8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzM; else goto cdzN;
       cdzN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzP; else goto cdzO;
       cdzP: // global
           HpAlloc = 32;
           goto cdzM;
       cdzM: // global
           R2 = _s7W6::P64;
           R1 = _s7W8::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzO: // global
           _s7W2::P64 = P64[_s7W8::P64 + 7];
           _s7W5::P64 = P64[_s7W8::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s7W5::P64;
           P64[Hp] = _s7W6::P64;
           R2 = _s7W2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7W9_entry() //  [R1, R2]
         { info_tbl: [(cdzQ,
                       label: sat_s7W9_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzQ: // global
           _s7W5::P64 = R2;
           _s7W9::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzR; else goto cdzS;
       cdzS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzU; else goto cdzT;
       cdzU: // global
           HpAlloc = 24;
           goto cdzR;
       cdzR: // global
           R2 = _s7W5::P64;
           R1 = _s7W9::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzT: // global
           _s7W2::P64 = P64[_s7W9::P64 + 7];
           _s7W4::P64 = P64[_s7W9::P64 + 15];
           I64[Hp - 16] = sat_s7W8_info;
           P64[Hp - 8] = _s7W2::P64;
           P64[Hp] = _s7W5::P64;
           R2 = _s7W2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7W4::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.ap_entry() //  [R2, R3, R4]
         { info_tbl: [(cdzV,
                       label: GHC.Base.ap_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdzV: // global
           _s7W4::P64 = R4;
           _s7W3::P64 = R3;
           _s7W2::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzW; else goto cdzX;
       cdzX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzZ; else goto cdzY;
       cdzZ: // global
           HpAlloc = 24;
           goto cdzW;
       cdzW: // global
           R4 = _s7W4::P64;
           R3 = _s7W3::P64;
           R2 = _s7W2::P64;
           R1 = GHC.Base.ap_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzY: // global
           I64[Hp - 16] = sat_s7W9_info;
           P64[Hp - 8] = _s7W2::P64;
           P64[Hp] = _s7W4::P64;
           R2 = _s7W2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7W3::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.723283856 UTC

[section ""data" . GHC.Base.liftM1_closure" {
     GHC.Base.liftM1_closure:
         const GHC.Base.liftM1_info;
 },
 GHC.Base.liftM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdAp,
                       label: GHC.Base.liftM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAq; else goto cdAr;
       cdAq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAr: // global
           I64[Sp - 24] = block_cdAk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAk() //  [R1]
         { info_tbl: [(cdAk,
                       label: block_cdAk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAk: // global
           I64[Sp] = block_cdAm_info;
           _s7Wg::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Wg::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdAm() //  [R1]
         { info_tbl: [(cdAm,
                       label: block_cdAm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAv; else goto cdAu;
       cdAv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAu: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.730892554 UTC

[section ""data" . GHC.Base.liftM2_$sliftM1_closure" {
     GHC.Base.liftM2_$sliftM1_closure:
         const GHC.Base.liftM2_$sliftM1_info;
 },
 GHC.Base.liftM2_$sliftM1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdAO,
                       label: GHC.Base.liftM2_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdAO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.735083901 UTC

[section ""data" . GHC.Base.liftM2_closure" {
     GHC.Base.liftM2_closure:
         const GHC.Base.liftM2_info;
 },
 sat_s7Ws_entry() //  [R1, R2]
         { info_tbl: [(cdBa,
                       label: sat_s7Ws_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBa: // global
           _s7Wq::P64 = R2;
           _s7Ws::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBb; else goto cdBc;
       cdBc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBe; else goto cdBd;
       cdBe: // global
           HpAlloc = 40;
           goto cdBb;
       cdBb: // global
           R2 = _s7Wq::P64;
           R1 = _s7Ws::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBd: // global
           _s7Wl::P64 = P64[_s7Ws::P64 + 7];
           _s7Wm::P64 = P64[_s7Ws::P64 + 15];
           _s7Wp::P64 = P64[_s7Ws::P64 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _s7Wm::P64;
           P64[Hp - 8] = _s7Wp::P64;
           P64[Hp] = _s7Wq::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7Wt_entry() //  [R1, R2]
         { info_tbl: [(cdBf,
                       label: sat_s7Wt_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBf: // global
           _s7Wp::P64 = R2;
           _s7Wt::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBg; else goto cdBh;
       cdBh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBj; else goto cdBi;
       cdBj: // global
           HpAlloc = 32;
           goto cdBg;
       cdBg: // global
           R2 = _s7Wp::P64;
           R1 = _s7Wt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBi: // global
           _s7Wl::P64 = P64[_s7Wt::P64 + 7];
           _s7Wm::P64 = P64[_s7Wt::P64 + 15];
           _s7Wo::P64 = P64[_s7Wt::P64 + 23];
           I64[Hp - 24] = sat_s7Ws_info;
           P64[Hp - 16] = _s7Wl::P64;
           P64[Hp - 8] = _s7Wm::P64;
           P64[Hp] = _s7Wp::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Wo::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdBk,
                       label: GHC.Base.liftM2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBk: // global
           _s7Wo::P64 = R5;
           _s7Wn::P64 = R4;
           _s7Wm::P64 = R3;
           _s7Wl::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBl; else goto cdBm;
       cdBm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBo; else goto cdBn;
       cdBo: // global
           HpAlloc = 32;
           goto cdBl;
       cdBl: // global
           R5 = _s7Wo::P64;
           R4 = _s7Wn::P64;
           R3 = _s7Wm::P64;
           R2 = _s7Wl::P64;
           R1 = GHC.Base.liftM2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBn: // global
           I64[Hp - 24] = sat_s7Wt_info;
           P64[Hp - 16] = _s7Wl::P64;
           P64[Hp - 8] = _s7Wm::P64;
           P64[Hp] = _s7Wo::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Wn::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.743974174 UTC

[section ""data" . $cliftA2_r7PG_closure" {
     $cliftA2_r7PG_closure:
         const $cliftA2_r7PG_info;
 },
 $cliftA2_r7PG_entry() //  [R2, R3, R4]
         { info_tbl: [(cdBO,
                       label: $cliftA2_r7PG_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBP; else goto cdBQ;
       cdBP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBQ: // global
           I64[Sp - 24] = block_cdBJ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBJ() //  [R1]
         { info_tbl: [(cdBJ,
                       label: block_cdBJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBJ: // global
           I64[Sp] = block_cdBL_info;
           _s7WA::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WA::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdBL() //  [R1]
         { info_tbl: [(cdBL,
                       label: block_cdBL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdBL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBU; else goto cdBT;
       cdBU: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBT: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.751385214 UTC

[section ""data" . GHC.Base.$fApplicativeIO_$cliftA2_closure" {
     GHC.Base.$fApplicativeIO_$cliftA2_closure:
         const GHC.Base.$fApplicativeIO_$cliftA2_info;
 },
 GHC.Base.$fApplicativeIO_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdCd,
                       label: GHC.Base.$fApplicativeIO_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.75499132 UTC

[section ""data" . GHC.Base.liftA1_closure" {
     GHC.Base.liftA1_closure:
         const GHC.Base.liftA1_info;
 },
 GHC.Base.liftA1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCv,
                       label: GHC.Base.liftA1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCw; else goto cdCx;
       cdCw: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCx: // global
           I64[Sp - 32] = block_cdCo_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCo() //  [R1]
         { info_tbl: [(cdCo,
                       label: block_cdCo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCo: // global
           I64[Sp] = block_cdCq_info;
           _s7WM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WM::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCq() //  [R1]
         { info_tbl: [(cdCq,
                       label: block_cdCq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCq: // global
           I64[Sp] = block_cdCs_info;
           _s7WP::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7WP::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdCs() //  [R1]
         { info_tbl: [(cdCs,
                       label: block_cdCs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdCC; else goto cdCB;
       cdCC: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCB: // global
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.76438779 UTC

[section ""data" . GHC.Base.liftA3_$sliftA1_closure" {
     GHC.Base.liftA3_$sliftA1_closure:
         const GHC.Base.liftA3_$sliftA1_info;
 },
 GHC.Base.liftA3_$sliftA1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdCZ,
                       label: GHC.Base.liftA3_$sliftA1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdCZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.768454719 UTC

[section ""data" . GHC.Base.$fSemigroupIO2_closure" {
     GHC.Base.$fSemigroupIO2_closure:
         const GHC.Base.$fSemigroupIO2_info;
 },
 sat_s7X4_entry() //  [R1]
         { info_tbl: [(cdDi,
                       label: sat_s7X4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdDj; else goto cdDk;
       cdDj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupIO2_entry() //  [R2, R3, R4]
         { info_tbl: [(cdDl,
                       label: GHC.Base.$fSemigroupIO2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdDm; else goto cdDn;
       cdDm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDn: // global
           I64[Sp - 24] = block_cdDa_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDa() //  [R1]
         { info_tbl: [(cdDa,
                       label: block_cdDa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDa: // global
           I64[Sp] = block_cdDc_info;
           _s7X0::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7X0::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDc() //  [R1]
         { info_tbl: [(cdDc,
                       label: block_cdDc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDr; else goto cdDq;
       cdDr: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDq: // global
           I64[Hp - 32] = sat_s7X4_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.778558295 UTC

[section ""data" . GHC.Base.$w$csconcat4_closure" {
     GHC.Base.$w$csconcat4_closure:
         const GHC.Base.$w$csconcat4_info;
 },
 sat_s7Xm_entry() //  [R1]
         { info_tbl: [(cdE9,
                       label: sat_s7Xm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdEa; else goto cdEb;
       cdEa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s7X9_entry() //  [R1, R2, R3]
         { info_tbl: [(cdEg,
                       label: go_s7X9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdEh; else goto cdEi;
       cdEh: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEi: // global
           I64[Sp - 32] = block_cdDV_info;
           _s7X9::P64 = R1;
           _s7X5::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 24] = _s7X5::P64;
           P64[Sp - 16] = _s7X9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udEq; else goto cdDW;
       udEq: // global
           call _cdDV(R1) args: 0, res: 0, upd: 0;
       cdDW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdDV() //  [R1]
         { info_tbl: [(cdDV,
                       label: block_cdDV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdDV: // global
           _s7Xa::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdEd; else goto cdEe;
       cdEd: // global
           R1 = _s7Xa::P64;
           Sp = Sp + 32;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cdEe: // global
           I64[Sp - 8] = block_cdE1_info;
           _s7Xe::P64 = P64[R1 + 6];
           _s7Xf::P64 = P64[R1 + 14];
           R1 = _s7Xa::P64;
           P64[Sp] = _s7Xf::P64;
           P64[Sp + 24] = _s7Xe::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdE1() //  [R1]
         { info_tbl: [(cdE1,
                       label: block_cdE1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE1: // global
           _s7Xf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdE3_info;
           R3 = _s7Xf::P64;
           R2 = P64[Sp + 32];
           _s7Xi::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 32] = _s7Xi::P64;
           Sp = Sp + 8;
           call go_s7X9_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdE3() //  [R1]
         { info_tbl: [(cdE3,
                       label: block_cdE3_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdE3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdEp; else goto cdEo;
       cdEp: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdEo: // global
           I64[Hp - 32] = sat_s7Xm_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat4_entry() //  [R2, R3, R4]
         { info_tbl: [(cdEr,
                       label: GHC.Base.$w$csconcat4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdEr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdEv; else goto cdEu;
       cdEv: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEu: // global
           I64[Hp - 8] = go_s7X9_info;
           P64[Hp] = R2;
           _s7X6::P64 = R3;
           R3 = R4;
           R2 = _s7X6::P64;
           R1 = Hp - 5;
           call go_s7X9_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.792832268 UTC

[section ""data" . GHC.Base.$fSemigroupIO1_closure" {
     GHC.Base.$fSemigroupIO1_closure:
         const GHC.Base.$fSemigroupIO1_info;
 },
 GHC.Base.$fSemigroupIO1_entry() //  [R2, R3]
         { info_tbl: [(cdF6,
                       label: GHC.Base.$fSemigroupIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdF7; else goto cdF8;
       cdF7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdF8: // global
           I64[Sp - 16] = block_cdF3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udFc; else goto cdF4;
       udFc: // global
           call _cdF3(R1) args: 0, res: 0, upd: 0;
       cdF4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdF3() //  [R1]
         { info_tbl: [(cdF3,
                       label: block_cdF3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdF3: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat4_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.799381892 UTC

[section ""data" . GHC.Base.$fSemigroupIO_closure" {
     GHC.Base.$fSemigroupIO_closure:
         const GHC.Base.$fSemigroupIO_info;
         const 0;
 },
 sat_s7Xw_entry() //  [R1, R2]
         { info_tbl: [(cdFv,
                       label: sat_s7Xw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFv: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupIO_$cstimes_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Xv_entry() //  [R1, R2]
         { info_tbl: [(cdFD,
                       label: sat_s7Xv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFD: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroupIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Xu_entry() //  [R1, R2, R3]
         { info_tbl: [(cdFL,
                       label: sat_s7Xu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroupIO2_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroupIO_entry() //  [R2]
         { info_tbl: [(cdFP,
                       label: GHC.Base.$fSemigroupIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdFP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdFT; else goto cdFS;
       cdFT: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFS: // global
           I64[Hp - 72] = sat_s7Xw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s7Xv_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s7Xu_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 54;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.$fSemigroupIO_$cstimes_closure" {
     GHC.Base.$fSemigroupIO_$cstimes_closure:
         const GHC.Base.$fSemigroupIO_$cstimes_info;
         const 0;
 },
 sat_s7Xz_entry() //  [R1]
         { info_tbl: [(cdG2,
                       label: sat_s7Xz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdG3; else goto cdG4;
       cdG3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupIO_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(cdG5,
                       label: GHC.Base.$fSemigroupIO_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdG5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdG9; else goto cdG8;
       cdG9: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG8: // global
           I64[Hp - 16] = sat_s7Xz_info;
           P64[Hp] = R2;
           _s7Xy::P64 = R3;
           R3 = Hp - 16;
           R2 = _s7Xy::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.813777703 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cp1Monoid_closure" {
     GHC.Base.$fMonoidIO_$cp1Monoid_closure:
         const GHC.Base.$fMonoidIO_$cp1Monoid_info;
         const 0;
 },
 sat_s7XB_entry() //  [R1]
         { info_tbl: [(cdGH,
                       label: sat_s7XB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGI; else goto cdGJ;
       cdGI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidIO_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cdGK,
                       label: GHC.Base.$fMonoidIO_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdGK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGO; else goto cdGN;
       cdGO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGN: // global
           I64[Hp - 16] = sat_s7XB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.820515633 UTC

[section ""data" . $cmappend_r7PH_closure" {
     $cmappend_r7PH_closure:
         const $cmappend_r7PH_info;
 },
 sat_s7XN_entry() //  [R1]
         { info_tbl: [(cdHb,
                       label: sat_s7XN_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdHc; else goto cdHd;
       cdHc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdH9_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdH9() //  [R1]
         { info_tbl: [(cdH9,
                       label: block_cdH9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH9: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $cmappend_r7PH_entry() //  [R2, R3, R4]
         { info_tbl: [(cdHh,
                       label: $cmappend_r7PH_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHi; else goto cdHj;
       cdHi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHj: // global
           I64[Sp - 24] = block_cdH1_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdH1() //  [R1]
         { info_tbl: [(cdH1,
                       label: block_cdH1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH1: // global
           I64[Sp] = block_cdH3_info;
           _s7XI::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7XI::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdH3() //  [R1]
         { info_tbl: [(cdH3,
                       label: block_cdH3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdH3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdHn; else goto cdHm;
       cdHn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHm: // global
           I64[Hp - 32] = sat_s7XN_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.831329339 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cmappend_closure" {
     GHC.Base.$fMonoidIO_$cmappend_closure:
         const GHC.Base.$fMonoidIO_$cmappend_info;
 },
 GHC.Base.$fMonoidIO_$cmappend_entry() //  [R2, R3, R4]
         { info_tbl: [(cdHP,
                       label: GHC.Base.$fMonoidIO_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdHP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.835023503 UTC

[section ""data" . GHC.Base.$fAlternativeIO1_closure" {
     GHC.Base.$fAlternativeIO1_closure:
         const GHC.Base.$fAlternativeIO1_info;
 },
 GHC.Base.$fAlternativeIO1_entry() //  []
         { info_tbl: [(cdI0,
                       label: GHC.Base.$fAlternativeIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdI0: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.8388967 UTC

[section ""data" . GHC.Base.$fAlternativeIO2_closure" {
     GHC.Base.$fAlternativeIO2_closure:
         const GHC.Base.$fAlternativeIO2_info;
         const 0;
 },
 some_v_s7XR_entry() //  [R1]
         { info_tbl: [(cdIm,
                       label: some_v_s7XR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdIm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdIn; else goto cdIo;
       cdIn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdIo: // global
           I64[Sp - 16] = block_cdIh_info;
           _s7XR::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s7XR::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdIh() //  [R1]
         { info_tbl: [(cdIh,
                       label: block_cdIh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdIh: // global
           I64[Sp] = block_cdIj_info;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = P64[Sp + 8];
           _s7XV::P64 = R1;
           R1 = GHC.IO.mplusIO_closure;
           P64[Sp + 8] = _s7XV::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdIj() //  [R1]
         { info_tbl: [(cdIj,
                       label: block_cdIj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdIj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdIs; else goto cdIr;
       cdIs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdIr: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fAlternativeIO2_entry() //  [R2]
         { info_tbl: [(cdIt,
                       label: GHC.Base.$fAlternativeIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdIt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdIx; else goto cdIw;
       cdIx: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdIw: // global
           I64[Hp - 8] = some_v_s7XR_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_s7XR_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.848901727 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cmany_closure" {
     GHC.Base.$fAlternativeIO_$cmany_closure:
         const GHC.Base.$fAlternativeIO_$cmany_info;
         const 0;
 },
 sat_s7Ya_entry() //  [R1]
         { info_tbl: [(cdJ6,
                       label: sat_s7Ya_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdJ7; else goto cdJ8;
       cdJ7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdJ8: // global
           I64[Sp - 16] = block_cdJ1_info;
           _s7Y1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s7Y1::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdJ1() //  [R1]
         { info_tbl: [(cdJ1,
                       label: block_cdJ1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJ1: // global
           I64[Sp] = block_cdJ3_info;
           _s7Y5::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Y5::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdJ3() //  [R1]
         { info_tbl: [(cdJ3,
                       label: block_cdJ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJ3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdJc; else goto cdJb;
       cdJc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdJb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v_s7Y1_entry() //  [R1]
         { info_tbl: [(cdJd,
                       label: many_v_s7Y1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJd: // global
           _s7Y1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdJe; else goto cdJf;
       cdJf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdJh; else goto cdJg;
       cdJh: // global
           HpAlloc = 24;
           goto cdJe;
       cdJe: // global
           R1 = _s7Y1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdJg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Y1::P64;
           _s7Y0::P64 = P64[_s7Y1::P64 + 16];
           I64[Hp - 16] = sat_s7Ya_info;
           P64[Hp - 8] = _s7Y0::P64;
           P64[Hp] = _s7Y1::P64;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = Hp - 15;
           R1 = GHC.IO.mplusIO_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeIO_$cmany_entry() //  [R2]
         { info_tbl: [(cdJi,
                       label: GHC.Base.$fAlternativeIO_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdJm; else goto cdJl;
       cdJm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdJl: // global
           I64[Hp - 16] = many_v_s7Y1_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.86024507 UTC

[section ""data" . GHC.Base.liftM9_closure" {
     GHC.Base.liftM9_closure:
         const GHC.Base.liftM9_info;
 },
 GHC.Base.liftM9_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdJW,
                       label: GHC.Base.liftM9_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdJX; else goto cdJY;
       cdJX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM9_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdJY: // global
           I64[Sp - 40] = block_cdJL_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdJL() //  [R1]
         { info_tbl: [(cdJL,
                       label: block_cdJL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJL: // global
           I64[Sp] = block_cdJN_info;
           _s7Yk::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Yk::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdJN() //  [R1]
         { info_tbl: [(cdJN,
                       label: block_cdJN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJN: // global
           I64[Sp] = block_cdJP_info;
           _s7Yn::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Yn::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdJP() //  [R1]
         { info_tbl: [(cdJP,
                       label: block_cdJP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJP: // global
           I64[Sp] = block_cdJR_info;
           _s7Yq::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Yq::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdJR() //  [R1]
         { info_tbl: [(cdJR,
                       label: block_cdJR_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJR: // global
           I64[Sp] = block_cdJT_info;
           _s7Yt::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s7Yt::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdJT() //  [R1]
         { info_tbl: [(cdJT,
                       label: block_cdJT_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdJT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdK5; else goto cdK4;
       cdK5: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdK4: // global
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R1 = Hp - 56;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.873782071 UTC

[section ""data" . GHC.Base.liftM5_$sliftM1_closure" {
     GHC.Base.liftM5_$sliftM1_closure:
         const GHC.Base.liftM5_$sliftM1_info;
 },
 GHC.Base.liftM5_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdKA,
                       label: GHC.Base.liftM5_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdKA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM9_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.878373516 UTC

[section ""data" . GHC.Base.liftM5_closure" {
     GHC.Base.liftM5_closure:
         const GHC.Base.liftM5_info;
 },
 GHC.Base.liftM5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdKI: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.liftM5_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2,
                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7YL_entry() //  [R1, R2]
         { info_tbl: [(cdLc,
                       label: sat_s7YL_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLc: // global
           _s7YJ::P64 = R2;
           _s7YL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLd; else goto cdLe;
       cdLe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLg; else goto cdLf;
       cdLg: // global
           HpAlloc = 64;
           goto cdLd;
       cdLd: // global
           R2 = _s7YJ::P64;
           R1 = _s7YL::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLf: // global
           _s7Yy::P64 = P64[_s7YL::P64 + 7];
           _s7Yz::P64 = P64[_s7YL::P64 + 15];
           _s7YF::P64 = P64[_s7YL::P64 + 23];
           _s7YG::P64 = P64[_s7YL::P64 + 31];
           _s7YH::P64 = P64[_s7YL::P64 + 39];
           _s7YI::P64 = P64[_s7YL::P64 + 47];
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = _s7Yz::P64;
           P64[Hp - 32] = _s7YF::P64;
           P64[Hp - 24] = _s7YG::P64;
           P64[Hp - 16] = _s7YH::P64;
           P64[Hp - 8] = _s7YI::P64;
           P64[Hp] = _s7YJ::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7YM_entry() //  [R1, R2]
         { info_tbl: [(cdLh,
                       label: sat_s7YM_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLh: // global
           _s7YI::P64 = R2;
           _s7YM::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLi; else goto cdLj;
       cdLj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLl; else goto cdLk;
       cdLl: // global
           HpAlloc = 56;
           goto cdLi;
       cdLi: // global
           R2 = _s7YI::P64;
           R1 = _s7YM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLk: // global
           _s7Yy::P64 = P64[_s7YM::P64 + 7];
           _s7Yz::P64 = P64[_s7YM::P64 + 15];
           _s7YE::P64 = P64[_s7YM::P64 + 23];
           _s7YF::P64 = P64[_s7YM::P64 + 31];
           _s7YG::P64 = P64[_s7YM::P64 + 39];
           _s7YH::P64 = P64[_s7YM::P64 + 47];
           I64[Hp - 48] = sat_s7YL_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YF::P64;
           P64[Hp - 16] = _s7YG::P64;
           P64[Hp - 8] = _s7YH::P64;
           P64[Hp] = _s7YI::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YE::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7YN_entry() //  [R1, R2]
         { info_tbl: [(cdLm,
                       label: sat_s7YN_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLm: // global
           _s7YH::P64 = R2;
           _s7YN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLn; else goto cdLo;
       cdLo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLq; else goto cdLp;
       cdLq: // global
           HpAlloc = 56;
           goto cdLn;
       cdLn: // global
           R2 = _s7YH::P64;
           R1 = _s7YN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLp: // global
           _s7Yy::P64 = P64[_s7YN::P64 + 7];
           _s7Yz::P64 = P64[_s7YN::P64 + 15];
           _s7YD::P64 = P64[_s7YN::P64 + 23];
           _s7YE::P64 = P64[_s7YN::P64 + 31];
           _s7YF::P64 = P64[_s7YN::P64 + 39];
           _s7YG::P64 = P64[_s7YN::P64 + 47];
           I64[Hp - 48] = sat_s7YM_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YE::P64;
           P64[Hp - 16] = _s7YF::P64;
           P64[Hp - 8] = _s7YG::P64;
           P64[Hp] = _s7YH::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YD::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7YO_entry() //  [R1, R2]
         { info_tbl: [(cdLr,
                       label: sat_s7YO_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLr: // global
           _s7YG::P64 = R2;
           _s7YO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLs; else goto cdLt;
       cdLt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLv; else goto cdLu;
       cdLv: // global
           HpAlloc = 56;
           goto cdLs;
       cdLs: // global
           R2 = _s7YG::P64;
           R1 = _s7YO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLu: // global
           _s7Yy::P64 = P64[_s7YO::P64 + 7];
           _s7Yz::P64 = P64[_s7YO::P64 + 15];
           _s7YC::P64 = P64[_s7YO::P64 + 23];
           _s7YD::P64 = P64[_s7YO::P64 + 31];
           _s7YE::P64 = P64[_s7YO::P64 + 39];
           _s7YF::P64 = P64[_s7YO::P64 + 47];
           I64[Hp - 48] = sat_s7YN_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YD::P64;
           P64[Hp - 16] = _s7YE::P64;
           P64[Hp - 8] = _s7YF::P64;
           P64[Hp] = _s7YG::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YC::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7YP_entry() //  [R1, R2]
         { info_tbl: [(cdLw,
                       label: sat_s7YP_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLw: // global
           _s7YF::P64 = R2;
           _s7YP::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLx; else goto cdLy;
       cdLy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLA; else goto cdLz;
       cdLA: // global
           HpAlloc = 56;
           goto cdLx;
       cdLx: // global
           R2 = _s7YF::P64;
           R1 = _s7YP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLz: // global
           _s7Yy::P64 = P64[_s7YP::P64 + 7];
           _s7Yz::P64 = P64[_s7YP::P64 + 15];
           _s7YB::P64 = P64[_s7YP::P64 + 23];
           _s7YC::P64 = P64[_s7YP::P64 + 31];
           _s7YD::P64 = P64[_s7YP::P64 + 39];
           _s7YE::P64 = P64[_s7YP::P64 + 47];
           I64[Hp - 48] = sat_s7YO_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YC::P64;
           P64[Hp - 16] = _s7YD::P64;
           P64[Hp - 8] = _s7YE::P64;
           P64[Hp] = _s7YF::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YB::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdLB,
                       label: GHC.Base.liftM5_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdLB: // global
           _s7YC::P64 = R6;
           _s7YB::P64 = R5;
           _s7YA::P64 = R4;
           _s7Yz::P64 = R3;
           _s7Yy::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdLC; else goto cdLD;
       cdLD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLF; else goto cdLE;
       cdLF: // global
           HpAlloc = 56;
           goto cdLC;
       cdLC: // global
           R1 = GHC.Base.liftM5_closure;
           P64[Sp - 40] = _s7Yy::P64;
           P64[Sp - 32] = _s7Yz::P64;
           P64[Sp - 24] = _s7YA::P64;
           P64[Sp - 16] = _s7YB::P64;
           P64[Sp - 8] = _s7YC::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdLE: // global
           I64[Hp - 48] = sat_s7YP_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YB::P64;
           P64[Hp - 16] = _s7YC::P64;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R2 = _s7Yy::P64;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s7YA::P64;
           P64[Sp + 8] = Hp - 47;
           Sp = Sp - 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.89825288 UTC

[section ""data" . GHC.Base.liftM8_closure" {
     GHC.Base.liftM8_closure:
         const GHC.Base.liftM8_info;
 },
 GHC.Base.liftM8_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdMs,
                       label: GHC.Base.liftM8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdMt; else goto cdMu;
       cdMt: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM8_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMu: // global
           I64[Sp - 40] = block_cdMj_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMj() //  [R1]
         { info_tbl: [(cdMj,
                       label: block_cdMj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMj: // global
           I64[Sp] = block_cdMl_info;
           _s7YY::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7YY::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMl() //  [R1]
         { info_tbl: [(cdMl,
                       label: block_cdMl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMl: // global
           I64[Sp] = block_cdMn_info;
           _s7Z1::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Z1::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMn() //  [R1]
         { info_tbl: [(cdMn,
                       label: block_cdMn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMn: // global
           I64[Sp] = block_cdMp_info;
           _s7Z4::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Z4::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdMp() //  [R1]
         { info_tbl: [(cdMp,
                       label: block_cdMp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdMp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdMA; else goto cdMz;
       cdMA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdMz: // global
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R1 = Hp - 48;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.909190302 UTC

[section ""data" . GHC.Base.liftM4_$sliftM1_closure" {
     GHC.Base.liftM4_$sliftM1_closure:
         const GHC.Base.liftM4_$sliftM1_info;
 },
 GHC.Base.liftM4_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdN1,
                       label: GHC.Base.liftM4_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdN1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM8_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.913775094 UTC

[section ""data" . GHC.Base.liftM4_closure" {
     GHC.Base.liftM4_closure:
         const GHC.Base.liftM4_info;
 },
 sat_s7Zk_entry() //  [R1, R2]
         { info_tbl: [(cdNx,
                       label: sat_s7Zk_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNx: // global
           _s7Zi::P64 = R2;
           _s7Zk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNy; else goto cdNz;
       cdNz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdNB; else goto cdNA;
       cdNB: // global
           HpAlloc = 56;
           goto cdNy;
       cdNy: // global
           R2 = _s7Zi::P64;
           R1 = _s7Zk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNA: // global
           _s7Z9::P64 = P64[_s7Zk::P64 + 7];
           _s7Za::P64 = P64[_s7Zk::P64 + 15];
           _s7Zf::P64 = P64[_s7Zk::P64 + 23];
           _s7Zg::P64 = P64[_s7Zk::P64 + 31];
           _s7Zh::P64 = P64[_s7Zk::P64 + 39];
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = _s7Za::P64;
           P64[Hp - 24] = _s7Zf::P64;
           P64[Hp - 16] = _s7Zg::P64;
           P64[Hp - 8] = _s7Zh::P64;
           P64[Hp] = _s7Zi::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7Zl_entry() //  [R1, R2]
         { info_tbl: [(cdNC,
                       label: sat_s7Zl_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNC: // global
           _s7Zh::P64 = R2;
           _s7Zl::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdND; else goto cdNE;
       cdNE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNG; else goto cdNF;
       cdNG: // global
           HpAlloc = 48;
           goto cdND;
       cdND: // global
           R2 = _s7Zh::P64;
           R1 = _s7Zl::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNF: // global
           _s7Z9::P64 = P64[_s7Zl::P64 + 7];
           _s7Za::P64 = P64[_s7Zl::P64 + 15];
           _s7Ze::P64 = P64[_s7Zl::P64 + 23];
           _s7Zf::P64 = P64[_s7Zl::P64 + 31];
           _s7Zg::P64 = P64[_s7Zl::P64 + 39];
           I64[Hp - 40] = sat_s7Zk_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zf::P64;
           P64[Hp - 8] = _s7Zg::P64;
           P64[Hp] = _s7Zh::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Ze::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7Zm_entry() //  [R1, R2]
         { info_tbl: [(cdNH,
                       label: sat_s7Zm_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNH: // global
           _s7Zg::P64 = R2;
           _s7Zm::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNI; else goto cdNJ;
       cdNJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNL; else goto cdNK;
       cdNL: // global
           HpAlloc = 48;
           goto cdNI;
       cdNI: // global
           R2 = _s7Zg::P64;
           R1 = _s7Zm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNK: // global
           _s7Z9::P64 = P64[_s7Zm::P64 + 7];
           _s7Za::P64 = P64[_s7Zm::P64 + 15];
           _s7Zd::P64 = P64[_s7Zm::P64 + 23];
           _s7Ze::P64 = P64[_s7Zm::P64 + 31];
           _s7Zf::P64 = P64[_s7Zm::P64 + 39];
           I64[Hp - 40] = sat_s7Zl_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Ze::P64;
           P64[Hp - 8] = _s7Zf::P64;
           P64[Hp] = _s7Zg::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zd::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7Zn_entry() //  [R1, R2]
         { info_tbl: [(cdNM,
                       label: sat_s7Zn_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNM: // global
           _s7Zf::P64 = R2;
           _s7Zn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNN; else goto cdNO;
       cdNO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNQ; else goto cdNP;
       cdNQ: // global
           HpAlloc = 48;
           goto cdNN;
       cdNN: // global
           R2 = _s7Zf::P64;
           R1 = _s7Zn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNP: // global
           _s7Z9::P64 = P64[_s7Zn::P64 + 7];
           _s7Za::P64 = P64[_s7Zn::P64 + 15];
           _s7Zc::P64 = P64[_s7Zn::P64 + 23];
           _s7Zd::P64 = P64[_s7Zn::P64 + 31];
           _s7Ze::P64 = P64[_s7Zn::P64 + 39];
           I64[Hp - 40] = sat_s7Zm_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zd::P64;
           P64[Hp - 8] = _s7Ze::P64;
           P64[Hp] = _s7Zf::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zc::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdNR,
                       label: GHC.Base.liftM4_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdNR: // global
           _s7Zd::P64 = R6;
           _s7Zc::P64 = R5;
           _s7Zb::P64 = R4;
           _s7Za::P64 = R3;
           _s7Z9::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNS; else goto cdNT;
       cdNT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNV; else goto cdNU;
       cdNV: // global
           HpAlloc = 48;
           goto cdNS;
       cdNS: // global
           R6 = _s7Zd::P64;
           R5 = _s7Zc::P64;
           R4 = _s7Zb::P64;
           R3 = _s7Za::P64;
           R2 = _s7Z9::P64;
           R1 = GHC.Base.liftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdNU: // global
           I64[Hp - 40] = sat_s7Zn_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zc::P64;
           P64[Hp - 8] = _s7Zd::P64;
           P64[Hp] = P64[Sp];
           R2 = _s7Z9::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s7Zb::P64;
           P64[Sp] = Hp - 39;
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.928251382 UTC

[section ""data" . GHC.Base.liftM3_$sliftM1_closure" {
     GHC.Base.liftM3_$sliftM1_closure:
         const GHC.Base.liftM3_$sliftM1_info;
 },
 GHC.Base.liftM3_$sliftM1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdOr,
                       label: GHC.Base.liftM3_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.932224081 UTC

[section ""data" . GHC.Base.liftM3_closure" {
     GHC.Base.liftM3_closure:
         const GHC.Base.liftM3_info;
 },
 sat_s7Zx_entry() //  [R1, R2]
         { info_tbl: [(cdOS,
                       label: sat_s7Zx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOS: // global
           _s7Zv::P64 = R2;
           _s7Zx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOT; else goto cdOU;
       cdOU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdOW; else goto cdOV;
       cdOW: // global
           HpAlloc = 48;
           goto cdOT;
       cdOT: // global
           R2 = _s7Zv::P64;
           R1 = _s7Zx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOV: // global
           _s7Zo::P64 = P64[_s7Zx::P64 + 7];
           _s7Zp::P64 = P64[_s7Zx::P64 + 15];
           _s7Zt::P64 = P64[_s7Zx::P64 + 23];
           _s7Zu::P64 = P64[_s7Zx::P64 + 31];
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = _s7Zp::P64;
           P64[Hp - 16] = _s7Zt::P64;
           P64[Hp - 8] = _s7Zu::P64;
           P64[Hp] = _s7Zv::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7Zy_entry() //  [R1, R2]
         { info_tbl: [(cdOX,
                       label: sat_s7Zy_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOX: // global
           _s7Zu::P64 = R2;
           _s7Zy::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdOY; else goto cdOZ;
       cdOZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdP1; else goto cdP0;
       cdP1: // global
           HpAlloc = 40;
           goto cdOY;
       cdOY: // global
           R2 = _s7Zu::P64;
           R1 = _s7Zy::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdP0: // global
           _s7Zo::P64 = P64[_s7Zy::P64 + 7];
           _s7Zp::P64 = P64[_s7Zy::P64 + 15];
           _s7Zs::P64 = P64[_s7Zy::P64 + 23];
           _s7Zt::P64 = P64[_s7Zy::P64 + 31];
           I64[Hp - 32] = sat_s7Zx_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zt::P64;
           P64[Hp] = _s7Zu::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zs::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s7Zz_entry() //  [R1, R2]
         { info_tbl: [(cdP2,
                       label: sat_s7Zz_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP2: // global
           _s7Zt::P64 = R2;
           _s7Zz::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdP3; else goto cdP4;
       cdP4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdP6; else goto cdP5;
       cdP6: // global
           HpAlloc = 40;
           goto cdP3;
       cdP3: // global
           R2 = _s7Zt::P64;
           R1 = _s7Zz::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdP5: // global
           _s7Zo::P64 = P64[_s7Zz::P64 + 7];
           _s7Zp::P64 = P64[_s7Zz::P64 + 15];
           _s7Zr::P64 = P64[_s7Zz::P64 + 23];
           _s7Zs::P64 = P64[_s7Zz::P64 + 31];
           I64[Hp - 32] = sat_s7Zy_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zs::P64;
           P64[Hp] = _s7Zt::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zr::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdP7,
                       label: GHC.Base.liftM3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP7: // global
           _s7Zs::P64 = R6;
           _s7Zr::P64 = R5;
           _s7Zq::P64 = R4;
           _s7Zp::P64 = R3;
           _s7Zo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdP8; else goto cdP9;
       cdP9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdPb; else goto cdPa;
       cdPb: // global
           HpAlloc = 40;
           goto cdP8;
       cdP8: // global
           R6 = _s7Zs::P64;
           R5 = _s7Zr::P64;
           R4 = _s7Zq::P64;
           R3 = _s7Zp::P64;
           R2 = _s7Zo::P64;
           R1 = GHC.Base.liftM3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPa: // global
           I64[Hp - 32] = sat_s7Zz_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zr::P64;
           P64[Hp] = _s7Zs::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zq::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.944398212 UTC

[section ""data" . GHC.Base.liftM_$sliftM1_closure" {
     GHC.Base.liftM_$sliftM1_closure:
         const GHC.Base.liftM_$sliftM1_info;
 },
 GHC.Base.liftM_$sliftM1_entry() //  [R2, R3]
         { info_tbl: [(cdPB,
                       label: GHC.Base.liftM_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPB: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.947926383 UTC

[section ""data" . GHC.Base.liftM_closure" {
     GHC.Base.liftM_closure:
         const GHC.Base.liftM_info;
 },
 sat_s7ZF_entry() //  [R1, R2]
         { info_tbl: [(cdPS,
                       label: sat_s7ZF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPS: // global
           _s7ZD::P64 = R2;
           _s7ZF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPT; else goto cdPU;
       cdPU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdPW; else goto cdPV;
       cdPW: // global
           HpAlloc = 32;
           goto cdPT;
       cdPT: // global
           R2 = _s7ZD::P64;
           R1 = _s7ZF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdPV: // global
           _s7ZA::P64 = P64[_s7ZF::P64 + 7];
           _s7ZB::P64 = P64[_s7ZF::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s7ZB::P64;
           P64[Hp] = _s7ZD::P64;
           R2 = _s7ZA::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM_entry() //  [R2, R3, R4]
         { info_tbl: [(cdPX,
                       label: GHC.Base.liftM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPX: // global
           _s7ZC::P64 = R4;
           _s7ZB::P64 = R3;
           _s7ZA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdPY; else goto cdPZ;
       cdPZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQ1; else goto cdQ0;
       cdQ1: // global
           HpAlloc = 24;
           goto cdPY;
       cdPY: // global
           R4 = _s7ZC::P64;
           R3 = _s7ZB::P64;
           R2 = _s7ZA::P64;
           R1 = GHC.Base.liftM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdQ0: // global
           I64[Hp - 16] = sat_s7ZF_info;
           P64[Hp - 8] = _s7ZA::P64;
           P64[Hp] = _s7ZB::P64;
           R2 = _s7ZA::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7ZC::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.954963997 UTC

[section ""data" . GHC.Base.$!_closure" {
     GHC.Base.$!_closure:
         const GHC.Base.$!_info;
 },
 GHC.Base.$!_entry() //  [R2, R3]
         { info_tbl: [(cdQj,
                       label: GHC.Base.$!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQk; else goto cdQl;
       cdQk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdQl: // global
           I64[Sp - 16] = block_cdQh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQh() //  [R1]
         { info_tbl: [(cdQh,
                       label: block_cdQh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQh: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.960128582 UTC

[section ""data" . GHC.Base.$_closure" {
     GHC.Base.$_closure:
         const GHC.Base.$_info;
 },
 GHC.Base.$_entry() //  [R2, R3]
         { info_tbl: [(cdQz,
                       label: GHC.Base.$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQz: // global
           _s7ZJ::P64 = R2;
           R2 = R3;
           R1 = _s7ZJ::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.963461123 UTC

[section ""data" . GHC.Base.flip_closure" {
     GHC.Base.flip_closure:
         const GHC.Base.flip_info;
 },
 GHC.Base.flip_entry() //  [R2, R3, R4]
         { info_tbl: [(cdQK,
                       label: GHC.Base.flip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQK: // global
           R3 = R3;
           _s7ZL::P64 = R2;
           R2 = R4;
           R1 = _s7ZL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.967290933 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>_closure" {
     GHC.Base.$fMonad(->)_$c>>_closure:
         const GHC.Base.$fMonad(->)_$c>>_info;
 },
 GHC.Base.$fMonad(->)_$c>>_entry() //  [R3, R4]
         { info_tbl: [(cdQV,
                       label: GHC.Base.$fMonad(->)_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQV: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.970565974 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*_closure" {
     GHC.Base.$fApplicative(->)_$c<*_closure:
         const GHC.Base.$fApplicative(->)_$c<*_info;
 },
 GHC.Base.$fApplicative(->)_$c<*_entry() //  [R2, R4]
         { info_tbl: [(cdR6,
                       label: GHC.Base.$fApplicative(->)_$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR6: // global
           _s7ZR::P64 = R2;
           R2 = R4;
           R1 = _s7ZR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.974848375 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>_closure" {
     GHC.Base.$fMonad(,)_$c>>_closure:
         const GHC.Base.$fMonad(,)_$c>>_info;
 },
 sat_s804_entry() //  [R1]
         { info_tbl: [(cdRx,
                       label: sat_s804_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdRy; else goto cdRz;
       cdRy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdRv_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdRv() //  [R1]
         { info_tbl: [(cdRv,
                       label: block_cdRv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRv: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_$c>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cdRD,
                       label: GHC.Base.$fMonad(,)_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRF; else goto cdRG;
       cdRF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdRG: // global
           I64[Sp - 24] = block_cdRh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRM; else goto cdRi;
       udRM: // global
           call _cdRh(R1) args: 0, res: 0, upd: 0;
       cdRi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRh() //  [R1]
         { info_tbl: [(cdRh,
                       label: block_cdRh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRh: // global
           I64[Sp] = block_cdRm_info;
           _s7ZY::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7ZY::P64;
           if (R1 & 7 != 0) goto udRL; else goto cdRn;
       udRL: // global
           call _cdRm(R1) args: 0, res: 0, upd: 0;
       cdRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRm() //  [R1]
         { info_tbl: [(cdRm,
                       label: block_cdRm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdRK; else goto cdRJ;
       cdRK: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRJ: // global
           _s801::P64 = P64[R1 + 7];
           _s802::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s804_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s801::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s802::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.986879972 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*_closure" {
     GHC.Base.$fApplicative(,)_$c<*_closure:
         const GHC.Base.$fApplicative(,)_$c<*_info;
 },
 sat_s80f_entry() //  [R1]
         { info_tbl: [(cdSx,
                       label: sat_s80f_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSy; else goto cdSz;
       cdSy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdSz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdSv_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdSv() //  [R1]
         { info_tbl: [(cdSv,
                       label: block_cdSv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSv: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c<*_entry() //  [R2, R3, R4]
         { info_tbl: [(cdSD,
                       label: GHC.Base.$fApplicative(,)_$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdSF; else goto cdSG;
       cdSF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSG: // global
           I64[Sp - 24] = block_cdSh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udSM; else goto cdSi;
       udSM: // global
           call _cdSh(R1) args: 0, res: 0, upd: 0;
       cdSi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSh() //  [R1]
         { info_tbl: [(cdSh,
                       label: block_cdSh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSh: // global
           I64[Sp - 8] = block_cdSm_info;
           _s809::P64 = P64[R1 + 7];
           _s80a::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s80a::P64;
           P64[Sp + 16] = _s809::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSL; else goto cdSn;
       udSL: // global
           call _cdSm(R1) args: 0, res: 0, upd: 0;
       cdSn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdSm() //  [R1]
         { info_tbl: [(cdSm,
                       label: block_cdSm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdSm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdSK; else goto cdSJ;
       cdSK: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSJ: // global
           _s80c::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s80f_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s80c::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:44.998818451 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$c<$_closure" {
     GHC.Base.$fFunctor(,)_$c<$_closure:
         const GHC.Base.$fFunctor(,)_$c<$_info;
 },
 GHC.Base.$fFunctor(,)_$c<$_entry() //  [R2, R3]
         { info_tbl: [(cdTl,
                       label: GHC.Base.$fFunctor(,)_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdTp; else goto cdTq;
       cdTp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTq: // global
           I64[Sp - 16] = block_cdTi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTu; else goto cdTj;
       udTu: // global
           call _cdTi(R1) args: 0, res: 0, upd: 0;
       cdTj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTi() //  [R1]
         { info_tbl: [(cdTi,
                       label: block_cdTi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdTt; else goto cdTs;
       cdTt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTs: // global
           _s80j::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s80j::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.004838346 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_$c<$_closure" {
     GHC.Base.$fFunctorMaybe_$c<$_closure:
         const GHC.Base.$fFunctorMaybe_$c<$_info;
 },
 GHC.Base.$fFunctorMaybe_$c<$_entry() //  [R2, R3]
         { info_tbl: [(cdTR,
                       label: GHC.Base.$fFunctorMaybe_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdTS; else goto cdTT;
       cdTS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorMaybe_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTT: // global
           I64[Sp - 16] = block_cdTK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udU3; else goto cdTL;
       udU3: // global
           call _cdTK(R1) args: 0, res: 0, upd: 0;
       cdTL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdTK() //  [R1]
         { info_tbl: [(cdTK,
                       label: block_cdTK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdTK: // global
           if (R1 & 7 == 1) goto cdTO; else goto cdTP;
       cdTO: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdTP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdU2; else goto cdU1;
       cdU2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.010868448 UTC

[section ""data" . GHC.Base.$dm<$_closure" {
     GHC.Base.$dm<$_closure:
         const GHC.Base.$dm<$_info;
 },
 sat_s80s_entry() //  [R1]
         { info_tbl: [(cdUr,
                       label: sat_s80s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUr: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$dm<$_entry() //  [R2, R3]
         { info_tbl: [(cdUu,
                       label: GHC.Base.$dm<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUu: // global
           _s80q::P64 = R3;
           _s80p::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdUv; else goto cdUw;
       cdUw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUy; else goto cdUx;
       cdUy: // global
           HpAlloc = 16;
           goto cdUv;
       cdUv: // global
           R3 = _s80q::P64;
           R2 = _s80p::P64;
           R1 = GHC.Base.$dm<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdUx: // global
           I64[Hp - 8] = sat_s80s_info;
           P64[Hp] = _s80q::P64;
           R2 = _s80p::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.016584186 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmappend_closure" {
     GHC.Base.$fMonoid(->)_$cmappend_closure:
         const GHC.Base.$fMonoid(->)_$cmappend_info;
 },
 GHC.Base.$fMonoid(->)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdUQ,
                       label: GHC.Base.$fMonoid(->)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUQ: // global
           _s80w::P64 = R5;
           _s80v::P64 = R4;
           _s80u::P64 = R3;
           _s80t::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdUR; else goto cdUS;
       cdUS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdUU; else goto cdUT;
       cdUU: // global
           HpAlloc = 64;
           goto cdUR;
       cdUR: // global
           R5 = _s80w::P64;
           R4 = _s80v::P64;
           R3 = _s80u::P64;
           R2 = _s80t::P64;
           R1 = GHC.Base.$fMonoid(->)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdUT: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s80v::P64;
           P64[Hp - 32] = _s80w::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s80u::P64;
           P64[Hp] = _s80w::P64;
           I64[Sp - 24] = block_cdUO_info;
           R2 = _s80t::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdUO() //  [R1]
         { info_tbl: [(cdUO,
                       label: block_cdUO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdUO: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cdUM::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cdUM::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.023188527 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,)_$cmappend_info;
 },
 sat_s80N_entry() //  [R1]
         { info_tbl: [(cdVt,
                       label: sat_s80N_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdVu; else goto cdVv;
       cdVu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdVv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdVr_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdVr() //  [R1]
         { info_tbl: [(cdVr,
                       label: block_cdVr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVr: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s80L_entry() //  [R1]
         { info_tbl: [(cdVF,
                       label: sat_s80L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdVG; else goto cdVH;
       cdVG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdVH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdVD_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdVD() //  [R1]
         { info_tbl: [(cdVD,
                       label: block_cdVD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVD: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdVL,
                       label: GHC.Base.$fMonoid(,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdVN; else goto cdVO;
       cdVN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVO: // global
           I64[Sp - 32] = block_cdVd_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udVU; else goto cdVe;
       udVU: // global
           call _cdVd(R1) args: 0, res: 0, upd: 0;
       cdVe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVd() //  [R1]
         { info_tbl: [(cdVd,
                       label: block_cdVd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVd: // global
           I64[Sp - 8] = block_cdVi_info;
           _s80F::P64 = P64[R1 + 7];
           _s80G::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s80G::P64;
           P64[Sp + 24] = _s80F::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVT; else goto cdVj;
       udVT: // global
           call _cdVi(R1) args: 0, res: 0, upd: 0;
       cdVj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdVi() //  [R1]
         { info_tbl: [(cdVi,
                       label: block_cdVi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdVi: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdVS; else goto cdVR;
       cdVS: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVR: // global
           _s80I::P64 = P64[R1 + 7];
           _s80J::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s80N_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s80J::P64;
           I64[Hp - 56] = sat_s80L_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s80I::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.038519242 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_go_closure" {
     GHC.Base.$fSemigroupOrdering_go_closure:
         const GHC.Base.$fSemigroupOrdering_go_info;
 },
 GHC.Base.$fSemigroupOrdering_go_entry() //  [R2, R3]
         { info_tbl: [(cdWI,
                       label: GHC.Base.$fSemigroupOrdering_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdWJ; else goto udX9;
       cdWJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udX9: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdWy() args: 0, res: 0, upd: 0;
     }
 },
 _cdWy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWy: // global
           I64[Sp - 8] = block_cdWB_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udXb; else goto cdWC;
       udXb: // global
           call _cdWB(R1) args: 0, res: 0, upd: 0;
       cdWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWB() //  [R1]
         { info_tbl: [(cdWB,
                       label: block_cdWB_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWB: // global
           _s80O::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdWF; else goto cdWG;
       cdWF: // global
           R1 = _s80O::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdWG: // global
           I64[Sp] = block_cdWQ_info;
           _s80R::P64 = P64[R1 + 6];
           _s80S::P64 = P64[R1 + 14];
           R1 = _s80O::P64;
           P64[Sp + 8] = _s80S::P64;
           P64[Sp + 16] = _s80R::P64;
           if (R1 & 7 != 0) goto udXc; else goto cdWS;
       udXc: // global
           call _cdWQ(R1) args: 0, res: 0, upd: 0;
       cdWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWQ() //  [R1]
         { info_tbl: [(cdWQ,
                       label: block_cdWQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdWQ: // global
           _cdX7::P64 = R1 & 7;
           if (_cdX7::P64 < 3) goto udX8; else goto cdX6;
       udX8: // global
           if (_cdX7::P64 < 2) goto cdWY; else goto cdX2;
       cdWY: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdX2: // global
           _s80P::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s80P::P64;
           Sp = Sp + 8;
           call _cdWy() args: 0, res: 0, upd: 0;
       cdX6: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.048067828 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_$csconcat_closure" {
     GHC.Base.$fSemigroupOrdering_$csconcat_closure:
         const GHC.Base.$fSemigroupOrdering_$csconcat_info;
 },
 GHC.Base.$fSemigroupOrdering_$csconcat_entry() //  [R2]
         { info_tbl: [(cdXJ,
                       label: GHC.Base.$fSemigroupOrdering_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXK; else goto cdXL;
       cdXK: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXL: // global
           I64[Sp - 8] = block_cdXG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udXP; else goto cdXH;
       udXP: // global
           call _cdXG(R1) args: 0, res: 0, upd: 0;
       cdXH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdXG() //  [R1]
         { info_tbl: [(cdXG,
                       label: block_cdXG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdXG: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupOrdering_go_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.053506391 UTC

[section ""data" . GHC.Base.._closure" {
     GHC.Base.._closure:
         const GHC.Base.._info;
 },
 GHC.Base.._entry() //  [R2, R3, R4]
         { info_tbl: [(cdY4,
                       label: GHC.Base.._info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdY4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdY8; else goto cdY7;
       cdY8: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdY7: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _s80Y::P64 = R2;
           R2 = Hp - 24;
           R1 = _s80Y::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.057356702 UTC

[section ""data" . GHC.Base.mapFB_closure" {
     GHC.Base.mapFB_closure:
         const GHC.Base.mapFB_info;
 },
 GHC.Base.mapFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdYi,
                       label: GHC.Base.mapFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdYi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdYm; else goto cdYl;
       cdYm: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdYl: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _s812::P64 = R2;
           R2 = Hp - 24;
           R1 = _s812::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.061503152 UTC

[section ""data" . GHC.Base.$fFunctor(->)_$c<$_closure" {
     GHC.Base.$fFunctor(->)_$c<$_closure:
         const GHC.Base.$fFunctor(->)_$c<$_info;
 },
 GHC.Base.$fFunctor(->)_$c<$_entry() //  [R2]
         { info_tbl: [(cdYv,
                       label: GHC.Base.$fFunctor(->)_$c<$_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdYv: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.06440283 UTC

[section ""data" . GHC.Base.$fFunctor(->)_closure" {
     GHC.Base.$fFunctor(->)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.._closure+3;
         const GHC.Base.$fFunctor(->)_$c<$_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.06617989 UTC

[section ""data" . GHC.Base.const_closure" {
     GHC.Base.const_closure:
         const GHC.Base.const_info;
 },
 GHC.Base.const_entry() //  [R2]
         { info_tbl: [(cdYH,
                       label: GHC.Base.const_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdYH: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.069283727 UTC

[section ""data" . GHC.Base.asTypeOf_closure" {
     GHC.Base.asTypeOf_closure:
         const GHC.Base.asTypeOf_info;
 },
 GHC.Base.asTypeOf_entry() //  [R2, R3]
         { info_tbl: [(cdYS,
                       label: GHC.Base.asTypeOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdYS: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.072932148 UTC

[section ""data" . GHC.Base.$dm<*_closure" {
     GHC.Base.$dm<*_closure:
         const GHC.Base.$dm<*_info;
 },
 GHC.Base.$dm<*_entry() //  [R2]
         { info_tbl: [(cdZ3,
                       label: GHC.Base.$dm<*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdZ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdZ4; else goto cdZ5;
       cdZ4: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdZ5: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.const_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.076702503 UTC

[section ""data" . GHC.Base.$fApplicativeIO1_closure" {
     GHC.Base.$fApplicativeIO1_closure:
         const GHC.Base.$fApplicativeIO1_info;
 },
 GHC.Base.$fApplicativeIO1_entry() //  [R2, R3]
         { info_tbl: [(cdZj,
                       label: GHC.Base.$fApplicativeIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdZk; else goto cdZl;
       cdZk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdZl: // global
           I64[Sp - 16] = block_cdZf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdZf() //  [R1]
         { info_tbl: [(cdZf,
                       label: block_cdZf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdZf: // global
           I64[Sp] = block_cdZh_info;
           _s81i::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s81i::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdZh() //  []
         { info_tbl: [(cdZh,
                       label: block_cdZh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdZh: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.083086179 UTC

[section ""data" . GHC.Base.$fApplicativeIO_closure" {
     GHC.Base.$fApplicativeIO_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorIO_closure+1;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fApplicativeIO3_closure+3;
         const GHC.Base.$fApplicativeIO_$cliftA2_closure+4;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.085086302 UTC

[section ""data" . GHC.Base.breakpointCond_closure" {
     GHC.Base.breakpointCond_closure:
         const GHC.Base.breakpointCond_info;
 },
 GHC.Base.breakpointCond_entry() //  [R3]
         { info_tbl: [(cdZF,
                       label: GHC.Base.breakpointCond_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdZF: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.08873202 UTC

[section ""data" . GHC.Base.breakpoint_closure" {
     GHC.Base.breakpoint_closure:
         const GHC.Base.breakpoint_info;
 },
 GHC.Base.breakpoint_entry() //  [R2]
         { info_tbl: [(cdZQ,
                       label: GHC.Base.breakpoint_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdZQ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.091906331 UTC

[section ""data" . GHC.Base.assert_closure" {
     GHC.Base.assert_closure:
         const GHC.Base.assert_info;
 },
 GHC.Base.assert_entry() //  [R2, R3]
         { info_tbl: [(ce01,
                       label: GHC.Base.assert_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce01: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.breakpointCond_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.095238147 UTC

[section ""data" . GHC.Base.id_closure" {
     GHC.Base.id_closure:
         const GHC.Base.id_info;
 },
 GHC.Base.id_entry() //  [R2]
         { info_tbl: [(ce0c,
                       label: GHC.Base.id_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce0c: // global
           R2 = R2;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.098426942 UTC

[section ""data" . GHC.Base.join_closure" {
     GHC.Base.join_closure:
         const GHC.Base.join_info;
 },
 GHC.Base.join_entry() //  [R2, R3]
         { info_tbl: [(ce0n,
                       label: GHC.Base.join_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce0n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ce0o; else goto ce0p;
       ce0o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.join_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ce0p: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.10241901 UTC

[section ""data" . GHC.Base.$dm<*>_closure" {
     GHC.Base.$dm<*>_closure:
         const GHC.Base.$dm<*>_info;
 },
 GHC.Base.$dm<*>_entry() //  [R2]
         { info_tbl: [(ce0z,
                       label: GHC.Base.$dm<*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce0z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ce0A; else goto ce0B;
       ce0A: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ce0B: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.107688976 UTC

[section ""data" . GHC.Base.$dm*>_closure" {
     GHC.Base.$dm*>_closure:
         const GHC.Base.$dm*>_info;
 },
 sat_s81w_entry() //  [R1]
         { info_tbl: [(ce0R,
                       label: sat_s81w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce0R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ce0S; else goto ce0T;
       ce0S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ce0T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ce0P_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ce0P() //  [R1]
         { info_tbl: [(ce0P,
                       label: block_ce0P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce0P: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 8;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dm*>_entry() //  [R2, R3, R4]
         { info_tbl: [(ce0X,
                       label: GHC.Base.$dm*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce0X: // global
           _s81u::P64 = R4;
           _s81t::P64 = R3;
           _s81s::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto ce0Y; else goto ce0Z;
       ce0Z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ce11; else goto ce10;
       ce11: // global
           HpAlloc = 32;
           goto ce0Y;
       ce0Y: // global
           R4 = _s81u::P64;
           R3 = _s81t::P64;
           R2 = _s81s::P64;
           R1 = GHC.Base.$dm*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ce10: // global
           I64[Hp - 24] = sat_s81w_info;
           P64[Hp - 8] = _s81s::P64;
           P64[Hp] = _s81t::P64;
           R2 = _s81s::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s81u::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.114992672 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c*>_closure" {
     GHC.Base.$fApplicative(->)_$c*>_closure:
         const GHC.Base.$fApplicative(->)_$c*>_info;
 },
 GHC.Base.$fApplicative(->)_$c*>_entry() //  [R3, R4]
         { info_tbl: [(ce1k,
                       label: GHC.Base.$fApplicative(->)_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce1k: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.118482508 UTC

[section ""data" . GHC.Base.maxInt_closure" {
     GHC.Base.maxInt_closure:
         const GHC.Types.I#_con_info;
         const 9223372036854775807;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.120069675 UTC

[section ""data" . GHC.Base.minInt_closure" {
     GHC.Base.minInt_closure:
         const GHC.Types.I#_con_info;
         const (-9223372036854775808);
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.122391341 UTC

[section ""data" . GHC.Base.ord_closure" {
     GHC.Base.ord_closure:
         const GHC.Base.ord_info;
 },
 GHC.Base.ord_entry() //  [R2]
         { info_tbl: [(ce1A,
                       label: GHC.Base.ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce1A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ce1H; else goto ce1I;
       ce1H: // global
           R2 = R2;
           R1 = GHC.Base.ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ce1I: // global
           I64[Sp - 8] = block_ce1x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ue1M; else goto ce1y;
       ue1M: // global
           call _ce1x(R1) args: 0, res: 0, upd: 0;
       ce1y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ce1x() //  [R1]
         { info_tbl: [(ce1x,
                       label: block_ce1x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce1x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ce1L; else goto ce1K;
       ce1L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ce1K: // global
           _s81D::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s81D::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.128205725 UTC

[section ""data" . GHC.Base.unsafeChr_closure" {
     GHC.Base.unsafeChr_closure:
         const GHC.Base.unsafeChr_info;
 },
 GHC.Base.unsafeChr_entry() //  [R2]
         { info_tbl: [(ce24,
                       label: GHC.Base.unsafeChr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce24: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ce2b; else goto ce2c;
       ce2b: // global
           R2 = R2;
           R1 = GHC.Base.unsafeChr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ce2c: // global
           I64[Sp - 8] = block_ce21_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ue2g; else goto ce22;
       ue2g: // global
           call _ce21(R1) args: 0, res: 0, upd: 0;
       ce22: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ce21() //  [R1]
         { info_tbl: [(ce21,
                       label: block_ce21_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce21: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ce2f; else goto ce2e;
       ce2f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ce2e: // global
           _s81H::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s81H::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.13399 UTC

[section ""data" . GHC.Base.otherwise_closure" {
     GHC.Base.otherwise_closure:
         const GHC.Types.True_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.136199897 UTC

[section ""data" . GHC.Base.until_closure" {
     GHC.Base.until_closure:
         const GHC.Base.until_info;
 },
 GHC.Base.until_entry() //  [R2, R3, R4]
         { info_tbl: [(ce2y,
                       label: GHC.Base.until_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce2y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ce2z; else goto ce2A;
       ce2z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.until_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ce2A: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _ce2C() args: 0, res: 0, upd: 0;
     }
 },
 _ce2C() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce2C: // global
           I64[Sp - 8] = block_ce2E_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ce2E() //  [R1]
         { info_tbl: [(ce2E,
                       label: block_ce2E_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce2E: // global
           _s81M::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ce2I; else goto ce2R;
       ce2I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ce2N; else goto ce2M;
       ce2N: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ce2M: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s81M::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call _ce2C() args: 0, res: 0, upd: 0;
       ce2R: // global
           R1 = _s81M::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.143410636 UTC

[section ""data" . GHC.Base.divModInt#_closure" {
     GHC.Base.divModInt#_closure:
         const GHC.Base.divModInt#_info;
 },
 GHC.Base.divModInt#_entry() //  [R2, R3]
         { info_tbl: [(ce3l,
                       label: GHC.Base.divModInt#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce3l: // global
           if (%MO_S_Le_W64(R2, 0)) goto ce3j; else goto ce3k;
       ce3j: // global
           if (%MO_S_Ge_W64(R2, 0)) goto ce3v; else goto ce3F;
       ce3v: // global
           _s81Q::I64 = R3;
           (_ce3s::I64, _ce3t::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _ce3t::I64;
           R1 = _ce3s::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce3F: // global
           if (%MO_S_Le_W64(R3, 0)) goto ce3D; else goto ce3E;
       ce3D: // global
           _s81Q::I64 = R3;
           (_ce3A::I64, _ce3B::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _ce3B::I64;
           R1 = _ce3A::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce3E: // global
           _s81Q::I64 = R3;
           (_s81W::I64, _s81X::I64) = call MO_S_QuotRem W64(R2 + 1, _s81Q::I64);
           R2 = _s81X::I64 + _s81Q::I64 - 1;
           R1 = _s81W::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce3k: // global
           if (%MO_S_Ge_W64(R3, 0)) goto ce42; else goto ce43;
       ce42: // global
           if (%MO_S_Ge_W64(R2, 0)) goto ce3Q; else goto ce40;
       ce3Q: // global
           _s81Q::I64 = R3;
           (_ce3N::I64, _ce3O::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _ce3O::I64;
           R1 = _ce3N::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce40: // global
           if (%MO_S_Le_W64(R3, 0)) goto ce3Y; else goto ce3Z;
       ce3Y: // global
           _s81Q::I64 = R3;
           (_ce3V::I64, _ce3W::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _ce3W::I64;
           R1 = _ce3V::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce3Z: // global
           _s81Q::I64 = R3;
           (_s826::I64, _s827::I64) = call MO_S_QuotRem W64(R2 + 1, _s81Q::I64);
           R2 = _s827::I64 + _s81Q::I64 - 1;
           R1 = _s826::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce43: // global
           _s81Q::I64 = R3;
           (_s82d::I64, _s82e::I64) = call MO_S_QuotRem W64(R2 - 1, _s81Q::I64);
           R2 = _s82e::I64 + _s81Q::I64 + 1;
           R1 = _s82d::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.150944066 UTC

[section ""data" . GHC.Base.divModInt_closure" {
     GHC.Base.divModInt_closure:
         const GHC.Base.divModInt_info;
 },
 GHC.Base.divModInt_entry() //  [R2, R3]
         { info_tbl: [(ce4Z,
                       label: GHC.Base.divModInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce4Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ce53; else goto ce54;
       ce53: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divModInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ce54: // global
           I64[Sp - 16] = block_ce4W_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ue6P; else goto ce4X;
       ue6P: // global
           call _ce4W(R1) args: 0, res: 0, upd: 0;
       ce4X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ce4W() //  [R1]
         { info_tbl: [(ce4W,
                       label: block_ce4W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce4W: // global
           I64[Sp] = block_ce52_info;
           _s82l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s82l::I64;
           if (R1 & 7 != 0) goto ue6O; else goto ce56;
       ue6O: // global
           call _ce52(R1) args: 0, res: 0, upd: 0;
       ce56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ce52() //  [R1]
         { info_tbl: [(ce52,
                       label: block_ce52_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce52: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ce5c; else goto ce5b;
       ce5c: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ce5b: // global
           _s82l::I64 = I64[Sp + 8];
           _s82n::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s82l::I64, 0)) goto ce5Q; else goto ce6N;
       ce5Q: // global
           if (%MO_S_Ge_W64(_s82l::I64, 0)) goto ce5n; else goto ce5O;
       ce5n: // global
           (_s82r::I64, _s82s::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82s::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82r::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce5O: // global
           if (%MO_S_Le_W64(_s82n::I64, 0)) goto ce5w; else goto ce5N;
       ce5w: // global
           (_s82x::I64, _s82y::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82y::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82x::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce5N: // global
           (_s82D::I64, _s82E::I64) = call MO_S_QuotRem W64(_s82l::I64 + 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82E::I64 + _s82n::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82D::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce6N: // global
           if (%MO_S_Ge_W64(_s82n::I64, 0)) goto ce6v; else goto ce6M;
       ce6v: // global
           if (%MO_S_Ge_W64(_s82l::I64, 0)) goto ce62; else goto ce6t;
       ce62: // global
           (_s82N::I64, _s82O::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82O::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82N::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce6t: // global
           if (%MO_S_Le_W64(_s82n::I64, 0)) goto ce6b; else goto ce6s;
       ce6b: // global
           (_s82T::I64, _s82U::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82U::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82T::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce6s: // global
           (_s82Z::I64, _s830::I64) = call MO_S_QuotRem W64(_s82l::I64 + 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s830::I64 + _s82n::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82Z::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce6M: // global
           (_s838::I64, _s839::I64) = call MO_S_QuotRem W64(_s82l::I64 - 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s839::I64 + _s82n::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s838::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.162560737 UTC

[section ""data" . GHC.Base.shiftL#_closure" {
     GHC.Base.shiftL#_closure:
         const GHC.Base.shiftL#_info;
 },
 GHC.Base.shiftL#_entry() //  [R2, R3]
         { info_tbl: [(ce7J,
                       label: GHC.Base.shiftL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce7J: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce7H; else goto ce7I;
       ce7H: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce7I: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.166448393 UTC

[section ""data" . GHC.Base.shiftRL#_closure" {
     GHC.Base.shiftRL#_closure:
         const GHC.Base.shiftRL#_info;
 },
 GHC.Base.shiftRL#_entry() //  [R2, R3]
         { info_tbl: [(ce84,
                       label: GHC.Base.shiftRL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce84: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce82; else goto ce83;
       ce82: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce83: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.169963782 UTC

[section ""data" . GHC.Base.iShiftL#_closure" {
     GHC.Base.iShiftL#_closure:
         const GHC.Base.iShiftL#_info;
 },
 GHC.Base.iShiftL#_entry() //  [R2, R3]
         { info_tbl: [(ce8p,
                       label: GHC.Base.iShiftL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce8p: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce8n; else goto ce8o;
       ce8n: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce8o: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.173674171 UTC

[section ""data" . GHC.Base.iShiftRA#_closure" {
     GHC.Base.iShiftRA#_closure:
         const GHC.Base.iShiftRA#_info;
 },
 GHC.Base.iShiftRA#_entry() //  [R2, R3]
         { info_tbl: [(ce8K,
                       label: GHC.Base.iShiftRA#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce8K: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce8I; else goto ce8J;
       ce8I: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce8J: // global
           if (%MO_S_Ge_W64(R2, 0)) goto ce8T; else goto ce8U;
       ce8T: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce8U: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.178264756 UTC

[section ""data" . GHC.Base.iShiftRL#_closure" {
     GHC.Base.iShiftRL#_closure:
         const GHC.Base.iShiftRL#_info;
 },
 GHC.Base.iShiftRL#_entry() //  [R2, R3]
         { info_tbl: [(ce9c,
                       label: GHC.Base.iShiftRL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce9c: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce9a; else goto ce9b;
       ce9a: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce9b: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.181737498 UTC

[section ""data" . GHC.Base.build_closure" {
     GHC.Base.build_closure:
         const GHC.Base.build_info;
 },
 GHC.Base.build_entry() //  [R2]
         { info_tbl: [(ce9s,
                       label: GHC.Base.build_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce9s: // global
           R3 = GHC.Types.[]_closure+1;
           _s83v::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _s83v::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.185142501 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cpure_closure" {
     GHC.Base.$fApplicative[]_$cpure_closure:
         const GHC.Base.$fApplicative[]_$cpure_info;
 },
 GHC.Base.$fApplicative[]_$cpure_entry() //  [R2]
         { info_tbl: [(ce9E,
                       label: GHC.Base.$fApplicative[]_$cpure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce9E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ce9I; else goto ce9H;
       ce9I: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ce9H: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.189303764 UTC

[section ""data" . GHC.Base.augment_closure" {
     GHC.Base.augment_closure:
         const GHC.Base.augment_info;
 },
 GHC.Base.augment_entry() //  [R2, R3]
         { info_tbl: [(ce9S,
                       label: GHC.Base.augment_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ce9S: // global
           R3 = R3;
           _s83x::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _s83x::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.194323216 UTC

[section ""data" . GHC.Base.++_closure" {
     GHC.Base.++_closure:
         const GHC.Base.++_info;
 },
 sat_s83E_entry() //  [R1]
         { info_tbl: [(cead,
                       label: sat_s83E_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cead: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceae; else goto ceaf;
       ceae: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceaf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.++_entry() //  [R2, R3]
         { info_tbl: [(ceak,
                       label: GHC.Base.++_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceak: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceal; else goto ceam;
       ceal: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.++_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceam: // global
           I64[Sp - 16] = block_cea3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueat; else goto cea4;
       ueat: // global
           call _cea3(R1) args: 0, res: 0, upd: 0;
       cea4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cea3() //  [R1]
         { info_tbl: [(cea3,
                       label: block_cea3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cea3: // global
           _s83A::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ceah; else goto ceai;
       ceah: // global
           R1 = _s83A::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ceai: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ceas; else goto cear;
       ceas: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cear: // global
           _s83C::P64 = P64[R1 + 6];
           _s83D::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_s83E_info;
           P64[Hp - 32] = _s83A::P64;
           P64[Hp - 24] = _s83D::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s83C::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.foldr_closure" {
     GHC.Base.foldr_closure:
         const GHC.Base.foldr_info;
 },
 go_s83I_entry() //  [R1, R2]
         { info_tbl: [(ceaK,
                       label: go_s83I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceaK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceaL; else goto ceaM;
       ceaL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceaM: // global
           I64[Sp - 32] = block_ceaD_info;
           _s83I::P64 = R1;
           _s83F::P64 = P64[R1 + 7];
           _s83G::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s83F::P64;
           P64[Sp - 16] = _s83G::P64;
           P64[Sp - 8] = _s83I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ueaW; else goto ceaE;
       ueaW: // global
           call _ceaD(R1) args: 0, res: 0, upd: 0;
       ceaE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceaD() //  [R1]
         { info_tbl: [(ceaD,
                       label: block_ceaD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceaD: // global
           if (R1 & 7 == 1) goto ceaH; else goto ceaI;
       ceaH: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ceaI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceaV; else goto ceaU;
       ceaV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceaU: // global
           _s83L::P64 = P64[R1 + 6];
           _s83M::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s83M::P64;
           R3 = Hp - 24;
           R2 = _s83L::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.foldr_entry() //  [R2, R3, R4]
         { info_tbl: [(ceaX,
                       label: GHC.Base.foldr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceaX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceb1; else goto ceb0;
       ceb1: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.foldr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceb0: // global
           I64[Hp - 16] = go_s83I_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go_s83I_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.map_closure" {
     GHC.Base.map_closure:
         const GHC.Base.map_info;
 },
 sat_s83U_entry() //  [R1]
         { info_tbl: [(cebg,
                       label: sat_s83U_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cebg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cebh; else goto cebi;
       cebh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cebi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.map_entry() //  [R2, R3]
         { info_tbl: [(cebn,
                       label: GHC.Base.map_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cebn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cebo; else goto cebp;
       cebo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cebp: // global
           I64[Sp - 16] = block_ceb6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uebx; else goto ceb7;
       uebx: // global
           call _ceb6(R1) args: 0, res: 0, upd: 0;
       ceb7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceb6() //  [R1]
         { info_tbl: [(ceb6,
                       label: block_ceb6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceb6: // global
           if (R1 & 7 == 1) goto cebk; else goto cebl;
       cebk: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cebl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cebw; else goto cebv;
       cebw: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cebv: // global
           _s83R::P64 = P64[R1 + 6];
           _s83S::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_s83U_info;
           _s83O::P64 = P64[Sp + 8];
           P64[Hp - 64] = _s83O::P64;
           P64[Hp - 56] = _s83S::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s83O::P64;
           P64[Hp - 24] = _s83R::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.216839448 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$c<>_closure" {
     GHC.Base.$fSemigroupNonEmpty_$c<>_closure:
         const GHC.Base.$fSemigroupNonEmpty_$c<>_info;
 },
 sat_s849_entry() //  [R1]
         { info_tbl: [(cecF,
                       label: sat_s849_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cecF: // global
           _s849::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cecG; else goto cecH;
       cecH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cecJ; else goto cecI;
       cecJ: // global
           HpAlloc = 72;
           goto cecG;
       cecG: // global
           R1 = _s849::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cecI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s849::P64;
           _s83W::P64 = P64[_s849::P64 + 16];
           _s83Z::P64 = P64[_s849::P64 + 24];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _s83W::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _s83W::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _s83Z::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupNonEmpty_$c<>_entry() //  [R2, R3]
         { info_tbl: [(cecK,
                       label: GHC.Base.$fSemigroupNonEmpty_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cecK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cecM; else goto cecN;
       cecM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cecN: // global
           I64[Sp - 16] = block_cect_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uecR; else goto cecu;
       uecR: // global
           call _cect(R1) args: 0, res: 0, upd: 0;
       cecu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cect() //  [R1]
         { info_tbl: [(cect,
                       label: block_cect_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cect: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cecQ; else goto cecP;
       cecQ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cecP: // global
           _s83Y::P64 = P64[R1 + 7];
           _s83Z::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_s849_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s83Z::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _s83Y::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.226513732 UTC

[section ""data" . GHC.Base.$wpoly_go_closure" {
     GHC.Base.$wpoly_go_closure:
         const GHC.Base.$wpoly_go_info;
 },
 ds_s84g_entry() //  [R1]
         { info_tbl: [(cedv,
                       label: ds_s84g_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cedv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cedB; else goto cedC;
       cedB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cedC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ceds_info;
           _s84f::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s84f::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uedH; else goto cedt;
       uedH: // global
           call _ceds(R1) args: 0, res: 0, upd: 0;
       cedt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ceds() //  [R1]
         { info_tbl: [(ceds,
                       label: block_ceds_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceds: // global
           _s84f::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cedy_info;
           R4 = _s84f::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cedy() //  [R1, R2]
         { info_tbl: [(cedy,
                       label: block_cedy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cedy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cedG; else goto cedF;
       cedG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cedF: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s84w_entry() //  [R1]
         { info_tbl: [(cedL,
                       label: sat_s84w_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cedL: // global
           _s84w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cedM; else goto cedN;
       cedN: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cedP; else goto cedO;
       cedP: // global
           HpAlloc = 104;
           goto cedM;
       cedM: // global
           R1 = _s84w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cedO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s84w::P64;
           _s84b::P64 = P64[_s84w::P64 + 16];
           _s84e::P64 = P64[_s84w::P64 + 24];
           _s84f::P64 = P64[_s84w::P64 + 32];
           I64[Hp - 96] = ds_s84g_info;
           P64[Hp - 80] = _s84e::P64;
           P64[Hp - 72] = _s84f::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cedo::P64 = Hp - 96;
           P64[Hp - 48] = _cedo::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cedo::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _s84b::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$wpoly_go_entry() //  [R2, R3, R4]
         { info_tbl: [(cedU,
                       label: GHC.Base.$wpoly_go_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cedU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cedV; else goto cedW;
       cedV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$wpoly_go_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cedW: // global
           I64[Sp - 24] = block_cede_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uee2; else goto cedf;
       uee2: // global
           call _cede(R1) args: 0, res: 0, upd: 0;
       cedf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cede() //  [R1]
         { info_tbl: [(cede,
                       label: block_cede_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cede: // global
           _s84a::P64 = P64[Sp + 8];
           _s84b::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cedR; else goto cedS;
       cedR: // global
           R2 = _s84b::P64;
           R1 = _s84a::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cedS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cee1; else goto cee0;
       cee1: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cee0: // global
           _s84e::P64 = P64[R1 + 6];
           _s84f::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_s84w_info;
           P64[Hp - 16] = _s84b::P64;
           P64[Hp - 8] = _s84e::P64;
           P64[Hp] = _s84f::P64;
           R2 = Hp - 32;
           R1 = _s84a::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.241321757 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty1_closure" {
     GHC.Base.$fSemigroupNonEmpty1_closure:
         const GHC.Base.$fSemigroupNonEmpty1_info;
 },
 GHC.Base.$fSemigroupNonEmpty1_entry() //  [R2, R3]
         { info_tbl: [(ceeF,
                       label: GHC.Base.$fSemigroupNonEmpty1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceeF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceeL; else goto ceeM;
       ceeL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceeM: // global
           I64[Sp - 16] = block_ceeC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueeR; else goto ceeD;
       ueeR: // global
           call _ceeC(R1) args: 0, res: 0, upd: 0;
       ceeD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceeC() //  [R1]
         { info_tbl: [(ceeC,
                       label: block_ceeC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceeC: // global
           _s84y::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ceeI_info;
           R4 = _s84y::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ceeI() //  [R1, R2]
         { info_tbl: [(ceeI,
                       label: block_ceeI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceeI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceeQ; else goto ceeP;
       ceeQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceeP: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.249061829 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$csconcat_closure" {
     GHC.Base.$fSemigroupNonEmpty_$csconcat_closure:
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_info;
 },
 GHC.Base.$fSemigroupNonEmpty_$csconcat_entry() //  [R2]
         { info_tbl: [(cefc,
                       label: GHC.Base.$fSemigroupNonEmpty_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cefc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cefd; else goto cefe;
       cefd: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cefe: // global
           I64[Sp - 8] = block_cef9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uefi; else goto cefa;
       uefi: // global
           call _cef9(R1) args: 0, res: 0, upd: 0;
       cefa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cef9() //  [R1]
         { info_tbl: [(cef9,
                       label: block_cef9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cef9: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupNonEmpty1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.254254133 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_closure" {
     GHC.Base.$fSemigroupNonEmpty_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fSemigroupNonEmpty_$c<>_closure+2;
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_closure+1;
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupNonEmpty_$cstimes_closure" {
     GHC.Base.$fSemigroupNonEmpty_$cstimes_closure:
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupNonEmpty_$cstimes_entry() //  [R2]
         { info_tbl: [(cefw,
                       label: GHC.Base.$fSemigroupNonEmpty_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cefw: // global
           R3 = GHC.Base.$fSemigroupNonEmpty_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.258929794 UTC

[section ""data" . GHC.Base.$fSemigroup[]1_closure" {
     GHC.Base.$fSemigroup[]1_closure:
         const GHC.Base.$fSemigroup[]1_info;
 },
 sat_s84P_entry() //  [R1]
         { info_tbl: [(cefS,
                       label: sat_s84P_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cefS: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup[]1_entry() //  [R2, R3]
         { info_tbl: [(cefZ,
                       label: GHC.Base.$fSemigroup[]1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cefZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceg0; else goto ceg1;
       ceg0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceg1: // global
           I64[Sp - 16] = block_cefI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueg7; else goto cefJ;
       ueg7: // global
           call _cefI(R1) args: 0, res: 0, upd: 0;
       cefJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cefI() //  [R1]
         { info_tbl: [(cefI,
                       label: block_cefI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cefI: // global
           _s84K::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cefW; else goto cefX;
       cefW: // global
           R1 = _s84K::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cefX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceg6; else goto ceg5;
       ceg6: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceg5: // global
           _s84N::P64 = P64[R1 + 6];
           _s84O::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s84P_info;
           P64[Hp - 8] = _s84N::P64;
           P64[Hp] = _s84O::P64;
           R3 = Hp - 24;
           R2 = _s84K::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.26719901 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$csconcat_closure" {
     GHC.Base.$fSemigroup[]_$csconcat_closure:
         const GHC.Base.$fSemigroup[]_$csconcat_info;
 },
 GHC.Base.$fSemigroup[]_$csconcat_entry() //  [R2]
         { info_tbl: [(cegv,
                       label: GHC.Base.$fSemigroup[]_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cegv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cegw; else goto cegx;
       cegw: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cegx: // global
           I64[Sp - 8] = block_cegs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uegB; else goto cegt;
       uegB: // global
           call _cegs(R1) args: 0, res: 0, upd: 0;
       cegt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cegs() //  [R1]
         { info_tbl: [(cegs,
                       label: block_cegs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cegs: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.273405249 UTC

[section ""data" . GHC.Base.mapM_closure" {
     GHC.Base.mapM_closure:
         const GHC.Base.mapM_info;
 },
 z_s84X_entry() //  [R1]
         { info_tbl: [(cegT,
                       label: z_s84X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cegT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cegU; else goto cegV;
       cegU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cegV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s858_entry() //  [R1, R2]
         { info_tbl: [(cehj,
                       label: sat_s858_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cehj: // global
           _s856::P64 = R2;
           _s858::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cehk; else goto cehl;
       cehl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cehn; else goto cehm;
       cehn: // global
           HpAlloc = 24;
           goto cehk;
       cehk: // global
           R2 = _s856::P64;
           R1 = _s858::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cehm: // global
           _s84U::P64 = P64[_s858::P64 + 7];
           _s855::P64 = P64[_s858::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s855::P64;
           P64[Hp] = _s856::P64;
           R2 = _s84U::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s859_entry() //  [R1, R2]
         { info_tbl: [(ceho,
                       label: sat_s859_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceho: // global
           _s855::P64 = R2;
           _s859::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cehp; else goto cehq;
       cehq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cehs; else goto cehr;
       cehs: // global
           HpAlloc = 24;
           goto cehp;
       cehp: // global
           R2 = _s855::P64;
           R1 = _s859::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cehr: // global
           _s84U::P64 = P64[_s859::P64 + 7];
           _s853::P64 = P64[_s859::P64 + 15];
           I64[Hp - 16] = sat_s858_info;
           P64[Hp - 8] = _s84U::P64;
           P64[Hp] = _s855::P64;
           R2 = _s84U::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s853::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 go_s84Y_entry() //  [R1, R2]
         { info_tbl: [(cehx,
                       label: go_s84Y_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cehx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cehy; else goto cehz;
       cehy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cehz: // global
           I64[Sp - 40] = block_ceh1_info;
           _s84Y::P64 = R1;
           _s84U::P64 = P64[R1 + 7];
           _s84V::P64 = P64[R1 + 15];
           _s84X::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s84U::P64;
           P64[Sp - 24] = _s84V::P64;
           P64[Sp - 16] = _s84X::P64;
           P64[Sp - 8] = _s84Y::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uehG; else goto ceh2;
       uehG: // global
           call _ceh1(R1) args: 0, res: 0, upd: 0;
       ceh2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceh1() //  [R1]
         { info_tbl: [(ceh1,
                       label: block_ceh1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceh1: // global
           if (R1 & 7 == 1) goto cehu; else goto cehv;
       cehu: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cehv: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cehE; else goto cehD;
       cehE: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cehD: // global
           _s851::P64 = P64[R1 + 6];
           _s852::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _s852::P64;
           I64[Hp - 48] = sat_s859_info;
           _s84U::P64 = P64[Sp + 8];
           P64[Hp - 40] = _s84U::P64;
           P64[Hp - 32] = Hp - 80;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s851::P64;
           R2 = _s84U::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 47;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.mapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cehH,
                       label: GHC.Base.mapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cehH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cehL; else goto cehK;
       cehL: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cehK: // global
           I64[Hp - 48] = z_s84X_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_s84Y_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R2 = R4;
           R1 = Hp - 23;
           call go_s84Y_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.288659998 UTC

[section ""data" . GHC.Base.sequence_closure" {
     GHC.Base.sequence_closure:
         const GHC.Base.sequence_info;
 },
 GHC.Base.sequence_entry() //  [R2, R3]
         { info_tbl: [(ceio,
                       label: GHC.Base.sequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceio: // global
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call GHC.Base.mapM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.293059553 UTC

[section ""data" . GHC.Base.$dmmconcat_closure" {
     GHC.Base.$dmmconcat_closure:
         const GHC.Base.$dmmconcat_info;
 },
 z_s85d_entry() //  [R1]
         { info_tbl: [(ceiD,
                       label: z_s85d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceiD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceiE; else goto ceiF;
       ceiE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceiF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s85e_entry() //  [R1, R2]
         { info_tbl: [(ceiS,
                       label: go_s85e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceiS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceiT; else goto ceiU;
       ceiT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceiU: // global
           I64[Sp - 32] = block_ceiL_info;
           _s85e::P64 = R1;
           _s85b::P64 = P64[R1 + 7];
           _s85d::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s85b::P64;
           P64[Sp - 16] = _s85d::P64;
           P64[Sp - 8] = _s85e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uej4; else goto ceiM;
       uej4: // global
           call _ceiL(R1) args: 0, res: 0, upd: 0;
       ceiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceiL() //  [R1]
         { info_tbl: [(ceiL,
                       label: block_ceiL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceiL: // global
           if (R1 & 7 == 1) goto ceiP; else goto ceiQ;
       ceiP: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ceiQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cej2; else goto cej1;
       cej2: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cej1: // global
           _s85h::P64 = P64[R1 + 6];
           _s85i::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s85i::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s85h::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$dmmconcat_entry() //  [R2, R3]
         { info_tbl: [(cej5,
                       label: GHC.Base.$dmmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cej5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cej9; else goto cej8;
       cej9: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cej8: // global
           I64[Hp - 40] = z_s85d_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85e_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s85e_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.303783101 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmconcat_closure" {
     GHC.Base.$fMonoid(->)_$cmconcat_closure:
         const GHC.Base.$fMonoid(->)_$cmconcat_info;
 },
 lvl3_s85n_entry() //  [R1]
         { info_tbl: [(cejD,
                       label: lvl3_s85n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cejD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cejE; else goto cejF;
       cejE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cejF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup_s85o_entry() //  [R1]
         { info_tbl: [(cejK,
                       label: $dSemigroup_s85o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cejK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cejL; else goto cejM;
       cejL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cejM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s85p_entry() //  [R1, R2, R3]
         { info_tbl: [(cejZ,
                       label: go_s85p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cejZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cek0; else goto cek1;
       cek0: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cek1: // global
           I64[Sp - 40] = block_cejS_info;
           _s85p::P64 = R1;
           _s85n::P64 = P64[R1 + 6];
           _s85o::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _s85n::P64;
           P64[Sp - 24] = _s85o::P64;
           P64[Sp - 16] = _s85p::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uekc; else goto cejT;
       uekc: // global
           call _cejS(R1) args: 0, res: 0, upd: 0;
       cejT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cejS() //  [R1]
         { info_tbl: [(cejS,
                       label: block_cejS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cejS: // global
           if (R1 & 7 == 1) goto cejW; else goto cejX;
       cejW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cejX: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cek9; else goto cek8;
       cek9: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cek8: // global
           _s85t::P64 = P64[R1 + 6];
           _s85u::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = _s85u::P64;
           _s85r::P64 = P64[Sp + 32];
           P64[Hp - 32] = _s85r::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s85t::P64;
           P64[Hp] = _s85r::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(->)_$cmconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(cekd,
                       label: GHC.Base.$fMonoid(->)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cekd: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cekh; else goto cekg;
       cekh: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cekg: // global
           I64[Hp - 64] = lvl3_s85n_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = $dSemigroup_s85o_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85p_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           _s85l::P64 = R3;
           R3 = R4;
           R2 = _s85l::P64;
           R1 = Hp - 14;
           call go_s85p_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.317447928 UTC

[section ""data" . GHC.Base.$fMonoidIO1_closure" {
     GHC.Base.$fMonoidIO1_closure:
         const GHC.Base.$fMonoidIO1_info;
 },
 $dSemigroup_s85A_entry() //  [R1]
         { info_tbl: [(cekR,
                       label: $dSemigroup_s85A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cekR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cekS; else goto cekT;
       cekS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cekT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl3_s85B_entry() //  [R1]
         { info_tbl: [(cekY,
                       label: lvl3_s85B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cekY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cekZ; else goto cel0;
       cekZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cel0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s85O_entry() //  [R1]
         { info_tbl: [(celk,
                       label: sat_s85O_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       celk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cell; else goto celm;
       cell: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       celm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s85C_entry() //  [R1, R2]
         { info_tbl: [(celr,
                       label: go_s85C_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       celr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cels; else goto celt;
       cels: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       celt: // global
           I64[Sp - 32] = block_cel6_info;
           _s85C::P64 = R1;
           _s85A::P64 = P64[R1 + 6];
           _s85B::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _s85A::P64;
           P64[Sp - 16] = _s85B::P64;
           P64[Sp - 8] = _s85C::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uelB; else goto cel7;
       uelB: // global
           call _cel6(R1) args: 0, res: 0, upd: 0;
       cel7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cel6() //  [R1]
         { info_tbl: [(cel6,
                       label: block_cel6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cel6: // global
           if (R1 & 7 == 1) goto celo; else goto celp;
       celo: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       celp: // global
           I64[Sp] = block_celc_info;
           _s85H::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s85H::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _celc() //  [R1]
         { info_tbl: [(celc,
                       label: block_celc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       celc: // global
           I64[Sp] = block_cele_info;
           R2 = P64[Sp + 16];
           _s85K::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s85K::P64;
           call go_s85C_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cele() //  [R1]
         { info_tbl: [(cele,
                       label: block_cele_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cele: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto celA; else goto celz;
       celA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       celz: // global
           I64[Hp - 32] = sat_s85O_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoidIO1_entry() //  [R2, R3]
         { info_tbl: [(celC,
                       label: GHC.Base.$fMonoidIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       celC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto celG; else goto celF;
       celG: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       celF: // global
           I64[Hp - 64] = $dSemigroup_s85A_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl3_s85B_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85C_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 14;
           call go_s85C_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.334986271 UTC

[section ""data" . GHC.Base.$fMonoidIO_closure" {
     GHC.Base.$fMonoidIO_closure:
         const GHC.Base.$fMonoidIO_info;
         const 0;
 },
 sat_s85V_entry() //  [R1, R2]
         { info_tbl: [(cemu,
                       label: sat_s85V_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cemu: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s85U_entry() //  [R1, R2, R3]
         { info_tbl: [(cemC,
                       label: sat_s85U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cemC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoidIO_$cmappend_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s85S_entry() //  [R1]
         { info_tbl: [(cemO,
                       label: sat_s85S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cemO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cemP; else goto cemQ;
       cemP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cemQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s85T_entry() //  [R1]
         { info_tbl: [(cemR,
                       label: sat_s85T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cemR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cemV; else goto cemU;
       cemV: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cemU: // global
           _s85P::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s85S_info;
           P64[Hp] = _s85P::P64;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s85Q_entry() //  [R1]
         { info_tbl: [(cen0,
                       label: sat_s85Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cen0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cen1; else goto cen2;
       cen1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cen2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoidIO_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidIO_entry() //  [R2]
         { info_tbl: [(cen4,
                       label: GHC.Base.$fMonoidIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cen4: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cen8; else goto cen7;
       cen8: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cen7: // global
           I64[Hp - 104] = sat_s85V_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s85U_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s85T_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s85Q_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.348023685 UTC

[section ""data" . GHC.Base.$fFunctor[]_$c<$_closure" {
     GHC.Base.$fFunctor[]_$c<$_closure:
         const GHC.Base.$fFunctor[]_$c<$_info;
 },
 sat_s85Z_entry() //  [R1]
         { info_tbl: [(cenJ,
                       label: sat_s85Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cenJ: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fFunctor[]_$c<$_entry() //  [R2, R3]
         { info_tbl: [(cenM,
                       label: GHC.Base.$fFunctor[]_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cenM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cenQ; else goto cenP;
       cenQ: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor[]_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cenP: // global
           I64[Hp - 8] = sat_s85Z_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.353965722 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$c<$_closure" {
     GHC.Base.$fFunctorNonEmpty_$c<$_closure:
         const GHC.Base.$fFunctorNonEmpty_$c<$_info;
 },
 sat_s866_entry() //  [R1]
         { info_tbl: [(ceog,
                       label: sat_s866_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceog: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s867_entry() //  [R1]
         { info_tbl: [(ceoj,
                       label: sat_s867_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceoj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceok; else goto ceol;
       ceok: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceol: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ceo6_info;
           _s860::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s860::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ueop; else goto ceo7;
       ueop: // global
           call _ceo6(R1) args: 0, res: 0, upd: 0;
       ceo7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ceo6() //  [R1]
         { info_tbl: [(ceo6,
                       label: block_ceo6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceo6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceoo; else goto ceon;
       ceoo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ceon: // global
           _s864::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s866_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _s864::P64;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fFunctorNonEmpty_$c<$_entry() //  [R2, R3]
         { info_tbl: [(ceor,
                       label: GHC.Base.$fFunctorNonEmpty_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceor: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ceov; else goto ceou;
       ceov: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceou: // global
           I64[Hp - 48] = sat_s867_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.36327282 UTC

[section ""data" . GHC.Base.$fFunctor[]_closure" {
     GHC.Base.$fFunctor[]_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.366185961 UTC

[section ""data" . GHC.Base.$fMonad[]_$c>>=_closure" {
     GHC.Base.$fMonad[]_$c>>=_closure:
         const GHC.Base.$fMonad[]_$c>>=_info;
 },
 sat_s86g_entry() //  [R1]
         { info_tbl: [(cep8,
                       label: sat_s86g_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cep8: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s86a_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86a_entry() //  [R1, R2]
         { info_tbl: [(cepf,
                       label: go_s86a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cepf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cepg; else goto ceph;
       cepg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceph: // global
           I64[Sp - 24] = block_ceoY_info;
           _s86a::P64 = R1;
           _s869::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s869::P64;
           P64[Sp - 8] = _s86a::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueps; else goto ceoZ;
       ueps: // global
           call _ceoY(R1) args: 0, res: 0, upd: 0;
       ceoZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceoY() //  [R1]
         { info_tbl: [(ceoY,
                       label: block_ceoY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceoY: // global
           if (R1 & 7 == 1) goto cepc; else goto cepd;
       cepc: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cepd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cepn; else goto cepm;
       cepn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cepm: // global
           _s86d::P64 = P64[R1 + 6];
           _s86e::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s86g_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s86e::P64;
           _s869::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cepk_info;
           R2 = _s86d::P64;
           R1 = _s869::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cepk() //  [R1]
         { info_tbl: [(cepk,
                       label: block_cepk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cepk: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonad[]_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cept,
                       label: GHC.Base.$fMonad[]_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cept: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cepx; else goto cepw;
       cepx: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad[]_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cepw: // global
           I64[Hp - 8] = go_s86a_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86a_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.377384685 UTC

[section ""data" . GHC.Base.=<<_$s=<<_closure" {
     GHC.Base.=<<_$s=<<_closure:
         const GHC.Base.=<<_$s=<<_info;
 },
 GHC.Base.=<<_$s=<<_entry() //  [R2, R3]
         { info_tbl: [(cepZ,
                       label: GHC.Base.=<<_$s=<<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cepZ: // global
           _s86i::P64 = R3;
           R3 = R2;
           R2 = _s86i::P64;
           call GHC.Base.$fMonad[]_$c>>=_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.38122433 UTC

[section ""data" . GHC.Base.=<<_closure" {
     GHC.Base.=<<_closure:
         const GHC.Base.=<<_info;
 },
 GHC.Base.=<<_entry() //  [R2, R3, R4]
         { info_tbl: [(ceqa,
                       label: GHC.Base.=<<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceqa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceqb; else goto ceqc;
       ceqb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.=<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceqc: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.385494785 UTC

[section ""data" . poly_go_r7PI_closure" {
     poly_go_r7PI_closure:
         const poly_go_r7PI_info;
 },
 sat_s86q_entry() //  [R1]
         { info_tbl: [(ceqw,
                       label: sat_s86q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceqw: // global
           R2 = P64[R1 + 16];
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 poly_go_r7PI_entry() //  [R2]
         { info_tbl: [(ceqD,
                       label: poly_go_r7PI_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceqD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceqE; else goto ceqF;
       ceqE: // global
           R2 = R2;
           R1 = poly_go_r7PI_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceqF: // global
           I64[Sp - 8] = block_ceqm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueqL; else goto ceqn;
       ueqL: // global
           call _ceqm(R1) args: 0, res: 0, upd: 0;
       ceqn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceqm() //  [R1]
         { info_tbl: [(ceqm,
                       label: block_ceqm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceqm: // global
           if (R1 & 7 == 1) goto ceqA; else goto ceqB;
       ceqA: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceqB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceqK; else goto ceqJ;
       ceqK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceqJ: // global
           _s86o::P64 = P64[R1 + 6];
           _s86p::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_s86q_info;
           P64[Hp] = _s86p::P64;
           R3 = Hp - 16;
           R2 = _s86o::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.393564554 UTC

[section ""data" . GHC.Base.$fMonoid[]_$cmconcat_closure" {
     GHC.Base.$fMonoid[]_$cmconcat_closure:
         const GHC.Base.$fMonoid[]_$cmconcat_info;
 },
 GHC.Base.$fMonoid[]_$cmconcat_entry() //  [R2]
         { info_tbl: [(cer5,
                       label: GHC.Base.$fMonoid[]_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cer5: // global
           R2 = R2;
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.398034043 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*>_closure" {
     GHC.Base.$fApplicative[]_$c<*>_closure:
         const GHC.Base.$fApplicative[]_$c<*>_info;
 },
 go1_s86A_entry() //  [R1, R2]
         { info_tbl: [(cerE,
                       label: go1_s86A_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cerE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cerF; else goto cerG;
       cerF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cerG: // global
           I64[Sp - 32] = block_cerx_info;
           _s86A::P64 = R1;
           _s86x::P64 = P64[R1 + 7];
           _s86z::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s86x::P64;
           P64[Sp - 16] = _s86z::P64;
           P64[Sp - 8] = _s86A::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uerS; else goto cery;
       uerS: // global
           call _cerx(R1) args: 0, res: 0, upd: 0;
       cery: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cerx() //  [R1]
         { info_tbl: [(cerx,
                       label: block_cerx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cerx: // global
           if (R1 & 7 == 1) goto cerB; else goto cerC;
       cerB: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cerC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cerR; else goto cerQ;
       cerR: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cerQ: // global
           _s86D::P64 = P64[R1 + 6];
           _s86E::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = _s86E::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s86D::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86u_entry() //  [R1, R2]
         { info_tbl: [(cerX,
                       label: go_s86u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cerX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cerY; else goto cerZ;
       cerY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cerZ: // global
           I64[Sp - 24] = block_cerl_info;
           _s86u::P64 = R1;
           _s86t::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s86t::P64;
           P64[Sp - 8] = _s86u::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ues5; else goto cerm;
       ues5: // global
           call _cerl(R1) args: 0, res: 0, upd: 0;
       cerm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cerl() //  [R1]
         { info_tbl: [(cerl,
                       label: block_cerl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cerl: // global
           if (R1 & 7 == 1) goto cerU; else goto cerV;
       cerU: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cerV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ces4; else goto ces3;
       ces4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ces3: // global
           _s86x::P64 = P64[R1 + 6];
           _s86y::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s86y::P64;
           I64[Hp - 16] = go1_s86A_info;
           P64[Hp - 8] = _s86x::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s86A_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(ces6,
                       label: GHC.Base.$fApplicative[]_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ces6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cesa; else goto ces9;
       cesa: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ces9: // global
           I64[Hp - 8] = go_s86u_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86u_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.412275524 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cliftA2_closure" {
     GHC.Base.$fApplicative[]_$cliftA2_closure:
         const GHC.Base.$fApplicative[]_$cliftA2_info;
 },
 go1_s86Q_entry() //  [R1, R2]
         { info_tbl: [(cetb,
                       label: go1_s86Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cetb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cetc; else goto cetd;
       cetc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cetd: // global
           I64[Sp - 40] = block_cet4_info;
           _s86Q::P64 = R1;
           _s86H::P64 = P64[R1 + 7];
           _s86N::P64 = P64[R1 + 15];
           _s86P::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s86H::P64;
           P64[Sp - 24] = _s86N::P64;
           P64[Sp - 16] = _s86P::P64;
           P64[Sp - 8] = _s86Q::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uetp; else goto cet5;
       uetp: // global
           call _cet4(R1) args: 0, res: 0, upd: 0;
       cet5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cet4() //  [R1]
         { info_tbl: [(cet4,
                       label: block_cet4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cet4: // global
           if (R1 & 7 == 1) goto cet8; else goto cet9;
       cet8: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cet9: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ceto; else goto cetn;
       ceto: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cetn: // global
           _s86T::P64 = P64[R1 + 6];
           _s86U::P64 = P64[R1 + 14];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = _s86U::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s86T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86K_entry() //  [R1, R2]
         { info_tbl: [(cetu,
                       label: go_s86K_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cetu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cetv; else goto cetw;
       cetv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cetw: // global
           I64[Sp - 32] = block_cesS_info;
           _s86K::P64 = R1;
           _s86H::P64 = P64[R1 + 7];
           _s86J::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s86H::P64;
           P64[Sp - 16] = _s86J::P64;
           P64[Sp - 8] = _s86K::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uetC; else goto cesT;
       uetC: // global
           call _cesS(R1) args: 0, res: 0, upd: 0;
       cesT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cesS() //  [R1]
         { info_tbl: [(cesS,
                       label: block_cesS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cesS: // global
           if (R1 & 7 == 1) goto cetr; else goto cets;
       cetr: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cets: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cetB; else goto cetA;
       cetB: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cetA: // global
           _s86N::P64 = P64[R1 + 6];
           _s86O::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _s86O::P64;
           I64[Hp - 24] = go1_s86Q_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s86N::P64;
           P64[Hp] = Hp - 56;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call go1_s86Q_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cetD,
                       label: GHC.Base.$fApplicative[]_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cetD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cetH; else goto cetG;
       cetH: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cetG: // global
           I64[Hp - 16] = go_s86K_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = R3;
           R1 = Hp - 15;
           call go_s86K_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.425696047 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*_closure" {
     GHC.Base.$fApplicative[]_$c<*_closure:
         const GHC.Base.$fApplicative[]_$c<*_info;
 },
 GHC.Base.$fApplicative[]_$c<*_entry() //  [R2, R3]
         { info_tbl: [(ceum,
                       label: GHC.Base.$fApplicative[]_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceum: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.const_closure+2;
           call GHC.Base.$fApplicative[]_$cliftA2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.429695069 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c*>_closure" {
     GHC.Base.$fApplicative[]_$c*>_closure:
         const GHC.Base.$fApplicative[]_$c*>_info;
 },
 sat_s874_entry() //  [R1]
         { info_tbl: [(ceuM,
                       label: sat_s874_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceuM: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s86Z_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s86Z_entry() //  [R1, R2]
         { info_tbl: [(ceuT,
                       label: go_s86Z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceuT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceuU; else goto ceuV;
       ceuU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceuV: // global
           I64[Sp - 24] = block_ceuC_info;
           _s86Z::P64 = R1;
           _s86Y::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s86Y::P64;
           P64[Sp - 8] = _s86Z::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uev1; else goto ceuD;
       uev1: // global
           call _ceuC(R1) args: 0, res: 0, upd: 0;
       ceuD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceuC() //  [R1]
         { info_tbl: [(ceuC,
                       label: block_ceuC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceuC: // global
           if (R1 & 7 == 1) goto ceuQ; else goto ceuR;
       ceuQ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceuR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cev0; else goto ceuZ;
       cev0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceuZ: // global
           _s873::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s874_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s873::P64;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$c*>_entry() //  [R2, R3]
         { info_tbl: [(cev2,
                       label: GHC.Base.$fApplicative[]_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cev2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cev6; else goto cev5;
       cev6: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cev5: // global
           I64[Hp - 8] = go_s86Z_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86Z_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.439248085 UTC

[section ""data" . GHC.Base.$fApplicative[]_closure" {
     GHC.Base.$fApplicative[]_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor[]_closure+1;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fApplicative[]_$c<*>_closure+2;
         const GHC.Base.$fApplicative[]_$cliftA2_closure+3;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.441736323 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$cfmap_closure" {
     GHC.Base.$fFunctorNonEmpty_$cfmap_closure:
         const GHC.Base.$fFunctorNonEmpty_$cfmap_info;
 },
 sat_s87f_entry() //  [R1]
         { info_tbl: [(cevC,
                       label: sat_s87f_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cevC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cevD; else goto cevE;
       cevD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cevE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cevz_info;
           _s875::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s875::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uevI; else goto cevA;
       uevI: // global
           call _cevz(R1) args: 0, res: 0, upd: 0;
       cevA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cevz() //  [R1]
         { info_tbl: [(cevz,
                       label: block_cevz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cevz: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s87b_entry() //  [R1]
         { info_tbl: [(cevO,
                       label: sat_s87b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cevO: // global
           _s87b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cevP; else goto cevQ;
       cevQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cevS; else goto cevR;
       cevS: // global
           HpAlloc = 24;
           goto cevP;
       cevP: // global
           R1 = _s87b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cevR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87b::P64;
           _s875::P64 = P64[_s87b::P64 + 16];
           _s876::P64 = P64[_s87b::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s876::P64;
           R2 = Hp - 16;
           R1 = _s875::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fFunctorNonEmpty_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(cevU,
                       label: GHC.Base.$fFunctorNonEmpty_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cevU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cevY; else goto cevX;
       cevY: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cevX: // global
           I64[Hp - 80] = sat_s87f_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s87b_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.451727632 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_closure" {
     GHC.Base.$fFunctorNonEmpty_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorNonEmpty_$cfmap_closure+2;
         const GHC.Base.$fFunctorNonEmpty_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.453363212 UTC

[section ""data" . GHC.Base.$fAlternative[]1_closure" {
     GHC.Base.$fAlternative[]1_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.456298772 UTC

[section ""data" . GHC.Base.$fAlternative[]_$csome_closure" {
     GHC.Base.$fAlternative[]_$csome_closure:
         const GHC.Base.$fAlternative[]_$csome_info;
 },
 ys_s87i_entry() //  [R1]
         { info_tbl: [(ceww,
                       label: ys_s87i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceww: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cewx; else goto cewy;
       cewx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cewy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_s87p_entry() //  [R1, R2]
         { info_tbl: [(cewX,
                       label: go1_s87p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cewX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cewY; else goto cewZ;
       cewY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cewZ: // global
           I64[Sp - 32] = block_cewQ_info;
           _s87p::P64 = R1;
           _s87m::P64 = P64[R1 + 7];
           _s87o::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s87m::P64;
           P64[Sp - 16] = _s87o::P64;
           P64[Sp - 8] = _s87p::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uexb; else goto cewR;
       uexb: // global
           call _cewQ(R1) args: 0, res: 0, upd: 0;
       cewR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cewQ() //  [R1]
         { info_tbl: [(cewQ,
                       label: block_cewQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cewQ: // global
           if (R1 & 7 == 1) goto cewU; else goto cewV;
       cewU: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cewV: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cexa; else goto cex9;
       cexa: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cex9: // global
           _s87s::P64 = P64[R1 + 6];
           _s87t::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s87t::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s87s::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s87j_entry() //  [R1, R2]
         { info_tbl: [(cexg,
                       label: go_s87j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cexg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cexh; else goto cexi;
       cexh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cexi: // global
           I64[Sp - 24] = block_cewE_info;
           _s87j::P64 = R1;
           _s87i::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87i::P64;
           P64[Sp - 8] = _s87j::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uexo; else goto cewF;
       uexo: // global
           call _cewE(R1) args: 0, res: 0, upd: 0;
       cewF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cewE() //  [R1]
         { info_tbl: [(cewE,
                       label: block_cewE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cewE: // global
           if (R1 & 7 == 1) goto cexd; else goto cexe;
       cexd: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cexe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cexn; else goto cexm;
       cexn: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cexm: // global
           _s87m::P64 = P64[R1 + 6];
           _s87n::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s87n::P64;
           I64[Hp - 16] = go1_s87p_info;
           P64[Hp - 8] = _s87m::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s87p_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 some_v_s87h_entry() //  [R1]
         { info_tbl: [(cexp,
                       label: some_v_s87h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cexp: // global
           _s87h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cexq; else goto cexr;
       cexr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cext; else goto cexs;
       cext: // global
           HpAlloc = 40;
           goto cexq;
       cexq: // global
           R1 = _s87h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cexs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87h::P64;
           _s87g::P64 = P64[_s87h::P64 + 16];
           I64[Hp - 32] = ys_s87i_info;
           P64[Hp - 16] = _s87h::P64;
           I64[Hp - 8] = go_s87j_info;
           P64[Hp] = Hp - 32;
           R2 = _s87g::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_s87j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternative[]_$csome_entry() //  [R2]
         { info_tbl: [(cexu,
                       label: GHC.Base.$fAlternative[]_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cexu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cexy; else goto cexx;
       cexy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cexx: // global
           I64[Hp - 16] = some_v_s87h_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.47397508 UTC

[section ""data" . GHC.Base.$fAlternative[]_$cmany_closure" {
     GHC.Base.$fAlternative[]_$cmany_closure:
         const GHC.Base.$fAlternative[]_$cmany_info;
 },
 go1_s87E_entry() //  [R1, R2]
         { info_tbl: [(ceyO,
                       label: go1_s87E_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceyO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceyP; else goto ceyQ;
       ceyP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceyQ: // global
           I64[Sp - 32] = block_ceyH_info;
           _s87E::P64 = R1;
           _s87B::P64 = P64[R1 + 7];
           _s87D::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s87B::P64;
           P64[Sp - 16] = _s87D::P64;
           P64[Sp - 8] = _s87E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uez2; else goto ceyI;
       uez2: // global
           call _ceyH(R1) args: 0, res: 0, upd: 0;
       ceyI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceyH() //  [R1]
         { info_tbl: [(ceyH,
                       label: block_ceyH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceyH: // global
           if (R1 & 7 == 1) goto ceyL; else goto ceyM;
       ceyL: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ceyM: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cez1; else goto cez0;
       cez1: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cez0: // global
           _s87H::P64 = P64[R1 + 6];
           _s87I::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s87I::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s87H::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s87y_entry() //  [R1, R2]
         { info_tbl: [(cez7,
                       label: go_s87y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cez7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cez8; else goto cez9;
       cez8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cez9: // global
           I64[Sp - 24] = block_ceyv_info;
           _s87y::P64 = R1;
           _s87x::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87x::P64;
           P64[Sp - 8] = _s87y::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uezf; else goto ceyw;
       uezf: // global
           call _ceyv(R1) args: 0, res: 0, upd: 0;
       ceyw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceyv() //  [R1]
         { info_tbl: [(ceyv,
                       label: block_ceyv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceyv: // global
           if (R1 & 7 == 1) goto cez4; else goto cez5;
       cez4: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cez5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ceze; else goto cezd;
       ceze: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cezd: // global
           _s87B::P64 = P64[R1 + 6];
           _s87C::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s87C::P64;
           I64[Hp - 16] = go1_s87E_info;
           P64[Hp - 8] = _s87B::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s87E_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v_s87x_entry() //  [R1]
         { info_tbl: [(cezi,
                       label: many_v_s87x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cezi: // global
           _s87x::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cezj; else goto cezk;
       cezk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cezm; else goto cezl;
       cezm: // global
           HpAlloc = 16;
           goto cezj;
       cezj: // global
           R1 = _s87x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cezl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87x::P64;
           _s87w::P64 = P64[_s87x::P64 + 16];
           I64[Hp - 8] = go_s87y_info;
           P64[Hp] = _s87x::P64;
           I64[Sp - 24] = block_cezg_info;
           R2 = _s87w::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_s87y_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cezg() //  [R1]
         { info_tbl: [(cezg,
                       label: block_cezg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cezg: // global
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternative[]_$cmany_entry() //  [R2]
         { info_tbl: [(cezq,
                       label: GHC.Base.$fAlternative[]_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cezq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cezu; else goto cezt;
       cezu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cezt: // global
           I64[Hp - 16] = many_v_s87x_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.490606423 UTC

[section ""data" . GHC.Base.$fAlternative[]_closure" {
     GHC.Base.$fAlternative[]_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fAlternative[]_$csome_closure+1;
         const GHC.Base.$fAlternative[]_$cmany_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.494451822 UTC

[section ""data" . GHC.Base.$w$c>>=_closure" {
     GHC.Base.$w$c>>=_closure:
         const GHC.Base.$w$c>>=_info;
 },
 ds_s87O_entry() //  [R1]
         { info_tbl: [(ceAm,
                       label: ds_s87O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceAm: // global
           _s87O::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ceAn; else goto ceAo;
       ceAo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceAq; else goto ceAp;
       ceAq: // global
           HpAlloc = 24;
           goto ceAn;
       ceAn: // global
           R1 = _s87O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceAp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87O::P64;
           _s87M::P64 = P64[_s87O::P64 + 16];
           _s87N::P64 = P64[_s87O::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s87M::P64;
           R2 = Hp - 16;
           R1 = _s87N::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s88i_entry() //  [R1]
         { info_tbl: [(ceAZ,
                       label: sat_s88i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceAZ: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s883_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s883_entry() //  [R1, R2]
         { info_tbl: [(ceB6,
                       label: go_s883_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceB6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceB7; else goto ceB8;
       ceB7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceB8: // global
           I64[Sp - 24] = block_ceAO_info;
           _s883::P64 = R1;
           _s87N::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87N::P64;
           P64[Sp - 8] = _s883::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueBh; else goto ceAP;
       ueBh: // global
           call _ceAO(R1) args: 0, res: 0, upd: 0;
       ceAP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceAO() //  [R1]
         { info_tbl: [(ceAO,
                       label: block_ceAO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceAO: // global
           if (R1 & 7 == 1) goto ceB3; else goto ceB4;
       ceB3: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceB4: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ceBg; else goto ceBf;
       ceBg: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceBf: // global
           _s886::P64 = P64[R1 + 6];
           _s887::P64 = P64[R1 + 14];
           I64[Hp - 128] = stg_ap_2_upd_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _s886::P64;
           I64[Hp - 96] = sat_s88i_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s887::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _ceAU::P64 = Hp - 128;
           P64[Hp - 48] = _ceAU::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _ceAU::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 96;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s88j_entry() //  [R1]
         { info_tbl: [(ceBi,
                       label: sat_s88j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceBi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceBj; else goto ceBk;
       ceBj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceBk: // global
           I64[Sp - 16] = block_ceAE_info;
           _s87N::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s87N::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueBo; else goto ceAF;
       ueBo: // global
           call _ceAE(R1) args: 0, res: 0, upd: 0;
       ceAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceAE() //  [R1]
         { info_tbl: [(ceAE,
                       label: block_ceAE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceAE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceBn; else goto ceBm;
       ceBn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceBm: // global
           _s882::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_s883_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _s882::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_s883_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s88k_entry() //  [R1]
         { info_tbl: [(ceBp,
                       label: sat_s88k_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceBp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ceBq; else goto ceBr;
       ceBq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceBr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ceAv_info;
           _s87M::P64 = P64[R1 + 16];
           _s87N::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _s87M::P64;
           P64[Sp - 24] = _s87N::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ueBv; else goto ceAw;
       ueBv: // global
           call _ceAv(R1) args: 0, res: 0, upd: 0;
       ceAw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ceAv() //  [R1]
         { info_tbl: [(ceAv,
                       label: block_ceAv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceAv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceBu; else goto ceBt;
       ceBu: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ceBt: // global
           _s87Z::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s88j_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 24;
           R2 = _s87Z::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$w$c>>=_entry() //  [R2, R3]
         { info_tbl: [(ceBx,
                       label: GHC.Base.$w$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceBx: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ceBB; else goto ceBA;
       ceBB: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceBA: // global
           I64[Hp - 88] = ds_s87O_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s88k_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _ceAh::P64 = Hp - 88;
           P64[Hp - 24] = _ceAh::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _ceAh::P64;
           R2 = Hp - 56;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.51480505 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>=_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>=_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>=_info;
 },
 GHC.Base.$fMonadNonEmpty_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(ceCt,
                       label: GHC.Base.$fMonadNonEmpty_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceCt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceCu; else goto ceCv;
       ceCu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceCv: // global
           I64[Sp - 8] = block_ceCq_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ceCq() //  [R1, R2]
         { info_tbl: [(ceCq,
                       label: block_ceCq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceCq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceCy; else goto ceCx;
       ceCy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceCx: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.520534168 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>_info;
 },
 sat_s88t_entry() //  [R1]
         { info_tbl: [(ceCR,
                       label: sat_s88t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceCR: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonadNonEmpty_$c>>_entry() //  [R2, R3]
         { info_tbl: [(ceCX,
                       label: GHC.Base.$fMonadNonEmpty_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceCX: // global
           _s88r::P64 = R3;
           _s88q::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ceCY; else goto ceCZ;
       ceCZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceD1; else goto ceD0;
       ceD1: // global
           HpAlloc = 16;
           goto ceCY;
       ceCY: // global
           R3 = _s88r::P64;
           R2 = _s88q::P64;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceD0: // global
           I64[Hp - 8] = sat_s88t_info;
           P64[Hp] = _s88r::P64;
           I64[Sp - 8] = block_ceCU_info;
           R3 = Hp - 7;
           R2 = _s88q::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ceCU() //  [R1, R2]
         { info_tbl: [(ceCU,
                       label: block_ceCU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceCU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceD4; else goto ceD3;
       ceD4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceD3: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.528260439 UTC

[section ""data" . GHC.Base.<**>1_closure" {
     GHC.Base.<**>1_closure:
         const GHC.Base.<**>1_info;
 },
 GHC.Base.<**>1_entry() //  [R2, R3]
         { info_tbl: [(ceDn,
                       label: GHC.Base.<**>1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceDn: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.531578565 UTC

[section ""data" . GHC.Base.<**>_closure" {
     GHC.Base.<**>_closure:
         const GHC.Base.<**>_info;
 },
 GHC.Base.<**>_entry() //  [R2]
         { info_tbl: [(ceDy,
                       label: GHC.Base.<**>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceDy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceDz; else goto ceDA;
       ceDz: // global
           R2 = R2;
           R1 = GHC.Base.<**>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceDA: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.<**>1_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.535507695 UTC

[section ""data" . GHC.Base.$dmliftA2_closure" {
     GHC.Base.$dmliftA2_closure:
         const GHC.Base.$dmliftA2_info;
 },
 sat_s88E_entry() //  [R1]
         { info_tbl: [(ceDQ,
                       label: sat_s88E_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceDQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ceDR; else goto ceDS;
       ceDR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceDS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ceDO_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ceDO() //  [R1]
         { info_tbl: [(ceDO,
                       label: block_ceDO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceDO: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(ceDW,
                       label: GHC.Base.$dmliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceDW: // global
           _s88C::P64 = R4;
           _s88B::P64 = R3;
           _s88A::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ceDX; else goto ceDY;
       ceDY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ceE0; else goto ceDZ;
       ceE0: // global
           HpAlloc = 40;
           goto ceDX;
       ceDX: // global
           R4 = _s88C::P64;
           R3 = _s88B::P64;
           R2 = _s88A::P64;
           R1 = GHC.Base.$dmliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceDZ: // global
           I64[Hp - 32] = sat_s88E_info;
           P64[Hp - 16] = _s88A::P64;
           P64[Hp - 8] = _s88B::P64;
           P64[Hp] = _s88C::P64;
           R2 = _s88A::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.544394933 UTC

[section ""data" . GHC.Base.$dmsome_closure" {
     GHC.Base.$dmsome_closure:
         const GHC.Base.$dmsome_info;
 },
 sat_s88J_entry() //  [R1]
         { info_tbl: [(ceEA,
                       label: sat_s88J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceEA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceEB; else goto ceEC;
       ceEB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceEC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s88K_entry() //  [R1]
         { info_tbl: [(ceED,
                       label: sat_s88K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceED: // global
           _s88K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto ceEE; else goto ceEF;
       ceEF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceEH; else goto ceEG;
       ceEH: // global
           HpAlloc = 24;
           goto ceEE;
       ceEE: // global
           R1 = _s88K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceEG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s88K::P64;
           _s88F::P64 = P64[_s88K::P64 + 16];
           _s88H::P64 = P64[_s88K::P64 + 24];
           _s88I::P64 = P64[_s88K::P64 + 32];
           I64[Hp - 16] = sat_s88J_info;
           P64[Hp] = _s88I::P64;
           R2 = _s88F::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s88H::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 some_v_s88H_entry() //  [R1]
         { info_tbl: [(ceEI,
                       label: some_v_s88H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceEI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ceEJ; else goto ceEK;
       ceEJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceEK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ceEo_info;
           _s88F::P64 = P64[R1 + 16];
           R2 = _s88F::P64;
           P64[Sp - 40] = _s88F::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ceEo() //  [R1]
         { info_tbl: [(ceEo,
                       label: block_ceEo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceEo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ceEN; else goto ceEM;
       ceEN: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ceEM: // global
           I64[Hp - 32] = sat_s88K_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 32;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmsome_entry() //  [R2, R3]
         { info_tbl: [(ceEO,
                       label: GHC.Base.$dmsome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceEO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceES; else goto ceER;
       ceES: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceER: // global
           I64[Hp - 24] = some_v_s88H_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.557404404 UTC

[section ""data" . GHC.Base.$dmmany_closure" {
     GHC.Base.$dmmany_closure:
         const GHC.Base.$dmmany_info;
 },
 $dApplicative_s88O_entry() //  [R1]
         { info_tbl: [(ceFt,
                       label: $dApplicative_s88O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceFt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceFu; else goto ceFv;
       ceFu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceFv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s88Q_entry() //  [R1]
         { info_tbl: [(ceFA,
                       label: sat_s88Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceFA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceFB; else goto ceFC;
       ceFB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceFC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s88P_entry() //  [R1]
         { info_tbl: [(ceFH,
                       label: sat_s88P_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceFH: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ceFI; else goto ceFJ;
       ceFI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceFJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 many_v_s88N_entry() //  [R1]
         { info_tbl: [(ceFK,
                       label: many_v_s88N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceFK: // global
           _s88N::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto ceFL; else goto ceFM;
       ceFM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ceFO; else goto ceFN;
       ceFO: // global
           HpAlloc = 88;
           goto ceFL;
       ceFL: // global
           R1 = _s88N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceFN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s88N::P64;
           _s88L::P64 = P64[_s88N::P64 + 16];
           _s88M::P64 = P64[_s88N::P64 + 24];
           I64[Hp - 80] = $dApplicative_s88O_info;
           P64[Hp - 64] = _s88L::P64;
           I64[Hp - 56] = sat_s88Q_info;
           _ceFp::P64 = Hp - 80;
           P64[Hp - 40] = _ceFp::P64;
           I64[Hp - 32] = sat_s88P_info;
           P64[Hp - 16] = _s88M::P64;
           P64[Hp - 8] = _s88N::P64;
           P64[Hp] = _ceFp::P64;
           R2 = _s88L::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmmany_entry() //  [R2, R3]
         { info_tbl: [(ceFP,
                       label: GHC.Base.$dmmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceFP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceFT; else goto ceFS;
       ceFT: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceFS: // global
           I64[Hp - 24] = many_v_s88N_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.570480226 UTC

[section ""data" . GHC.Base.$w$csconcat3_closure" {
     GHC.Base.$w$csconcat3_closure:
         const GHC.Base.$w$csconcat3_info;
 },
 sat_s894_entry() //  [R1, R2]
         { info_tbl: [(ceGF,
                       label: sat_s894_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceGF: // global
           _s891::P64 = R2;
           _s894::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ceGG; else goto ceGH;
       ceGH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ceGJ; else goto ceGI;
       ceGJ: // global
           HpAlloc = 64;
           goto ceGG;
       ceGG: // global
           R2 = _s891::P64;
           R1 = _s894::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceGI: // global
           _s88R::P64 = P64[_s894::P64 + 7];
           _s88V::P64 = P64[_s894::P64 + 15];
           _s890::P64 = P64[_s894::P64 + 23];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s890::P64;
           P64[Hp - 32] = _s891::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s88V::P64;
           P64[Hp] = _s891::P64;
           R2 = _s88R::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 go_s88U_entry() //  [R1, R2, R3]
         { info_tbl: [(ceGO,
                       label: go_s88U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceGO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceGP; else goto ceGQ;
       ceGP: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceGQ: // global
           I64[Sp - 32] = block_ceGr_info;
           _s88U::P64 = R1;
           _s88R::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s88R::P64;
           P64[Sp - 16] = _s88U::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ueGW; else goto ceGs;
       ueGW: // global
           call _ceGr(R1) args: 0, res: 0, upd: 0;
       ceGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceGr() //  [R1]
         { info_tbl: [(ceGr,
                       label: block_ceGr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceGr: // global
           _s88V::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ceGL; else goto ceGM;
       ceGL: // global
           R1 = _s88V::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ceGM: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ceGV; else goto ceGU;
       ceGV: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceGU: // global
           _s88Y::P64 = P64[R1 + 6];
           _s88Z::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _s88Y::P64;
           P64[Hp - 32] = _s88Z::P64;
           I64[Hp - 24] = sat_s894_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s88V::P64;
           P64[Hp] = Hp - 64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat3_entry() //  [R2, R3, R4]
         { info_tbl: [(ceGX,
                       label: GHC.Base.$w$csconcat3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceGX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceH1; else goto ceH0;
       ceH1: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceH0: // global
           I64[Hp - 8] = go_s88U_info;
           P64[Hp] = R2;
           _s88S::P64 = R3;
           R3 = R4;
           R2 = _s88S::P64;
           R1 = Hp - 6;
           call go_s88U_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.581705549 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$csconcat_closure" {
     GHC.Base.$fSemigroup(->)_$csconcat_closure:
         const GHC.Base.$fSemigroup(->)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(->)_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(ceHx,
                       label: GHC.Base.$fSemigroup(->)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceHx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceHy; else goto ceHz;
       ceHy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceHz: // global
           I64[Sp - 16] = block_ceHu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueHD; else goto ceHv;
       ueHD: // global
           call _ceHu(R1) args: 0, res: 0, upd: 0;
       ceHv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceHu() //  [R1]
         { info_tbl: [(ceHu,
                       label: block_ceHu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceHu: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.588033959 UTC

[section ""data" . GHC.Base.$w$csconcat_closure" {
     GHC.Base.$w$csconcat_closure:
         const GHC.Base.$w$csconcat_info;
 },
 sat_s89t_entry() //  [R1]
         { info_tbl: [(ceId,
                       label: sat_s89t_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceId: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ceIe; else goto ceIf;
       ceIe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceIf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s89s_entry() //  [R1]
         { info_tbl: [(ceIk,
                       label: sat_s89s_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceIk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ceIl; else goto ceIm;
       ceIl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceIm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s89f_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ceIr,
                       label: $wgo_s89f_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceIr: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ceIs; else goto ceIt;
       ceIs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceIt: // global
           I64[Sp - 48] = block_ceHW_info;
           _s89f::P64 = R1;
           _s89a::P64 = P64[R1 + 5];
           _s89b::P64 = P64[R1 + 13];
           R1 = R4;
           P64[Sp - 40] = _s89a::P64;
           P64[Sp - 32] = _s89b::P64;
           P64[Sp - 24] = _s89f::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ueIC; else goto ceHX;
       ueIC: // global
           call _ceHW(R1) args: 0, res: 0, upd: 0;
       ceHX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceHW() //  [R1]
         { info_tbl: [(ceHW,
                       label: block_ceHW_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceHW: // global
           if (R1 & 7 == 1) goto ceIo; else goto ceIp;
       ceIo: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ceIp: // global
           I64[Sp - 8] = block_ceI2_info;
           _s89l::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s89l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueIB; else goto ceI3;
       ueIB: // global
           call _ceI2(R1) args: 0, res: 0, upd: 0;
       ceI3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceI2() //  [R1]
         { info_tbl: [(ceI2,
                       label: block_ceI2_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceI2: // global
           _s89l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ceI7_info;
           R4 = _s89l::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           Sp = Sp + 8;
           call $wgo_s89f_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceI7() //  [R1, R2]
         { info_tbl: [(ceI7,
                       label: block_ceI7_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceI7: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ceIA; else goto ceIz;
       ceIA: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceIz: // global
           I64[Hp - 72] = sat_s89t_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s89s_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ceID,
                       label: GHC.Base.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceID: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceIH; else goto ceIG;
       ceIH: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceIG: // global
           I64[Hp - 16] = $wgo_s89f_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _s89c::P64 = R4;
           R4 = R6;
           R3 = R5;
           R2 = _s89c::P64;
           R1 = Hp - 13;
           call $wgo_s89f_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.609499574 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,)_$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(ceJs,
                       label: GHC.Base.$fSemigroup(,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceJs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceJD; else goto ceJE;
       ceJD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceJE: // global
           I64[Sp - 24] = block_ceJp_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueJL; else goto ceJq;
       ueJL: // global
           call _ceJp(R1) args: 0, res: 0, upd: 0;
       ceJq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceJp() //  [R1]
         { info_tbl: [(ceJp,
                       label: block_ceJp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceJp: // global
           I64[Sp - 8] = block_ceJv_info;
           _s89z::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s89z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueJK; else goto ceJw;
       ueJK: // global
           call _ceJv(R1) args: 0, res: 0, upd: 0;
       ceJw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceJv() //  [R1]
         { info_tbl: [(ceJv,
                       label: block_ceJv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceJv: // global
           _s89v::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ceJA_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s89v::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Base.$w$csconcat_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _ceJA() //  [R1, R2]
         { info_tbl: [(ceJA,
                       label: block_ceJA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceJA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceJJ; else goto ceJI;
       ceJJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceJI: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.623599379 UTC

[section ""data" . GHC.Base.$dmsconcat_closure" {
     GHC.Base.$dmsconcat_closure:
         const GHC.Base.$dmsconcat_info;
 },
 go_s89L_entry() //  [R1, R2, R3]
         { info_tbl: [(ceKo,
                       label: go_s89L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceKo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceKp; else goto ceKq;
       ceKp: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceKq: // global
           I64[Sp - 32] = block_ceKh_info;
           _s89L::P64 = R1;
           _s89G::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s89G::P64;
           P64[Sp - 16] = _s89L::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ueKA; else goto ceKi;
       ueKA: // global
           call _ceKh(R1) args: 0, res: 0, upd: 0;
       ceKi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceKh() //  [R1]
         { info_tbl: [(ceKh,
                       label: block_ceKh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceKh: // global
           _s89M::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ceKl; else goto ceKm;
       ceKl: // global
           R1 = _s89M::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ceKm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ceKy; else goto ceKx;
       ceKy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceKx: // global
           _s89P::P64 = P64[R1 + 6];
           _s89Q::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s89P::P64;
           P64[Hp] = _s89Q::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s89M::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$dmsconcat_entry() //  [R2, R3]
         { info_tbl: [(ceKB,
                       label: GHC.Base.$dmsconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceKB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceKC; else goto ceKD;
       ceKC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceKD: // global
           I64[Sp - 16] = block_ceK7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueKH; else goto ceK8;
       ueKH: // global
           call _ceK7(R1) args: 0, res: 0, upd: 0;
       ceK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceK7() //  [R1]
         { info_tbl: [(ceK7,
                       label: block_ceK7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceK7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceKG; else goto ceKF;
       ceKG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceKF: // global
           _s89J::P64 = P64[R1 + 7];
           _s89K::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_s89L_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _s89K::P64;
           R2 = _s89J::P64;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call go_s89L_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.634456666 UTC

[section ""data" . GHC.Base.$dmstimes_closure" {
     GHC.Base.$dmstimes_closure:
         const GHC.Base.$dmstimes_info;
         const 0;
 },
 GHC.Base.$dmstimes_entry() //  [R2, R3]
         { info_tbl: [(ceL8,
                       label: GHC.Base.$dmstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceL8: // global
           _s89T::P64 = R3;
           R3 = R2;
           R2 = _s89T::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.638040374 UTC

[section ""data" . GHC.Base.$dmmappend_closure" {
     GHC.Base.$dmmappend_closure:
         const GHC.Base.$dmmappend_info;
 },
 GHC.Base.$dmmappend_entry() //  [R2]
         { info_tbl: [(ceLl,
                       label: GHC.Base.$dmmappend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceLl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceLm; else goto ceLn;
       ceLm: // global
           R2 = R2;
           R1 = GHC.Base.$dmmappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceLn: // global
           I64[Sp - 8] = block_ceLj_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ceLj() //  [R1]
         { info_tbl: [(ceLj,
                       label: block_ceLj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceLj: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.64333437 UTC

[section ""data" . GHC.Base.$dm>>_closure" {
     GHC.Base.$dm>>_closure:
         const GHC.Base.$dm>>_info;
 },
 sat_s8a0_entry() //  [R1]
         { info_tbl: [(ceLI,
                       label: sat_s8a0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceLI: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$dm>>_entry() //  [R2, R3, R4]
         { info_tbl: [(ceLL,
                       label: GHC.Base.$dm>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceLL: // global
           _s89Y::P64 = R4;
           _s89X::P64 = R3;
           _s89W::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto ceLM; else goto ceLN;
       ceLN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceLP; else goto ceLO;
       ceLP: // global
           HpAlloc = 16;
           goto ceLM;
       ceLM: // global
           R4 = _s89Y::P64;
           R3 = _s89X::P64;
           R2 = _s89W::P64;
           R1 = GHC.Base.$dm>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceLO: // global
           I64[Hp - 8] = sat_s8a0_info;
           P64[Hp] = _s89Y::P64;
           R2 = _s89W::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s89X::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.649569001 UTC

[section ""data" . GHC.Base.$dmreturn_closure" {
     GHC.Base.$dmreturn_closure:
         const GHC.Base.$dmreturn_info;
 },
 GHC.Base.$dmreturn_entry() //  [R2]
         { info_tbl: [(ceM5,
                       label: GHC.Base.$dmreturn_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceM5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceM6; else goto ceM7;
       ceM6: // global
           R2 = R2;
           R1 = GHC.Base.$dmreturn_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceM7: // global
           I64[Sp - 8] = block_ceM3_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ceM3() //  [R1]
         { info_tbl: [(ceM3,
                       label: block_ceM3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceM3: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.654495601 UTC

[section ""data" . GHC.Base.$dmfail_closure" {
     GHC.Base.$dmfail_closure:
         const GHC.Base.$dmfail_info;
         const 0;
 },
 GHC.Base.$dmfail_entry() //  [R3]
         { info_tbl: [(ceMn,
                       label: GHC.Base.$dmfail_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceMn: // global
           R2 = R3;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.658449045 UTC

[section ""data" . GHC.Base.$dmmzero_closure" {
     GHC.Base.$dmmzero_closure:
         const GHC.Base.$dmmzero_info;
 },
 GHC.Base.$dmmzero_entry() //  [R2]
         { info_tbl: [(ceMA,
                       label: GHC.Base.$dmmzero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceMA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceMB; else goto ceMC;
       ceMB: // global
           R2 = R2;
           R1 = GHC.Base.$dmmzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceMC: // global
           I64[Sp - 8] = block_ceMy_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ceMy() //  [R1]
         { info_tbl: [(ceMy,
                       label: block_ceMy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceMy: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.663634508 UTC

[section ""data" . GHC.Base.$dmmplus_closure" {
     GHC.Base.$dmmplus_closure:
         const GHC.Base.$dmmplus_info;
 },
 GHC.Base.$dmmplus_entry() //  [R2]
         { info_tbl: [(ceMU,
                       label: GHC.Base.$dmmplus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceMU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceMV; else goto ceMW;
       ceMV: // global
           R2 = R2;
           R1 = GHC.Base.$dmmplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceMW: // global
           I64[Sp - 8] = block_ceMS_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ceMS() //  [R1]
         { info_tbl: [(ceMS,
                       label: block_ceMS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceMS: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.669150034 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c==_closure" {
     GHC.Base.$fEqMaybe_$c==_closure:
         const GHC.Base.$fEqMaybe_$c==_info;
 },
 GHC.Base.$fEqMaybe_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(ceNj,
                       label: GHC.Base.$fEqMaybe_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceNj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceNk; else goto ceNl;
       ceNk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceNl: // global
           I64[Sp - 24] = block_ceNc_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueNW; else goto ceNd;
       ueNW: // global
           call _ceNc(R1) args: 0, res: 0, upd: 0;
       ceNd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceNc() //  [R1]
         { info_tbl: [(ceNc,
                       label: block_ceNc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceNc: // global
           _s8ab::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceNg; else goto ceNh;
       ceNg: // global
           I64[Sp + 16] = block_ceNo_info;
           R1 = _s8ab::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueNU; else goto ceNq;
       ueNU: // global
           call _ceNo(R1) args: 0, res: 0, upd: 0;
       ceNq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceNh: // global
           I64[Sp] = block_ceND_info;
           _s8af::P64 = P64[R1 + 6];
           R1 = _s8ab::P64;
           P64[Sp + 16] = _s8af::P64;
           if (R1 & 7 != 0) goto ueNV; else goto ceNF;
       ueNV: // global
           call _ceND(R1) args: 0, res: 0, upd: 0;
       ceNF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceNo() //  [R1]
         { info_tbl: [(ceNo,
                       label: block_ceNo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceNo: // global
           if (R1 & 7 == 1) goto ceNw; else goto ueNT;
       ceNw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ueNT: // global
           Sp = Sp + 8;
           call _ceNL() args: 0, res: 0, upd: 0;
     }
 },
 _ceND() //  [R1]
         { info_tbl: [(ceND,
                       label: block_ceND_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceND: // global
           if (R1 & 7 == 1) goto ueNS; else goto ceNP;
       ueNS: // global
           Sp = Sp + 24;
           call _ceNL() args: 0, res: 0, upd: 0;
       ceNP: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _ceNL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceNL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.68048573 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c/=_closure" {
     GHC.Base.$fEqMaybe_$c/=_closure:
         const GHC.Base.$fEqMaybe_$c/=_info;
 },
 GHC.Base.$fEqMaybe_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(ceOD,
                       label: GHC.Base.$fEqMaybe_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceOD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceOE; else goto ceOF;
       ceOE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceOF: // global
           I64[Sp - 24] = block_ceOw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uePv; else goto ceOx;
       uePv: // global
           call _ceOw(R1) args: 0, res: 0, upd: 0;
       ceOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceOw() //  [R1]
         { info_tbl: [(ceOw,
                       label: block_ceOw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceOw: // global
           _s8ak::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceOA; else goto ceOB;
       ceOA: // global
           I64[Sp + 16] = block_ceOI_info;
           R1 = _s8ak::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uePt; else goto ceOK;
       uePt: // global
           call _ceOI(R1) args: 0, res: 0, upd: 0;
       ceOK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceOB: // global
           I64[Sp] = block_ceOX_info;
           _s8ao::P64 = P64[R1 + 6];
           R1 = _s8ak::P64;
           P64[Sp + 16] = _s8ao::P64;
           if (R1 & 7 != 0) goto uePu; else goto ceOZ;
       uePu: // global
           call _ceOX(R1) args: 0, res: 0, upd: 0;
       ceOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceOI() //  [R1]
         { info_tbl: [(ceOI,
                       label: block_ceOI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceOI: // global
           if (R1 & 7 == 1) goto uePr; else goto uePs;
       uePr: // global
           Sp = Sp + 8;
           call _cePk() args: 0, res: 0, upd: 0;
       uePs: // global
           Sp = Sp + 8;
           call _cePg() args: 0, res: 0, upd: 0;
     }
 },
 _ceOX() //  [R1]
         { info_tbl: [(ceOX,
                       label: block_ceOX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceOX: // global
           if (R1 & 7 == 1) goto uePo; else goto cePa;
       uePo: // global
           Sp = Sp + 24;
           call _cePg() args: 0, res: 0, upd: 0;
       cePa: // global
           _s8ao::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ceP8_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8ao::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ceP8() //  [R1]
         { info_tbl: [(ceP8,
                       label: block_ceP8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceP8: // global
           if (R1 & 7 == 1) goto uePp; else goto uePq;
       uePp: // global
           Sp = Sp + 8;
           call _cePg() args: 0, res: 0, upd: 0;
       uePq: // global
           Sp = Sp + 8;
           call _cePk() args: 0, res: 0, upd: 0;
     }
 },
 _cePg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cePg: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cePk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cePk: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.693747329 UTC

[section ""data" . GHC.Base.$fEqMaybe_closure" {
     GHC.Base.$fEqMaybe_closure:
         const GHC.Base.$fEqMaybe_info;
 },
 sat_s8au_entry() //  [R1, R2, R3]
         { info_tbl: [(ceQj,
                       label: sat_s8au_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceQj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8at_entry() //  [R1, R2, R3]
         { info_tbl: [(ceQr,
                       label: sat_s8at_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceQr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fEqMaybe_entry() //  [R2]
         { info_tbl: [(ceQv,
                       label: GHC.Base.$fEqMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceQv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ceQz; else goto ceQy;
       ceQz: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceQy: // global
           I64[Hp - 48] = sat_s8au_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8at_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.701188426 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cp1Ord_closure" {
     GHC.Base.$fOrdMaybe_$cp1Ord_closure:
         const GHC.Base.$fOrdMaybe_$cp1Ord_info;
 },
 sat_s8aw_entry() //  [R1]
         { info_tbl: [(ceQV,
                       label: sat_s8aw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceQV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceQW; else goto ceQX;
       ceQW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceQX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdMaybe_$cp1Ord_entry() //  [R2]
         { info_tbl: [(ceQY,
                       label: GHC.Base.$fOrdMaybe_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceQY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceR2; else goto ceR1;
       ceR2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceR1: // global
           I64[Hp - 16] = sat_s8aw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqMaybe_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.707334016 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$ccompare_closure" {
     GHC.Base.$fOrdMaybe_$ccompare_closure:
         const GHC.Base.$fOrdMaybe_$ccompare_info;
 },
 GHC.Base.$fOrdMaybe_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(ceRm,
                       label: GHC.Base.$fOrdMaybe_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceRm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceRn; else goto ceRo;
       ceRn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceRo: // global
           I64[Sp - 24] = block_ceRf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueRX; else goto ceRg;
       ueRX: // global
           call _ceRf(R1) args: 0, res: 0, upd: 0;
       ceRg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceRf() //  [R1]
         { info_tbl: [(ceRf,
                       label: block_ceRf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceRf: // global
           _s8az::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceRj; else goto ceRk;
       ceRj: // global
           I64[Sp + 16] = block_ceRr_info;
           R1 = _s8az::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueRV; else goto ceRt;
       ueRV: // global
           call _ceRr(R1) args: 0, res: 0, upd: 0;
       ceRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceRk: // global
           I64[Sp] = block_ceRG_info;
           _s8aD::P64 = P64[R1 + 6];
           R1 = _s8az::P64;
           P64[Sp + 16] = _s8aD::P64;
           if (R1 & 7 != 0) goto ueRW; else goto ceRI;
       ueRW: // global
           call _ceRG(R1) args: 0, res: 0, upd: 0;
       ceRI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceRr() //  [R1]
         { info_tbl: [(ceRr,
                       label: block_ceRr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceRr: // global
           if (R1 & 7 == 1) goto ceRz; else goto ceRD;
       ceRz: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceRD: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ceRG() //  [R1]
         { info_tbl: [(ceRG,
                       label: block_ceRG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceRG: // global
           if (R1 & 7 == 1) goto ceRO; else goto ceRS;
       ceRO: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceRS: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.717735926 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<_closure" {
     GHC.Base.$fOrdMaybe_$c<_closure:
         const GHC.Base.$fOrdMaybe_$c<_info;
 },
 GHC.Base.$fOrdMaybe_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(ceSB,
                       label: GHC.Base.$fOrdMaybe_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceSB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceSC; else goto ceSD;
       ceSC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceSD: // global
           I64[Sp - 24] = block_ceSu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueTe; else goto ceSv;
       ueTe: // global
           call _ceSu(R1) args: 0, res: 0, upd: 0;
       ceSv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceSu() //  [R1]
         { info_tbl: [(ceSu,
                       label: block_ceSu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceSu: // global
           _s8aI::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceSy; else goto ceSz;
       ceSy: // global
           I64[Sp + 16] = block_ceSG_info;
           R1 = _s8aI::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueTc; else goto ceSI;
       ueTc: // global
           call _ceSG(R1) args: 0, res: 0, upd: 0;
       ceSI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceSz: // global
           I64[Sp] = block_ceSV_info;
           _s8aM::P64 = P64[R1 + 6];
           R1 = _s8aI::P64;
           P64[Sp + 16] = _s8aM::P64;
           if (R1 & 7 != 0) goto ueTd; else goto ceSX;
       ueTd: // global
           call _ceSV(R1) args: 0, res: 0, upd: 0;
       ceSX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceSG() //  [R1]
         { info_tbl: [(ceSG,
                       label: block_ceSG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceSG: // global
           if (R1 & 7 == 1) goto ueTb; else goto ceSS;
       ueTb: // global
           Sp = Sp + 8;
           call _ceT3() args: 0, res: 0, upd: 0;
       ceSS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ceSV() //  [R1]
         { info_tbl: [(ceSV,
                       label: block_ceSV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceSV: // global
           if (R1 & 7 == 1) goto ueTa; else goto ceT7;
       ueTa: // global
           Sp = Sp + 24;
           call _ceT3() args: 0, res: 0, upd: 0;
       ceT7: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _ceT3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceT3: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.73031845 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<=_closure" {
     GHC.Base.$fOrdMaybe_$c<=_closure:
         const GHC.Base.$fOrdMaybe_$c<=_info;
 },
 GHC.Base.$fOrdMaybe_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(ceTV,
                       label: GHC.Base.$fOrdMaybe_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceTV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceTW; else goto ceTX;
       ceTW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceTX: // global
           I64[Sp - 24] = block_ceTO_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueUN; else goto ceTP;
       ueUN: // global
           call _ceTO(R1) args: 0, res: 0, upd: 0;
       ceTP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceTO() //  [R1]
         { info_tbl: [(ceTO,
                       label: block_ceTO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceTO: // global
           _s8aQ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceTS; else goto ceTT;
       ceTS: // global
           I64[Sp + 16] = block_ceU0_info;
           R1 = _s8aQ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueUL; else goto ceU2;
       ueUL: // global
           call _ceU0(R1) args: 0, res: 0, upd: 0;
       ceU2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceTT: // global
           I64[Sp] = block_ceUf_info;
           _s8aV::P64 = P64[R1 + 6];
           R1 = _s8aQ::P64;
           P64[Sp + 16] = _s8aV::P64;
           if (R1 & 7 != 0) goto ueUM; else goto ceUh;
       ueUM: // global
           call _ceUf(R1) args: 0, res: 0, upd: 0;
       ceUh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceU0() //  [R1]
         { info_tbl: [(ceU0,
                       label: block_ceU0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceU0: // global
           if (R1 & 7 == 1) goto ueUJ; else goto ueUK;
       ueUJ: // global
           Sp = Sp + 8;
           call _ceUy() args: 0, res: 0, upd: 0;
       ueUK: // global
           Sp = Sp + 8;
           call _ceUC() args: 0, res: 0, upd: 0;
     }
 },
 _ceUf() //  [R1]
         { info_tbl: [(ceUf,
                       label: block_ceUf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceUf: // global
           if (R1 & 7 == 1) goto ueUG; else goto ceUs;
       ueUG: // global
           Sp = Sp + 24;
           call _ceUy() args: 0, res: 0, upd: 0;
       ceUs: // global
           _s8aV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ceUq_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8aV::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ceUq() //  [R1]
         { info_tbl: [(ceUq,
                       label: block_ceUq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceUq: // global
           if (R1 & 7 == 1) goto ueUH; else goto ueUI;
       ueUH: // global
           Sp = Sp + 8;
           call _ceUy() args: 0, res: 0, upd: 0;
       ueUI: // global
           Sp = Sp + 8;
           call _ceUC() args: 0, res: 0, upd: 0;
     }
 },
 _ceUy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceUy: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ceUC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceUC: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.743687843 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmax_closure" {
     GHC.Base.$fOrdMaybe_$cmax_closure:
         const GHC.Base.$fOrdMaybe_$cmax_info;
 },
 GHC.Base.$fOrdMaybe_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(ceVD,
                       label: GHC.Base.$fOrdMaybe_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceVD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ceVE; else goto ceVF;
       ceVE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceVF: // global
           I64[Sp - 24] = block_ceVw_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueWe; else goto ceVx;
       ueWe: // global
           call _ceVw(R1) args: 0, res: 0, upd: 0;
       ceVx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceVw() //  [R1]
         { info_tbl: [(ceVw,
                       label: block_ceVw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceVw: // global
           _s8b0::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceVA; else goto ceVB;
       ceVA: // global
           R1 = _s8b0::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ceVB: // global
           I64[Sp - 8] = block_ceVL_info;
           _s8b2::P64 = R1;
           _s8b3::P64 = P64[R1 + 6];
           R1 = _s8b0::P64;
           P64[Sp] = _s8b3::P64;
           P64[Sp + 16] = _s8b2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueWd; else goto ceVN;
       ueWd: // global
           call _ceVL(R1) args: 0, res: 0, upd: 0;
       ceVN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceVL() //  [R1]
         { info_tbl: [(ceVL,
                       label: block_ceVL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceVL: // global
           if (R1 & 7 == 1) goto ueWb; else goto ceVY;
       ueWb: // global
           Sp = Sp + 24;
           call _ceW4() args: 0, res: 0, upd: 0;
       ceVY: // global
           _s8b3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ceVW_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s8b3::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ceVW() //  [R1]
         { info_tbl: [(ceVW,
                       label: block_ceVW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceVW: // global
           if (R1 & 7 == 1) goto ueWc; else goto ceW8;
       ueWc: // global
           Sp = Sp + 16;
           call _ceW4() args: 0, res: 0, upd: 0;
       ceW8: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ceW4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceW4: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.754884543 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmin_closure" {
     GHC.Base.$fOrdMaybe_$cmin_closure:
         const GHC.Base.$fOrdMaybe_$cmin_info;
 },
 GHC.Base.$fOrdMaybe_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(ceWX,
                       label: GHC.Base.$fOrdMaybe_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceWX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ceWY; else goto ceWZ;
       ceWY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceWZ: // global
           I64[Sp - 24] = block_ceWQ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueXD; else goto ceWR;
       ueXD: // global
           call _ceWQ(R1) args: 0, res: 0, upd: 0;
       ceWR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceWQ() //  [R1]
         { info_tbl: [(ceWQ,
                       label: block_ceWQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceWQ: // global
           _s8b8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceWU; else goto ceWV;
       ceWU: // global
           I64[Sp + 16] = block_ceX2_info;
           R1 = _s8b8::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueXB; else goto ceX4;
       ueXB: // global
           call _ceX2() args: 0, res: 0, upd: 0;
       ceX4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceWV: // global
           I64[Sp - 8] = block_ceXb_info;
           _s8ba::P64 = R1;
           _s8bc::P64 = P64[R1 + 6];
           R1 = _s8b8::P64;
           P64[Sp] = _s8bc::P64;
           P64[Sp + 16] = _s8ba::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueXC; else goto ceXd;
       ueXC: // global
           call _ceXb(R1) args: 0, res: 0, upd: 0;
       ceXd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceX2() //  []
         { info_tbl: [(ceX2,
                       label: block_ceX2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceX2: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ceXb() //  [R1]
         { info_tbl: [(ceXb,
                       label: block_ceXb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceXb: // global
           if (R1 & 7 == 1) goto ceXj; else goto ceXo;
       ceXj: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceXo: // global
           _s8bc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ceXm_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s8bc::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ceXm() //  [R1]
         { info_tbl: [(ceXm,
                       label: block_ceXm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceXm: // global
           if (R1 & 7 == 1) goto ceXu; else goto ceXy;
       ceXu: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ceXy: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.767491905 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c>=_closure" {
     GHC.Base.$fOrdMaybe_$c>=_closure:
         const GHC.Base.$fOrdMaybe_$c>=_info;
 },
 GHC.Base.$fOrdMaybe_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(ceYm,
                       label: GHC.Base.$fOrdMaybe_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceYm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceYn; else goto ceYo;
       ceYn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceYo: // global
           I64[Sp - 24] = block_ceYf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueZe; else goto ceYg;
       ueZe: // global
           call _ceYf(R1) args: 0, res: 0, upd: 0;
       ceYg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceYf() //  [R1]
         { info_tbl: [(ceYf,
                       label: block_ceYf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceYf: // global
           _s8bi::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceYj; else goto ceYk;
       ceYj: // global
           I64[Sp + 16] = block_ceYr_info;
           R1 = _s8bi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueZc; else goto ceYt;
       ueZc: // global
           call _ceYr(R1) args: 0, res: 0, upd: 0;
       ceYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceYk: // global
           I64[Sp] = block_ceYG_info;
           _s8bm::P64 = P64[R1 + 6];
           R1 = _s8bi::P64;
           P64[Sp + 16] = _s8bm::P64;
           if (R1 & 7 != 0) goto ueZd; else goto ceYI;
       ueZd: // global
           call _ceYG(R1) args: 0, res: 0, upd: 0;
       ceYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ceYr() //  [R1]
         { info_tbl: [(ceYr,
                       label: block_ceYr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceYr: // global
           if (R1 & 7 == 1) goto ueZa; else goto ueZb;
       ueZa: // global
           Sp = Sp + 8;
           call _ceYZ() args: 0, res: 0, upd: 0;
       ueZb: // global
           Sp = Sp + 8;
           call _ceZ3() args: 0, res: 0, upd: 0;
     }
 },
 _ceYG() //  [R1]
         { info_tbl: [(ceYG,
                       label: block_ceYG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceYG: // global
           if (R1 & 7 == 1) goto ueZ7; else goto ceYT;
       ueZ7: // global
           Sp = Sp + 24;
           call _ceYZ() args: 0, res: 0, upd: 0;
       ceYT: // global
           _s8bm::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ceYR_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8bm::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _ceYR() //  [R1]
         { info_tbl: [(ceYR,
                       label: block_ceYR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceYR: // global
           if (R1 & 7 == 1) goto ueZ8; else goto ueZ9;
       ueZ8: // global
           Sp = Sp + 8;
           call _ceYZ() args: 0, res: 0, upd: 0;
       ueZ9: // global
           Sp = Sp + 8;
           call _ceZ3() args: 0, res: 0, upd: 0;
     }
 },
 _ceYZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceYZ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ceZ3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ceZ3: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.781762635 UTC

[section ""data" . GHC.Base.$fOrdMaybe_closure" {
     GHC.Base.$fOrdMaybe_closure:
         const GHC.Base.$fOrdMaybe_info;
 },
 sat_s8bA_entry() //  [R1, R2, R3]
         { info_tbl: [(cf02,
                       label: sat_s8bA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf02: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bz_entry() //  [R1, R2, R3]
         { info_tbl: [(cf0a,
                       label: sat_s8bz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf0a: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8by_entry() //  [R1, R2, R3]
         { info_tbl: [(cf0i,
                       label: sat_s8by_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf0i: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bx_entry() //  [R1, R2, R3]
         { info_tbl: [(cf0q,
                       label: sat_s8bx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf0q: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bu_entry() //  [R1, R2, R3]
         { info_tbl: [(cf0y,
                       label: sat_s8bu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf0y: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bt_entry() //  [R1, R2, R3]
         { info_tbl: [(cf0G,
                       label: sat_s8bt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf0G: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8bs_entry() //  [R1, R2, R3]
         { info_tbl: [(cf0O,
                       label: sat_s8bs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf0O: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8br_entry() //  [R1]
         { info_tbl: [(cf0V,
                       label: sat_s8br_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf0V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cf0W; else goto cf0X;
       cf0W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cf0X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdMaybe_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdMaybe_entry() //  [R2]
         { info_tbl: [(cf0Z,
                       label: GHC.Base.$fOrdMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf0Z: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cf13; else goto cf12;
       cf13: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cf12: // global
           I64[Hp - 200] = sat_s8bA_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s8bz_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8by_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s8bx_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s8bu_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s8bt_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8bs_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8br_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.799929434 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c/=_closure" {
     GHC.Base.$fEqNonEmpty_$c/=_closure:
         const GHC.Base.$fEqNonEmpty_$c/=_info;
 },
 GHC.Base.$fEqNonEmpty_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(cf1N,
                       label: GHC.Base.$fEqNonEmpty_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf1N: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf1R; else goto cf1S;
       cf1R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf1S: // global
           I64[Sp - 24] = block_cf1K_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf2q; else goto cf1L;
       uf2q: // global
           call _cf1K(R1) args: 0, res: 0, upd: 0;
       cf1L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf1K() //  [R1]
         { info_tbl: [(cf1K,
                       label: block_cf1K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf1K: // global
           I64[Sp - 8] = block_cf1Q_info;
           _s8bF::P64 = P64[R1 + 7];
           _s8bG::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8bG::P64;
           P64[Sp + 16] = _s8bF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf2p; else goto cf1U;
       uf2p: // global
           call _cf1Q(R1) args: 0, res: 0, upd: 0;
       cf1U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf1Q() //  [R1]
         { info_tbl: [(cf1Q,
                       label: block_cf1Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf1Q: // global
           I64[Sp] = block_cf1Y_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cf1Y() //  [R1]
         { info_tbl: [(cf1Y,
                       label: block_cf1Y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf1Y: // global
           if (R1 & 7 == 1) goto uf2n; else goto cf2a;
       uf2n: // global
           Sp = Sp + 32;
           call _cf2g() args: 0, res: 0, upd: 0;
       cf2a: // global
           _s8bJ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cf28_info;
           R4 = _s8bJ::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cf28() //  [R1]
         { info_tbl: [(cf28,
                       label: block_cf28_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf28: // global
           if (R1 & 7 == 1) goto uf2o; else goto cf2k;
       uf2o: // global
           Sp = Sp + 8;
           call _cf2g() args: 0, res: 0, upd: 0;
       cf2k: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cf2g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf2g: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.812467555 UTC

[section ""data" . GHC.Base.$w$c==_closure" {
     GHC.Base.$w$c==_closure:
         const GHC.Base.$w$c==_info;
 },
 GHC.Base.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cf37,
                       label: GHC.Base.$w$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf37: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf38; else goto cf39;
       cf38: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf39: // global
           I64[Sp - 32] = block_cf31_info;
           _s8bM::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8bM::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cf31() //  [R1]
         { info_tbl: [(cf31,
                       label: block_cf31_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf31: // global
           if (R1 & 7 == 1) goto cf34; else goto cf35;
       cf34: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cf35: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.818817528 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c==_closure" {
     GHC.Base.$fEqNonEmpty_$c==_closure:
         const GHC.Base.$fEqNonEmpty_$c==_info;
 },
 GHC.Base.$fEqNonEmpty_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(cf3y,
                       label: GHC.Base.$fEqNonEmpty_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf3y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cf3C; else goto cf3D;
       cf3C: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf3D: // global
           I64[Sp - 24] = block_cf3v_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf3L; else goto cf3w;
       uf3L: // global
           call _cf3v(R1) args: 0, res: 0, upd: 0;
       cf3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf3v() //  [R1]
         { info_tbl: [(cf3v,
                       label: block_cf3v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf3v: // global
           I64[Sp - 8] = block_cf3B_info;
           _s8bW::P64 = P64[R1 + 7];
           _s8bX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8bX::P64;
           P64[Sp + 16] = _s8bW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf3K; else goto cf3F;
       uf3K: // global
           call _cf3B(R1) args: 0, res: 0, upd: 0;
       cf3F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf3B() //  [R1]
         { info_tbl: [(cf3B,
                       label: block_cf3B_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf3B: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c==_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.82663286 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_closure" {
     GHC.Base.$fEqNonEmpty_closure:
         const GHC.Base.$fEqNonEmpty_info;
 },
 sat_s8c3_entry() //  [R1, R2, R3]
         { info_tbl: [(cf48,
                       label: sat_s8c3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf48: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c/=_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8c2_entry() //  [R1, R2, R3]
         { info_tbl: [(cf4g,
                       label: sat_s8c2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf4g: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c==_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fEqNonEmpty_entry() //  [R2]
         { info_tbl: [(cf4k,
                       label: GHC.Base.$fEqNonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf4k: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cf4o; else goto cf4n;
       cf4o: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cf4n: // global
           I64[Hp - 48] = sat_s8c3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8c2_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.83418046 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cp1Ord_closure" {
     GHC.Base.$fOrdNonEmpty_$cp1Ord_closure:
         const GHC.Base.$fOrdNonEmpty_$cp1Ord_info;
 },
 sat_s8c5_entry() //  [R1]
         { info_tbl: [(cf4K,
                       label: sat_s8c5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf4K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cf4L; else goto cf4M;
       cf4L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cf4M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdNonEmpty_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cf4N,
                       label: GHC.Base.$fOrdNonEmpty_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf4N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cf4R; else goto cf4Q;
       cf4R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cf4Q: // global
           I64[Hp - 16] = sat_s8c5_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqNonEmpty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.840153139 UTC

[section ""data" . GHC.Base.$w$ccompare_closure" {
     GHC.Base.$w$ccompare_closure:
         const GHC.Base.$w$ccompare_info;
 },
 GHC.Base.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cf5b,
                       label: GHC.Base.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf5b: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf5c; else goto cf5d;
       cf5c: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf5d: // global
           I64[Sp - 32] = block_cf54_info;
           _s8c6::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8c6::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cf54() //  [R1]
         { info_tbl: [(cf54,
                       label: block_cf54_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf54: // global
           _cf5a::P64 = R1 & 7;
           if (_cf5a::P64 < 3) goto uf5n; else goto cf59;
       uf5n: // global
           if (_cf5a::P64 < 2) goto cf57; else goto cf58;
       cf57: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cf58: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
       cf59: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.846846739 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$ccompare_closure" {
     GHC.Base.$fOrdNonEmpty_$ccompare_closure:
         const GHC.Base.$fOrdNonEmpty_$ccompare_info;
 },
 GHC.Base.$fOrdNonEmpty_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(cf5G,
                       label: GHC.Base.$fOrdNonEmpty_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf5G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cf5K; else goto cf5L;
       cf5K: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf5L: // global
           I64[Sp - 24] = block_cf5D_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf5T; else goto cf5E;
       uf5T: // global
           call _cf5D(R1) args: 0, res: 0, upd: 0;
       cf5E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf5D() //  [R1]
         { info_tbl: [(cf5D,
                       label: block_cf5D_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf5D: // global
           I64[Sp - 8] = block_cf5J_info;
           _s8cg::P64 = P64[R1 + 7];
           _s8ch::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8ch::P64;
           P64[Sp + 16] = _s8cg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf5S; else goto cf5N;
       uf5S: // global
           call _cf5J(R1) args: 0, res: 0, upd: 0;
       cf5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf5J() //  [R1]
         { info_tbl: [(cf5J,
                       label: block_cf5J_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf5J: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.85454215 UTC

[section ""data" . GHC.Base.$w$c<_closure" {
     GHC.Base.$w$c<_closure:
         const GHC.Base.$w$c<_info;
 },
 GHC.Base.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cf6i,
                       label: GHC.Base.$w$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf6i: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf6j; else goto cf6k;
       cf6j: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf6k: // global
           I64[Sp - 32] = block_cf6b_info;
           _s8cl::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8cl::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cf6b() //  [R1]
         { info_tbl: [(cf6b,
                       label: block_cf6b_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf6b: // global
           _cf6h::P64 = R1 & 7;
           if (_cf6h::P64 < 3) goto uf6u; else goto cf6g;
       uf6u: // global
           if (_cf6h::P64 < 2) goto cf6e; else goto cf6f;
       cf6e: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cf6f: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       cf6g: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.861178263 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<_closure" {
     GHC.Base.$fOrdNonEmpty_$c<_closure:
         const GHC.Base.$fOrdNonEmpty_$c<_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(cf6N,
                       label: GHC.Base.$fOrdNonEmpty_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf6N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cf6R; else goto cf6S;
       cf6R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf6S: // global
           I64[Sp - 24] = block_cf6K_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf70; else goto cf6L;
       uf70: // global
           call _cf6K(R1) args: 0, res: 0, upd: 0;
       cf6L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf6K() //  [R1]
         { info_tbl: [(cf6K,
                       label: block_cf6K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf6K: // global
           I64[Sp - 8] = block_cf6Q_info;
           _s8cv::P64 = P64[R1 + 7];
           _s8cw::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8cw::P64;
           P64[Sp + 16] = _s8cv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf6Z; else goto cf6U;
       uf6Z: // global
           call _cf6Q(R1) args: 0, res: 0, upd: 0;
       cf6U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf6Q() //  [R1]
         { info_tbl: [(cf6Q,
                       label: block_cf6Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf6Q: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.869791419 UTC

[section ""data" . GHC.Base.$w$c<=_closure" {
     GHC.Base.$w$c<=_closure:
         const GHC.Base.$w$c<=_info;
 },
 GHC.Base.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cf7p,
                       label: GHC.Base.$w$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf7p: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf7q; else goto cf7r;
       cf7q: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf7r: // global
           I64[Sp - 32] = block_cf7i_info;
           _s8cA::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R5;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _s8cA::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cf7i() //  [R1]
         { info_tbl: [(cf7i,
                       label: block_cf7i_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf7i: // global
           _cf7o::P64 = R1 & 7;
           if (_cf7o::P64 < 3) goto uf7N; else goto uf7O;
       uf7N: // global
           if (_cf7o::P64 < 2) goto uf7P; else goto cf7m;
       uf7P: // global
           Sp = Sp + 32;
           call _cf7I() args: 0, res: 0, upd: 0;
       cf7m: // global
           _s8cE::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cf7x_info;
           R4 = P64[Sp + 16];
           R3 = _s8cE::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       uf7O: // global
           Sp = Sp + 32;
           call _cf7n() args: 0, res: 0, upd: 0;
     }
 },
 _cf7x() //  [R1]
         { info_tbl: [(cf7x,
                       label: block_cf7x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf7x: // global
           if (R1 & 7 == 1) goto uf7Q; else goto uf7R;
       uf7Q: // global
           Sp = Sp + 8;
           call _cf7I() args: 0, res: 0, upd: 0;
       uf7R: // global
           Sp = Sp + 8;
           call _cf7n() args: 0, res: 0, upd: 0;
     }
 },
 _cf7I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf7I: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cf7n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf7n: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.879826392 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<=_closure" {
     GHC.Base.$fOrdNonEmpty_$c<=_closure:
         const GHC.Base.$fOrdNonEmpty_$c<=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(cf8n,
                       label: GHC.Base.$fOrdNonEmpty_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf8n: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cf8r; else goto cf8s;
       cf8r: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf8s: // global
           I64[Sp - 24] = block_cf8k_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf8A; else goto cf8l;
       uf8A: // global
           call _cf8k(R1) args: 0, res: 0, upd: 0;
       cf8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf8k() //  [R1]
         { info_tbl: [(cf8k,
                       label: block_cf8k_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf8k: // global
           I64[Sp - 8] = block_cf8q_info;
           _s8cL::P64 = P64[R1 + 7];
           _s8cM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8cM::P64;
           P64[Sp + 16] = _s8cL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf8z; else goto cf8u;
       uf8z: // global
           call _cf8q(R1) args: 0, res: 0, upd: 0;
       cf8u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf8q() //  [R1]
         { info_tbl: [(cf8q,
                       label: block_cf8q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf8q: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.888340258 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmax_closure" {
     GHC.Base.$fOrdNonEmpty_$cmax_closure:
         const GHC.Base.$fOrdNonEmpty_$cmax_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(cf8V,
                       label: GHC.Base.$fOrdNonEmpty_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf8V: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cf8Z; else goto cf90;
       cf8Z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf90: // global
           I64[Sp - 24] = block_cf8S_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf9F; else goto cf8T;
       uf9F: // global
           call _cf8S(R1) args: 0, res: 0, upd: 0;
       cf8T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf8S() //  [R1]
         { info_tbl: [(cf8S,
                       label: block_cf8S_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf8S: // global
           I64[Sp - 16] = block_cf8Y_info;
           _s8cT::P64 = R1;
           _s8cU::P64 = P64[R1 + 7];
           _s8cV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8cV::P64;
           P64[Sp] = _s8cU::P64;
           P64[Sp + 16] = _s8cT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uf9E; else goto cf92;
       uf9E: // global
           call _cf8Y(R1) args: 0, res: 0, upd: 0;
       cf92: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cf8Y() //  [R1]
         { info_tbl: [(cf8Y,
                       label: block_cf8Y_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf8Y: // global
           I64[Sp - 8] = block_cf96_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cf96() //  [R1]
         { info_tbl: [(cf96,
                       label: block_cf96_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf96: // global
           _cf9x::P64 = R1 & 7;
           if (_cf9x::P64 < 3) goto uf9z; else goto uf9A;
       uf9z: // global
           if (_cf9x::P64 < 2) goto uf9B; else goto cf9i;
       uf9B: // global
           Sp = Sp + 40;
           call _cf9s() args: 0, res: 0, upd: 0;
       cf9i: // global
           _s8cV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cf9g_info;
           R4 = _s8cV::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       uf9A: // global
           Sp = Sp + 24;
           call _cf9w() args: 0, res: 0, upd: 0;
     }
 },
 _cf9g() //  [R1]
         { info_tbl: [(cf9g,
                       label: block_cf9g_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf9g: // global
           if (R1 & 7 == 1) goto uf9C; else goto uf9D;
       uf9C: // global
           Sp = Sp + 24;
           call _cf9s() args: 0, res: 0, upd: 0;
       uf9D: // global
           Sp = Sp + 8;
           call _cf9w() args: 0, res: 0, upd: 0;
     }
 },
 _cf9s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf9s: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cf9w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cf9w: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.901981073 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmin_closure" {
     GHC.Base.$fOrdNonEmpty_$cmin_closure:
         const GHC.Base.$fOrdNonEmpty_$cmin_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(cfao,
                       label: GHC.Base.$fOrdNonEmpty_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfao: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cfas; else goto cfat;
       cfas: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfat: // global
           I64[Sp - 24] = block_cfal_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufb8; else goto cfam;
       ufb8: // global
           call _cfal(R1) args: 0, res: 0, upd: 0;
       cfam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfal() //  [R1]
         { info_tbl: [(cfal,
                       label: block_cfal_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfal: // global
           I64[Sp - 16] = block_cfar_info;
           _s8d4::P64 = R1;
           _s8d5::P64 = P64[R1 + 7];
           _s8d6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8d6::P64;
           P64[Sp] = _s8d5::P64;
           P64[Sp + 16] = _s8d4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufb7; else goto cfav;
       ufb7: // global
           call _cfar(R1) args: 0, res: 0, upd: 0;
       cfav: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfar() //  [R1]
         { info_tbl: [(cfar,
                       label: block_cfar_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfar: // global
           I64[Sp - 8] = block_cfaz_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cfaz() //  [R1]
         { info_tbl: [(cfaz,
                       label: block_cfaz_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfaz: // global
           _cfb0::P64 = R1 & 7;
           if (_cfb0::P64 < 3) goto ufb2; else goto ufb3;
       ufb2: // global
           if (_cfb0::P64 < 2) goto ufb4; else goto cfaL;
       ufb4: // global
           Sp = Sp + 24;
           call _cfaV() args: 0, res: 0, upd: 0;
       cfaL: // global
           _s8d6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cfaJ_info;
           R4 = _s8d6::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ufb3: // global
           Sp = Sp + 40;
           call _cfaZ() args: 0, res: 0, upd: 0;
     }
 },
 _cfaJ() //  [R1]
         { info_tbl: [(cfaJ,
                       label: block_cfaJ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfaJ: // global
           if (R1 & 7 == 1) goto ufb5; else goto ufb6;
       ufb5: // global
           Sp = Sp + 8;
           call _cfaV() args: 0, res: 0, upd: 0;
       ufb6: // global
           Sp = Sp + 24;
           call _cfaZ() args: 0, res: 0, upd: 0;
     }
 },
 _cfaV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfaV: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfaZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfaZ: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.915572048 UTC

[section ""data" . GHC.Base.$w$c>=_closure" {
     GHC.Base.$w$c>=_closure:
         const GHC.Base.$w$c>=_info;
 },
 GHC.Base.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfbV,
                       label: GHC.Base.$w$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfbV: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cfbW; else goto cfbX;
       cfbW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfbX: // global
           I64[Sp - 32] = block_cfbO_info;
           _s8dc::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8dc::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cfbO() //  [R1]
         { info_tbl: [(cfbO,
                       label: block_cfbO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfbO: // global
           _cfbU::P64 = R1 & 7;
           if (_cfbU::P64 < 3) goto ufcj; else goto ufck;
       ufcj: // global
           if (_cfbU::P64 < 2) goto ufcl; else goto cfbS;
       ufcl: // global
           Sp = Sp + 32;
           call _cfce() args: 0, res: 0, upd: 0;
       cfbS: // global
           _s8dg::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfc3_info;
           R4 = _s8dg::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ufck: // global
           Sp = Sp + 32;
           call _cfbT() args: 0, res: 0, upd: 0;
     }
 },
 _cfc3() //  [R1]
         { info_tbl: [(cfc3,
                       label: block_cfc3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfc3: // global
           if (R1 & 7 == 1) goto ufcm; else goto ufcn;
       ufcm: // global
           Sp = Sp + 8;
           call _cfce() args: 0, res: 0, upd: 0;
       ufcn: // global
           Sp = Sp + 8;
           call _cfbT() args: 0, res: 0, upd: 0;
     }
 },
 _cfce() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfce: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfbT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfbT: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.924993499 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c>=_closure" {
     GHC.Base.$fOrdNonEmpty_$c>=_closure:
         const GHC.Base.$fOrdNonEmpty_$c>=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cfcT,
                       label: GHC.Base.$fOrdNonEmpty_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfcT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfcX; else goto cfcY;
       cfcX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfcY: // global
           I64[Sp - 24] = block_cfcQ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufd6; else goto cfcR;
       ufd6: // global
           call _cfcQ(R1) args: 0, res: 0, upd: 0;
       cfcR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfcQ() //  [R1]
         { info_tbl: [(cfcQ,
                       label: block_cfcQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfcQ: // global
           I64[Sp - 8] = block_cfcW_info;
           _s8dn::P64 = P64[R1 + 7];
           _s8do::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8do::P64;
           P64[Sp + 16] = _s8dn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufd5; else goto cfd0;
       ufd5: // global
           call _cfcW(R1) args: 0, res: 0, upd: 0;
       cfd0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfcW() //  [R1]
         { info_tbl: [(cfcW,
                       label: block_cfcW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfcW: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c>=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.934320491 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_closure" {
     GHC.Base.$fOrdNonEmpty_closure:
         const GHC.Base.$fOrdNonEmpty_info;
 },
 sat_s8dC_entry() //  [R1, R2, R3]
         { info_tbl: [(cfdt,
                       label: sat_s8dC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfdt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmin_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dB_entry() //  [R1, R2, R3]
         { info_tbl: [(cfdB,
                       label: sat_s8dB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfdB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmax_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dA_entry() //  [R1, R2, R3]
         { info_tbl: [(cfdJ,
                       label: sat_s8dA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfdJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c>=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dz_entry() //  [R1, R2, R3]
         { info_tbl: [(cfdR,
                       label: sat_s8dz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfdR: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dw_entry() //  [R1, R2, R3]
         { info_tbl: [(cfdZ,
                       label: sat_s8dw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfdZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dv_entry() //  [R1, R2, R3]
         { info_tbl: [(cfe7,
                       label: sat_s8dv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfe7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8du_entry() //  [R1, R2, R3]
         { info_tbl: [(cfef,
                       label: sat_s8du_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfef: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$ccompare_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8dt_entry() //  [R1]
         { info_tbl: [(cfem,
                       label: sat_s8dt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfem: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfen; else goto cfeo;
       cfen: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfeo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdNonEmpty_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdNonEmpty_entry() //  [R2]
         { info_tbl: [(cfeq,
                       label: GHC.Base.$fOrdNonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfeq: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cfeu; else goto cfet;
       cfeu: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfet: // global
           I64[Hp - 200] = sat_s8dC_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s8dB_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8dA_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s8dz_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s8dw_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s8dv_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8du_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8dt_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.951779208 UTC

[section ""data" . GHC.Base.$fMonadIO_$cfail_closure" {
     GHC.Base.$fMonadIO_$cfail_closure:
         const GHC.Base.$fMonadIO_$cfail_info;
         const 0;
 },
 GHC.Base.$fMonadIO_$cfail_entry() //  [R2]
         { info_tbl: [(cffb,
                       label: GHC.Base.$fMonadIO_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cffb: // global
           R2 = R2;
           R1 = GHC.IO.failIO_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.955325557 UTC

[section ""data" . GHC.Base.$fMonadIO_closure" {
     GHC.Base.$fMonadIO_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fMonadIO1_closure+3;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fMonadIO_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.957718258 UTC

[section ""data" . GHC.Base.$fMonad[]_$cfail_closure" {
     GHC.Base.$fMonad[]_$cfail_closure:
         const GHC.Base.$fMonad[]_$cfail_info;
 },
 GHC.Base.$fMonad[]_$cfail_entry() //  []
         { info_tbl: [(cffn,
                       label: GHC.Base.$fMonad[]_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cffn: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.960884777 UTC

[section ""data" . GHC.Base.$fMonad[]_closure" {
     GHC.Base.$fMonad[]_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Base.$fMonad[]_$c>>=_closure+2;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fMonad[]_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.962719846 UTC

[section ""data" . GHC.Base.$fMonadPlus[]_closure" {
     GHC.Base.$fMonadPlus[]_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternative[]_closure+1;
         const GHC.Base.$fMonad[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.964915255 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$c>>=_closure" {
     GHC.Base.$fMonadMaybe_$c>>=_closure:
         const GHC.Base.$fMonadMaybe_$c>>=_info;
 },
 GHC.Base.$fMonadMaybe_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cffI,
                       label: GHC.Base.$fMonadMaybe_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cffI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cffJ; else goto cffK;
       cffJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadMaybe_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cffK: // global
           I64[Sp - 16] = block_cffB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uffR; else goto cffC;
       uffR: // global
           call _cffB(R1) args: 0, res: 0, upd: 0;
       cffC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cffB() //  [R1]
         { info_tbl: [(cffB,
                       label: block_cffB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cffB: // global
           if (R1 & 7 == 1) goto cffF; else goto cffG;
       cffF: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cffG: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.974380983 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$cfail_closure" {
     GHC.Base.$fMonadMaybe_$cfail_closure:
         const GHC.Base.$fMonadMaybe_$cfail_info;
 },
 GHC.Base.$fMonadMaybe_$cfail_entry() //  []
         { info_tbl: [(cfg8,
                       label: GHC.Base.$fMonadMaybe_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfg8: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.979905363 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>=_closure" {
     GHC.Base.$fMonad(->)_$c>>=_closure:
         const GHC.Base.$fMonad(->)_$c>>=_info;
 },
 GHC.Base.$fMonad(->)_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cfgl,
                       label: GHC.Base.$fMonad(->)_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfgl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfgp; else goto cfgo;
       cfgp: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(->)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfgo: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _s8dL::P64 = R3;
           R3 = R4;
           R2 = Hp - 24;
           R1 = _s8dL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:45.986573677 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>=_closure" {
     GHC.Base.$fMonad(,)_$c>>=_closure:
         const GHC.Base.$fMonad(,)_$c>>=_info;
 },
 sat_s8dY_entry() //  [R1]
         { info_tbl: [(cfgN,
                       label: sat_s8dY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfgN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfgO; else goto cfgP;
       cfgO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfgP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfgL_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfgL() //  [R1]
         { info_tbl: [(cfgL,
                       label: block_cfgL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfgL: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cfgT,
                       label: GHC.Base.$fMonad(,)_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfgT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfgV; else goto cfgW;
       cfgV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfgW: // global
           I64[Sp - 24] = block_cfgy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufh1; else goto cfgz;
       ufh1: // global
           call _cfgy(R1) args: 0, res: 0, upd: 0;
       cfgz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfgy() //  [R1]
         { info_tbl: [(cfgy,
                       label: block_cfgy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfgy: // global
           I64[Sp] = block_cfgD_info;
           R2 = P64[R1 + 15];
           _s8dS::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8dS::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfgD() //  [R1]
         { info_tbl: [(cfgD,
                       label: block_cfgD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfgD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfh0; else goto cfgZ;
       cfh0: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfgZ: // global
           _s8dV::P64 = P64[R1 + 7];
           _s8dW::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s8dY_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s8dV::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s8dW::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.004841753 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*>_closure" {
     GHC.Base.$fApplicative(,)_$c<*>_closure:
         const GHC.Base.$fApplicative(,)_$c<*>_info;
 },
 sat_s8e9_entry() //  [R1]
         { info_tbl: [(cfhM,
                       label: sat_s8e9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfhM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfhN; else goto cfhO;
       cfhN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfhO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfhK_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfhK() //  [R1]
         { info_tbl: [(cfhK,
                       label: block_cfhK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfhK: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(cfhS,
                       label: GHC.Base.$fApplicative(,)_$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfhS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfhU; else goto cfhV;
       cfhU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfhV: // global
           I64[Sp - 24] = block_cfhv_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufi1; else goto cfhw;
       ufi1: // global
           call _cfhv(R1) args: 0, res: 0, upd: 0;
       cfhw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfhv() //  [R1]
         { info_tbl: [(cfhv,
                       label: block_cfhv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfhv: // global
           I64[Sp - 8] = block_cfhA_info;
           _s8e3::P64 = P64[R1 + 7];
           _s8e4::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8e4::P64;
           P64[Sp + 16] = _s8e3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufi0; else goto cfhB;
       ufi0: // global
           call _cfhA(R1) args: 0, res: 0, upd: 0;
       cfhB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfhA() //  [R1]
         { info_tbl: [(cfhA,
                       label: block_cfhA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfhA: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cfhZ; else goto cfhY;
       cfhZ: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfhY: // global
           _s8e6::P64 = P64[R1 + 7];
           _s8e7::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8e7::P64;
           I64[Hp - 56] = sat_s8e9_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s8e6::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.022645959 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c*>_closure" {
     GHC.Base.$fApplicative(,)_$c*>_closure:
         const GHC.Base.$fApplicative(,)_$c*>_info;
 },
 sat_s8el_entry() //  [R1]
         { info_tbl: [(cfiO,
                       label: sat_s8el_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfiO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfiP; else goto cfiQ;
       cfiP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfiQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfiM_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfiM() //  [R1]
         { info_tbl: [(cfiM,
                       label: block_cfiM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfiM: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c*>_entry() //  [R2, R3, R4]
         { info_tbl: [(cfiU,
                       label: GHC.Base.$fApplicative(,)_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfiU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfiW; else goto cfiX;
       cfiW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfiX: // global
           I64[Sp - 24] = block_cfiy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufj3; else goto cfiz;
       ufj3: // global
           call _cfiy(R1) args: 0, res: 0, upd: 0;
       cfiz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfiy() //  [R1]
         { info_tbl: [(cfiy,
                       label: block_cfiy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfiy: // global
           I64[Sp] = block_cfiD_info;
           _s8ef::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8ef::P64;
           if (R1 & 7 != 0) goto ufj2; else goto cfiE;
       ufj2: // global
           call _cfiD(R1) args: 0, res: 0, upd: 0;
       cfiE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfiD() //  [R1]
         { info_tbl: [(cfiD,
                       label: block_cfiD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfiD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfj1; else goto cfj0;
       cfj1: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfj0: // global
           _s8ei::P64 = P64[R1 + 7];
           _s8ej::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s8el_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s8ei::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s8ej::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.040905515 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$cliftA2_closure" {
     GHC.Base.$fApplicative(,)_$cliftA2_closure:
         const GHC.Base.$fApplicative(,)_$cliftA2_info;
 },
 sat_s8ex_entry() //  [R1]
         { info_tbl: [(cfjP,
                       label: sat_s8ex_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfjP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfjQ; else goto cfjR;
       cfjQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfjR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfjN_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfjN() //  [R1]
         { info_tbl: [(cfjN,
                       label: block_cfjN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfjN: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfjV,
                       label: GHC.Base.$fApplicative(,)_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfjV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfjX; else goto cfjY;
       cfjX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfjY: // global
           I64[Sp - 32] = block_cfjy_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufk4; else goto cfjz;
       ufk4: // global
           call _cfjy(R1) args: 0, res: 0, upd: 0;
       cfjz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfjy() //  [R1]
         { info_tbl: [(cfjy,
                       label: block_cfjy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfjy: // global
           I64[Sp - 8] = block_cfjD_info;
           _s8er::P64 = P64[R1 + 7];
           _s8es::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8es::P64;
           P64[Sp + 24] = _s8er::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufk3; else goto cfjE;
       ufk3: // global
           call _cfjD(R1) args: 0, res: 0, upd: 0;
       cfjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfjD() //  [R1]
         { info_tbl: [(cfjD,
                       label: block_cfjD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfjD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cfk2; else goto cfk1;
       cfk2: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfk1: // global
           _s8eu::P64 = P64[R1 + 7];
           _s8ev::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8ev::P64;
           I64[Hp - 56] = sat_s8ex_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8eu::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.056575611 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmempty_info;
 },
 sat_s8eI_entry() //  [R1]
         { info_tbl: [(cfkG,
                       label: sat_s8eI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfkG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfkH; else goto cfkI;
       cfkH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfkI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eH_entry() //  [R1]
         { info_tbl: [(cfkN,
                       label: sat_s8eH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfkN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfkO; else goto cfkP;
       cfkO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfkP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eG_entry() //  [R1]
         { info_tbl: [(cfkU,
                       label: sat_s8eG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfkU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfkV; else goto cfkW;
       cfkV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfkW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eF_entry() //  [R1]
         { info_tbl: [(cfl1,
                       label: sat_s8eF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfl1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfl2; else goto cfl3;
       cfl2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfl3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eE_entry() //  [R1]
         { info_tbl: [(cfl8,
                       label: sat_s8eE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfl8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfl9; else goto cfla;
       cfl9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfla: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cmempty_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cflc,
                       label: GHC.Base.$fMonoid(,,,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cflc: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cflg; else goto cflf;
       cflg: // global
           HpAlloc = 168;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmempty_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cflf: // global
           I64[Hp - 160] = sat_s8eI_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_s8eH_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_s8eG_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8eF_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8eE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.070470415 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,)_$cmempty_info;
 },
 sat_s8eQ_entry() //  [R1]
         { info_tbl: [(cflT,
                       label: sat_s8eQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cflT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cflU; else goto cflV;
       cflU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cflV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eP_entry() //  [R1]
         { info_tbl: [(cfm0,
                       label: sat_s8eP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfm0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfm1; else goto cfm2;
       cfm1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfm2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eO_entry() //  [R1]
         { info_tbl: [(cfm7,
                       label: sat_s8eO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfm7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfm8; else goto cfm9;
       cfm8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfm9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eN_entry() //  [R1]
         { info_tbl: [(cfme,
                       label: sat_s8eN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfme: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfmf; else goto cfmg;
       cfmf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfmg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_$cmempty_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfmi,
                       label: GHC.Base.$fMonoid(,,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfmi: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cfmm; else goto cfml;
       cfmm: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmempty_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfml: // global
           I64[Hp - 128] = sat_s8eQ_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8eP_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_s8eO_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s8eN_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.082411921 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,)_$cmempty_info;
 },
 sat_s8eW_entry() //  [R1]
         { info_tbl: [(cfmU,
                       label: sat_s8eW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfmU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfmV; else goto cfmW;
       cfmV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfmW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eV_entry() //  [R1]
         { info_tbl: [(cfn1,
                       label: sat_s8eV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfn1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfn2; else goto cfn3;
       cfn2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfn3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eU_entry() //  [R1]
         { info_tbl: [(cfn8,
                       label: sat_s8eU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfn8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfn9; else goto cfna;
       cfn9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfna: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmempty_entry() //  [R2, R3, R4]
         { info_tbl: [(cfnc,
                       label: GHC.Base.$fMonoid(,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfnc: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cfng; else goto cfnf;
       cfng: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmempty_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfnf: // global
           I64[Hp - 96] = sat_s8eW_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s8eV_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s8eU_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.092577404 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,)_$cmempty_info;
 },
 sat_s8f0_entry() //  [R1]
         { info_tbl: [(cfnJ,
                       label: sat_s8f0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfnJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfnK; else goto cfnL;
       cfnK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfnL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8eZ_entry() //  [R1]
         { info_tbl: [(cfnQ,
                       label: sat_s8eZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfnQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfnR; else goto cfnS;
       cfnR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfnS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cmempty_entry() //  [R2, R3]
         { info_tbl: [(cfnU,
                       label: GHC.Base.$fMonoid(,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfnU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfnY; else goto cfnX;
       cfnY: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfnX: // global
           I64[Hp - 64] = sat_s8f0_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_s8eZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.10207552 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,)_$cmconcat_info;
 },
 $dSemigroup_s8f4_entry() //  [R1]
         { info_tbl: [(cfom,
                       label: $dSemigroup_s8f4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfom: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfon; else goto cfoo;
       cfon: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfoo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup1_s8f5_entry() //  [R1]
         { info_tbl: [(cfot,
                       label: $dSemigroup1_s8f5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfot: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfou; else goto cfov;
       cfou: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfov: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8f6_entry() //  [R1]
         { info_tbl: [(cfoA,
                       label: z_s8f6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfoA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfoB; else goto cfoC;
       cfoB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfoC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8f7_entry() //  [R1]
         { info_tbl: [(cfoH,
                       label: z1_s8f7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfoH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfoI; else goto cfoJ;
       cfoI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfoJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8fl_entry() //  [R1]
         { info_tbl: [(cfp9,
                       label: sat_s8fl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfp9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfpa; else goto cfpb;
       cfpa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfpb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8fk_entry() //  [R1]
         { info_tbl: [(cfpg,
                       label: sat_s8fk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfpg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfph; else goto cfpi;
       cfph: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfpi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8f9_entry() //  [R1, R2]
         { info_tbl: [(cfpn,
                       label: go_s8f9_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfpn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfpo; else goto cfpp;
       cfpo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfpp: // global
           I64[Sp - 40] = block_cfoQ_info;
           _s8f9::P64 = R1;
           _s8f4::P64 = P64[R1 + 7];
           _s8f5::P64 = P64[R1 + 15];
           _s8f8::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s8f4::P64;
           P64[Sp - 24] = _s8f5::P64;
           P64[Sp - 16] = _s8f8::P64;
           P64[Sp - 8] = _s8f9::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufpz; else goto cfoR;
       ufpz: // global
           call _cfoQ(R1) args: 0, res: 0, upd: 0;
       cfoR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfoQ() //  [R1]
         { info_tbl: [(cfoQ,
                       label: block_cfoQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfoQ: // global
           if (R1 & 7 == 1) goto cfpk; else goto cfpl;
       cfpk: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfpl: // global
           I64[Sp] = block_cfoW_info;
           _s8fd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _s8fd::P64;
           if (R1 & 7 != 0) goto ufpy; else goto cfoX;
       ufpy: // global
           call _cfoW(R1) args: 0, res: 0, upd: 0;
       cfoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfoW() //  [R1]
         { info_tbl: [(cfoW,
                       label: block_cfoW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfoW: // global
           I64[Sp] = block_cfp1_info;
           R2 = P64[Sp + 24];
           _s8ff::P64 = P64[R1 + 7];
           _s8fg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _s8fg::P64;
           P64[Sp + 32] = _s8ff::P64;
           call go_s8f9_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfp1() //  [R1]
         { info_tbl: [(cfp1,
                       label: block_cfp1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfp1: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cfpx; else goto cfpw;
       cfpx: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfpw: // global
           _s8fi::P64 = P64[R1 + 7];
           _s8fj::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s8fl_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = _s8fj::P64;
           I64[Hp - 56] = sat_s8fk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8fi::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,)_$cmconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(cfpA,
                       label: GHC.Base.$fMonoid(,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfpA: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cfpE; else goto cfpD;
       cfpE: // global
           HpAlloc = 152;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfpD: // global
           I64[Hp - 144] = $dSemigroup_s8f4_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = $dSemigroup1_s8f5_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = z_s8f6_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = z1_s8f7_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = Hp - 96;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = go_s8f9_info;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 47;
           R2 = R4;
           R1 = Hp - 23;
           call go_s8f9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.12499004 UTC

[section ""data" . GHC.Base.$fMonoid()_$cmconcat_closure" {
     GHC.Base.$fMonoid()_$cmconcat_closure:
         const GHC.Base.$fMonoid()_$cmconcat_info;
 },
 GHC.Base.$fMonoid()_$cmconcat_entry() //  []
         { info_tbl: [(cfqJ,
                       label: GHC.Base.$fMonoid()_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfqJ: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.129345855 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$c<>_closure" {
     GHC.Base.$fMonoidMaybe_$c<>_closure:
         const GHC.Base.$fMonoidMaybe_$c<>_info;
 },
 sat_s8fu_entry() //  [R1]
         { info_tbl: [(cfrb,
                       label: sat_s8fu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfrb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfrc; else goto cfrd;
       cfrc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfrd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidMaybe_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(cfri,
                       label: GHC.Base.$fMonoidMaybe_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfri: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfrj; else goto cfrk;
       cfrj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfrk: // global
           I64[Sp - 24] = block_cfqV_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufrz; else goto cfqW;
       ufrz: // global
           call _cfqV(R1) args: 0, res: 0, upd: 0;
       cfqW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfqV() //  [R1]
         { info_tbl: [(cfqV,
                       label: block_cfqV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfqV: // global
           _s8fp::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfrf; else goto cfrg;
       cfrf: // global
           R1 = _s8fp::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfrg: // global
           I64[Sp - 8] = block_cfr1_info;
           _s8fq::P64 = R1;
           _s8fr::P64 = P64[R1 + 6];
           R1 = _s8fp::P64;
           P64[Sp] = _s8fr::P64;
           P64[Sp + 16] = _s8fq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufry; else goto cfr2;
       ufry: // global
           call _cfr1(R1) args: 0, res: 0, upd: 0;
       cfr2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfr1() //  [R1]
         { info_tbl: [(cfr1,
                       label: block_cfr1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfr1: // global
           if (R1 & 7 == 1) goto cfrr; else goto cfrt;
       cfrr: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfrt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfrw; else goto cfrv;
       cfrw: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfrv: // global
           _s8ft::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8fu_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8ft::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.140260425 UTC

[section ""data" . GHC.Base.$w$csconcat5_closure" {
     GHC.Base.$w$csconcat5_closure:
         const GHC.Base.$w$csconcat5_info;
 },
 sat_s8fI_entry() //  [R1]
         { info_tbl: [(cfsz,
                       label: sat_s8fI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfsz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfsA; else goto cfsB;
       cfsA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfsB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8fy_entry() //  [R1, R2, R3]
         { info_tbl: [(cfsG,
                       label: go_s8fy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfsG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfsH; else goto uft3;
       cfsH: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uft3: // global
           P64[Sp - 24] = R1;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cfsb() args: 0, res: 0, upd: 0;
     }
 },
 _cfsb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfsb: // global
           _s8fv::P64 = P64[P64[Sp] + 6];
           I64[Sp - 8] = block_cfse_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8fv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uft5; else goto cfsf;
       uft5: // global
           call _cfse(R1) args: 0, res: 0, upd: 0;
       cfsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfse() //  [R1]
         { info_tbl: [(cfse,
                       label: block_cfse_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfse: // global
           _s8fz::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfsD; else goto cfsE;
       cfsD: // global
           R1 = _s8fz::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfsE: // global
           I64[Sp - 8] = block_cfsk_info;
           _s8fC::P64 = P64[R1 + 6];
           _s8fD::P64 = P64[R1 + 14];
           R1 = _s8fz::P64;
           P64[Sp] = _s8fD::P64;
           P64[Sp + 16] = _s8fC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uft6; else goto cfsl;
       uft6: // global
           call _cfsk(R1) args: 0, res: 0, upd: 0;
       cfsl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfsk() //  [R1]
         { info_tbl: [(cfsk,
                       label: block_cfsk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfsk: // global
           _s8fC::P64 = P64[Sp + 24];
           _s8fD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cfsP; else goto cfsR;
       cfsP: // global
           P64[Sp + 24] = _s8fC::P64;
           P64[Sp + 32] = _s8fD::P64;
           Sp = Sp + 16;
           call _cfsb() args: 0, res: 0, upd: 0;
       cfsR: // global
           I64[Sp + 8] = block_cfsq_info;
           R3 = _s8fD::P64;
           R2 = _s8fC::P64;
           _s8fE::P64 = R1;
           _s8fF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8fF::P64;
           P64[Sp + 24] = _s8fE::P64;
           Sp = Sp + 8;
           call go_s8fy_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfsq() //  [R1]
         { info_tbl: [(cfsq,
                       label: block_cfsq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfsq: // global
           if (R1 & 7 == 1) goto cfsV; else goto cfsX;
       cfsV: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfsX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cft0; else goto cfsZ;
       cft0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfsZ: // global
           _s8fH::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8fI_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8fH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat5_entry() //  [R2, R3, R4]
         { info_tbl: [(cft9,
                       label: GHC.Base.$w$csconcat5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cft9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cftd; else goto cftc;
       cftd: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cftc: // global
           I64[Hp - 8] = go_s8fy_info;
           P64[Hp] = R2;
           _s8fw::P64 = R3;
           R3 = R4;
           R2 = _s8fw::P64;
           R1 = Hp - 6;
           call go_s8fy_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.155903528 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_$csconcat_closure" {
     GHC.Base.$fSemigroupMaybe_$csconcat_closure:
         const GHC.Base.$fSemigroupMaybe_$csconcat_info;
 },
 GHC.Base.$fSemigroupMaybe_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(cfu1,
                       label: GHC.Base.$fSemigroupMaybe_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfu1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfu2; else goto cfu3;
       cfu2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfu3: // global
           I64[Sp - 16] = block_cftY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufu7; else goto cftZ;
       ufu7: // global
           call _cftY(R1) args: 0, res: 0, upd: 0;
       cftZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cftY() //  [R1]
         { info_tbl: [(cftY,
                       label: block_cftY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cftY: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat5_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.162415035 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_closure" {
     GHC.Base.$fSemigroupMaybe_closure:
         const GHC.Base.$fSemigroupMaybe_info;
         const 0;
 },
 sat_s8fS_entry() //  [R1, R2]
         { info_tbl: [(cfuq,
                       label: sat_s8fS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfuq: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8fQ_entry() //  [R1, R2]
         { info_tbl: [(cfuy,
                       label: sat_s8fQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfuy: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupMaybe_$csconcat_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8fP_entry() //  [R1, R2, R3]
         { info_tbl: [(cfuG,
                       label: sat_s8fP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfuG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroupMaybe_entry() //  [R2]
         { info_tbl: [(cfuK,
                       label: GHC.Base.$fSemigroupMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfuK: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfuO; else goto cfuN;
       cfuO: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfuN: // global
           I64[Hp - 72] = sat_s8fS_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8fQ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8fP_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.172481878 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$cmconcat_closure" {
     GHC.Base.$fMonoidMaybe_$cmconcat_closure:
         const GHC.Base.$fMonoidMaybe_$cmconcat_info;
 },
 sat_s8g4_entry() //  [R1]
         { info_tbl: [(cfvA,
                       label: sat_s8g4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfvB; else goto cfvC;
       cfvB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8fV_entry() //  [R1, R2]
         { info_tbl: [(cfvH,
                       label: go_s8fV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfvI; else goto ufw4;
       cfvI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ufw4: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cfvc() args: 0, res: 0, upd: 0;
     }
 },
 _cfvc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvc: // global
           _s8fT::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cfvf_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8fT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufw6; else goto cfvg;
       ufw6: // global
           call _cfvf(R1) args: 0, res: 0, upd: 0;
       cfvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvf() //  [R1]
         { info_tbl: [(cfvf,
                       label: block_cfvf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvf: // global
           if (R1 & 7 == 1) goto cfvE; else goto cfvF;
       cfvE: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfvF: // global
           I64[Sp - 8] = block_cfvl_info;
           _s8fZ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8fZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufw7; else goto cfvm;
       ufw7: // global
           call _cfvl(R1) args: 0, res: 0, upd: 0;
       cfvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvl() //  [R1]
         { info_tbl: [(cfvl,
                       label: block_cfvl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvl: // global
           _s8fZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cfvQ; else goto cfvS;
       cfvQ: // global
           P64[Sp + 24] = _s8fZ::P64;
           Sp = Sp + 16;
           call _cfvc() args: 0, res: 0, upd: 0;
       cfvS: // global
           I64[Sp] = block_cfvr_info;
           R2 = _s8fZ::P64;
           _s8g0::P64 = R1;
           _s8g1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _s8g1::P64;
           P64[Sp + 16] = _s8g0::P64;
           call go_s8fV_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvr() //  [R1]
         { info_tbl: [(cfvr,
                       label: block_cfvr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfvr: // global
           if (R1 & 7 == 1) goto cfvW; else goto cfvY;
       cfvW: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfvY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfw1; else goto cfw0;
       cfw1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfw0: // global
           _s8g3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8g4_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8g3::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoidMaybe_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(cfwa,
                       label: GHC.Base.$fMonoidMaybe_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfwe; else goto cfwd;
       cfwe: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwd: // global
           I64[Hp - 8] = go_s8fV_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s8fV_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.188330457 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_closure" {
     GHC.Base.$fMonoidMaybe_closure:
         const GHC.Base.$fMonoidMaybe_info;
         const 0;
 },
 sat_s8g8_entry() //  [R1, R2]
         { info_tbl: [(cfx3,
                       label: sat_s8g8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfx3: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoidMaybe_$cmconcat_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8g7_entry() //  [R1, R2, R3]
         { info_tbl: [(cfxb,
                       label: sat_s8g7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfxb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8g6_entry() //  [R1]
         { info_tbl: [(cfxi,
                       label: sat_s8g6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfxi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfxj; else goto cfxk;
       cfxj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfxk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidMaybe_entry() //  [R2]
         { info_tbl: [(cfxm,
                       label: GHC.Base.$fMonoidMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfxm: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cfxq; else goto cfxp;
       cfxq: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfxp: // global
           I64[Hp - 88] = sat_s8g8_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s8g7_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8g6_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.197609505 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_$c<>_closure" {
     GHC.Base.$fMonoidOrdering_$c<>_closure:
         const GHC.Base.$fMonoidOrdering_$c<>_info;
 },
 GHC.Base.$fMonoidOrdering_$c<>_entry() //  [R2, R3]
         { info_tbl: [(cfxV,
                       label: GHC.Base.$fMonoidOrdering_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfxV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfxW; else goto cfxX;
       cfxW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfxX: // global
           I64[Sp - 16] = block_cfxN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufy8; else goto cfxO;
       ufy8: // global
           call _cfxN(R1) args: 0, res: 0, upd: 0;
       cfxO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfxN() //  [R1]
         { info_tbl: [(cfxN,
                       label: block_cfxN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfxN: // global
           _cfxU::P64 = R1 & 7;
           if (_cfxU::P64 < 3) goto ufy7; else goto cfxT;
       ufy7: // global
           if (_cfxU::P64 < 2) goto cfxR; else goto cfxS;
       cfxR: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfxS: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfxT: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.204656348 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_go_closure" {
     GHC.Base.$fMonoidOrdering_go_closure:
         const GHC.Base.$fMonoidOrdering_go_info;
 },
 GHC.Base.$fMonoidOrdering_go_entry() //  [R2]
         { info_tbl: [(cfyy,
                       label: GHC.Base.$fMonoidOrdering_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfyy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfyz; else goto ufyZ;
       cfyz: // global
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ufyZ: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cfyo() args: 0, res: 0, upd: 0;
     }
 },
 _cfyo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfyo: // global
           _s8gc::P64 = P64[Sp];
           I64[Sp] = block_cfyr_info;
           R1 = _s8gc::P64;
           if (R1 & 7 != 0) goto ufz1; else goto cfys;
       ufz1: // global
           call _cfyr(R1) args: 0, res: 0, upd: 0;
       cfys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfyr() //  [R1]
         { info_tbl: [(cfyr,
                       label: block_cfyr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfyr: // global
           if (R1 & 7 == 1) goto cfyv; else goto cfyw;
       cfyv: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfyw: // global
           I64[Sp - 8] = block_cfyG_info;
           _s8gf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8gf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufz2; else goto cfyI;
       ufz2: // global
           call _cfyG(R1) args: 0, res: 0, upd: 0;
       cfyI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfyG() //  [R1]
         { info_tbl: [(cfyG,
                       label: block_cfyG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfyG: // global
           _cfyX::P64 = R1 & 7;
           if (_cfyX::P64 < 3) goto ufyY; else goto cfyW;
       ufyY: // global
           if (_cfyX::P64 < 2) goto cfyO; else goto cfyS;
       cfyO: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfyS: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cfyo() args: 0, res: 0, upd: 0;
       cfyW: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.213345176 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_closure" {
     GHC.Base.$fSemigroupOrdering_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fSemigroupOrdering_$csconcat_closure+1;
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fMonoidOrdering_closure" {
     GHC.Base.$fMonoidOrdering_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroupOrdering_closure+1;
         const GHC.Types.EQ_closure+2;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fMonoidOrdering_go_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupOrdering_$cstimes_closure" {
     GHC.Base.$fSemigroupOrdering_$cstimes_closure:
         const GHC.Base.$fSemigroupOrdering_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupOrdering_$cstimes_entry() //  [R2]
         { info_tbl: [(cfzv,
                       label: GHC.Base.$fSemigroupOrdering_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfzv: // global
           R3 = GHC.Base.$fMonoidOrdering_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.220041062 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,,)_$c<>_info;
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfzF: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8gF_entry() //  [R1]
         { info_tbl: [(cfzX,
                       label: sat_s8gF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfzX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfzY; else goto cfzZ;
       cfzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfzZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gE_entry() //  [R1]
         { info_tbl: [(cfA4,
                       label: sat_s8gE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfA4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfA5; else goto cfA6;
       cfA5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfA6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gD_entry() //  [R1]
         { info_tbl: [(cfAb,
                       label: sat_s8gD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfAb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfAc; else goto cfAd;
       cfAc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfAd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gC_entry() //  [R1]
         { info_tbl: [(cfAi,
                       label: sat_s8gC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfAi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfAj; else goto cfAk;
       cfAj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfAk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8gB_entry() //  [R1]
         { info_tbl: [(cfAp,
                       label: sat_s8gB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfAp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfAq; else goto cfAr;
       cfAq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfAr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfAs,
                       label: GHC.Base.$fMonoid(,,,,)_$c<>_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfAs: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cfAu; else goto cfAv;
       cfAu: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$c<>_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cfAv: // global
           I64[Sp - 40] = block_cfzJ_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufAB; else goto cfzK;
       ufAB: // global
           call _cfzJ(R1) args: 0, res: 0, upd: 0;
       cfzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfzJ() //  [R1]
         { info_tbl: [(cfzJ,
                       label: block_cfzJ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfzJ: // global
           I64[Sp - 32] = block_cfzO_info;
           _s8gq::P64 = P64[R1 + 7];
           _s8gr::P64 = P64[R1 + 15];
           _s8gs::P64 = P64[R1 + 23];
           _s8gt::P64 = P64[R1 + 31];
           _s8gu::P64 = P64[R1 + 39];
           R1 = P64[Sp + 48];
           P64[Sp - 24] = _s8gs::P64;
           P64[Sp - 16] = _s8gt::P64;
           P64[Sp - 8] = _s8gu::P64;
           P64[Sp] = _s8gr::P64;
           P64[Sp + 48] = _s8gq::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufAA; else goto cfzP;
       ufAA: // global
           call _cfzO(R1) args: 0, res: 0, upd: 0;
       cfzP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfzO() //  [R1]
         { info_tbl: [(cfzO,
                       label: block_cfzO_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfzO: // global
           Hp = Hp + 248;
           if (Hp > HpLim) (likely: False) goto cfAz; else goto cfAy;
       cfAz: // global
           HpAlloc = 248;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfAy: // global
           _s8gw::P64 = P64[R1 + 7];
           _s8gx::P64 = P64[R1 + 15];
           _s8gy::P64 = P64[R1 + 23];
           _s8gz::P64 = P64[R1 + 31];
           _s8gA::P64 = P64[R1 + 39];
           I64[Hp - 240] = sat_s8gF_info;
           P64[Hp - 224] = P64[Sp + 64];
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _s8gA::P64;
           I64[Hp - 200] = sat_s8gE_info;
           P64[Hp - 184] = P64[Sp + 56];
           P64[Hp - 176] = P64[Sp + 16];
           P64[Hp - 168] = _s8gz::P64;
           I64[Hp - 160] = sat_s8gD_info;
           P64[Hp - 144] = P64[Sp + 48];
           P64[Hp - 136] = P64[Sp + 8];
           P64[Hp - 128] = _s8gy::P64;
           I64[Hp - 120] = sat_s8gC_info;
           P64[Hp - 104] = P64[Sp + 40];
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = _s8gx::P64;
           I64[Hp - 80] = sat_s8gB_info;
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = _s8gw::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 160;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 240;
           R1 = Hp - 39;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.242637587 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$csconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$csconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$csconcat_info;
 },
 sat_s8hl_entry() //  [R1]
         { info_tbl: [(cfCd,
                       label: sat_s8hl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfCd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCe; else goto cfCf;
       cfCe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hk_entry() //  [R1]
         { info_tbl: [(cfCk,
                       label: sat_s8hk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfCk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCl; else goto cfCm;
       cfCl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hj_entry() //  [R1]
         { info_tbl: [(cfCr,
                       label: sat_s8hj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfCr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCs; else goto cfCt;
       cfCs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hi_entry() //  [R1]
         { info_tbl: [(cfCy,
                       label: sat_s8hi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfCy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCz; else goto cfCA;
       cfCz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8hh_entry() //  [R1]
         { info_tbl: [(cfCF,
                       label: sat_s8hh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfCF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCG; else goto cfCH;
       cfCG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s8gV_entry() //  [R1, R2, R3, R4, R5, R6]
         { info_tbl: [(cfCM,
                       label: $wgo_s8gV_info
                       rep:HeapRep 5 ptrs { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfCM: // global
           if ((Sp + -120) < SpLim) (likely: False) goto cfCN; else goto cfCO;
       cfCN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfCO: // global
           I64[Sp - 88] = block_cfBU_info;
           _s8gV::P64 = R1;
           _s8gG::P64 = P64[R1 + 2];
           _s8gH::P64 = P64[R1 + 10];
           _s8gI::P64 = P64[R1 + 18];
           _s8gJ::P64 = P64[R1 + 26];
           _s8gK::P64 = P64[R1 + 34];
           R1 = P64[Sp];
           P64[Sp - 80] = _s8gH::P64;
           P64[Sp - 72] = _s8gI::P64;
           P64[Sp - 64] = _s8gJ::P64;
           P64[Sp - 56] = _s8gK::P64;
           P64[Sp - 48] = _s8gV::P64;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = _s8gG::P64;
           Sp = Sp - 88;
           if (R1 & 7 != 0) goto ufCZ; else goto cfBV;
       ufCZ: // global
           call _cfBU(R1) args: 0, res: 0, upd: 0;
       cfBV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfBU() //  [R1]
         { info_tbl: [(cfBU,
                       label: block_cfBU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfBU: // global
           if (R1 & 7 == 1) goto cfCJ; else goto cfCK;
       cfCJ: // global
           R5 = P64[Sp + 80];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfCK: // global
           I64[Sp - 8] = block_cfC0_info;
           _s8h4::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8h4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufCX; else goto cfC1;
       ufCX: // global
           call _cfC0(R1) args: 0, res: 0, upd: 0;
       cfC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfC0() //  [R1]
         { info_tbl: [(cfC0,
                       label: block_cfC0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfC0: // global
           _s8h4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfC5_info;
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp] = _s8h4::P64;
           call $wgo_s8gV_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 _cfC5() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfC5,
                       label: block_cfC5_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfC5: // global
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R2;
           P64[Sp + 40] = R1;
           Sp = Sp - 32;
           call _cfC6() args: 0, res: 0, upd: 0;
     }
 },
 _cfC6() //  []
         { info_tbl: [(cfC6,
                       label: block_cfC6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfC6: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cfCV; else goto cfCU;
       cfCV: // global
           HpAlloc = 200;
           I64[Sp] = block_cfC6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfCU: // global
           I64[Hp - 192] = sat_s8hl_info;
           P64[Hp - 176] = P64[Sp + 64];
           P64[Hp - 168] = P64[Sp + 112];
           P64[Hp - 160] = P64[Sp + 24];
           I64[Hp - 152] = sat_s8hk_info;
           P64[Hp - 136] = P64[Sp + 56];
           P64[Hp - 128] = P64[Sp + 104];
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = sat_s8hj_info;
           P64[Hp - 96] = P64[Sp + 48];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = sat_s8hi_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 32];
           I64[Hp - 32] = sat_s8hh_info;
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 80];
           P64[Hp] = P64[Sp + 72];
           R5 = Hp - 192;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfD0,
                       label: GHC.Base.$fMonoid(,,,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfD0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfD6; else goto cfD7;
       cfD6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfD7: // global
           I64[Sp - 40] = block_cfBF_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufDh; else goto cfBG;
       ufDh: // global
           call _cfBF(R1) args: 0, res: 0, upd: 0;
       cfBG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfBF() //  [R1]
         { info_tbl: [(cfBF,
                       label: block_cfBF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfBF: // global
           I64[Sp - 8] = block_cfBK_info;
           _s8gO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8gO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufDg; else goto cfBL;
       ufDg: // global
           call _cfBK(R1) args: 0, res: 0, upd: 0;
       cfBL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfBK() //  [R1]
         { info_tbl: [(cfBK,
                       label: block_cfBK_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfBK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfDb; else goto cfDa;
       cfDb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfDa: // global
           _s8gQ::P64 = P64[R1 + 7];
           _s8gR::P64 = P64[R1 + 15];
           _s8gS::P64 = P64[R1 + 23];
           _s8gT::P64 = P64[R1 + 31];
           _s8gU::P64 = P64[R1 + 39];
           I64[Hp - 40] = $wgo_s8gV_info;
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 48] = block_cfD1_info;
           R6 = _s8gU::P64;
           R5 = _s8gT::P64;
           R4 = _s8gS::P64;
           R3 = _s8gR::P64;
           R2 = _s8gQ::P64;
           R1 = Hp - 34;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call $wgo_s8gV_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 _cfD1() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfD1,
                       label: block_cfD1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfD1: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call _cfD2() args: 0, res: 0, upd: 0;
     }
 },
 _cfD2() //  []
         { info_tbl: [(cfD2,
                       label: block_cfD2_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfD2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfDe; else goto cfDd;
       cfDe: // global
           HpAlloc = 48;
           I64[Sp] = block_cfD2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfDd: // global
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.277981054 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cstimes_closure" {
     GHC.Base.$fMonoid(,,,,)_$cstimes_closure:
         const GHC.Base.$fMonoid(,,,,)_$cstimes_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfEU: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8hK_entry() //  [R1]
         { info_tbl: [(cfF7,
                       label: sat_s8hK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfF7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfF8; else goto cfF9;
       cfF8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfF9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hJ_entry() //  [R1]
         { info_tbl: [(cfFe,
                       label: sat_s8hJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfFe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfFf; else goto cfFg;
       cfFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hI_entry() //  [R1]
         { info_tbl: [(cfFl,
                       label: sat_s8hI_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfFl: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfFm; else goto cfFn;
       cfFm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfFn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hH_entry() //  [R1]
         { info_tbl: [(cfFs,
                       label: sat_s8hH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfFs: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfFt; else goto cfFu;
       cfFt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfFu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8hG_entry() //  [R1]
         { info_tbl: [(cfFz,
                       label: sat_s8hG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfFz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfFA; else goto cfFB;
       cfFA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfFB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfFC,
                       label: GHC.Base.$fMonoid(,,,,)_$cstimes_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfFC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfFE; else goto cfFF;
       cfFE: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cfFF: // global
           I64[Sp - 40] = block_cfEY_info;
           R1 = P64[Sp + 16];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 16] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufFJ; else goto cfEZ;
       ufFJ: // global
           call _cfEY(R1) args: 0, res: 0, upd: 0;
       cfEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfEY() //  [R1]
         { info_tbl: [(cfEY,
                       label: block_cfEY_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfEY: // global
           Hp = Hp + 288;
           if (Hp > HpLim) (likely: False) goto cfFI; else goto cfFH;
       cfFI: // global
           HpAlloc = 288;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfFH: // global
           _s8hB::P64 = P64[R1 + 7];
           _s8hC::P64 = P64[R1 + 15];
           _s8hD::P64 = P64[R1 + 23];
           _s8hE::P64 = P64[R1 + 31];
           _s8hF::P64 = P64[R1 + 39];
           I64[Hp - 280] = sat_s8hK_info;
           P64[Hp - 264] = P64[Sp + 32];
           _s8hx::P64 = P64[Sp + 40];
           P64[Hp - 256] = _s8hx::P64;
           _s8hy::P64 = P64[Sp + 48];
           P64[Hp - 248] = _s8hy::P64;
           P64[Hp - 240] = _s8hF::P64;
           I64[Hp - 232] = sat_s8hJ_info;
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _s8hx::P64;
           P64[Hp - 200] = _s8hy::P64;
           P64[Hp - 192] = _s8hE::P64;
           I64[Hp - 184] = sat_s8hI_info;
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _s8hx::P64;
           P64[Hp - 152] = _s8hy::P64;
           P64[Hp - 144] = _s8hD::P64;
           I64[Hp - 136] = sat_s8hH_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8hx::P64;
           P64[Hp - 104] = _s8hy::P64;
           P64[Hp - 96] = _s8hC::P64;
           I64[Hp - 88] = sat_s8hG_info;
           P64[Hp - 72] = P64[Sp + 56];
           P64[Hp - 64] = _s8hx::P64;
           P64[Hp - 56] = _s8hy::P64;
           P64[Hp - 48] = _s8hB::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 88;
           P64[Hp - 24] = Hp - 136;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 280;
           R1 = Hp - 39;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.297600818 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,,)_closure" {
     GHC.Base.$fSemigroup(,,,,)_closure:
         const GHC.Base.$fSemigroup(,,,,)_info;
 },
 sat_s8hS_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfGO,
                       label: sat_s8hS_info
                       rep:HeapRep 5 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfGO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfGP; else goto cfGQ;
       cfGP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfGQ: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8hR_entry() //  [R1, R2]
         { info_tbl: [(cfGW,
                       label: sat_s8hR_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfGW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfGX; else goto cfGY;
       cfGX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfGY: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_s8hQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cfH4,
                       label: sat_s8hQ_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfH4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfH5; else goto cfH6;
       cfH5: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfH6: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfH8,
                       label: GHC.Base.$fSemigroup(,,,,)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfH8: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cfHc; else goto cfHb;
       cfHc: // global
           HpAlloc = 176;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfHb: // global
           I64[Hp - 168] = sat_s8hS_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = sat_s8hR_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_s8hQ_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 165;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.311417022 UTC

[section ""data" . GHC.Base.$w$cp1Monoid1_closure" {
     GHC.Base.$w$cp1Monoid1_closure:
         const GHC.Base.$w$cp1Monoid1_info;
 },
 sat_s8ie_entry() //  [R1]
         { info_tbl: [(cfHF,
                       label: sat_s8ie_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfHF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfHG; else goto cfHH;
       cfHG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfHH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8id_entry() //  [R1]
         { info_tbl: [(cfHM,
                       label: sat_s8id_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfHM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfHN; else goto cfHO;
       cfHN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfHO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ic_entry() //  [R1]
         { info_tbl: [(cfHT,
                       label: sat_s8ic_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfHT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfHU; else goto cfHV;
       cfHU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfHV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ib_entry() //  [R1]
         { info_tbl: [(cfI0,
                       label: sat_s8ib_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfI0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfI1; else goto cfI2;
       cfI1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfI2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ia_entry() //  [R1]
         { info_tbl: [(cfI7,
                       label: sat_s8ia_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfI7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfI8; else goto cfI9;
       cfI8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfI9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8if_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfIf,
                       label: sat_s8if_info
                       rep:HeapRep 5 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfIf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfIg; else goto cfIh;
       cfIg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfIh: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8i8_entry() //  [R1]
         { info_tbl: [(cfIm,
                       label: sat_s8i8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfIm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfIn; else goto cfIo;
       cfIn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i7_entry() //  [R1]
         { info_tbl: [(cfIt,
                       label: sat_s8i7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfIt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfIu; else goto cfIv;
       cfIu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i6_entry() //  [R1]
         { info_tbl: [(cfIA,
                       label: sat_s8i6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfIA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfIB; else goto cfIC;
       cfIB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i5_entry() //  [R1]
         { info_tbl: [(cfIH,
                       label: sat_s8i5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfIH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfII; else goto cfIJ;
       cfII: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i4_entry() //  [R1]
         { info_tbl: [(cfIO,
                       label: sat_s8i4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfIO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfIP; else goto cfIQ;
       cfIP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i9_entry() //  [R1, R2]
         { info_tbl: [(cfIW,
                       label: sat_s8i9_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfIW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfIX; else goto cfIY;
       cfIX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfIY: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_s8i2_entry() //  [R1]
         { info_tbl: [(cfJ3,
                       label: sat_s8i2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfJ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJ4; else goto cfJ5;
       cfJ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i1_entry() //  [R1]
         { info_tbl: [(cfJa,
                       label: sat_s8i1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfJa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJb; else goto cfJc;
       cfJb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i0_entry() //  [R1]
         { info_tbl: [(cfJh,
                       label: sat_s8i0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfJh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJi; else goto cfJj;
       cfJi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8hZ_entry() //  [R1]
         { info_tbl: [(cfJo,
                       label: sat_s8hZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfJo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJp; else goto cfJq;
       cfJp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8hY_entry() //  [R1]
         { info_tbl: [(cfJv,
                       label: sat_s8hY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfJv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJw; else goto cfJx;
       cfJw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8i3_entry() //  [R1, R2, R3]
         { info_tbl: [(cfJD,
                       label: sat_s8i3_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfJD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJE; else goto cfJF;
       cfJE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfJF: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cp1Monoid1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfJG,
                       label: GHC.Base.$w$cp1Monoid1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfJG: // global
           Hp = Hp + 504;
           if (Hp > HpLim) (likely: False) goto cfJK; else goto cfJJ;
       cfJK: // global
           HpAlloc = 504;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfJJ: // global
           I64[Hp - 496] = sat_s8ie_info;
           P64[Hp - 480] = R6;
           I64[Hp - 472] = sat_s8id_info;
           P64[Hp - 456] = R5;
           I64[Hp - 448] = sat_s8ic_info;
           P64[Hp - 432] = R4;
           I64[Hp - 424] = sat_s8ib_info;
           P64[Hp - 408] = R3;
           I64[Hp - 400] = sat_s8ia_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s8if_info;
           P64[Hp - 368] = Hp - 400;
           P64[Hp - 360] = Hp - 424;
           P64[Hp - 352] = Hp - 448;
           P64[Hp - 344] = Hp - 472;
           P64[Hp - 336] = Hp - 496;
           I64[Hp - 328] = sat_s8i8_info;
           P64[Hp - 312] = R6;
           I64[Hp - 304] = sat_s8i7_info;
           P64[Hp - 288] = R5;
           I64[Hp - 280] = sat_s8i6_info;
           P64[Hp - 264] = R4;
           I64[Hp - 256] = sat_s8i5_info;
           P64[Hp - 240] = R3;
           I64[Hp - 232] = sat_s8i4_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s8i9_info;
           P64[Hp - 200] = Hp - 232;
           P64[Hp - 192] = Hp - 256;
           P64[Hp - 184] = Hp - 280;
           P64[Hp - 176] = Hp - 304;
           P64[Hp - 168] = Hp - 328;
           I64[Hp - 160] = sat_s8i2_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_s8i1_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_s8i0_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8hZ_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8hY_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8i3_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R3 = Hp - 373;
           R2 = Hp - 207;
           R1 = Hp - 38;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.351501298 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfLm,
                       label: GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfLm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfLn; else goto cfLo;
       cfLn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfLo: // global
           I64[Sp - 8] = block_cfLj_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfLj() //  [R1, R2, R3]
         { info_tbl: [(cfLj,
                       label: block_cfLj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfLj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfLr; else goto cfLq;
       cfLr: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cfLq: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.358798488 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfLH,
                       label: GHC.Base.$fMonoid(,,,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfLH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfLI; else goto cfLJ;
       cfLI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfLJ: // global
           I64[Sp - 8] = block_cfLF_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfLF() //  [R1]
         { info_tbl: [(cfLF,
                       label: block_cfLF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfLF: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.365741174 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmconcat_info;
 },
 k_s8iD_entry() //  [R1]
         { info_tbl: [(cfM4,
                       label: k_s8iD_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfM4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfM5; else goto cfM6;
       cfM5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfM6: // global
           I64[Sp - 8] = block_cfM1_info;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfM1() //  [R1, R2, R3]
         { info_tbl: [(cfM1,
                       label: block_cfM1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfM1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfM9; else goto cfM8;
       cfM9: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cfM8: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 k1_s8iI_entry() //  [R1]
         { info_tbl: [(cfMe,
                       label: k1_s8iI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfMe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMf; else goto cfMg;
       cfMf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8iJ_entry() //  [R1]
         { info_tbl: [(cfMl,
                       label: z_s8iJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfMl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMm; else goto cfMn;
       cfMm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8iK_entry() //  [R1]
         { info_tbl: [(cfMs,
                       label: z1_s8iK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfMs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMt; else goto cfMu;
       cfMt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_s8iL_entry() //  [R1]
         { info_tbl: [(cfMz,
                       label: z2_s8iL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfMz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMA; else goto cfMB;
       cfMA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z3_s8iM_entry() //  [R1]
         { info_tbl: [(cfMG,
                       label: z3_s8iM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfMG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMH; else goto cfMI;
       cfMH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z4_s8iN_entry() //  [R1]
         { info_tbl: [(cfMN,
                       label: z4_s8iN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfMN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMO; else goto cfMP;
       cfMO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8iP_entry() //  [R1, R2]
         { info_tbl: [(cfN3,
                       label: go_s8iP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfN3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfN4; else goto cfN5;
       cfN4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfN5: // global
           I64[Sp - 32] = block_cfMW_info;
           _s8iP::P64 = R1;
           _s8iI::P64 = P64[R1 + 7];
           _s8iO::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s8iI::P64;
           P64[Sp - 16] = _s8iO::P64;
           P64[Sp - 8] = _s8iP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufNf; else goto cfMX;
       ufNf: // global
           call _cfMW(R1) args: 0, res: 0, upd: 0;
       cfMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfMW() //  [R1]
         { info_tbl: [(cfMW,
                       label: block_cfMW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfMW: // global
           if (R1 & 7 == 1) goto cfN0; else goto cfN1;
       cfN0: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfN1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfNe; else goto cfNd;
       cfNe: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfNd: // global
           _s8iS::P64 = P64[R1 + 6];
           _s8iT::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s8iT::P64;
           R3 = Hp - 24;
           R2 = _s8iS::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cmconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfNg,
                       label: GHC.Base.$fMonoid(,,,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfNg: // global
           Hp = Hp + 272;
           if (Hp > HpLim) (likely: False) goto cfNk; else goto cfNj;
       cfNk: // global
           HpAlloc = 272;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfNj: // global
           I64[Hp - 264] = k_s8iD_info;
           P64[Hp - 248] = R2;
           P64[Hp - 240] = R3;
           P64[Hp - 232] = R4;
           P64[Hp - 224] = R5;
           P64[Hp - 216] = R6;
           I64[Hp - 208] = k1_s8iI_info;
           P64[Hp - 192] = Hp - 264;
           I64[Hp - 184] = z_s8iJ_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = z1_s8iK_info;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = z2_s8iL_info;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = z3_s8iM_info;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = z4_s8iN_info;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = (,,,,)_con_info;
           P64[Hp - 56] = Hp - 184;
           P64[Hp - 48] = Hp - 160;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = go_s8iP_info;
           P64[Hp - 8] = Hp - 208;
           P64[Hp] = Hp - 63;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.40150004 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_closure" {
     GHC.Base.$fMonoid(,,,,)_closure:
         const GHC.Base.$fMonoid(,,,,)_info;
 },
 sat_s8j3_entry() //  [R1]
         { info_tbl: [(cfOo,
                       label: sat_s8j3_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfOo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfOp; else goto cfOq;
       cfOp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfOq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j2_entry() //  [R1]
         { info_tbl: [(cfOv,
                       label: sat_s8j2_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfOv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfOw; else goto cfOx;
       cfOw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfOx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmappend_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j1_entry() //  [R1]
         { info_tbl: [(cfOC,
                       label: sat_s8j1_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfOC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfOD; else goto cfOE;
       cfOD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfOE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmempty_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8j0_entry() //  [R1]
         { info_tbl: [(cfOJ,
                       label: sat_s8j0_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfOJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfOK; else goto cfOL;
       cfOK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfOL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfON,
                       label: GHC.Base.$fMonoid(,,,,)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfON: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cfOR; else goto cfOQ;
       cfOR: // global
           HpAlloc = 264;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfOQ: // global
           I64[Hp - 256] = sat_s8j3_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           P64[Hp - 224] = R4;
           P64[Hp - 216] = R5;
           P64[Hp - 208] = R6;
           I64[Hp - 200] = sat_s8j2_info;
           P64[Hp - 184] = R2;
           P64[Hp - 176] = R3;
           P64[Hp - 168] = R4;
           P64[Hp - 160] = R5;
           P64[Hp - 152] = R6;
           I64[Hp - 144] = sat_s8j1_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           P64[Hp - 104] = R5;
           P64[Hp - 96] = R6;
           I64[Hp - 88] = sat_s8j0_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 256;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.415705896 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,)_$c<>_info;
 },
 sat_s8jn_entry() //  [R1]
         { info_tbl: [(cfPz,
                       label: sat_s8jn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfPz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfPA; else goto cfPB;
       cfPA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfPB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jm_entry() //  [R1]
         { info_tbl: [(cfPG,
                       label: sat_s8jm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfPG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfPH; else goto cfPI;
       cfPH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfPI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jl_entry() //  [R1]
         { info_tbl: [(cfPN,
                       label: sat_s8jl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfPN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfPO; else goto cfPP;
       cfPO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfPP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jk_entry() //  [R1]
         { info_tbl: [(cfPU,
                       label: sat_s8jk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfPU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfPV; else goto cfPW;
       cfPV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfPW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfPX,
                       label: GHC.Base.$fMonoid(,,,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfPX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cfPZ; else goto cfQ0;
       cfPZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfQ0: // global
           I64[Sp - 40] = block_cfPl_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufQ6; else goto cfPm;
       ufQ6: // global
           call _cfPl(R1) args: 0, res: 0, upd: 0;
       cfPm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfPl() //  [R1]
         { info_tbl: [(cfPl,
                       label: block_cfPl_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfPl: // global
           I64[Sp - 24] = block_cfPq_info;
           _s8jb::P64 = P64[R1 + 7];
           _s8jc::P64 = P64[R1 + 15];
           _s8jd::P64 = P64[R1 + 23];
           _s8je::P64 = P64[R1 + 31];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _s8jd::P64;
           P64[Sp - 8] = _s8je::P64;
           P64[Sp] = _s8jc::P64;
           P64[Sp + 40] = _s8jb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufQ5; else goto cfPr;
       ufQ5: // global
           call _cfPq(R1) args: 0, res: 0, upd: 0;
       cfPr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfPq() //  [R1]
         { info_tbl: [(cfPq,
                       label: block_cfPq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfPq: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cfQ4; else goto cfQ3;
       cfQ4: // global
           HpAlloc = 200;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfQ3: // global
           _s8jg::P64 = P64[R1 + 7];
           _s8jh::P64 = P64[R1 + 15];
           _s8ji::P64 = P64[R1 + 23];
           _s8jj::P64 = P64[R1 + 31];
           I64[Hp - 192] = sat_s8jn_info;
           P64[Hp - 176] = P64[Sp + 56];
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _s8jj::P64;
           I64[Hp - 152] = sat_s8jm_info;
           P64[Hp - 136] = P64[Sp + 48];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = _s8ji::P64;
           I64[Hp - 112] = sat_s8jl_info;
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = _s8jh::P64;
           I64[Hp - 72] = sat_s8jk_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = _s8jg::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.435071679 UTC

[section ""data" . GHC.Base.$w$csconcat2_closure" {
     GHC.Base.$w$csconcat2_closure:
         const GHC.Base.$w$csconcat2_info;
 },
 GHC.Base.$w$csconcat2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfQW: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_s8jT_entry() //  [R1]
         { info_tbl: [(cfRm,
                       label: sat_s8jT_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfRm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfRn; else goto cfRo;
       cfRn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfRo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jS_entry() //  [R1]
         { info_tbl: [(cfRt,
                       label: sat_s8jS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfRt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfRu; else goto cfRv;
       cfRu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfRv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jR_entry() //  [R1]
         { info_tbl: [(cfRA,
                       label: sat_s8jR_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfRA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfRB; else goto cfRC;
       cfRB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfRC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8jQ_entry() //  [R1]
         { info_tbl: [(cfRH,
                       label: sat_s8jQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfRH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfRI; else goto cfRJ;
       cfRI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfRJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s8jx_entry() //  [R1, R2, R3, R4, R5, R6]
         { info_tbl: [(cfRO,
                       label: $wgo_s8jx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfRO: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cfRP; else goto cfRQ;
       cfRP: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfRQ: // global
           I64[Sp - 80] = block_cfR5_info;
           _s8jx::P64 = R1;
           _s8jo::P64 = P64[R1 + 3];
           _s8jp::P64 = P64[R1 + 11];
           _s8jq::P64 = P64[R1 + 19];
           _s8jr::P64 = P64[R1 + 27];
           R1 = R6;
           P64[Sp - 72] = _s8jo::P64;
           P64[Sp - 64] = _s8jp::P64;
           P64[Sp - 56] = _s8jq::P64;
           P64[Sp - 48] = _s8jr::P64;
           P64[Sp - 40] = _s8jx::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto ufRZ; else goto cfR6;
       ufRZ: // global
           call _cfR5(R1) args: 0, res: 0, upd: 0;
       cfR6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfR5() //  [R1]
         { info_tbl: [(cfR5,
                       label: block_cfR5_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfR5: // global
           if (R1 & 7 == 1) goto cfRL; else goto cfRM;
       cfRL: // global
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfRM: // global
           I64[Sp - 8] = block_cfRb_info;
           _s8jF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8jF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufRY; else goto cfRc;
       ufRY: // global
           call _cfRb(R1) args: 0, res: 0, upd: 0;
       cfRc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfRb() //  [R1]
         { info_tbl: [(cfRb,
                       label: block_cfRb_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfRb: // global
           _s8jF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfRg_info;
           R6 = _s8jF::P64;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           Sp = Sp + 8;
           call $wgo_s8jx_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfRg() //  [R1, R2, R3, R4]
         { info_tbl: [(cfRg,
                       label: block_cfRg_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfRg: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cfRX; else goto cfRW;
       cfRX: // global
           HpAlloc = 160;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cfRW: // global
           I64[Hp - 152] = sat_s8jT_info;
           P64[Hp - 136] = P64[Sp + 32];
           P64[Hp - 128] = P64[Sp + 72];
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_s8jS_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8jR_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8jQ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfS0,
                       label: GHC.Base.$w$csconcat2_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfS0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfS4; else goto cfS3;
       cfS4: // global
           HpAlloc = 40;
           R1 = GHC.Base.$w$csconcat2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cfS3: // global
           I64[Hp - 32] = $wgo_s8jx_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _s8js::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _s8js::P64;
           R1 = Hp - 27;
           Sp = Sp + 32;
           call $wgo_s8jx_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.458268188 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,,)_$csconcat_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(cfT7,
                       label: GHC.Base.$fSemigroup(,,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfT7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfTi; else goto cfTj;
       cfTi: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfTj: // global
           I64[Sp - 40] = block_cfT4_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufTq; else goto cfT5;
       ufTq: // global
           call _cfT4(R1) args: 0, res: 0, upd: 0;
       cfT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfT4() //  [R1]
         { info_tbl: [(cfT4,
                       label: block_cfT4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfT4: // global
           I64[Sp - 8] = block_cfTa_info;
           _s8k1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8k1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufTp; else goto cfTb;
       ufTp: // global
           call _cfTa(R1) args: 0, res: 0, upd: 0;
       cfTb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfTa() //  [R1]
         { info_tbl: [(cfTa,
                       label: block_cfTa_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfTa: // global
           _s8jX::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cfTf_info;
           R6 = P64[R1 + 7];
           R5 = _s8jX::P64;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           _s8k1::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _s8k1::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfTf() //  [R1, R2, R3, R4]
         { info_tbl: [(cfTf,
                       label: block_cfTf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfTf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfTo; else goto cfTn;
       cfTo: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cfTn: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.469884487 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,,)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfTM: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8kr_entry() //  [R1]
         { info_tbl: [(cfTZ,
                       label: sat_s8kr_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfTZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfU0; else goto cfU1;
       cfU0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfU1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8kq_entry() //  [R1]
         { info_tbl: [(cfU6,
                       label: sat_s8kq_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfU6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfU7; else goto cfU8;
       cfU7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfU8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8kp_entry() //  [R1]
         { info_tbl: [(cfUd,
                       label: sat_s8kp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfUd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfUe; else goto cfUf;
       cfUe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfUf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8ko_entry() //  [R1]
         { info_tbl: [(cfUk,
                       label: sat_s8ko_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfUk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfUl; else goto cfUm;
       cfUl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfUm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cfUn,
                       label: GHC.Base.$fSemigroup(,,,)_$cstimes_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfUn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfUp; else goto cfUq;
       cfUp: // global
           R1 = GHC.Base.$fSemigroup(,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cfUq: // global
           I64[Sp - 40] = block_cfTQ_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufUu; else goto cfTR;
       ufUu: // global
           call _cfTQ(R1) args: 0, res: 0, upd: 0;
       cfTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfTQ() //  [R1]
         { info_tbl: [(cfTQ,
                       label: block_cfTQ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfTQ: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cfUt; else goto cfUs;
       cfUt: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfUs: // global
           _s8kk::P64 = P64[R1 + 7];
           _s8kl::P64 = P64[R1 + 15];
           _s8km::P64 = P64[R1 + 23];
           _s8kn::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_s8kr_info;
           P64[Hp - 208] = P64[Sp + 24];
           _s8kg::P64 = P64[Sp + 32];
           P64[Hp - 200] = _s8kg::P64;
           _s8kh::P64 = P64[Sp + 40];
           P64[Hp - 192] = _s8kh::P64;
           P64[Hp - 184] = _s8kn::P64;
           I64[Hp - 176] = sat_s8kq_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _s8kg::P64;
           P64[Hp - 144] = _s8kh::P64;
           P64[Hp - 136] = _s8km::P64;
           I64[Hp - 128] = sat_s8kp_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _s8kg::P64;
           P64[Hp - 96] = _s8kh::P64;
           P64[Hp - 88] = _s8kl::P64;
           I64[Hp - 80] = sat_s8ko_info;
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = _s8kg::P64;
           P64[Hp - 48] = _s8kh::P64;
           P64[Hp - 40] = _s8kk::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.487018506 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_closure" {
     GHC.Base.$fSemigroup(,,,)_closure:
         const GHC.Base.$fSemigroup(,,,)_info;
 },
 sat_s8ky_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfVq,
                       label: sat_s8ky_info
                       rep:HeapRep 4 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfVr; else goto cfVs;
       cfVr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfVs: // global
           R6 = R2;
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8kx_entry() //  [R1, R2]
         { info_tbl: [(cfVy,
                       label: sat_s8kx_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVy: // global
           R6 = R2;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,,)_$csconcat_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8kw_entry() //  [R1, R2, R3]
         { info_tbl: [(cfVG,
                       label: sat_s8kw_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfVH; else goto cfVI;
       cfVH: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfVI: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfVK,
                       label: GHC.Base.$fSemigroup(,,,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVK: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cfVO; else goto cfVN;
       cfVO: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfVN: // global
           I64[Hp - 144] = sat_s8ky_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8kx_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_s8kw_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 62;
           P64[Hp - 8] = Hp - 103;
           P64[Hp] = Hp - 141;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.500791293 UTC

[section ""data" . GHC.Base.$w$cp1Monoid_closure" {
     GHC.Base.$w$cp1Monoid_closure:
         const GHC.Base.$w$cp1Monoid_info;
 },
 w4_s8l1_entry() //  [R1]
         { info_tbl: [(cfWg,
                       label: w4_s8l1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWh; else goto cfWi;
       cfWh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_s8l2_entry() //  [R1]
         { info_tbl: [(cfWn,
                       label: w5_s8l2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWo; else goto cfWp;
       cfWo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_s8l3_entry() //  [R1]
         { info_tbl: [(cfWu,
                       label: w6_s8l3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWv; else goto cfWw;
       cfWv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_s8l4_entry() //  [R1]
         { info_tbl: [(cfWB,
                       label: w7_s8l4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWC; else goto cfWD;
       cfWC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lg_entry() //  [R1]
         { info_tbl: [(cfWS,
                       label: sat_s8lg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfWT; else goto cfWU;
       cfWT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8lf_entry() //  [R1]
         { info_tbl: [(cfWZ,
                       label: sat_s8lf_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfX0; else goto cfX1;
       cfX0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfX1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8le_entry() //  [R1]
         { info_tbl: [(cfX6,
                       label: sat_s8le_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfX6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfX7; else goto cfX8;
       cfX7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfX8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8ld_entry() //  [R1]
         { info_tbl: [(cfXd,
                       label: sat_s8ld_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfXd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfXe; else goto cfXf;
       cfXe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8lh_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cfXg,
                       label: sat_s8lh_info
                       rep:HeapRep 4 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfXg: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cfXi; else goto cfXj;
       cfXi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfXj: // global
           I64[Sp - 56] = block_cfWJ_info;
           _s8l1::P64 = P64[R1 + 5];
           _s8l2::P64 = P64[R1 + 13];
           _s8l3::P64 = P64[R1 + 21];
           _s8l4::P64 = P64[R1 + 29];
           R1 = R4;
           P64[Sp - 48] = _s8l1::P64;
           P64[Sp - 40] = _s8l2::P64;
           P64[Sp - 32] = _s8l3::P64;
           P64[Sp - 24] = _s8l4::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ufXn; else goto cfWK;
       ufXn: // global
           call _cfWJ(R1) args: 0, res: 0, upd: 0;
       cfWK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWJ() //  [R1]
         { info_tbl: [(cfWJ,
                       label: block_cfWJ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWJ: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cfXm; else goto cfXl;
       cfXm: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfXl: // global
           _s8l9::P64 = P64[R1 + 7];
           _s8la::P64 = P64[R1 + 15];
           _s8lb::P64 = P64[R1 + 23];
           _s8lc::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_s8lg_info;
           P64[Hp - 208] = P64[Sp + 8];
           _s8l5::P64 = P64[Sp + 40];
           P64[Hp - 200] = _s8l5::P64;
           _s8l6::P64 = P64[Sp + 48];
           P64[Hp - 192] = _s8l6::P64;
           P64[Hp - 184] = _s8lc::P64;
           I64[Hp - 176] = sat_s8lf_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _s8l5::P64;
           P64[Hp - 144] = _s8l6::P64;
           P64[Hp - 136] = _s8lb::P64;
           I64[Hp - 128] = sat_s8le_info;
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = _s8l5::P64;
           P64[Hp - 96] = _s8l6::P64;
           P64[Hp - 88] = _s8la::P64;
           I64[Hp - 80] = sat_s8ld_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _s8l5::P64;
           P64[Hp - 48] = _s8l6::P64;
           P64[Hp - 40] = _s8l9::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 w4_s8kI_entry() //  [R1]
         { info_tbl: [(cfXs,
                       label: w4_s8kI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfXs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfXt; else goto cfXu;
       cfXt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_s8kJ_entry() //  [R1]
         { info_tbl: [(cfXz,
                       label: w5_s8kJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfXz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfXA; else goto cfXB;
       cfXA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_s8kK_entry() //  [R1]
         { info_tbl: [(cfXG,
                       label: w6_s8kK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfXG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfXH; else goto cfXI;
       cfXH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_s8kL_entry() //  [R1]
         { info_tbl: [(cfXN,
                       label: w7_s8kL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfXN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfXO; else goto cfXP;
       cfXO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8l0_entry() //  [R1, R2]
         { info_tbl: [(cfXY,
                       label: sat_s8l0_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfXY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfY9; else goto cfYa;
       cfY9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYa: // global
           I64[Sp - 40] = block_cfXV_info;
           _s8kI::P64 = P64[R1 + 7];
           _s8kJ::P64 = P64[R1 + 15];
           _s8kK::P64 = P64[R1 + 23];
           _s8kL::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _s8kI::P64;
           P64[Sp - 24] = _s8kJ::P64;
           P64[Sp - 16] = _s8kK::P64;
           P64[Sp - 8] = _s8kL::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYh; else goto cfXW;
       ufYh: // global
           call _cfXV(R1) args: 0, res: 0, upd: 0;
       cfXW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfXV() //  [R1]
         { info_tbl: [(cfXV,
                       label: block_cfXV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfXV: // global
           I64[Sp - 8] = block_cfY1_info;
           _s8kP::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8kP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYg; else goto cfY2;
       ufYg: // global
           call _cfY1(R1) args: 0, res: 0, upd: 0;
       cfY2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfY1() //  [R1]
         { info_tbl: [(cfY1,
                       label: block_cfY1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY1: // global
           _s8kL::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cfY6_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = _s8kL::P64;
           _s8kP::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _s8kP::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 _cfY6() //  [R1, R2, R3, R4]
         { info_tbl: [(cfY6,
                       label: block_cfY6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfY6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfYf; else goto cfYe;
       cfYf: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cfYe: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8kG_entry() //  [R1]
         { info_tbl: [(cfYm,
                       label: sat_s8kG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYn; else goto cfYo;
       cfYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kF_entry() //  [R1]
         { info_tbl: [(cfYt,
                       label: sat_s8kF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYu; else goto cfYv;
       cfYu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kE_entry() //  [R1]
         { info_tbl: [(cfYA,
                       label: sat_s8kE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYB; else goto cfYC;
       cfYB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kD_entry() //  [R1]
         { info_tbl: [(cfYH,
                       label: sat_s8kD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYI; else goto cfYJ;
       cfYI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8kH_entry() //  [R1, R2, R3]
         { info_tbl: [(cfYP,
                       label: sat_s8kH_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYQ; else goto cfYR;
       cfYQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYR: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cfYS,
                       label: GHC.Base.$w$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfYS: // global
           Hp = Hp + 408;
           if (Hp > HpLim) (likely: False) goto cfYW; else goto cfYV;
       cfYW: // global
           HpAlloc = 408;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYV: // global
           I64[Hp - 400] = w4_s8l1_info;
           P64[Hp - 384] = R5;
           I64[Hp - 376] = w5_s8l2_info;
           P64[Hp - 360] = R4;
           I64[Hp - 352] = w6_s8l3_info;
           P64[Hp - 336] = R3;
           I64[Hp - 328] = w7_s8l4_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s8lh_info;
           P64[Hp - 296] = Hp - 400;
           P64[Hp - 288] = Hp - 376;
           P64[Hp - 280] = Hp - 352;
           P64[Hp - 272] = Hp - 328;
           I64[Hp - 264] = w4_s8kI_info;
           P64[Hp - 248] = R5;
           I64[Hp - 240] = w5_s8kJ_info;
           P64[Hp - 224] = R4;
           I64[Hp - 216] = w6_s8kK_info;
           P64[Hp - 200] = R3;
           I64[Hp - 192] = w7_s8kL_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8l0_info;
           P64[Hp - 160] = Hp - 264;
           P64[Hp - 152] = Hp - 240;
           P64[Hp - 144] = Hp - 216;
           P64[Hp - 136] = Hp - 192;
           I64[Hp - 128] = sat_s8kG_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8kF_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_s8kE_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s8kD_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8kH_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R3 = Hp - 301;
           R2 = Hp - 167;
           R1 = Hp - 30;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.551675989 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg1d,
                       label: GHC.Base.$fMonoid(,,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1e; else goto cg1f;
       cg1e: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1f: // global
           I64[Sp - 8] = block_cg1a_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg1a() //  [R1, R2, R3]
         { info_tbl: [(cg1a,
                       label: block_cg1a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1a: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg1i; else goto cg1h;
       cg1i: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cg1h: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.557865846 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg1y,
                       label: GHC.Base.$fMonoid(,,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1z; else goto cg1A;
       cg1z: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1A: // global
           I64[Sp - 8] = block_cg1w_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg1w() //  [R1]
         { info_tbl: [(cg1w,
                       label: block_cg1w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1w: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.56517242 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,)_$cmconcat_info;
 },
 k_s8lC_entry() //  [R1]
         { info_tbl: [(cg1V,
                       label: k_s8lC_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1W; else goto cg1X;
       cg1W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1X: // global
           I64[Sp - 8] = block_cg1S_info;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _cg1S() //  [R1, R2, R3]
         { info_tbl: [(cg1S,
                       label: block_cg1S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg1S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg20; else goto cg1Z;
       cg20: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cg1Z: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 k1_s8lH_entry() //  [R1]
         { info_tbl: [(cg25,
                       label: k1_s8lH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg25: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg26; else goto cg27;
       cg26: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg27: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8lI_entry() //  [R1]
         { info_tbl: [(cg2c,
                       label: z_s8lI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2d; else goto cg2e;
       cg2d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8lJ_entry() //  [R1]
         { info_tbl: [(cg2j,
                       label: z1_s8lJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2k; else goto cg2l;
       cg2k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_s8lK_entry() //  [R1]
         { info_tbl: [(cg2q,
                       label: z2_s8lK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2r; else goto cg2s;
       cg2r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z3_s8lL_entry() //  [R1]
         { info_tbl: [(cg2x,
                       label: z3_s8lL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2y; else goto cg2z;
       cg2y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s8lN_entry() //  [R1, R2]
         { info_tbl: [(cg2N,
                       label: go_s8lN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg2O; else goto cg2P;
       cg2O: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg2P: // global
           I64[Sp - 32] = block_cg2G_info;
           _s8lN::P64 = R1;
           _s8lH::P64 = P64[R1 + 7];
           _s8lM::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s8lH::P64;
           P64[Sp - 16] = _s8lM::P64;
           P64[Sp - 8] = _s8lN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2Z; else goto cg2H;
       ug2Z: // global
           call _cg2G(R1) args: 0, res: 0, upd: 0;
       cg2H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg2G() //  [R1]
         { info_tbl: [(cg2G,
                       label: block_cg2G_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg2G: // global
           if (R1 & 7 == 1) goto cg2K; else goto cg2L;
       cg2K: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg2L: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg2Y; else goto cg2X;
       cg2Y: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2X: // global
           _s8lQ::P64 = P64[R1 + 6];
           _s8lR::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s8lR::P64;
           R3 = Hp - 24;
           R2 = _s8lQ::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg30,
                       label: GHC.Base.$fMonoid(,,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg30: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cg34; else goto cg33;
       cg34: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg33: // global
           I64[Hp - 224] = k_s8lC_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = k1_s8lH_info;
           P64[Hp - 160] = Hp - 224;
           I64[Hp - 152] = z_s8lI_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = z1_s8lJ_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = z2_s8lK_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = z3_s8lL_info;
           P64[Hp - 64] = R5;
           I64[Hp - 56] = (,,,)_con_info;
           P64[Hp - 48] = Hp - 152;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 104;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = go_s8lN_info;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.58846473 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_closure" {
     GHC.Base.$fMonoid(,,,)_closure:
         const GHC.Base.$fMonoid(,,,)_info;
 },
 sat_s8m0_entry() //  [R1]
         { info_tbl: [(cg43,
                       label: sat_s8m0_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg43: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg44; else goto cg45;
       cg44: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg45: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmconcat_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lZ_entry() //  [R1]
         { info_tbl: [(cg4a,
                       label: sat_s8lZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg4a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg4b; else goto cg4c;
       cg4b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg4c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmappend_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lY_entry() //  [R1]
         { info_tbl: [(cg4h,
                       label: sat_s8lY_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg4h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg4i; else goto cg4j;
       cg4i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg4j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmempty_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8lX_entry() //  [R1]
         { info_tbl: [(cg4o,
                       label: sat_s8lX_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg4o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg4p; else goto cg4q;
       cg4p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg4q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg4s,
                       label: GHC.Base.$fMonoid(,,,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg4s: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cg4w; else goto cg4v;
       cg4w: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg4v: // global
           I64[Hp - 224] = sat_s8m0_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = sat_s8lZ_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           I64[Hp - 128] = sat_s8lY_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           I64[Hp - 80] = sat_s8lX_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.602356149 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,)_$c<>_info;
 },
 sat_s8mg_entry() //  [R1]
         { info_tbl: [(cg5e,
                       label: sat_s8mg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5e: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5f; else goto cg5g;
       cg5f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8mf_entry() //  [R1]
         { info_tbl: [(cg5l,
                       label: sat_s8mf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5l: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5m; else goto cg5n;
       cg5m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8me_entry() //  [R1]
         { info_tbl: [(cg5s,
                       label: sat_s8me_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5s: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5t; else goto cg5u;
       cg5t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg5v,
                       label: GHC.Base.$fMonoid(,,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg5v: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg5x; else goto cg5y;
       cg5x: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5y: // global
           I64[Sp - 40] = block_cg50_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5E; else goto cg51;
       ug5E: // global
           call _cg50(R1) args: 0, res: 0, upd: 0;
       cg51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg50() //  [R1]
         { info_tbl: [(cg50,
                       label: block_cg50_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg50: // global
           I64[Sp - 16] = block_cg55_info;
           _s8m7::P64 = P64[R1 + 7];
           _s8m8::P64 = P64[R1 + 15];
           _s8m9::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _s8m9::P64;
           P64[Sp] = _s8m8::P64;
           P64[Sp + 32] = _s8m7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug5D; else goto cg56;
       ug5D: // global
           call _cg55(R1) args: 0, res: 0, upd: 0;
       cg56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg55() //  [R1]
         { info_tbl: [(cg55,
                       label: block_cg55_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg55: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cg5C; else goto cg5B;
       cg5C: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg5B: // global
           _s8mb::P64 = P64[R1 + 7];
           _s8mc::P64 = P64[R1 + 15];
           _s8md::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8mg_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8md::P64;
           I64[Hp - 104] = sat_s8mf_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s8mc::P64;
           I64[Hp - 64] = sat_s8me_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8mb::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.618891168 UTC

[section ""data" . GHC.Base.$w$csconcat1_closure" {
     GHC.Base.$w$csconcat1_closure:
         const GHC.Base.$w$csconcat1_info;
 },
 GHC.Base.$w$csconcat1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6l: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8mG_entry() //  [R1]
         { info_tbl: [(cg6L,
                       label: sat_s8mG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6L: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6M; else goto cg6N;
       cg6M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8mF_entry() //  [R1]
         { info_tbl: [(cg6S,
                       label: sat_s8mF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6S: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6T; else goto cg6U;
       cg6T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8mE_entry() //  [R1]
         { info_tbl: [(cg6Z,
                       label: sat_s8mE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6Z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg70; else goto cg71;
       cg70: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg71: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_s8mo_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cg76,
                       label: $wgo_s8mo_info
                       rep:HeapRep 3 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg76: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cg77; else goto cg78;
       cg77: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg78: // global
           I64[Sp - 64] = block_cg6u_info;
           _s8mo::P64 = R1;
           _s8mh::P64 = P64[R1 + 4];
           _s8mi::P64 = P64[R1 + 12];
           _s8mj::P64 = P64[R1 + 20];
           R1 = R5;
           P64[Sp - 56] = _s8mh::P64;
           P64[Sp - 48] = _s8mi::P64;
           P64[Sp - 40] = _s8mj::P64;
           P64[Sp - 32] = _s8mo::P64;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ug7h; else goto cg6v;
       ug7h: // global
           call _cg6u(R1) args: 0, res: 0, upd: 0;
       cg6v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6u() //  [R1]
         { info_tbl: [(cg6u,
                       label: block_cg6u_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6u: // global
           if (R1 & 7 == 1) goto cg73; else goto cg74;
       cg73: // global
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg74: // global
           I64[Sp - 8] = block_cg6A_info;
           _s8mv::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8mv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7g; else goto cg6B;
       ug7g: // global
           call _cg6A(R1) args: 0, res: 0, upd: 0;
       cg6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6A() //  [R1]
         { info_tbl: [(cg6A,
                       label: block_cg6A_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6A: // global
           _s8mv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cg6F_info;
           R5 = _s8mv::P64;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wgo_s8mo_entry(R5, R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg6F() //  [R1, R2, R3]
         { info_tbl: [(cg6F,
                       label: block_cg6F_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg6F: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg7f; else goto cg7e;
       cg7f: // global
           HpAlloc = 120;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cg7e: // global
           I64[Hp - 112] = sat_s8mG_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 56];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8mF_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8mE_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg7i,
                       label: GHC.Base.$w$csconcat1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg7i: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg7m; else goto cg7l;
       cg7m: // global
           HpAlloc = 32;
           R1 = GHC.Base.$w$csconcat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg7l: // global
           I64[Hp - 24] = $wgo_s8mo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _s8mk::P64 = R5;
           R5 = P64[Sp + 8];
           R4 = P64[Sp];
           R3 = R6;
           R2 = _s8mk::P64;
           R1 = Hp - 20;
           Sp = Sp + 16;
           call $wgo_s8mo_entry(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.639683597 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,)_$csconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cg8h,
                       label: GHC.Base.$fSemigroup(,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8h: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8s; else goto cg8t;
       cg8s: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$csconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8t: // global
           I64[Sp - 32] = block_cg8e_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug8A; else goto cg8f;
       ug8A: // global
           call _cg8e(R1) args: 0, res: 0, upd: 0;
       cg8f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8e() //  [R1]
         { info_tbl: [(cg8e,
                       label: block_cg8e_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8e: // global
           I64[Sp - 8] = block_cg8k_info;
           _s8mN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8mN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8z; else goto cg8l;
       ug8z: // global
           call _cg8k(R1) args: 0, res: 0, upd: 0;
       cg8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8k() //  [R1]
         { info_tbl: [(cg8k,
                       label: block_cg8k_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8k: // global
           _s8mJ::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg8p_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = _s8mJ::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 24, res: 8, upd: 8;
     }
 },
 _cg8p() //  [R1, R2, R3]
         { info_tbl: [(cg8p,
                       label: block_cg8p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8p: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg8y; else goto cg8x;
       cg8y: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cg8x: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.651022802 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,)_$cmappend_info;
 },
 sat_s8ne_entry() //  [R1]
         { info_tbl: [(cg9e,
                       label: sat_s8ne_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9e: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9f; else goto cg9g;
       cg9f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg9c_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg9c() //  [R1]
         { info_tbl: [(cg9c,
                       label: block_cg9c_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9c: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8nc_entry() //  [R1]
         { info_tbl: [(cg9q,
                       label: sat_s8nc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9r; else goto cg9s;
       cg9r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg9o_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg9o() //  [R1]
         { info_tbl: [(cg9o,
                       label: block_cg9o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9o: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8na_entry() //  [R1]
         { info_tbl: [(cg9C,
                       label: sat_s8na_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9C: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9D; else goto cg9E;
       cg9D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg9A_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cg9A() //  [R1]
         { info_tbl: [(cg9A,
                       label: block_cg9A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9A: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cg9I,
                       label: GHC.Base.$fMonoid(,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg9I: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg9K; else goto cg9L;
       cg9K: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9L: // global
           I64[Sp - 40] = block_cg8Y_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9R; else goto cg8Z;
       ug9R: // global
           call _cg8Y(R1) args: 0, res: 0, upd: 0;
       cg8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg8Y() //  [R1]
         { info_tbl: [(cg8Y,
                       label: block_cg8Y_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg8Y: // global
           I64[Sp - 16] = block_cg93_info;
           _s8n2::P64 = P64[R1 + 7];
           _s8n3::P64 = P64[R1 + 15];
           _s8n4::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _s8n4::P64;
           P64[Sp] = _s8n3::P64;
           P64[Sp + 32] = _s8n2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug9Q; else goto cg94;
       ug9Q: // global
           call _cg93(R1) args: 0, res: 0, upd: 0;
       cg94: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cg93() //  [R1]
         { info_tbl: [(cg93,
                       label: block_cg93_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cg93: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cg9P; else goto cg9O;
       cg9P: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9O: // global
           _s8n6::P64 = P64[R1 + 7];
           _s8n7::P64 = P64[R1 + 15];
           _s8n8::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8ne_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8n8::P64;
           I64[Hp - 104] = sat_s8nc_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s8n7::P64;
           I64[Hp - 64] = sat_s8na_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8n6::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.671649271 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,)_$cmconcat_info;
 },
 $dSemigroup_s8nj_entry() //  [R1]
         { info_tbl: [(cgaO,
                       label: $dSemigroup_s8nj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaP; else goto cgaQ;
       cgaP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup1_s8nk_entry() //  [R1]
         { info_tbl: [(cgaV,
                       label: $dSemigroup1_s8nk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgaV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaW; else goto cgaX;
       cgaW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup2_s8nl_entry() //  [R1]
         { info_tbl: [(cgb2,
                       label: $dSemigroup2_s8nl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb3; else goto cgb4;
       cgb3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s8nm_entry() //  [R1]
         { info_tbl: [(cgb9,
                       label: z_s8nm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgb9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgba; else goto cgbb;
       cgba: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_s8nn_entry() //  [R1]
         { info_tbl: [(cgbg,
                       label: z1_s8nn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbh; else goto cgbi;
       cgbh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_s8no_entry() //  [R1]
         { info_tbl: [(cgbn,
                       label: z2_s8no_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbo; else goto cgbp;
       cgbo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8nF_entry() //  [R1]
         { info_tbl: [(cgbP,
                       label: sat_s8nF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbQ; else goto cgbR;
       cgbQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8nE_entry() //  [R1]
         { info_tbl: [(cgbW,
                       label: sat_s8nE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbX; else goto cgbY;
       cgbX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8nD_entry() //  [R1]
         { info_tbl: [(cgc3,
                       label: sat_s8nD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgc3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc4; else goto cgc5;
       cgc4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_s8nq_entry() //  [R1, R2]
         { info_tbl: [(cgca,
                       label: go_s8nq_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgca: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgcb; else goto cgcc;
       cgcb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcc: // global
           I64[Sp - 48] = block_cgbw_info;
           _s8nq::P64 = R1;
           _s8nj::P64 = P64[R1 + 7];
           _s8nk::P64 = P64[R1 + 15];
           _s8nl::P64 = P64[R1 + 23];
           _s8np::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _s8nj::P64;
           P64[Sp - 32] = _s8nk::P64;
           P64[Sp - 24] = _s8nl::P64;
           P64[Sp - 16] = _s8np::P64;
           P64[Sp - 8] = _s8nq::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ugcm; else goto cgbx;
       ugcm: // global
           call _cgbw(R1) args: 0, res: 0, upd: 0;
       cgbx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbw() //  [R1]
         { info_tbl: [(cgbw,
                       label: block_cgbw_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbw: // global
           if (R1 & 7 == 1) goto cgc7; else goto cgc8;
       cgc7: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgc8: // global
           I64[Sp] = block_cgbC_info;
           _s8nu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 32] = _s8nu::P64;
           if (R1 & 7 != 0) goto ugcl; else goto cgbD;
       ugcl: // global
           call _cgbC(R1) args: 0, res: 0, upd: 0;
       cgbD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbC() //  [R1]
         { info_tbl: [(cgbC,
                       label: block_cgbC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbC: // global
           I64[Sp - 8] = block_cgbH_info;
           R2 = P64[Sp + 32];
           _s8nw::P64 = P64[R1 + 7];
           _s8nx::P64 = P64[R1 + 15];
           _s8ny::P64 = P64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp] = _s8ny::P64;
           P64[Sp + 32] = _s8nx::P64;
           P64[Sp + 40] = _s8nw::P64;
           Sp = Sp - 8;
           call go_s8nq_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgbH() //  [R1]
         { info_tbl: [(cgbH,
                       label: block_cgbH_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgbH: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cgck; else goto cgcj;
       cgck: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcj: // global
           _s8nA::P64 = P64[R1 + 7];
           _s8nB::P64 = P64[R1 + 15];
           _s8nC::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8nF_info;
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8nC::P64;
           I64[Hp - 104] = sat_s8nE_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = _s8nB::P64;
           I64[Hp - 64] = sat_s8nD_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8nA::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgcn,
                       label: GHC.Base.$fMonoid(,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgcn: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cgcr; else goto cgcq;
       cgcr: // global
           HpAlloc = 216;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcq: // global
           I64[Hp - 208] = $dSemigroup_s8nj_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = $dSemigroup1_s8nk_info;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = $dSemigroup2_s8nl_info;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = z_s8nm_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = z1_s8nn_info;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = z2_s8no_info;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = (,,)_con_info;
           P64[Hp - 56] = Hp - 136;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 88;
           I64[Hp - 32] = go_s8nq_info;
           P64[Hp - 24] = Hp - 208;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 160;
           P64[Hp] = Hp - 63;
           R2 = R5;
           R1 = Hp - 31;
           call go_s8nq_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.702597186 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,)_$cstimes_info;
 },
 sat_s8nS_entry() //  [R1]
         { info_tbl: [(cgdY,
                       label: sat_s8nS_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgdY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgdZ; else goto cge0;
       cgdZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8nR_entry() //  [R1]
         { info_tbl: [(cge5,
                       label: sat_s8nR_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cge5: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cge6; else goto cge7;
       cge6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8nQ_entry() //  [R1]
         { info_tbl: [(cgec,
                       label: sat_s8nQ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgec: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cged; else goto cgee;
       cged: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgee: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgef,
                       label: GHC.Base.$fSemigroup(,,)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgef: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeh; else goto cgei;
       cgeh: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgei: // global
           I64[Sp - 40] = block_cgdP_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugem; else goto cgdQ;
       ugem: // global
           call _cgdP(R1) args: 0, res: 0, upd: 0;
       cgdQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgdP() //  [R1]
         { info_tbl: [(cgdP,
                       label: block_cgdP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgdP: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cgel; else goto cgek;
       cgel: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgek: // global
           _s8nN::P64 = P64[R1 + 7];
           _s8nO::P64 = P64[R1 + 15];
           _s8nP::P64 = P64[R1 + 23];
           I64[Hp - 168] = sat_s8nS_info;
           P64[Hp - 152] = P64[Sp + 16];
           _s8nJ::P64 = P64[Sp + 24];
           P64[Hp - 144] = _s8nJ::P64;
           _s8nK::P64 = P64[Sp + 32];
           P64[Hp - 136] = _s8nK::P64;
           P64[Hp - 128] = _s8nP::P64;
           I64[Hp - 120] = sat_s8nR_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = _s8nJ::P64;
           P64[Hp - 88] = _s8nK::P64;
           P64[Hp - 80] = _s8nO::P64;
           I64[Hp - 72] = sat_s8nQ_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = _s8nJ::P64;
           P64[Hp - 40] = _s8nK::P64;
           P64[Hp - 32] = _s8nN::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 168;
           R1 = Hp - 23;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.716211986 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_closure" {
     GHC.Base.$fSemigroup(,,)_closure:
         const GHC.Base.$fSemigroup(,,)_info;
 },
 sat_s8nY_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgf7,
                       label: sat_s8nY_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgf7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgf8; else goto cgf9;
       cgf8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf9: // global
           R6 = R3;
           R5 = R2;
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fSemigroup(,,)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_s8nX_entry() //  [R1, R2]
         { info_tbl: [(cgff,
                       label: sat_s8nX_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgff: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,)_$csconcat_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8nW_entry() //  [R1, R2, R3]
         { info_tbl: [(cgfn,
                       label: sat_s8nW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfn: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$c<>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,)_entry() //  [R2, R3, R4]
         { info_tbl: [(cgfr,
                       label: GHC.Base.$fSemigroup(,,)_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfr: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgfv; else goto cgfu;
       cgfv: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfu: // global
           I64[Hp - 120] = sat_s8nY_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8nX_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_s8nW_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 117;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.727026361 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,)_$cp1Monoid_info;
 },
 sat_s8o4_entry() //  [R1]
         { info_tbl: [(cgfW,
                       label: sat_s8o4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgfW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfX; else goto cgfY;
       cgfX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8o3_entry() //  [R1]
         { info_tbl: [(cgg3,
                       label: sat_s8o3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgg3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg4; else goto cgg5;
       cgg4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8o2_entry() //  [R1]
         { info_tbl: [(cgga,
                       label: sat_s8o2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgga: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggb; else goto cggc;
       cggb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cp1Monoid_entry() //  [R2, R3, R4]
         { info_tbl: [(cggd,
                       label: GHC.Base.$fMonoid(,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggd: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cggh; else goto cggg;
       cggh: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggg: // global
           I64[Hp - 64] = sat_s8o4_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s8o3_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8o2_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,,)_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.737482917 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_closure" {
     GHC.Base.$fMonoid(,,)_closure:
         const GHC.Base.$fMonoid(,,)_info;
 },
 sat_s8ob_entry() //  [R1, R2]
         { info_tbl: [(cggH,
                       label: sat_s8ob_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggH: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,,)_$cmconcat_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oa_entry() //  [R1, R2, R3]
         { info_tbl: [(cggP,
                       label: sat_s8oa_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggP: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$cmappend_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8o9_entry() //  [R1]
         { info_tbl: [(cggW,
                       label: sat_s8o9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cggW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggX; else goto cggY;
       cggX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cmempty_entry(R4,
                                                     R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8o8_entry() //  [R1]
         { info_tbl: [(cgh3,
                       label: sat_s8o8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgh3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgh4; else goto cgh5;
       cgh4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgh5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cp1Monoid_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_entry() //  [R2, R3, R4]
         { info_tbl: [(cgh7,
                       label: GHC.Base.$fMonoid(,,)_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgh7: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cghb; else goto cgha;
       cghb: // global
           HpAlloc = 184;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgha: // global
           I64[Hp - 176] = sat_s8ob_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           P64[Hp - 152] = R4;
           I64[Hp - 144] = sat_s8oa_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_s8o9_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s8o8_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 142;
           P64[Hp] = Hp - 175;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.750484861 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$c<>_closure" {
     GHC.Base.$fSemigroup(,)_$c<>_closure:
         const GHC.Base.$fSemigroup(,)_$c<>_info;
 },
 sat_s8on_entry() //  [R1]
         { info_tbl: [(cghR,
                       label: sat_s8on_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghS; else goto cghT;
       cghS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s8om_entry() //  [R1]
         { info_tbl: [(cghY,
                       label: sat_s8om_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghZ; else goto cgi0;
       cghZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,)_$c<>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgi1,
                       label: GHC.Base.$fSemigroup(,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgi1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgi3; else goto cgi4;
       cgi3: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi4: // global
           I64[Sp - 32] = block_cghD_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugia; else goto cghE;
       ugia: // global
           call _cghD(R1) args: 0, res: 0, upd: 0;
       cghE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cghD() //  [R1]
         { info_tbl: [(cghD,
                       label: block_cghD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghD: // global
           I64[Sp - 8] = block_cghI_info;
           _s8oh::P64 = P64[R1 + 7];
           _s8oi::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8oi::P64;
           P64[Sp + 24] = _s8oh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugi9; else goto cghJ;
       ugi9: // global
           call _cghI(R1) args: 0, res: 0, upd: 0;
       cghJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cghI() //  [R1]
         { info_tbl: [(cghI,
                       label: block_cghI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cghI: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgi8; else goto cgi7;
       cgi8: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgi7: // global
           _s8ok::P64 = P64[R1 + 7];
           _s8ol::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s8on_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8ol::P64;
           I64[Hp - 56] = sat_s8om_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8ok::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.763206574 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,)_$cstimes_info;
 },
 sat_s8ox_entry() //  [R1]
         { info_tbl: [(cgiU,
                       label: sat_s8ox_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgiV; else goto cgiW;
       cgiV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s8ow_entry() //  [R1]
         { info_tbl: [(cgj1,
                       label: sat_s8ow_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgj1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgj2; else goto cgj3;
       cgj2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgj3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgj4,
                       label: GHC.Base.$fSemigroup(,)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgj4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgj6; else goto cgj7;
       cgj6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgj7: // global
           I64[Sp - 40] = block_cgiL_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugjb; else goto cgiM;
       ugjb: // global
           call _cgiL(R1) args: 0, res: 0, upd: 0;
       cgiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgiL() //  [R1]
         { info_tbl: [(cgiL,
                       label: block_cgiL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgiL: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgja; else goto cgj9;
       cgja: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgj9: // global
           _s8ou::P64 = P64[R1 + 7];
           _s8ov::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_s8ox_info;
           P64[Hp - 96] = P64[Sp + 16];
           _s8oq::P64 = P64[Sp + 24];
           P64[Hp - 88] = _s8oq::P64;
           _s8or::P64 = P64[Sp + 32];
           P64[Hp - 80] = _s8or::P64;
           P64[Hp - 72] = _s8ov::P64;
           I64[Hp - 64] = sat_s8ow_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _s8oq::P64;
           P64[Hp - 32] = _s8or::P64;
           P64[Hp - 24] = _s8ou::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.774905458 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_closure" {
     GHC.Base.$fSemigroup(,)_closure:
         const GHC.Base.$fSemigroup(,)_info;
 },
 sat_s8oC_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgjN,
                       label: sat_s8oC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjN: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oB_entry() //  [R1, R2]
         { info_tbl: [(cgjV,
                       label: sat_s8oB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgjV: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,)_$csconcat_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oA_entry() //  [R1, R2, R3]
         { info_tbl: [(cgk3,
                       label: sat_s8oA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk3: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroup(,)_$c<>_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,)_entry() //  [R2, R3]
         { info_tbl: [(cgk7,
                       label: GHC.Base.$fSemigroup(,)_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgk7: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgkb; else goto cgka;
       cgkb: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgka: // global
           I64[Hp - 96] = sat_s8oC_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8oB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s8oA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 46;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 93;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.784413474 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,)_$cp1Monoid_info;
 },
 sat_s8oG_entry() //  [R1]
         { info_tbl: [(cgkB,
                       label: sat_s8oG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkC; else goto cgkD;
       cgkC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oF_entry() //  [R1]
         { info_tbl: [(cgkI,
                       label: sat_s8oF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkJ; else goto cgkK;
       cgkJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cp1Monoid_entry() //  [R2, R3]
         { info_tbl: [(cgkL,
                       label: GHC.Base.$fMonoid(,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgkL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgkP; else goto cgkO;
       cgkP: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkO: // global
           I64[Hp - 40] = sat_s8oG_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8oF_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,)_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.793172499 UTC

[section ""data" . GHC.Base.$fMonoid(,)_closure" {
     GHC.Base.$fMonoid(,)_closure:
         const GHC.Base.$fMonoid(,)_info;
 },
 sat_s8oM_entry() //  [R1, R2]
         { info_tbl: [(cglb,
                       label: sat_s8oM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglb: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,)_$cmconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oL_entry() //  [R1, R2, R3]
         { info_tbl: [(cglj,
                       label: sat_s8oL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglj: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,)_$cmappend_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8oK_entry() //  [R1]
         { info_tbl: [(cglq,
                       label: sat_s8oK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglr; else goto cgls;
       cglr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgls: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cmempty_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8oJ_entry() //  [R1]
         { info_tbl: [(cglx,
                       label: sat_s8oJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgly; else goto cglz;
       cgly: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cp1Monoid_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_entry() //  [R2, R3]
         { info_tbl: [(cglB,
                       label: GHC.Base.$fMonoid(,)_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cglB: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cglF; else goto cglE;
       cglF: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglE: // global
           I64[Hp - 144] = sat_s8oM_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_s8oL_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_s8oK_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8oJ_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 143;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.804711548 UTC

[section ""data" . GHC.Base.$fMonoid()_$c<>_closure" {
     GHC.Base.$fMonoid()_$c<>_closure:
         const GHC.Base.$fMonoid()_$c<>_info;
 },
 GHC.Base.$fMonoid()_$c<>_entry() //  []
         { info_tbl: [(cgm7,
                       label: GHC.Base.$fMonoid()_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgm7: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.808590462 UTC

[section ""data" . GHC.Base.$fSemigroup()_$csconcat_closure" {
     GHC.Base.$fSemigroup()_$csconcat_closure:
         const GHC.Base.$fSemigroup()_$csconcat_info;
 },
 GHC.Base.$fSemigroup()_$csconcat_entry() //  []
         { info_tbl: [(cgmj,
                       label: GHC.Base.$fSemigroup()_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmj: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.812042846 UTC

[section ""data" . GHC.Base.$fSemigroup()_$cstimes_closure" {
     GHC.Base.$fSemigroup()_$cstimes_closure:
         const GHC.Base.$fSemigroup()_$cstimes_info;
 },
 GHC.Base.$fSemigroup()_$cstimes_entry() //  []
         { info_tbl: [(cgmv,
                       label: GHC.Base.$fSemigroup()_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmv: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.815812229 UTC

[section ""data" . GHC.Base.$fSemigroup()_closure" {
     GHC.Base.$fSemigroup()_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fSemigroup()_$csconcat_closure+1;
         const GHC.Base.$fSemigroup()_$cstimes_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.817630626 UTC

[section ""data" . GHC.Base.$fMonoid()_closure" {
     GHC.Base.$fMonoid()_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup()_closure+1;
         const GHC.Tuple.()_closure+1;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fMonoid()_$cmconcat_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.819800244 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$c<>_closure" {
     GHC.Base.$fSemigroup(->)_$c<>_closure:
         const GHC.Base.$fSemigroup(->)_$c<>_info;
 },
 GHC.Base.$fSemigroup(->)_$c<>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgmL,
                       label: GHC.Base.$fSemigroup(->)_$c<>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgmL: // global
           _s8oW::P64 = R5;
           _s8oV::P64 = R4;
           _s8oU::P64 = R3;
           _s8oT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmM; else goto cgmN;
       cgmN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmP; else goto cgmO;
       cgmP: // global
           HpAlloc = 64;
           goto cgmM;
       cgmM: // global
           R5 = _s8oW::P64;
           R4 = _s8oV::P64;
           R3 = _s8oU::P64;
           R2 = _s8oT::P64;
           R1 = GHC.Base.$fSemigroup(->)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmO: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s8oV::P64;
           P64[Hp - 32] = _s8oW::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s8oU::P64;
           P64[Hp] = _s8oW::P64;
           R2 = _s8oT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.824470683 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$cstimes_closure" {
     GHC.Base.$fSemigroup(->)_$cstimes_closure:
         const GHC.Base.$fSemigroup(->)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(->)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgn2,
                       label: GHC.Base.$fSemigroup(->)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgn2: // global
           _s8p3::P64 = R6;
           _s8p2::P64 = R5;
           _s8p1::P64 = R4;
           _s8p0::P64 = R3;
           _s8oZ::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgn3; else goto cgn4;
       cgn4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgn6; else goto cgn5;
       cgn6: // global
           HpAlloc = 32;
           goto cgn3;
       cgn3: // global
           R6 = _s8p3::P64;
           R5 = _s8p2::P64;
           R4 = _s8p1::P64;
           R3 = _s8p0::P64;
           R2 = _s8oZ::P64;
           R1 = GHC.Base.$fSemigroup(->)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgn5: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s8p2::P64;
           P64[Hp] = _s8p3::P64;
           R2 = _s8oZ::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s8p0::P64;
           P64[Sp - 16] = _s8p1::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.830376722 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_closure" {
     GHC.Base.$fSemigroup(->)_closure:
         const GHC.Base.$fSemigroup(->)_info;
 },
 sat_s8p8_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cgnm,
                       label: sat_s8p8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnm: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8p7_entry() //  [R1, R2]
         { info_tbl: [(cgnu,
                       label: sat_s8p7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8p6_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgnC,
                       label: sat_s8p6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnC: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(->)_entry() //  [R2]
         { info_tbl: [(cgnG,
                       label: GHC.Base.$fSemigroup(->)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgnG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgnK; else goto cgnJ;
       cgnK: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgnJ: // global
           I64[Hp - 72] = sat_s8p8_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8p7_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8p6_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.839425755 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(->)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(->)_$cp1Monoid_info;
 },
 sat_s8pa_entry() //  [R1]
         { info_tbl: [(cgoa,
                       label: sat_s8pa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgob; else goto cgoc;
       cgob: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(->)_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cgod,
                       label: GHC.Base.$fMonoid(->)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgod: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoh; else goto cgog;
       cgoh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgog: // global
           I64[Hp - 16] = sat_s8pa_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(->)_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.846652054 UTC

[section ""data" . GHC.Base.$fMonoid(->)_closure" {
     GHC.Base.$fMonoid(->)_closure:
         const GHC.Base.$fMonoid(->)_info;
 },
 lvl3_s8pc_entry() //  [R1]
         { info_tbl: [(cgoy,
                       label: lvl3_s8pc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoz; else goto cgoA;
       cgoz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ph_entry() //  [R1, R2, R3]
         { info_tbl: [(cgoG,
                       label: sat_s8ph_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgoO,
                       label: sat_s8pg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoO: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pf_entry() //  [R1]
         { info_tbl: [(cgoW,
                       label: sat_s8pf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgoW: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pd_entry() //  [R1]
         { info_tbl: [(cgp3,
                       label: sat_s8pd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp4; else goto cgp5;
       cgp4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(->)_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(->)_entry() //  [R2]
         { info_tbl: [(cgp7,
                       label: GHC.Base.$fMonoid(->)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgp7: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgpb; else goto cgpa;
       cgpb: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpa: // global
           I64[Hp - 128] = lvl3_s8pc_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8ph_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8pg_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s8pf_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_s8pd_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.859597423 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$cstimes_closure" {
     GHC.Base.$fSemigroup[]_$cstimes_closure:
         const GHC.Base.$fSemigroup[]_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroup[]_$cstimes_entry() //  [R2]
         { info_tbl: [(cgpH,
                       label: GHC.Base.$fSemigroup[]_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpH: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.863195292 UTC

[section ""data" . GHC.Base.$fSemigroup[]_closure" {
     GHC.Base.$fSemigroup[]_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fSemigroup[]_$csconcat_closure+1;
         const GHC.Base.$fSemigroup[]_$cstimes_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.864939064 UTC

[section ""data" . GHC.Base.$fMonoid[]_closure" {
     GHC.Base.$fMonoid[]_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fMonoid[]_$cmconcat_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.867070889 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cpure_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cpure_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cpure_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cpure_entry() //  [R2]
         { info_tbl: [(cgpV,
                       label: GHC.Base.$fApplicativeNonEmpty_$cpure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgpV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpZ; else goto cgpY;
       cgpZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpY: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.872447477 UTC

[section ""data" . GHC.Base.$w$cliftA2_closure" {
     GHC.Base.$w$cliftA2_closure:
         const GHC.Base.$w$cliftA2_info;
 },
 sat_s8pq_entry() //  [R1, R2]
         { info_tbl: [(cgql,
                       label: sat_s8pq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgql: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgqp; else goto cgqo;
       cgqp: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqo: // global
           _s8pk::P64 = P64[R1 + 7];
           _s8pn::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _s8pk::P64;
           P64[Hp - 32] = _s8pn::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pu_entry() //  [R1, R2]
         { info_tbl: [(cgqt,
                       label: sat_s8pu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqt: // global
           _s8pn::P64 = R2;
           _s8pu::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cgqu; else goto cgqv;
       cgqv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqx; else goto cgqw;
       cgqx: // global
           HpAlloc = 24;
           goto cgqu;
       cgqu: // global
           R2 = _s8pn::P64;
           R1 = _s8pu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqw: // global
           _s8pk::P64 = P64[_s8pu::P64 + 7];
           _s8pm::P64 = P64[_s8pu::P64 + 15];
           I64[Hp - 16] = sat_s8pq_info;
           P64[Hp - 8] = _s8pk::P64;
           P64[Hp] = _s8pn::P64;
           I64[Sp - 8] = block_cgqq_info;
           R3 = Hp - 15;
           R2 = _s8pm::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgqq() //  [R1, R2]
         { info_tbl: [(cgqq,
                       label: block_cgqq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqA; else goto cgqz;
       cgqA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgqz: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cgqB,
                       label: GHC.Base.$w$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgqB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqF; else goto cgqE;
       cgqF: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqE: // global
           I64[Hp - 16] = sat_s8pu_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _s8pl::P64 = R3;
           R3 = Hp - 15;
           R2 = _s8pl::P64;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.883301034 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cgr4,
                       label: GHC.Base.$fApplicativeNonEmpty_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgr5; else goto cgr6;
       cgr5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgr6: // global
           I64[Sp - 8] = block_cgr1_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cliftA2_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgr1() //  [R1, R2]
         { info_tbl: [(cgr1,
                       label: block_cgr1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgr1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgr9; else goto cgr8;
       cgr9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgr8: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.889669735 UTC

[section ""data" . GHC.Base.$w$c<*_closure" {
     GHC.Base.$w$c<*_closure:
         const GHC.Base.$w$c<*_info;
 },
 sat_s8pG_entry() //  [R1]
         { info_tbl: [(cgry,
                       label: sat_s8pG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgry: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pK_entry() //  [R1, R2]
         { info_tbl: [(cgrE,
                       label: sat_s8pK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrE: // global
           _s8pD::P64 = R2;
           _s8pK::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cgrF; else goto cgrG;
       cgrG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgrI; else goto cgrH;
       cgrI: // global
           HpAlloc = 40;
           goto cgrF;
       cgrF: // global
           R2 = _s8pD::P64;
           R1 = _s8pK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrH: // global
           _s8pC::P64 = P64[_s8pK::P64 + 7];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _s8pD::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = sat_s8pG_info;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_cgrB_info;
           R3 = Hp - 7;
           R2 = _s8pC::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgrB() //  [R1, R2]
         { info_tbl: [(cgrB,
                       label: block_cgrB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrL; else goto cgrK;
       cgrL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgrK: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$c<*_entry() //  [R2, R3]
         { info_tbl: [(cgrM,
                       label: GHC.Base.$w$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgrM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgrQ; else goto cgrP;
       cgrQ: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrP: // global
           I64[Hp - 8] = sat_s8pK_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.899864159 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*_entry() //  [R2, R3]
         { info_tbl: [(cgsf,
                       label: GHC.Base.$fApplicativeNonEmpty_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgsg; else goto cgsh;
       cgsg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgsh: // global
           I64[Sp - 8] = block_cgsc_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgsc() //  [R1, R2]
         { info_tbl: [(cgsc,
                       label: block_cgsc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgsk; else goto cgsj;
       cgsk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgsj: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.9066259 UTC

[section ""data" . GHC.Base.$w$c<*>_closure" {
     GHC.Base.$w$c<*>_closure:
         const GHC.Base.$w$c<*>_info;
 },
 sat_s8pV_entry() //  [R1, R2]
         { info_tbl: [(cgsK,
                       label: sat_s8pV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgsO; else goto cgsN;
       cgsO: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgsN: // global
           _s8pS::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s8pS::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8pZ_entry() //  [R1, R2]
         { info_tbl: [(cgsS,
                       label: sat_s8pZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsS: // global
           _s8pS::P64 = R2;
           _s8pZ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cgsT; else goto cgsU;
       cgsU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgsW; else goto cgsV;
       cgsW: // global
           HpAlloc = 16;
           goto cgsT;
       cgsT: // global
           R2 = _s8pS::P64;
           R1 = _s8pZ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgsV: // global
           _s8pR::P64 = P64[_s8pZ::P64 + 7];
           I64[Hp - 8] = sat_s8pV_info;
           P64[Hp] = _s8pS::P64;
           I64[Sp - 8] = block_cgsP_info;
           R3 = Hp - 7;
           R2 = _s8pR::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgsP() //  [R1, R2]
         { info_tbl: [(cgsP,
                       label: block_cgsP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgsP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgsZ; else goto cgsY;
       cgsZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgsY: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$c<*>_entry() //  [R2, R3]
         { info_tbl: [(cgt0,
                       label: GHC.Base.$w$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgt0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgt4; else goto cgt3;
       cgt4: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgt3: // global
           I64[Hp - 8] = sat_s8pZ_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.917096144 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(cgtt,
                       label: GHC.Base.$fApplicativeNonEmpty_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgtt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgtu; else goto cgtv;
       cgtu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgtv: // global
           I64[Sp - 8] = block_cgtq_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cgtq() //  [R1, R2]
         { info_tbl: [(cgtq,
                       label: block_cgtq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgtq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgty; else goto cgtx;
       cgty: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgtx: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.922806388 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty1_closure" {
     GHC.Base.$fApplicativeNonEmpty1_closure:
         const GHC.Base.$fApplicativeNonEmpty1_info;
 },
 GHC.Base.$fApplicativeNonEmpty1_entry() //  [R3]
         { info_tbl: [(cgtM,
                       label: GHC.Base.$fApplicativeNonEmpty1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgtM: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.927695298 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c*>_info;
 },
 sat_s8qc_entry() //  [R1]
         { info_tbl: [(cgu4,
                       label: sat_s8qc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgu4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgu5; else goto cgu6;
       cgu5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgu6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgu1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugua; else goto cgu2;
       ugua: // global
           call _cgu1(R1) args: 0, res: 0, upd: 0;
       cgu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cgu1() //  [R1]
         { info_tbl: [(cgu1,
                       label: block_cgu1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgu1: // global
           R3 = P64[R1 + 15];
           R2 = GHC.Base.$fApplicativeNonEmpty1_closure+2;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicativeNonEmpty_$c*>_entry() //  [R2, R3]
         { info_tbl: [(cguf,
                       label: GHC.Base.$fApplicativeNonEmpty_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cguf: // global
           _s8q8::P64 = R3;
           _s8q7::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cgug; else goto cguh;
       cguh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cguj; else goto cgui;
       cguj: // global
           HpAlloc = 48;
           goto cgug;
       cgug: // global
           R3 = _s8q8::P64;
           R2 = _s8q7::P64;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgui: // global
           I64[Hp - 40] = sat_s8qc_info;
           P64[Hp - 24] = _s8q7::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = GHC.Base.breakpoint_closure+1;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_cguc_info;
           R3 = _s8q8::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cguc() //  [R1, R2]
         { info_tbl: [(cguc,
                       label: block_cguc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cguc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgum; else goto cgul;
       cgum: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgul: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.937077986 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_closure" {
     GHC.Base.$fApplicativeNonEmpty_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeNonEmpty_$c*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.939813806 UTC

[section ""data" . lvl_r7PJ_closure" {
     lvl_r7PJ_closure:
         const lvl_r7PJ_info;
         const 0;
 },
 lvl_r7PJ_entry() //  [R2]
         { info_tbl: [(cguK,
                       label: lvl_r7PJ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cguK: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.942977586 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_closure" {
     GHC.Base.$fMonadNonEmpty_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeNonEmpty_closure+1;
         const GHC.Base.$fMonadNonEmpty_$c>>=_closure+2;
         const GHC.Base.$fMonadNonEmpty_$c>>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const lvl_r7PJ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.944823896 UTC

[section ""cstring" . GHC.Base.$fAlternativeIO4_bytes" {
     GHC.Base.$fAlternativeIO4_bytes:
         I8[] [109,122,101,114,111]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.946799019 UTC

[section ""data" . GHC.Base.$fAlternativeIO3_closure" {
     GHC.Base.$fAlternativeIO3_closure:
         const GHC.Base.$fAlternativeIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO3_entry() //  [R1]
         { info_tbl: [(cguZ,
                       label: GHC.Base.$fAlternativeIO3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cguZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgv0; else goto cgv1;
       cgv0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgv1: // global
           (_cguW::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cguW::I64 == 0) goto cguY; else goto cguX;
       cguY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cguX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cguW::I64;
           R2 = GHC.Base.$fAlternativeIO4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.951533665 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cempty_closure" {
     GHC.Base.$fAlternativeIO_$cempty_closure:
         const GHC.Base.$fAlternativeIO_$cempty_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO_$cempty_entry() //  [R1]
         { info_tbl: [(cgvf,
                       label: GHC.Base.$fAlternativeIO_$cempty_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgvf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgvg; else goto cgvh;
       cgvg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgvh: // global
           (_cgvc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgvc::I64 == 0) goto cgve; else goto cgvd;
       cgve: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgvd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgvc::I64;
           R2 = GHC.Base.$fAlternativeIO3_closure;
           R1 = GHC.IO.failIO_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.956129651 UTC

[section ""data" . GHC.Base.$fAlternativeIO_closure" {
     GHC.Base.$fAlternativeIO_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure+2;
         const GHC.Base.$fAlternativeIO_$cmany_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.957957665 UTC

[section ""data" . GHC.Base.$fMonadPlusIO_closure" {
     GHC.Base.$fMonadPlusIO_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeIO_closure+1;
         const GHC.Base.$fMonadIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.960104086 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$c<|>_closure" {
     GHC.Base.$fAlternativeMaybe_$c<|>_closure:
         const GHC.Base.$fAlternativeMaybe_$c<|>_info;
 },
 GHC.Base.$fAlternativeMaybe_$c<|>_entry() //  [R2, R3]
         { info_tbl: [(cgvC,
                       label: GHC.Base.$fAlternativeMaybe_$c<|>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgvC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgvD; else goto cgvE;
       cgvD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$c<|>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgvE: // global
           I64[Sp - 16] = block_cgvv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugvL; else goto cgvw;
       ugvL: // global
           call _cgvv(R1) args: 0, res: 0, upd: 0;
       cgvw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgvv() //  [R1]
         { info_tbl: [(cgvv,
                       label: block_cgvv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgvv: // global
           if (R1 & 7 == 1) goto cgvz; else goto cgvA;
       cgvz: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cgvA: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.967110332 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cliftA2_closure" {
     GHC.Base.$fApplicativeMaybe_$cliftA2_closure:
         const GHC.Base.$fApplicativeMaybe_$cliftA2_info;
 },
 GHC.Base.$fApplicativeMaybe_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cgwc,
                       label: GHC.Base.$fApplicativeMaybe_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgwc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgwd; else goto cgwe;
       cgwd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgwe: // global
           I64[Sp - 24] = block_cgw5_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugwG; else goto cgw6;
       ugwG: // global
           call _cgw5(R1) args: 0, res: 0, upd: 0;
       cgw6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgw5() //  [R1]
         { info_tbl: [(cgw5,
                       label: block_cgw5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgw5: // global
           if (R1 & 7 == 1) goto ugwC; else goto cgwa;
       ugwC: // global
           Sp = Sp + 24;
           call _cgws() args: 0, res: 0, upd: 0;
       cgwa: // global
           I64[Sp] = block_cgwk_info;
           _s8qq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8qq::P64;
           if (R1 & 7 != 0) goto ugwE; else goto cgwm;
       ugwE: // global
           call _cgwk(R1) args: 0, res: 0, upd: 0;
       cgwm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgwk() //  [R1]
         { info_tbl: [(cgwk,
                       label: block_cgwk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgwk: // global
           if (R1 & 7 == 1) goto ugwD; else goto cgwx;
       ugwD: // global
           Sp = Sp + 24;
           call _cgws() args: 0, res: 0, upd: 0;
       cgwx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgwA; else goto cgwz;
       cgwA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgwz: // global
           _s8qs::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _s8qs::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgws() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgws: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.976471412 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c*>_entry() //  [R2, R3]
         { info_tbl: [(cgxh,
                       label: GHC.Base.$fApplicativeMaybe_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgxh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgxi; else goto cgxj;
       cgxi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgxj: // global
           I64[Sp - 16] = block_cgxa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugxq; else goto cgxb;
       ugxq: // global
           call _cgxa(R1) args: 0, res: 0, upd: 0;
       cgxb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgxa() //  [R1]
         { info_tbl: [(cgxa,
                       label: block_cgxa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgxa: // global
           if (R1 & 7 == 1) goto cgxe; else goto cgxf;
       cgxe: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgxf: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.983267647 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*>_closure" {
     GHC.Base.$fApplicative(->)_$c<*>_closure:
         const GHC.Base.$fApplicative(->)_$c<*>_info;
 },
 GHC.Base.$fApplicative(->)_$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(cgxK,
                       label: GHC.Base.$fApplicative(->)_$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgxK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgxO; else goto cgxN;
       cgxO: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgxN: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 24;
           _s8qy::P64 = R2;
           R2 = R4;
           R1 = _s8qy::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.987475881 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$cliftA2_closure" {
     GHC.Base.$fApplicative(->)_$cliftA2_closure:
         const GHC.Base.$fApplicative(->)_$cliftA2_info;
 },
 GHC.Base.$fApplicative(->)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgxZ,
                       label: GHC.Base.$fApplicative(->)_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgxZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgy3; else goto cgy2;
       cgy3: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgy2: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _s8qC::P64 = R2;
           R2 = Hp - 24;
           R1 = _s8qC::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.991416861 UTC

[section ""data" . GHC.Base.$fApplicative(->)_closure" {
     GHC.Base.$fApplicative(->)_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor(->)_closure+1;
         const GHC.Base.const_closure+2;
         const GHC.Base.$fApplicative(->)_$c<*>_closure+3;
         const GHC.Base.$fApplicative(->)_$cliftA2_closure+4;
         const GHC.Base.$fApplicative(->)_$c*>_closure+3;
         const GHC.Base.$fApplicative(->)_$c<*_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.993925522 UTC

[section ""data" . lvl1_r7PK_closure" {
     lvl1_r7PK_closure:
         const lvl1_r7PK_info;
         const 0;
 },
 lvl1_r7PK_entry() //  [R2]
         { info_tbl: [(cgyd,
                       label: lvl1_r7PK_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgyd: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.997118305 UTC

[section ""data" . GHC.Base.$fMonad(->)_closure" {
     GHC.Base.$fMonad(->)_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative(->)_closure+1;
         const GHC.Base.$fMonad(->)_$c>>=_closure+3;
         const GHC.Base.$fMonad(->)_$c>>_closure+3;
         const GHC.Base.const_closure+2;
         const lvl1_r7PK_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:46.999381527 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cfmap_closure" {
     GHC.Base.$fApplicativeMaybe_$cfmap_closure:
         const GHC.Base.$fApplicativeMaybe_$cfmap_info;
 },
 GHC.Base.$fApplicativeMaybe_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(cgyw,
                       label: GHC.Base.$fApplicativeMaybe_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgyw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgyx; else goto cgyy;
       cgyx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgyy: // global
           I64[Sp - 16] = block_cgyp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugyJ; else goto cgyq;
       ugyJ: // global
           call _cgyp(R1) args: 0, res: 0, upd: 0;
       cgyq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgyp() //  [R1]
         { info_tbl: [(cgyp,
                       label: block_cgyp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgyp: // global
           if (R1 & 7 == 1) goto cgyt; else goto cgyu;
       cgyt: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgyu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgyI; else goto cgyH;
       cgyI: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgyH: // global
           _s8qM::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8qM::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.005530336 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_closure" {
     GHC.Base.$fFunctorMaybe_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.008110272 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(cgzb,
                       label: GHC.Base.$fApplicativeMaybe_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgzb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgzc; else goto cgzd;
       cgzc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgzd: // global
           I64[Sp - 16] = block_cgz4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugzk; else goto cgz5;
       ugzk: // global
           call _cgz4(R1) args: 0, res: 0, upd: 0;
       cgz5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgz4() //  [R1]
         { info_tbl: [(cgz4,
                       label: block_cgz4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgz4: // global
           if (R1 & 7 == 1) goto cgz8; else goto cgz9;
       cgz8: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgz9: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.013829032 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_closure" {
     GHC.Base.$fApplicativeMaybe_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorMaybe_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.01563958 UTC

[section ""data" . GHC.Base.$fMonadMaybe_closure" {
     GHC.Base.$fMonadMaybe_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.017902878 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_closure" {
     GHC.Base.$fAlternativeMaybe_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const GHC.Base.$fAlternativeMaybe_$csome_closure+1;
         const GHC.Base.$fAlternativeMaybe_$cmany_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.019755885 UTC

[section ""data" . GHC.Base.$fMonadPlusMaybe_closure" {
     GHC.Base.$fMonadPlusMaybe_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.022993844 UTC

[section ""data" . GHC.Base.liftA3_$sliftA3_closure" {
     GHC.Base.liftA3_$sliftA3_closure:
         const GHC.Base.liftA3_$sliftA3_info;
 },
 GHC.Base.liftA3_$sliftA3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgzM,
                       label: GHC.Base.liftA3_$sliftA3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgzM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgzN; else goto cgzO;
       cgzN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA3_$sliftA3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgzO: // global
           I64[Sp - 32] = block_cgzF_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugAu; else goto cgzG;
       ugAu: // global
           call _cgzF(R1) args: 0, res: 0, upd: 0;
       cgzG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgzF() //  [R1]
         { info_tbl: [(cgzF,
                       label: block_cgzF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgzF: // global
           if (R1 & 7 == 1) goto ugAp; else goto cgzK;
       ugAp: // global
           Sp = Sp + 32;
           call _cgAe() args: 0, res: 0, upd: 0;
       cgzK: // global
           I64[Sp] = block_cgzU_info;
           _s8qX::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8qX::P64;
           if (R1 & 7 != 0) goto ugAs; else goto cgzW;
       ugAs: // global
           call _cgzU(R1) args: 0, res: 0, upd: 0;
       cgzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgzU() //  [R1]
         { info_tbl: [(cgzU,
                       label: block_cgzU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgzU: // global
           if (R1 & 7 == 1) goto ugAq; else goto cgA7;
       ugAq: // global
           Sp = Sp + 32;
           call _cgAe() args: 0, res: 0, upd: 0;
       cgA7: // global
           I64[Sp] = block_cgA5_info;
           _s8qZ::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s8qZ::P64;
           if (R1 & 7 != 0) goto ugAv; else goto cgA8;
       ugAv: // global
           call _cgA5(R1) args: 0, res: 0, upd: 0;
       cgA8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgA5() //  [R1]
         { info_tbl: [(cgA5,
                       label: block_cgA5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgA5: // global
           if (R1 & 7 == 1) goto ugAr; else goto cgAj;
       ugAr: // global
           Sp = Sp + 32;
           call _cgAe() args: 0, res: 0, upd: 0;
       cgAj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgAm; else goto cgAl;
       cgAm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgAl: // global
           _s8r1::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s8r1::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cgAe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgAe: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.035560113 UTC

[section ""data" . GHC.Base.liftA3_closure" {
     GHC.Base.liftA3_closure:
         const GHC.Base.liftA3_info;
 },
 sat_s8r8_entry() //  [R1]
         { info_tbl: [(cgBb,
                       label: sat_s8r8_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgBb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgBc; else goto cgBd;
       cgBc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgBd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.liftA3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgBe,
                       label: GHC.Base.liftA3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgBe: // global
           _s8r7::P64 = R6;
           _s8r6::P64 = R5;
           _s8r5::P64 = R4;
           _s8r4::P64 = R3;
           _s8r3::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgBf; else goto cgBg;
       cgBg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgBi; else goto cgBh;
       cgBi: // global
           HpAlloc = 48;
           goto cgBf;
       cgBf: // global
           R6 = _s8r7::P64;
           R5 = _s8r6::P64;
           R4 = _s8r5::P64;
           R3 = _s8r4::P64;
           R2 = _s8r3::P64;
           R1 = GHC.Base.liftA3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgBh: // global
           I64[Hp - 40] = sat_s8r8_info;
           P64[Hp - 24] = _s8r3::P64;
           P64[Hp - 16] = _s8r4::P64;
           P64[Hp - 8] = _s8r5::P64;
           P64[Hp] = _s8r6::P64;
           R2 = _s8r3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = _s8r7::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.041949918 UTC

[section ""data" . GHC.Base.liftA_$sliftA_closure" {
     GHC.Base.liftA_$sliftA_closure:
         const GHC.Base.liftA_$sliftA_info;
 },
 GHC.Base.liftA_$sliftA_entry() //  [R2, R3]
         { info_tbl: [(cgBA,
                       label: GHC.Base.liftA_$sliftA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgBA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.04576658 UTC

[section ""data" . GHC.Base.liftA_closure" {
     GHC.Base.liftA_closure:
         const GHC.Base.liftA_info;
 },
 sat_s8rc_entry() //  [R1]
         { info_tbl: [(cgBP,
                       label: sat_s8rc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgBP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgBQ; else goto cgBR;
       cgBQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgBR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Base.liftA_entry() //  [R2, R3, R4]
         { info_tbl: [(cgBS,
                       label: GHC.Base.liftA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgBS: // global
           _s8rb::P64 = R4;
           _s8ra::P64 = R3;
           _s8r9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgBT; else goto cgBU;
       cgBU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgBW; else goto cgBV;
       cgBW: // global
           HpAlloc = 32;
           goto cgBT;
       cgBT: // global
           R4 = _s8rb::P64;
           R3 = _s8ra::P64;
           R2 = _s8r9::P64;
           R1 = GHC.Base.liftA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgBV: // global
           I64[Hp - 24] = sat_s8rc_info;
           P64[Hp - 8] = _s8r9::P64;
           P64[Hp] = _s8ra::P64;
           R2 = _s8r9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s8rb::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.05279925 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$cfmap_closure" {
     GHC.Base.$fFunctor(,)_$cfmap_closure:
         const GHC.Base.$fFunctor(,)_$cfmap_info;
 },
 GHC.Base.$fFunctor(,)_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(cgCf,
                       label: GHC.Base.$fFunctor(,)_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgCf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgCk; else goto cgCl;
       cgCk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgCl: // global
           I64[Sp - 16] = block_cgCc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugCp; else goto cgCd;
       ugCp: // global
           call _cgCc(R1) args: 0, res: 0, upd: 0;
       cgCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cgCc() //  [R1]
         { info_tbl: [(cgCc,
                       label: block_cgCc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgCc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgCo; else goto cgCn;
       cgCo: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgCn: // global
           _s8rg::P64 = P64[R1 + 7];
           _s8rh::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s8rh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rg::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.058749251 UTC

[section ""data" . GHC.Base.$fFunctor(,)_closure" {
     GHC.Base.$fFunctor(,)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctor(,)_$cfmap_closure+2;
         const GHC.Base.$fFunctor(,)_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.061910757 UTC

[section ""data" . GHC.Base.$fApplicative(,)_closure" {
     GHC.Base.$fApplicative(,)_closure:
         const GHC.Base.$fApplicative(,)_info;
 },
 lvl3_s8rk_entry() //  [R1]
         { info_tbl: [(cgCL,
                       label: lvl3_s8rk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgCL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgCM; else goto cgCN;
       cgCM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgCN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8rq_entry() //  [R1, R2, R3]
         { info_tbl: [(cgCT,
                       label: sat_s8rq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgCT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rp_entry() //  [R1, R2, R3]
         { info_tbl: [(cgD1,
                       label: sat_s8rp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgD1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c*>_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ro_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cgD9,
                       label: sat_s8ro_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgD9: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fApplicative(,)_$cliftA2_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rn_entry() //  [R1, R2, R3]
         { info_tbl: [(cgDh,
                       label: sat_s8rn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgDh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*>_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rm_entry() //  [R1, R2]
         { info_tbl: [(cgDq,
                       label: sat_s8rm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgDq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgDu; else goto cgDt;
       cgDu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgDt: // global
           _s8rk::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rk::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative(,)_entry() //  [R2]
         { info_tbl: [(cgDw,
                       label: GHC.Base.$fApplicative(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgDw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cgDA; else goto cgDz;
       cgDA: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgDz: // global
           I64[Hp - 152] = lvl3_s8rk_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s8rq_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s8rp_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s8ro_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s8rn_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s8rm_info;
           P64[Hp - 56] = Hp - 152;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = GHC.Base.$fFunctor(,)_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 93;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 126;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.07750067 UTC

[section ""data" . lvl2_r7PL_closure" {
     lvl2_r7PL_closure:
         const lvl2_r7PL_info;
         const 0;
 },
 lvl2_r7PL_entry() //  [R2]
         { info_tbl: [(cgEa,
                       label: lvl2_r7PL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgEa: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.081568658 UTC

[section ""data" . GHC.Base.$fMonad(,)_closure" {
     GHC.Base.$fMonad(,)_closure:
         const GHC.Base.$fMonad(,)_info;
         const 0;
 },
 lvl3_s8rt_entry() //  [R1]
         { info_tbl: [(cgEp,
                       label: lvl3_s8rt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgEp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgEq; else goto cgEr;
       cgEq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgEr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8ry_entry() //  [R1, R2]
         { info_tbl: [(cgEy,
                       label: sat_s8ry_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgEy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgEC; else goto cgEB;
       cgEC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgEB: // global
           _s8rt::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rt::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rw_entry() //  [R1, R2, R3]
         { info_tbl: [(cgEI,
                       label: sat_s8rw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgEI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8rv_entry() //  [R1, R2, R3]
         { info_tbl: [(cgEQ,
                       label: sat_s8rv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgEQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>=_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8ru_entry() //  [R1]
         { info_tbl: [(cgEX,
                       label: sat_s8ru_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgEX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgEY; else goto cgEZ;
       cgEY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgEZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fApplicative(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_entry() //  [R2]
         { info_tbl: [(cgF1,
                       label: GHC.Base.$fMonad(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgF1: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgF5; else goto cgF4;
       cgF5: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgF4: // global
           I64[Hp - 136] = lvl3_s8rt_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s8ry_info;
           P64[Hp - 104] = Hp - 136;
           I64[Hp - 96] = sat_s8rw_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s8rv_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s8ru_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl2_r7PL_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.095654181 UTC

[section ""data" . GHC.Base.C:Monad_closure" {
     GHC.Base.C:Monad_closure:
         const GHC.Base.C:Monad_info;
 },
 GHC.Base.C:Monad_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgFD,
                       label: GHC.Base.C:Monad_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgFD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgFH; else goto cgFG;
       cgFH: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monad_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgFG: // global
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.099773354 UTC

[section ""data" . GHC.Base.C:Functor_closure" {
     GHC.Base.C:Functor_closure:
         const GHC.Base.C:Functor_info;
 },
 GHC.Base.C:Functor_entry() //  [R2, R3]
         { info_tbl: [(cgFS,
                       label: GHC.Base.C:Functor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgFS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgFW; else goto cgFV;
       cgFW: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Functor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgFV: // global
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.104412453 UTC

[section ""data" . GHC.Base.C:Applicative_closure" {
     GHC.Base.C:Applicative_closure:
         const GHC.Base.C:Applicative_info;
 },
 GHC.Base.C:Applicative_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgG7,
                       label: GHC.Base.C:Applicative_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgG7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgGb; else goto cgGa;
       cgGb: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Applicative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgGa: // global
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.108707281 UTC

[section ""data" . GHC.Base.C:Semigroup_closure" {
     GHC.Base.C:Semigroup_closure:
         const GHC.Base.C:Semigroup_info;
 },
 GHC.Base.C:Semigroup_entry() //  [R2, R3, R4]
         { info_tbl: [(cgGn,
                       label: GHC.Base.C:Semigroup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgGn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgGr; else goto cgGq;
       cgGr: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Semigroup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgGq: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.11271275 UTC

[section ""data" . GHC.Base.C:Monoid_closure" {
     GHC.Base.C:Monoid_closure:
         const GHC.Base.C:Monoid_info;
 },
 GHC.Base.C:Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgGC,
                       label: GHC.Base.C:Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgGC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgGG; else goto cgGF;
       cgGG: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgGF: // global
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.116592063 UTC

[section ""data" . GHC.Base.Nothing_closure" {
     GHC.Base.Nothing_closure:
         const GHC.Base.Nothing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.119618849 UTC

[section ""data" . GHC.Base.Just_closure" {
     GHC.Base.Just_closure:
         const GHC.Base.Just_info;
 },
 GHC.Base.Just_entry() //  [R2]
         { info_tbl: [(cgGS,
                       label: GHC.Base.Just_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgGS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgGW; else goto cgGV;
       cgGW: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.Just_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgGV: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.123760712 UTC

[section ""data" . GHC.Base.O_closure" {
     GHC.Base.O_closure:
         const GHC.Base.O_info;
 },
 GHC.Base.O_entry() //  [R2]
         { info_tbl: [(cgH7,
                       label: GHC.Base.O_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgH7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgHb; else goto cgHa;
       cgHb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.O_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgHa: // global
           I64[Hp - 8] = GHC.Base.O_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.127597015 UTC

[section ""data" . GHC.Base.:|_closure" {
     GHC.Base.:|_closure:
         const GHC.Base.:|_info;
 },
 GHC.Base.:|_entry() //  [R2, R3]
         { info_tbl: [(cgHm,
                       label: GHC.Base.:|_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgHm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgHq; else goto cgHp;
       cgHq: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.:|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgHp: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.13174518 UTC

[section ""data" . GHC.Base.C:MonadPlus_closure" {
     GHC.Base.C:MonadPlus_closure:
         const GHC.Base.C:MonadPlus_info;
 },
 GHC.Base.C:MonadPlus_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cgHB,
                       label: GHC.Base.C:MonadPlus_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgHB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgHF; else goto cgHE;
       cgHF: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:MonadPlus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgHE: // global
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.136962023 UTC

[section ""data" . GHC.Base.C:Alternative_closure" {
     GHC.Base.C:Alternative_closure:
         const GHC.Base.C:Alternative_info;
 },
 GHC.Base.C:Alternative_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cgHQ,
                       label: GHC.Base.C:Alternative_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgHQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgHU; else goto cgHT;
       cgHU: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Alternative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgHT: // global
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.140891498 UTC

[GHC.Base.C:Monad_con_entry() //  [R1]
         { info_tbl: [(cgI0,
                       label: GHC.Base.C:Monad_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgI0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.144221878 UTC

[GHC.Base.C:Functor_con_entry() //  [R1]
         { info_tbl: [(cgI6,
                       label: GHC.Base.C:Functor_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,70,117,110,99,116,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgI6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.147938573 UTC

[GHC.Base.C:Applicative_con_entry() //  [R1]
         { info_tbl: [(cgIc,
                       label: GHC.Base.C:Applicative_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,112,112,108,105,99,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgIc: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.151274598 UTC

[GHC.Base.C:Semigroup_con_entry() //  [R1]
         { info_tbl: [(cgIi,
                       label: GHC.Base.C:Semigroup_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,83,101,109,105,103,114,111,117,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgIi: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.154491164 UTC

[GHC.Base.C:Monoid_con_entry() //  [R1]
         { info_tbl: [(cgIo,
                       label: GHC.Base.C:Monoid_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,111,105,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgIo: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.157726845 UTC

[GHC.Base.Nothing_con_entry() //  [R1]
         { info_tbl: [(cgIu,
                       label: GHC.Base.Nothing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,78,111,116,104,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgIu: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.161592554 UTC

[GHC.Base.Just_con_entry() //  [R1]
         { info_tbl: [(cgIA,
                       label: GHC.Base.Just_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,74,117,115,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgIA: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.165014641 UTC

[GHC.Base.O_con_entry() //  [R1]
         { info_tbl: [(cgIG,
                       label: GHC.Base.O_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,79]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgIG: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.168602008 UTC

[GHC.Base.:|_con_entry() //  [R1]
         { info_tbl: [(cgIM,
                       label: GHC.Base.:|_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,58,124]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgIM: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.171933163 UTC

[GHC.Base.C:MonadPlus_con_entry() //  [R1]
         { info_tbl: [(cgIS,
                       label: GHC.Base.C:MonadPlus_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgIS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.17592348 UTC

[GHC.Base.C:Alternative_con_entry() //  [R1]
         { info_tbl: [(cgIY,
                       label: GHC.Base.C:Alternative_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,108,116,101,114,110,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cgIY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:47.179923636 UTC

[section ""relreadonly" . S8R0_srt" {
     S8R0_srt:
         const GHC.Base.$fSemigroupIO_$cstimes_closure;
         const GHC.Base.$fSemigroupIO_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const GHC.Base.$fMonoidIO_$cp1Monoid_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure;
         const GHC.Base.$fAlternativeIO_$cmany_closure;
         const GHC.Base.$fSemigroupNonEmpty_closure;
         const GHC.Base.$fMonoidIO_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.failIO_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const GHC.Base.$fSemigroupMaybe_closure;
         const GHC.Base.$fMonoidMaybe_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const GHC.Base.$fAlternativeIO3_closure;
         const GHC.Base.$fMonad(,)_closure;
         const lvl2_r7PL_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.263496427 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:54:56.264881165 UTC

[section ""data" . GHC.Base.$p1Monad_closure" {
     GHC.Base.$p1Monad_closure:
         const GHC.Base.$p1Monad_info;
 },
 GHC.Base.$p1Monad_entry() //  [R2]
         { info_tbl: [(chkY,
                       label: GHC.Base.$p1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chkY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chkZ; else goto chl0;
       chkZ: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chl0: // global
           I64[Sp - 8] = block_chkV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhl4; else goto chkW;
       uhl4: // global
           call _chkV(R1) args: 0, res: 0, upd: 0;
       chkW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chkV() //  [R1]
         { info_tbl: [(chkV,
                       label: block_chkV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chkV: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.270183167 UTC

[section ""data" . GHC.Base.>>=_closure" {
     GHC.Base.>>=_closure:
         const GHC.Base.>>=_info;
 },
 GHC.Base.>>=_entry() //  [R2]
         { info_tbl: [(chlo,
                       label: GHC.Base.>>=_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chlo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chlp; else goto chlq;
       chlp: // global
           R2 = R2;
           R1 = GHC.Base.>>=_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chlq: // global
           I64[Sp - 8] = block_chll_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhlu; else goto chlm;
       uhlu: // global
           call _chll(R1) args: 0, res: 0, upd: 0;
       chlm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chll() //  [R1]
         { info_tbl: [(chll,
                       label: block_chll_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chll: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.275375717 UTC

[section ""data" . GHC.Base.>>_closure" {
     GHC.Base.>>_closure:
         const GHC.Base.>>_info;
 },
 GHC.Base.>>_entry() //  [R2]
         { info_tbl: [(chlM,
                       label: GHC.Base.>>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chlM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chlN; else goto chlO;
       chlN: // global
           R2 = R2;
           R1 = GHC.Base.>>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chlO: // global
           I64[Sp - 8] = block_chlJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhlS; else goto chlK;
       uhlS: // global
           call _chlJ(R1) args: 0, res: 0, upd: 0;
       chlK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chlJ() //  [R1]
         { info_tbl: [(chlJ,
                       label: block_chlJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chlJ: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.280557851 UTC

[section ""data" . GHC.Base.return_closure" {
     GHC.Base.return_closure:
         const GHC.Base.return_info;
 },
 GHC.Base.return_entry() //  [R2]
         { info_tbl: [(chma,
                       label: GHC.Base.return_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chma: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chmb; else goto chmc;
       chmb: // global
           R2 = R2;
           R1 = GHC.Base.return_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chmc: // global
           I64[Sp - 8] = block_chm7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhmg; else goto chm8;
       uhmg: // global
           call _chm7(R1) args: 0, res: 0, upd: 0;
       chm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chm7() //  [R1]
         { info_tbl: [(chm7,
                       label: block_chm7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chm7: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.285917932 UTC

[section ""data" . GHC.Base.fail_closure" {
     GHC.Base.fail_closure:
         const GHC.Base.fail_info;
 },
 GHC.Base.fail_entry() //  [R2]
         { info_tbl: [(chmy,
                       label: GHC.Base.fail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chmy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chmz; else goto chmA;
       chmz: // global
           R2 = R2;
           R1 = GHC.Base.fail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chmA: // global
           I64[Sp - 8] = block_chmv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhmE; else goto chmw;
       uhmE: // global
           call _chmv(R1) args: 0, res: 0, upd: 0;
       chmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chmv() //  [R1]
         { info_tbl: [(chmv,
                       label: block_chmv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chmv: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.308717387 UTC

[section ""data" . GHC.Base.fmap_closure" {
     GHC.Base.fmap_closure:
         const GHC.Base.fmap_info;
 },
 GHC.Base.fmap_entry() //  [R2]
         { info_tbl: [(chmW,
                       label: GHC.Base.fmap_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chmW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chmX; else goto chmY;
       chmX: // global
           R2 = R2;
           R1 = GHC.Base.fmap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chmY: // global
           I64[Sp - 8] = block_chmT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhn2; else goto chmU;
       uhn2: // global
           call _chmT(R1) args: 0, res: 0, upd: 0;
       chmU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chmT() //  [R1]
         { info_tbl: [(chmT,
                       label: block_chmT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chmT: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.313997695 UTC

[section ""data" . GHC.Base.<$_closure" {
     GHC.Base.<$_closure:
         const GHC.Base.<$_info;
 },
 GHC.Base.<$_entry() //  [R2]
         { info_tbl: [(chnk,
                       label: GHC.Base.<$_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chnk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chnl; else goto chnm;
       chnl: // global
           R2 = R2;
           R1 = GHC.Base.<$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chnm: // global
           I64[Sp - 8] = block_chnh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhnq; else goto chni;
       uhnq: // global
           call _chnh(R1) args: 0, res: 0, upd: 0;
       chni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chnh() //  [R1]
         { info_tbl: [(chnh,
                       label: block_chnh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chnh: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.319354143 UTC

[section ""data" . GHC.Base.$p1Applicative_closure" {
     GHC.Base.$p1Applicative_closure:
         const GHC.Base.$p1Applicative_info;
 },
 GHC.Base.$p1Applicative_entry() //  [R2]
         { info_tbl: [(chnI,
                       label: GHC.Base.$p1Applicative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chnI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chnJ; else goto chnK;
       chnJ: // global
           R2 = R2;
           R1 = GHC.Base.$p1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chnK: // global
           I64[Sp - 8] = block_chnF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhnO; else goto chnG;
       uhnO: // global
           call _chnF(R1) args: 0, res: 0, upd: 0;
       chnG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chnF() //  [R1]
         { info_tbl: [(chnF,
                       label: block_chnF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chnF: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.324600093 UTC

[section ""data" . GHC.Base.pure_closure" {
     GHC.Base.pure_closure:
         const GHC.Base.pure_info;
 },
 GHC.Base.pure_entry() //  [R2]
         { info_tbl: [(cho8,
                       label: GHC.Base.pure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cho8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cho9; else goto choa;
       cho9: // global
           R2 = R2;
           R1 = GHC.Base.pure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       choa: // global
           I64[Sp - 8] = block_cho5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhoe; else goto cho6;
       uhoe: // global
           call _cho5(R1) args: 0, res: 0, upd: 0;
       cho6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cho5() //  [R1]
         { info_tbl: [(cho5,
                       label: block_cho5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cho5: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.329818089 UTC

[section ""data" . GHC.Base.<*>_closure" {
     GHC.Base.<*>_closure:
         const GHC.Base.<*>_info;
 },
 GHC.Base.<*>_entry() //  [R2]
         { info_tbl: [(chow,
                       label: GHC.Base.<*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chow: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chox; else goto choy;
       chox: // global
           R2 = R2;
           R1 = GHC.Base.<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       choy: // global
           I64[Sp - 8] = block_chot_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhoC; else goto chou;
       uhoC: // global
           call _chot(R1) args: 0, res: 0, upd: 0;
       chou: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chot() //  [R1]
         { info_tbl: [(chot,
                       label: block_chot_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chot: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.335590613 UTC

[section ""data" . GHC.Base.liftA2_closure" {
     GHC.Base.liftA2_closure:
         const GHC.Base.liftA2_info;
 },
 GHC.Base.liftA2_entry() //  [R2]
         { info_tbl: [(choU,
                       label: GHC.Base.liftA2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       choU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto choV; else goto choW;
       choV: // global
           R2 = R2;
           R1 = GHC.Base.liftA2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       choW: // global
           I64[Sp - 8] = block_choR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhp0; else goto choS;
       uhp0: // global
           call _choR(R1) args: 0, res: 0, upd: 0;
       choS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _choR() //  [R1]
         { info_tbl: [(choR,
                       label: block_choR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       choR: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.341320838 UTC

[section ""data" . GHC.Base.*>_closure" {
     GHC.Base.*>_closure:
         const GHC.Base.*>_info;
 },
 GHC.Base.*>_entry() //  [R2]
         { info_tbl: [(chpi,
                       label: GHC.Base.*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chpi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chpj; else goto chpk;
       chpj: // global
           R2 = R2;
           R1 = GHC.Base.*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chpk: // global
           I64[Sp - 8] = block_chpf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhpo; else goto chpg;
       uhpo: // global
           call _chpf(R1) args: 0, res: 0, upd: 0;
       chpg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chpf() //  [R1]
         { info_tbl: [(chpf,
                       label: block_chpf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chpf: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.346663805 UTC

[section ""data" . GHC.Base.<*_closure" {
     GHC.Base.<*_closure:
         const GHC.Base.<*_info;
 },
 GHC.Base.<*_entry() //  [R2]
         { info_tbl: [(chpG,
                       label: GHC.Base.<*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chpG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chpH; else goto chpI;
       chpH: // global
           R2 = R2;
           R1 = GHC.Base.<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chpI: // global
           I64[Sp - 8] = block_chpD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhpM; else goto chpE;
       uhpM: // global
           call _chpD(R1) args: 0, res: 0, upd: 0;
       chpE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chpD() //  [R1]
         { info_tbl: [(chpD,
                       label: block_chpD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chpD: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.352198616 UTC

[section ""data" . GHC.Base.<>_closure" {
     GHC.Base.<>_closure:
         const GHC.Base.<>_info;
 },
 GHC.Base.<>_entry() //  [R2]
         { info_tbl: [(chq4,
                       label: GHC.Base.<>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chq4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chq5; else goto chq6;
       chq5: // global
           R2 = R2;
           R1 = GHC.Base.<>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chq6: // global
           I64[Sp - 8] = block_chq1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhqa; else goto chq2;
       uhqa: // global
           call _chq1(R1) args: 0, res: 0, upd: 0;
       chq2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chq1() //  [R1]
         { info_tbl: [(chq1,
                       label: block_chq1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chq1: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.357406844 UTC

[section ""data" . GHC.Base.sconcat_closure" {
     GHC.Base.sconcat_closure:
         const GHC.Base.sconcat_info;
 },
 GHC.Base.sconcat_entry() //  [R2]
         { info_tbl: [(chqs,
                       label: GHC.Base.sconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chqs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chqt; else goto chqu;
       chqt: // global
           R2 = R2;
           R1 = GHC.Base.sconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chqu: // global
           I64[Sp - 8] = block_chqp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhqy; else goto chqq;
       uhqy: // global
           call _chqp(R1) args: 0, res: 0, upd: 0;
       chqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chqp() //  [R1]
         { info_tbl: [(chqp,
                       label: block_chqp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chqp: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.363097046 UTC

[section ""data" . GHC.Base.stimes_closure" {
     GHC.Base.stimes_closure:
         const GHC.Base.stimes_info;
 },
 GHC.Base.stimes_entry() //  [R2]
         { info_tbl: [(chqQ,
                       label: GHC.Base.stimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chqQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chqR; else goto chqS;
       chqR: // global
           R2 = R2;
           R1 = GHC.Base.stimes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chqS: // global
           I64[Sp - 8] = block_chqN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhqW; else goto chqO;
       uhqW: // global
           call _chqN(R1) args: 0, res: 0, upd: 0;
       chqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chqN() //  [R1]
         { info_tbl: [(chqN,
                       label: block_chqN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chqN: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.368369944 UTC

[section ""data" . GHC.Base.$p1Monoid_closure" {
     GHC.Base.$p1Monoid_closure:
         const GHC.Base.$p1Monoid_info;
 },
 GHC.Base.$p1Monoid_entry() //  [R2]
         { info_tbl: [(chre,
                       label: GHC.Base.$p1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chre: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chrf; else goto chrg;
       chrf: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chrg: // global
           I64[Sp - 8] = block_chrb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhrk; else goto chrc;
       uhrk: // global
           call _chrb(R1) args: 0, res: 0, upd: 0;
       chrc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chrb() //  [R1]
         { info_tbl: [(chrb,
                       label: block_chrb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chrb: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.374492904 UTC

[section ""data" . GHC.Base.mempty_closure" {
     GHC.Base.mempty_closure:
         const GHC.Base.mempty_info;
 },
 GHC.Base.mempty_entry() //  [R2]
         { info_tbl: [(chrE,
                       label: GHC.Base.mempty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chrE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chrF; else goto chrG;
       chrF: // global
           R2 = R2;
           R1 = GHC.Base.mempty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chrG: // global
           I64[Sp - 8] = block_chrB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhrK; else goto chrC;
       uhrK: // global
           call _chrB(R1) args: 0, res: 0, upd: 0;
       chrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chrB() //  [R1]
         { info_tbl: [(chrB,
                       label: block_chrB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chrB: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.379757405 UTC

[section ""data" . GHC.Base.mappend_closure" {
     GHC.Base.mappend_closure:
         const GHC.Base.mappend_info;
 },
 GHC.Base.mappend_entry() //  [R2]
         { info_tbl: [(chs2,
                       label: GHC.Base.mappend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chs2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chs3; else goto chs4;
       chs3: // global
           R2 = R2;
           R1 = GHC.Base.mappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chs4: // global
           I64[Sp - 8] = block_chrZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhs8; else goto chs0;
       uhs8: // global
           call _chrZ(R1) args: 0, res: 0, upd: 0;
       chs0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chrZ() //  [R1]
         { info_tbl: [(chrZ,
                       label: block_chrZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chrZ: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.385189468 UTC

[section ""data" . GHC.Base.mconcat_closure" {
     GHC.Base.mconcat_closure:
         const GHC.Base.mconcat_info;
 },
 GHC.Base.mconcat_entry() //  [R2]
         { info_tbl: [(chsq,
                       label: GHC.Base.mconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chsq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chsr; else goto chss;
       chsr: // global
           R2 = R2;
           R1 = GHC.Base.mconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chss: // global
           I64[Sp - 8] = block_chsn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhsw; else goto chso;
       uhsw: // global
           call _chsn(R1) args: 0, res: 0, upd: 0;
       chso: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chsn() //  [R1]
         { info_tbl: [(chsn,
                       label: block_chsn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chsn: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.390443594 UTC

[section ""data" . GHC.Base.$p1MonadPlus_closure" {
     GHC.Base.$p1MonadPlus_closure:
         const GHC.Base.$p1MonadPlus_info;
 },
 GHC.Base.$p1MonadPlus_entry() //  [R2]
         { info_tbl: [(chsO,
                       label: GHC.Base.$p1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chsO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chsP; else goto chsQ;
       chsP: // global
           R2 = R2;
           R1 = GHC.Base.$p1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chsQ: // global
           I64[Sp - 8] = block_chsL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhsU; else goto chsM;
       uhsU: // global
           call _chsL(R1) args: 0, res: 0, upd: 0;
       chsM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chsL() //  [R1]
         { info_tbl: [(chsL,
                       label: block_chsL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chsL: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.396187137 UTC

[section ""data" . GHC.Base.$p2MonadPlus_closure" {
     GHC.Base.$p2MonadPlus_closure:
         const GHC.Base.$p2MonadPlus_info;
 },
 GHC.Base.$p2MonadPlus_entry() //  [R2]
         { info_tbl: [(chte,
                       label: GHC.Base.$p2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chte: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chtf; else goto chtg;
       chtf: // global
           R2 = R2;
           R1 = GHC.Base.$p2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chtg: // global
           I64[Sp - 8] = block_chtb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhtk; else goto chtc;
       uhtk: // global
           call _chtb(R1) args: 0, res: 0, upd: 0;
       chtc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chtb() //  [R1]
         { info_tbl: [(chtb,
                       label: block_chtb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chtb: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.401433476 UTC

[section ""data" . GHC.Base.mzero_closure" {
     GHC.Base.mzero_closure:
         const GHC.Base.mzero_info;
 },
 GHC.Base.mzero_entry() //  [R2]
         { info_tbl: [(chtE,
                       label: GHC.Base.mzero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chtE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chtF; else goto chtG;
       chtF: // global
           R2 = R2;
           R1 = GHC.Base.mzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chtG: // global
           I64[Sp - 8] = block_chtB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhtK; else goto chtC;
       uhtK: // global
           call _chtB(R1) args: 0, res: 0, upd: 0;
       chtC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chtB() //  [R1]
         { info_tbl: [(chtB,
                       label: block_chtB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chtB: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.407312134 UTC

[section ""data" . GHC.Base.mplus_closure" {
     GHC.Base.mplus_closure:
         const GHC.Base.mplus_info;
 },
 GHC.Base.mplus_entry() //  [R2]
         { info_tbl: [(chu2,
                       label: GHC.Base.mplus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chu2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chu3; else goto chu4;
       chu3: // global
           R2 = R2;
           R1 = GHC.Base.mplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chu4: // global
           I64[Sp - 8] = block_chtZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhu8; else goto chu0;
       uhu8: // global
           call _chtZ(R1) args: 0, res: 0, upd: 0;
       chu0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chtZ() //  [R1]
         { info_tbl: [(chtZ,
                       label: block_chtZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chtZ: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.413124274 UTC

[section ""data" . GHC.Base.$p1Alternative_closure" {
     GHC.Base.$p1Alternative_closure:
         const GHC.Base.$p1Alternative_info;
 },
 GHC.Base.$p1Alternative_entry() //  [R2]
         { info_tbl: [(chuq,
                       label: GHC.Base.$p1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chuq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chur; else goto chus;
       chur: // global
           R2 = R2;
           R1 = GHC.Base.$p1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chus: // global
           I64[Sp - 8] = block_chun_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhuw; else goto chuo;
       uhuw: // global
           call _chun(R1) args: 0, res: 0, upd: 0;
       chuo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chun() //  [R1]
         { info_tbl: [(chun,
                       label: block_chun_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chun: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.418576998 UTC

[section ""data" . GHC.Base.empty_closure" {
     GHC.Base.empty_closure:
         const GHC.Base.empty_info;
 },
 GHC.Base.empty_entry() //  [R2]
         { info_tbl: [(chuQ,
                       label: GHC.Base.empty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chuQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chuR; else goto chuS;
       chuR: // global
           R2 = R2;
           R1 = GHC.Base.empty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chuS: // global
           I64[Sp - 8] = block_chuN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhuW; else goto chuO;
       uhuW: // global
           call _chuN(R1) args: 0, res: 0, upd: 0;
       chuO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chuN() //  [R1]
         { info_tbl: [(chuN,
                       label: block_chuN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chuN: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.424303982 UTC

[section ""data" . GHC.Base.<|>_closure" {
     GHC.Base.<|>_closure:
         const GHC.Base.<|>_info;
 },
 GHC.Base.<|>_entry() //  [R2]
         { info_tbl: [(chve,
                       label: GHC.Base.<|>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chve: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chvf; else goto chvg;
       chvf: // global
           R2 = R2;
           R1 = GHC.Base.<|>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chvg: // global
           I64[Sp - 8] = block_chvb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhvk; else goto chvc;
       uhvk: // global
           call _chvb(R1) args: 0, res: 0, upd: 0;
       chvc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chvb() //  [R1]
         { info_tbl: [(chvb,
                       label: block_chvb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chvb: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.429680794 UTC

[section ""data" . GHC.Base.some_closure" {
     GHC.Base.some_closure:
         const GHC.Base.some_info;
 },
 GHC.Base.some_entry() //  [R2]
         { info_tbl: [(chvC,
                       label: GHC.Base.some_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chvC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chvD; else goto chvE;
       chvD: // global
           R2 = R2;
           R1 = GHC.Base.some_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chvE: // global
           I64[Sp - 8] = block_chvz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhvI; else goto chvA;
       uhvI: // global
           call _chvz(R1) args: 0, res: 0, upd: 0;
       chvA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chvz() //  [R1]
         { info_tbl: [(chvz,
                       label: block_chvz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chvz: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.4351037 UTC

[section ""data" . GHC.Base.many_closure" {
     GHC.Base.many_closure:
         const GHC.Base.many_info;
 },
 GHC.Base.many_entry() //  [R2]
         { info_tbl: [(chw0,
                       label: GHC.Base.many_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chw0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chw1; else goto chw2;
       chw1: // global
           R2 = R2;
           R1 = GHC.Base.many_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chw2: // global
           I64[Sp - 8] = block_chvX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhw6; else goto chvY;
       uhw6: // global
           call _chvX(R1) args: 0, res: 0, upd: 0;
       chvY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chvX() //  [R1]
         { info_tbl: [(chvX,
                       label: block_chvX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chvX: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.441587984 UTC

[section ""data" . GHC.Base.eqString_closure" {
     GHC.Base.eqString_closure:
         const GHC.Base.eqString_info;
 },
 GHC.Base.eqString_entry() //  [R2, R3]
         { info_tbl: [(chws,
                       label: GHC.Base.eqString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chws: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chwt; else goto uhxi;
       chwt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.eqString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uhxi: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _chwi() args: 0, res: 0, upd: 0;
     }
 },
 _chwi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chwi: // global
           _sgM8::P64 = P64[Sp];
           I64[Sp] = block_chwl_info;
           R1 = _sgM8::P64;
           if (R1 & 7 != 0) goto uhxn; else goto chwm;
       uhxn: // global
           call _chwl(R1) args: 0, res: 0, upd: 0;
       chwm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chwl() //  [R1]
         { info_tbl: [(chwl,
                       label: block_chwl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chwl: // global
           _sgM9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto chwp; else goto chwq;
       chwp: // global
           I64[Sp + 8] = block_chwx_info;
           R1 = _sgM9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uhxo; else goto chwz;
       uhxo: // global
           call _chwx(R1) args: 0, res: 0, upd: 0;
       chwz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       chwq: // global
           I64[Sp - 8] = block_chwM_info;
           _sgMe::P64 = P64[R1 + 6];
           _sgMf::P64 = P64[R1 + 14];
           R1 = _sgM9::P64;
           P64[Sp] = _sgMf::P64;
           P64[Sp + 8] = _sgMe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhxp; else goto chwO;
       uhxp: // global
           call _chwM(R1) args: 0, res: 0, upd: 0;
       chwO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chwx() //  [R1]
         { info_tbl: [(chwx,
                       label: block_chwx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chwx: // global
           if (R1 & 7 == 1) goto chwF; else goto uhxm;
       chwF: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uhxm: // global
           Sp = Sp + 8;
           call _chxe() args: 0, res: 0, upd: 0;
     }
 },
 _chwM() //  [R1]
         { info_tbl: [(chwM,
                       label: block_chwM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chwM: // global
           if (R1 & 7 == 1) goto uhxj; else goto chx4;
       uhxj: // global
           Sp = Sp + 24;
           call _chxe() args: 0, res: 0, upd: 0;
       chx4: // global
           I64[Sp - 8] = block_chwX_info;
           _sgMh::P64 = P64[R1 + 6];
           _sgMi::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgMi::P64;
           P64[Sp + 16] = _sgMh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhxs; else goto chwY;
       uhxs: // global
           call _chwX(R1) args: 0, res: 0, upd: 0;
       chwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chwX() //  [R1]
         { info_tbl: [(chwX,
                       label: block_chwX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chwX: // global
           I64[Sp] = block_chx2_info;
           _sgMk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sgMk::I64;
           if (R1 & 7 != 0) goto uhxu; else goto chx6;
       uhxu: // global
           call _chx2(R1) args: 0, res: 0, upd: 0;
       chx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chx2() //  [R1]
         { info_tbl: [(chx2,
                       label: block_chx2_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chx2: // global
           if (I64[Sp + 24] == I64[R1 + 7]) goto chxf; else goto uhxk;
       chxf: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _chwi() args: 0, res: 0, upd: 0;
       uhxk: // global
           Sp = Sp + 32;
           call _chxe() args: 0, res: 0, upd: 0;
     }
 },
 _chxe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chxe: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.456778242 UTC

[section ""data" . GHC.Base.when2_closure" {
     GHC.Base.when2_closure:
         const GHC.Base.when2_info;
 },
 GHC.Base.when2_entry() //  [R2, R3]
         { info_tbl: [(chyt,
                       label: GHC.Base.when2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chyt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chyu; else goto chyv;
       chyu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chyv: // global
           I64[Sp - 16] = block_chym_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhyC; else goto chyn;
       uhyC: // global
           call _chym(R1) args: 0, res: 0, upd: 0;
       chyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chym() //  [R1]
         { info_tbl: [(chym,
                       label: block_chym_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chym: // global
           if (R1 & 7 == 1) goto chyq; else goto chyr;
       chyq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       chyr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.462703593 UTC

[section ""data" . GHC.Base.when_$swhen1_closure" {
     GHC.Base.when_$swhen1_closure:
         const GHC.Base.when_$swhen1_info;
 },
 GHC.Base.when_$swhen1_entry() //  [R2, R3]
         { info_tbl: [(chyV,
                       label: GHC.Base.when_$swhen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chyV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.when2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.466140992 UTC

[section ""data" . GHC.Base.$fFunctorIO2_closure" {
     GHC.Base.$fFunctorIO2_closure:
         const GHC.Base.$fFunctorIO2_info;
 },
 GHC.Base.$fFunctorIO2_entry() //  [R2, R3]
         { info_tbl: [(chz9,
                       label: GHC.Base.$fFunctorIO2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chz9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chza; else goto chzb;
       chza: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chzb: // global
           I64[Sp - 16] = block_chz6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chz6() //  [R1]
         { info_tbl: [(chz6,
                       label: block_chz6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chz6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chze; else goto chzd;
       chze: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chzd: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.47164519 UTC

[section ""data" . GHC.Base.$fFunctorIO1_closure" {
     GHC.Base.$fFunctorIO1_closure:
         const GHC.Base.$fFunctorIO1_info;
 },
 GHC.Base.$fFunctorIO1_entry() //  [R2, R3]
         { info_tbl: [(chzx,
                       label: GHC.Base.$fFunctorIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chzx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chzy; else goto chzz;
       chzy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chzz: // global
           I64[Sp - 16] = block_chzv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chzv() //  []
         { info_tbl: [(chzv,
                       label: block_chzv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chzv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.477076781 UTC

[section ""data" . GHC.Base.$fFunctorIO_closure" {
     GHC.Base.$fFunctorIO_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorIO2_closure+3;
         const GHC.Base.$fFunctorIO1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.478775677 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe1_closure" {
     GHC.Base.$fAlternativeMaybe1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.481233107 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$cmany_closure" {
     GHC.Base.$fAlternativeMaybe_$cmany_closure:
         const GHC.Base.$fAlternativeMaybe_$cmany_info;
 },
 many_v_sgMG_entry() //  [R1]
         { info_tbl: [(chA2,
                       label: many_v_sgMG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chA2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chA3; else goto chA4;
       chA3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       chA4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_chzV_info;
           _sgMG::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sgMG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uhAw; else goto chzW;
       uhAw: // global
           call _chzV(R1) args: 0, res: 0, upd: 0;
       chzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _chzV() //  [R1]
         { info_tbl: [(chzV,
                       label: block_chzV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chzV: // global
           if (R1 & 7 == 1) goto uhAs; else goto chA0;
       uhAs: // global
           Sp = Sp + 16;
           call _chAi() args: 0, res: 0, upd: 0;
       chA0: // global
           I64[Sp] = block_chAa_info;
           _sgMI::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgMI::P64;
           if (R1 & 7 != 0) goto uhAu; else goto chAc;
       uhAu: // global
           call _chAa(R1) args: 0, res: 0, upd: 0;
       chAc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _chAa() //  [R1]
         { info_tbl: [(chAa,
                       label: block_chAa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chAa: // global
           if (R1 & 7 == 1) goto uhAt; else goto chAn;
       uhAt: // global
           Sp = Sp + 16;
           call _chAi() args: 0, res: 0, upd: 0;
       chAn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto chAq; else goto chAp;
       chAq: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       chAp: // global
           _sgMK::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sgMK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _chAi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chAi: // global
           R1 = GHC.Base.$fAlternativeMaybe1_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$cmany_entry() //  [R2]
         { info_tbl: [(chAy,
                       label: GHC.Base.$fAlternativeMaybe_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chAy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto chAC; else goto chAB;
       chAC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chAB: // global
           I64[Hp - 16] = many_v_sgMG_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.492630632 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$csome_closure" {
     GHC.Base.$fAlternativeMaybe_$csome_closure:
         const GHC.Base.$fAlternativeMaybe_$csome_info;
 },
 some_v_sgMN_entry() //  [R1]
         { info_tbl: [(chBq,
                       label: some_v_sgMN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chBq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chBr; else goto chBs;
       chBr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       chBs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_chBj_info;
           _sgMN::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sgMN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uhBV; else goto chBk;
       uhBV: // global
           call _chBj(R1) args: 0, res: 0, upd: 0;
       chBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _chBj() //  [R1]
         { info_tbl: [(chBj,
                       label: block_chBj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chBj: // global
           if (R1 & 7 == 1) goto chBn; else goto chBo;
       chBn: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       chBo: // global
           I64[Sp] = block_chBy_info;
           _sgMP::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgMP::P64;
           if (R1 & 7 != 0) goto uhBU; else goto chBA;
       uhBU: // global
           call _chBy(R1) args: 0, res: 0, upd: 0;
       chBA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _chBy() //  [R1]
         { info_tbl: [(chBy,
                       label: block_chBy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chBy: // global
           _sgMP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto chBH; else goto chBP;
       chBH: // global
           Hp = Hp + 40;
           _sgMQ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto chBS; else goto chBJ;
       chBJ: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _sgMP::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       chBP: // global
           Hp = Hp + 40;
           _sgMQ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto chBS; else goto chBR;
       chBS: // global
           HpAlloc = 40;
           R1 = _sgMQ::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       chBR: // global
           _sgMS::P64 = P64[_sgMQ::P64 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _sgMP::P64;
           P64[Hp - 16] = _sgMS::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$csome_entry() //  [R2]
         { info_tbl: [(chBW,
                       label: GHC.Base.$fAlternativeMaybe_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chBW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto chC0; else goto chBZ;
       chC0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chBZ: // global
           I64[Hp - 16] = some_v_sgMN_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.50363335 UTC

[section ""data" . GHC.Base.ap_$sap_closure" {
     GHC.Base.ap_$sap_closure:
         const GHC.Base.ap_$sap_info;
 },
 GHC.Base.ap_$sap_entry() //  [R2, R3]
         { info_tbl: [(chCN,
                       label: GHC.Base.ap_$sap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chCN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chCO; else goto chCP;
       chCO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap_$sap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chCP: // global
           I64[Sp - 16] = block_chCG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhDh; else goto chCH;
       uhDh: // global
           call _chCG(R1) args: 0, res: 0, upd: 0;
       chCH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chCG() //  [R1]
         { info_tbl: [(chCG,
                       label: block_chCG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chCG: // global
           if (R1 & 7 == 1) goto uhDd; else goto chCL;
       uhDd: // global
           Sp = Sp + 16;
           call _chD3() args: 0, res: 0, upd: 0;
       chCL: // global
           I64[Sp] = block_chCV_info;
           _sgMX::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgMX::P64;
           if (R1 & 7 != 0) goto uhDf; else goto chCX;
       uhDf: // global
           call _chCV(R1) args: 0, res: 0, upd: 0;
       chCX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chCV() //  [R1]
         { info_tbl: [(chCV,
                       label: block_chCV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chCV: // global
           if (R1 & 7 == 1) goto uhDe; else goto chD8;
       uhDe: // global
           Sp = Sp + 16;
           call _chD3() args: 0, res: 0, upd: 0;
       chD8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto chDb; else goto chDa;
       chDb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chDa: // global
           _sgMZ::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sgMZ::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _chD3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chD3: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.513856913 UTC

[section ""data" . GHC.Base.liftM5_$sliftM5_closure" {
     GHC.Base.liftM5_$sliftM5_closure:
         const GHC.Base.liftM5_$sliftM5_info;
 },
 GHC.Base.liftM5_$sliftM5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(chDV,
                       label: GHC.Base.liftM5_$sliftM5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chDV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto chDW; else goto chDX;
       chDW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM5_$sliftM5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       chDX: // global
           I64[Sp - 40] = block_chDO_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uhF5; else goto chDP;
       uhF5: // global
           call _chDO(R1) args: 0, res: 0, upd: 0;
       chDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chDO() //  [R1]
         { info_tbl: [(chDO,
                       label: block_chDO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chDO: // global
           if (R1 & 7 == 1) goto uhEY; else goto chDT;
       uhEY: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chDT: // global
           I64[Sp] = block_chE3_info;
           _sgN8::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgN8::P64;
           if (R1 & 7 != 0) goto uhF3; else goto chE5;
       uhF3: // global
           call _chE3(R1) args: 0, res: 0, upd: 0;
       chE5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chE3() //  [R1]
         { info_tbl: [(chE3,
                       label: block_chE3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chE3: // global
           if (R1 & 7 == 1) goto uhEZ; else goto chEg;
       uhEZ: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chEg: // global
           I64[Sp] = block_chEe_info;
           _sgNa::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgNa::P64;
           if (R1 & 7 != 0) goto uhF6; else goto chEh;
       uhF6: // global
           call _chEe(R1) args: 0, res: 0, upd: 0;
       chEh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chEe() //  [R1]
         { info_tbl: [(chEe,
                       label: block_chEe_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chEe: // global
           if (R1 & 7 == 1) goto uhF0; else goto chEs;
       uhF0: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chEs: // global
           I64[Sp] = block_chEq_info;
           _sgNc::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sgNc::P64;
           if (R1 & 7 != 0) goto uhF8; else goto chEt;
       uhF8: // global
           call _chEq(R1) args: 0, res: 0, upd: 0;
       chEt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chEq() //  [R1]
         { info_tbl: [(chEq,
                       label: block_chEq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chEq: // global
           if (R1 & 7 == 1) goto uhF1; else goto chEE;
       uhF1: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chEE: // global
           I64[Sp] = block_chEC_info;
           _sgNe::P64 = P64[R1 + 6];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _sgNe::P64;
           if (R1 & 7 != 0) goto uhFa; else goto chEF;
       uhFa: // global
           call _chEC(R1) args: 0, res: 0, upd: 0;
       chEF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chEC() //  [R1]
         { info_tbl: [(chEC,
                       label: block_chEC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chEC: // global
           if (R1 & 7 == 1) goto uhF2; else goto chEQ;
       uhF2: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chEQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto chET; else goto chES;
       chET: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chES: // global
           _sgNg::P64 = P64[R1 + 6];
           I64[Hp - 72] = stg_ap_6_upd_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = _sgNg::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 72;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _chEL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chEL: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.529475936 UTC

[section ""data" . GHC.Base.liftM4_$sliftM4_closure" {
     GHC.Base.liftM4_$sliftM4_closure:
         const GHC.Base.liftM4_$sliftM4_info;
 },
 GHC.Base.liftM4_$sliftM4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(chGe,
                       label: GHC.Base.liftM4_$sliftM4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chGe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto chGf; else goto chGg;
       chGf: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM4_$sliftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chGg: // global
           I64[Sp - 40] = block_chG7_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uhHa; else goto chG8;
       uhHa: // global
           call _chG7(R1) args: 0, res: 0, upd: 0;
       chG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chG7() //  [R1]
         { info_tbl: [(chG7,
                       label: block_chG7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chG7: // global
           if (R1 & 7 == 1) goto uhH4; else goto chGc;
       uhH4: // global
           Sp = Sp + 40;
           call _chGS() args: 0, res: 0, upd: 0;
       chGc: // global
           I64[Sp] = block_chGm_info;
           _sgNo::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgNo::P64;
           if (R1 & 7 != 0) goto uhH8; else goto chGo;
       uhH8: // global
           call _chGm(R1) args: 0, res: 0, upd: 0;
       chGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chGm() //  [R1]
         { info_tbl: [(chGm,
                       label: block_chGm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chGm: // global
           if (R1 & 7 == 1) goto uhH5; else goto chGz;
       uhH5: // global
           Sp = Sp + 40;
           call _chGS() args: 0, res: 0, upd: 0;
       chGz: // global
           I64[Sp] = block_chGx_info;
           _sgNq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgNq::P64;
           if (R1 & 7 != 0) goto uhHb; else goto chGA;
       uhHb: // global
           call _chGx(R1) args: 0, res: 0, upd: 0;
       chGA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chGx() //  [R1]
         { info_tbl: [(chGx,
                       label: block_chGx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chGx: // global
           if (R1 & 7 == 1) goto uhH6; else goto chGL;
       uhH6: // global
           Sp = Sp + 40;
           call _chGS() args: 0, res: 0, upd: 0;
       chGL: // global
           I64[Sp] = block_chGJ_info;
           _sgNs::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sgNs::P64;
           if (R1 & 7 != 0) goto uhHd; else goto chGM;
       uhHd: // global
           call _chGJ(R1) args: 0, res: 0, upd: 0;
       chGM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chGJ() //  [R1]
         { info_tbl: [(chGJ,
                       label: block_chGJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chGJ: // global
           if (R1 & 7 == 1) goto uhH7; else goto chGX;
       uhH7: // global
           Sp = Sp + 40;
           call _chGS() args: 0, res: 0, upd: 0;
       chGX: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto chH0; else goto chGZ;
       chH0: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chGZ: // global
           _sgNu::P64 = P64[R1 + 6];
           I64[Hp - 64] = stg_ap_5_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = _sgNu::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _chGS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chGS: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.542797632 UTC

[section ""data" . GHC.Base.liftM3_$sliftM3_closure" {
     GHC.Base.liftM3_$sliftM3_closure:
         const GHC.Base.liftM3_$sliftM3_info;
 },
 GHC.Base.liftM3_$sliftM3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(chI9,
                       label: GHC.Base.liftM3_$sliftM3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chI9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chIa; else goto chIb;
       chIa: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM3_$sliftM3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chIb: // global
           I64[Sp - 32] = block_chI2_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uhIR; else goto chI3;
       uhIR: // global
           call _chI2(R1) args: 0, res: 0, upd: 0;
       chI3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chI2() //  [R1]
         { info_tbl: [(chI2,
                       label: block_chI2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chI2: // global
           if (R1 & 7 == 1) goto uhIM; else goto chI7;
       uhIM: // global
           Sp = Sp + 32;
           call _chIB() args: 0, res: 0, upd: 0;
       chI7: // global
           I64[Sp] = block_chIh_info;
           _sgNB::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgNB::P64;
           if (R1 & 7 != 0) goto uhIP; else goto chIj;
       uhIP: // global
           call _chIh(R1) args: 0, res: 0, upd: 0;
       chIj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chIh() //  [R1]
         { info_tbl: [(chIh,
                       label: block_chIh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chIh: // global
           if (R1 & 7 == 1) goto uhIN; else goto chIu;
       uhIN: // global
           Sp = Sp + 32;
           call _chIB() args: 0, res: 0, upd: 0;
       chIu: // global
           I64[Sp] = block_chIs_info;
           _sgND::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgND::P64;
           if (R1 & 7 != 0) goto uhIS; else goto chIv;
       uhIS: // global
           call _chIs(R1) args: 0, res: 0, upd: 0;
       chIv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chIs() //  [R1]
         { info_tbl: [(chIs,
                       label: block_chIs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chIs: // global
           if (R1 & 7 == 1) goto uhIO; else goto chIG;
       uhIO: // global
           Sp = Sp + 32;
           call _chIB() args: 0, res: 0, upd: 0;
       chIG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto chIJ; else goto chII;
       chIJ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chII: // global
           _sgNF::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sgNF::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _chIB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chIB: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.555165885 UTC

[section ""data" . GHC.Base.liftM2_$sliftM2_closure" {
     GHC.Base.liftM2_$sliftM2_closure:
         const GHC.Base.liftM2_$sliftM2_info;
 },
 GHC.Base.liftM2_$sliftM2_entry() //  [R2, R3, R4]
         { info_tbl: [(chJG,
                       label: GHC.Base.liftM2_$sliftM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chJG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto chJH; else goto chJI;
       chJH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM2_$sliftM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chJI: // global
           I64[Sp - 24] = block_chJz_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uhKa; else goto chJA;
       uhKa: // global
           call _chJz(R1) args: 0, res: 0, upd: 0;
       chJA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chJz() //  [R1]
         { info_tbl: [(chJz,
                       label: block_chJz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chJz: // global
           if (R1 & 7 == 1) goto uhK6; else goto chJE;
       uhK6: // global
           Sp = Sp + 24;
           call _chJW() args: 0, res: 0, upd: 0;
       chJE: // global
           I64[Sp] = block_chJO_info;
           _sgNL::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgNL::P64;
           if (R1 & 7 != 0) goto uhK8; else goto chJQ;
       uhK8: // global
           call _chJO(R1) args: 0, res: 0, upd: 0;
       chJQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chJO() //  [R1]
         { info_tbl: [(chJO,
                       label: block_chJO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chJO: // global
           if (R1 & 7 == 1) goto uhK7; else goto chK1;
       uhK7: // global
           Sp = Sp + 24;
           call _chJW() args: 0, res: 0, upd: 0;
       chK1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto chK4; else goto chK3;
       chK4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chK3: // global
           _sgNN::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sgNN::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _chJW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chJW: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.564451384 UTC

[section ""data" . GHC.Base.liftM_$sliftM_closure" {
     GHC.Base.liftM_$sliftM_closure:
         const GHC.Base.liftM_$sliftM_info;
 },
 GHC.Base.liftM_$sliftM_entry() //  [R2, R3]
         { info_tbl: [(chKP,
                       label: GHC.Base.liftM_$sliftM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chKP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chKQ; else goto chKR;
       chKQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM_$sliftM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chKR: // global
           I64[Sp - 16] = block_chKI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhL2; else goto chKJ;
       uhL2: // global
           call _chKI(R1) args: 0, res: 0, upd: 0;
       chKJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chKI() //  [R1]
         { info_tbl: [(chKI,
                       label: block_chKI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chKI: // global
           if (R1 & 7 == 1) goto chKM; else goto chKN;
       chKM: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       chKN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto chL1; else goto chL0;
       chL1: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chL0: // global
           _sgNS::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sgNS::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.570507048 UTC

[section ""data" . GHC.Base.when1_closure" {
     GHC.Base.when1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.57256979 UTC

[section ""data" . GHC.Base.when_$swhen_closure" {
     GHC.Base.when_$swhen_closure:
         const GHC.Base.when_$swhen_info;
 },
 GHC.Base.when_$swhen_entry() //  [R2, R3]
         { info_tbl: [(chLx,
                       label: GHC.Base.when_$swhen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chLx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chLy; else goto chLz;
       chLy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_$swhen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chLz: // global
           I64[Sp - 16] = block_chLq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhLG; else goto chLr;
       uhLG: // global
           call _chLq(R1) args: 0, res: 0, upd: 0;
       chLr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chLq() //  [R1]
         { info_tbl: [(chLq,
                       label: block_chLq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chLq: // global
           if (R1 & 7 == 1) goto chLu; else goto chLv;
       chLu: // global
           R1 = GHC.Base.when1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       chLv: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.578421815 UTC

[section ""data" . GHC.Base.when_closure" {
     GHC.Base.when_closure:
         const GHC.Base.when_info;
 },
 GHC.Base.when_entry() //  [R2, R3, R4]
         { info_tbl: [(chM7,
                       label: GHC.Base.when_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chM7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto chM8; else goto chM9;
       chM8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chM9: // global
           I64[Sp - 24] = block_chM0_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uhMg; else goto chM1;
       uhMg: // global
           call _chM0(R1) args: 0, res: 0, upd: 0;
       chM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chM0() //  [R1]
         { info_tbl: [(chM0,
                       label: block_chM0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chM0: // global
           if (R1 & 7 == 1) goto chM4; else goto chM5;
       chM4: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       chM5: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.584550054 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*_entry() //  [R2, R3]
         { info_tbl: [(chMH,
                       label: GHC.Base.$fApplicativeMaybe_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chMH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chMI; else goto chMJ;
       chMI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chMJ: // global
           I64[Sp - 16] = block_chMA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhN7; else goto chMB;
       uhN7: // global
           call _chMA(R1) args: 0, res: 0, upd: 0;
       chMB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chMA() //  [R1]
         { info_tbl: [(chMA,
                       label: block_chMA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chMA: // global
           if (R1 & 7 == 1) goto uhN3; else goto chMF;
       uhN3: // global
           Sp = Sp + 16;
           call _chMX() args: 0, res: 0, upd: 0;
       chMF: // global
           I64[Sp] = block_chMP_info;
           _sgO3::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgO3::P64;
           if (R1 & 7 != 0) goto uhN5; else goto chMR;
       uhN5: // global
           call _chMP(R1) args: 0, res: 0, upd: 0;
       chMR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chMP() //  [R1]
         { info_tbl: [(chMP,
                       label: block_chMP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chMP: // global
           if (R1 & 7 == 1) goto uhN4; else goto chN1;
       uhN4: // global
           Sp = Sp + 16;
           call _chMX() args: 0, res: 0, upd: 0;
       chN1: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _chMX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chMX: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.59348964 UTC

[section ""cstring" . GHC.Base.$tc'O3_bytes" {
     GHC.Base.$tc'O3_bytes:
         I8[] [39,79]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.595166835 UTC

[section ""data" . GHC.Base.$tc'O2_closure" {
     GHC.Base.$tc'O2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'O3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.596764799 UTC

[section ""cstring" . GHC.Base.$tcOpaque2_bytes" {
     GHC.Base.$tcOpaque2_bytes:
         I8[] [79,112,97,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.598873646 UTC

[section ""data" . GHC.Base.$tcOpaque1_closure" {
     GHC.Base.$tcOpaque1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcOpaque2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.600456507 UTC

[section ""cstring" . GHC.Base.$tcMonadPlus2_bytes" {
     GHC.Base.$tcMonadPlus2_bytes:
         I8[] [77,111,110,97,100,80,108,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.602086144 UTC

[section ""data" . GHC.Base.$tcMonadPlus1_closure" {
     GHC.Base.$tcMonadPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonadPlus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.603697326 UTC

[section ""cstring" . GHC.Base.$tcMonad2_bytes" {
     GHC.Base.$tcMonad2_bytes:
         I8[] [77,111,110,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.605346867 UTC

[section ""data" . GHC.Base.$tcMonad1_closure" {
     GHC.Base.$tcMonad1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonad2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.607040206 UTC

[section ""cstring" . GHC.Base.$tc'C:Monoid3_bytes" {
     GHC.Base.$tc'C:Monoid3_bytes:
         I8[] [39,67,58,77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.60863846 UTC

[section ""data" . GHC.Base.$tc'C:Monoid2_closure" {
     GHC.Base.$tc'C:Monoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'C:Monoid3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.610315729 UTC

[section ""cstring" . GHC.Base.$tcMonoid3_bytes" {
     GHC.Base.$tcMonoid3_bytes:
         I8[] [77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.612007143 UTC

[section ""data" . GHC.Base.$tcMonoid2_closure" {
     GHC.Base.$tcMonoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonoid3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.614120582 UTC

[section ""cstring" . GHC.Base.$tcSemigroup2_bytes" {
     GHC.Base.$tcSemigroup2_bytes:
         I8[] [83,101,109,105,103,114,111,117,112]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.615823857 UTC

[section ""data" . GHC.Base.$tcSemigroup1_closure" {
     GHC.Base.$tcSemigroup1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcSemigroup2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.618005515 UTC

[section ""cstring" . GHC.Base.$tc':|3_bytes" {
     GHC.Base.$tc':|3_bytes:
         I8[] [39,58,124]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.619701534 UTC

[section ""data" . GHC.Base.$tc':|2_closure" {
     GHC.Base.$tc':|2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc':|3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.621354187 UTC

[section ""cstring" . GHC.Base.$tcNonEmpty2_bytes" {
     GHC.Base.$tcNonEmpty2_bytes:
         I8[] [78,111,110,69,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.623016065 UTC

[section ""data" . GHC.Base.$tcNonEmpty1_closure" {
     GHC.Base.$tcNonEmpty1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcNonEmpty2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.624714703 UTC

[section ""cstring" . GHC.Base.$tcAlternative3_bytes" {
     GHC.Base.$tcAlternative3_bytes:
         I8[] [65,108,116,101,114,110,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.626360617 UTC

[section ""data" . GHC.Base.$tcAlternative2_closure" {
     GHC.Base.$tcAlternative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcAlternative3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.62794954 UTC

[section ""cstring" . GHC.Base.$tcApplicative2_bytes" {
     GHC.Base.$tcApplicative2_bytes:
         I8[] [65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.629551864 UTC

[section ""data" . GHC.Base.$tcApplicative1_closure" {
     GHC.Base.$tcApplicative1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcApplicative2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.631234832 UTC

[section ""cstring" . GHC.Base.$tcFunctor2_bytes" {
     GHC.Base.$tcFunctor2_bytes:
         I8[] [70,117,110,99,116,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.632872124 UTC

[section ""data" . GHC.Base.$tcFunctor1_closure" {
     GHC.Base.$tcFunctor1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcFunctor2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.634600747 UTC

[section ""cstring" . GHC.Base.$tc'Just3_bytes" {
     GHC.Base.$tc'Just3_bytes:
         I8[] [39,74,117,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.636250798 UTC

[section ""data" . GHC.Base.$tc'Just2_closure" {
     GHC.Base.$tc'Just2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Just3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.637997836 UTC

[section ""cstring" . GHC.Base.$tc'Nothing3_bytes" {
     GHC.Base.$tc'Nothing3_bytes:
         I8[] [39,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.63965707 UTC

[section ""data" . GHC.Base.$tc'Nothing2_closure" {
     GHC.Base.$tc'Nothing2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Nothing3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.641767461 UTC

[section ""cstring" . GHC.Base.$tcMaybe2_bytes" {
     GHC.Base.$tcMaybe2_bytes:
         I8[] [77,97,121,98,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.643379615 UTC

[section ""data" . GHC.Base.$tcMaybe1_closure" {
     GHC.Base.$tcMaybe1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMaybe2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.64503857 UTC

[section ""data" . $krep_r7Pr_closure" {
     $krep_r7Pr_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.647437679 UTC

[section ""data" . $krep1_r7Ps_closure" {
     $krep1_r7Ps_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.649145181 UTC

[section ""data" . $krep2_r7Pt_closure" {
     $krep2_r7Pt_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep1_r7Ps_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.650836105 UTC

[section ""data" . $krep3_r7Pu_closure" {
     $krep3_r7Pu_closure:
         const :_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.65250289 UTC

[section ""data" . $krep4_r7Pv_closure" {
     $krep4_r7Pv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.654457142 UTC

[section ""data" . $krep5_r7Pw_closure" {
     $krep5_r7Pw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.656131028 UTC

[section ""data" . $krep6_r7Px_closure" {
     $krep6_r7Px_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.657823095 UTC

[section ""data" . GHC.Base.$tcMonoid1_closure" {
     GHC.Base.$tcMonoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.659510773 UTC

[section ""data" . GHC.Base.$tcAlternative1_closure" {
     GHC.Base.$tcAlternative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.661168774 UTC

[section ""cstring" . GHC.Base.$trModule2_bytes" {
     GHC.Base.$trModule2_bytes:
         I8[] [71,72,67,46,66,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.662829324 UTC

[section ""data" . GHC.Base.$trModule1_closure" {
     GHC.Base.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.664389471 UTC

[section ""cstring" . GHC.Base.$trModule4_bytes" {
     GHC.Base.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.666010001 UTC

[section ""data" . GHC.Base.$trModule3_closure" {
     GHC.Base.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.668104422 UTC

[section ""data" . GHC.Base.$trModule_closure" {
     GHC.Base.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Base.$trModule3_closure+1;
         const GHC.Base.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.67044798 UTC

[section ""data" . GHC.Base.$tcMaybe_closure" {
     GHC.Base.$tcMaybe_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMaybe1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 625655543500963593;
         const 6391758309165051762;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.67212807 UTC

[section ""data" . GHC.Base.$tc'Nothing1_closure" {
     GHC.Base.$tc'Nothing1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.673848096 UTC

[section ""data" . GHC.Base.$tc'Just1_closure" {
     GHC.Base.$tc'Just1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.675496713 UTC

[section ""data" . GHC.Base.$tc'Nothing_closure" {
     GHC.Base.$tc'Nothing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Nothing2_closure+1;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 14633289528184412192;
         const 12773126156421542470;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.677204585 UTC

[section ""data" . GHC.Base.$tc'Just_closure" {
     GHC.Base.$tc'Just_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Just2_closure+1;
         const GHC.Base.$tc'Just1_closure+4;
         const 5794512144280699493;
         const 9434423460978218117;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.679024777 UTC

[section ""data" . GHC.Base.$tcFunctor_closure" {
     GHC.Base.$tcFunctor_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcFunctor1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 211182333006544237;
         const 5556320544348084514;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.680752052 UTC

[section ""data" . GHC.Base.$tcApplicative_closure" {
     GHC.Base.$tcApplicative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcApplicative1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 12705055220831243597;
         const 2963353171490466073;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.68260089 UTC

[section ""data" . GHC.Base.$tcAlternative_closure" {
     GHC.Base.$tcAlternative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcAlternative2_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 1073491102990665358;
         const 14320772755704808948;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.684414379 UTC

[section ""data" . GHC.Base.$tcNonEmpty_closure" {
     GHC.Base.$tcNonEmpty_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcNonEmpty1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13207016872645468285;
         const 3455542966739695982;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.68627083 UTC

[section ""data" . $krep7_r7Py_closure" {
     $krep7_r7Py_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcNonEmpty_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.687931142 UTC

[section ""data" . $krep8_r7Pz_closure" {
     $krep8_r7Pz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep7_r7Py_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.690009425 UTC

[section ""data" . GHC.Base.$tc':|1_closure" {
     GHC.Base.$tc':|1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep8_r7Pz_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.691607254 UTC

[section ""data" . GHC.Base.$tc':|_closure" {
     GHC.Base.$tc':|_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc':|2_closure+1;
         const GHC.Base.$tc':|1_closure+4;
         const 9440832435183810765;
         const 3053237465234607583;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.693868027 UTC

[section ""data" . GHC.Base.$tcSemigroup_closure" {
     GHC.Base.$tcSemigroup_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcSemigroup1_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 16195352186364298277;
         const 3285685594139281062;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.69569614 UTC

[section ""data" . $krep9_r7PA_closure" {
     $krep9_r7PA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcSemigroup_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.697394174 UTC

[section ""data" . GHC.Base.$tcMonoid_closure" {
     GHC.Base.$tcMonoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonoid2_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 13838560045895743776;
         const 1291018260833769143;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.699138517 UTC

[section ""data" . $krep10_r7PB_closure" {
     $krep10_r7PB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMonoid_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.700849398 UTC

[section ""data" . $krep11_r7PC_closure" {
     $krep11_r7PC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r7Pw_closure+4;
         const $krep10_r7PB_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.703172153 UTC

[section ""data" . $krep12_r7PD_closure" {
     $krep12_r7PD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r7Pt_closure+4;
         const $krep11_r7PC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.70492601 UTC

[section ""data" . $krep13_r7PE_closure" {
     $krep13_r7PE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep12_r7PD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.706605506 UTC

[section ""data" . GHC.Base.$tc'C:Monoid1_closure" {
     GHC.Base.$tc'C:Monoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r7PA_closure+1;
         const $krep13_r7PE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.708336254 UTC

[section ""data" . GHC.Base.$tc'C:Monoid_closure" {
     GHC.Base.$tc'C:Monoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'C:Monoid2_closure+1;
         const GHC.Base.$tc'C:Monoid1_closure+4;
         const 16099296089107510343;
         const 5895832073319104984;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.710166279 UTC

[section ""data" . GHC.Base.$tcMonad_closure" {
     GHC.Base.$tcMonad_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonad1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 3168880480603756299;
         const 8398240611646296094;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.711917468 UTC

[section ""data" . GHC.Base.$tcMonadPlus_closure" {
     GHC.Base.$tcMonadPlus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonadPlus1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 14115673251620372550;
         const 14155357326069389390;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.713726314 UTC

[section ""data" . GHC.Base.$tcOpaque_closure" {
     GHC.Base.$tcOpaque_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcOpaque1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9339725405829241186;
         const 15550233501624900571;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.715512654 UTC

[section ""data" . $krep14_r7PF_closure" {
     $krep14_r7PF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcOpaque_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.717231964 UTC

[section ""data" . GHC.Base.$tc'O1_closure" {
     GHC.Base.$tc'O1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep14_r7PF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.720023331 UTC

[section ""data" . GHC.Base.$tc'O_closure" {
     GHC.Base.$tc'O_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'O2_closure+1;
         const GHC.Base.$tc'O1_closure+4;
         const 12551274612394834805;
         const 13000664474148134329;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.722531046 UTC

[section ""data" . GHC.Base.quotRemInt_closure" {
     GHC.Base.quotRemInt_closure:
         const GHC.Base.quotRemInt_info;
 },
 GHC.Base.quotRemInt_entry() //  [R2, R3]
         { info_tbl: [(chOO,
                       label: GHC.Base.quotRemInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chOO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chOZ; else goto chP0;
       chOZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotRemInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chP0: // global
           I64[Sp - 16] = block_chOL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhP6; else goto chOM;
       uhP6: // global
           call _chOL(R1) args: 0, res: 0, upd: 0;
       chOM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chOL() //  [R1]
         { info_tbl: [(chOL,
                       label: block_chOL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chOL: // global
           I64[Sp] = block_chOR_info;
           _sgOa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOa::I64;
           if (R1 & 7 != 0) goto uhP5; else goto chOS;
       uhP5: // global
           call _chOR(R1) args: 0, res: 0, upd: 0;
       chOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chOR() //  [R1]
         { info_tbl: [(chOR,
                       label: block_chOR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chOR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto chP4; else goto chP3;
       chP4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chP3: // global
           (_sgOe::I64, _sgOf::I64) = call MO_S_QuotRem W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgOf::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgOe::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.730562218 UTC

[section ""data" . GHC.Base.modInt_closure" {
     GHC.Base.modInt_closure:
         const GHC.Base.modInt_info;
 },
 GHC.Base.modInt_entry() //  [R2, R3]
         { info_tbl: [(chPz,
                       label: GHC.Base.modInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chPz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chPM; else goto chPN;
       chPM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.modInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chPN: // global
           I64[Sp - 16] = block_chPw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhPU; else goto chPx;
       uhPU: // global
           call _chPw(R1) args: 0, res: 0, upd: 0;
       chPx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chPw() //  [R1]
         { info_tbl: [(chPw,
                       label: block_chPw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chPw: // global
           I64[Sp] = block_chPC_info;
           _sgOl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOl::I64;
           if (R1 & 7 != 0) goto uhPT; else goto chPD;
       uhPT: // global
           call _chPC(R1) args: 0, res: 0, upd: 0;
       chPD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chPC() //  [R1]
         { info_tbl: [(chPC,
                       label: block_chPC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chPC: // global
           _sgOl::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_chPH_info;
           R3 = I64[R1 + 7];
           R2 = _sgOl::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _chPH() //  [R1]
         { info_tbl: [(chPH,
                       label: block_chPH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chPH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto chPS; else goto chPR;
       chPS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       chPR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.740098917 UTC

[section ""data" . GHC.Base.divInt_closure" {
     GHC.Base.divInt_closure:
         const GHC.Base.divInt_info;
 },
 GHC.Base.divInt_entry() //  [R2, R3]
         { info_tbl: [(chQn,
                       label: GHC.Base.divInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chQn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chQA; else goto chQB;
       chQA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chQB: // global
           I64[Sp - 16] = block_chQk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhQI; else goto chQl;
       uhQI: // global
           call _chQk(R1) args: 0, res: 0, upd: 0;
       chQl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chQk() //  [R1]
         { info_tbl: [(chQk,
                       label: block_chQk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chQk: // global
           I64[Sp] = block_chQq_info;
           _sgOs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOs::I64;
           if (R1 & 7 != 0) goto uhQH; else goto chQr;
       uhQH: // global
           call _chQq(R1) args: 0, res: 0, upd: 0;
       chQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chQq() //  [R1]
         { info_tbl: [(chQq,
                       label: block_chQq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chQq: // global
           _sgOs::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_chQv_info;
           R3 = I64[R1 + 7];
           R2 = _sgOs::I64;
           Sp = Sp + 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _chQv() //  [R1]
         { info_tbl: [(chQv,
                       label: block_chQv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chQv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto chQG; else goto chQF;
       chQG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       chQF: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.749443474 UTC

[section ""data" . GHC.Base.remInt_closure" {
     GHC.Base.remInt_closure:
         const GHC.Base.remInt_info;
 },
 GHC.Base.remInt_entry() //  [R2, R3]
         { info_tbl: [(chRb,
                       label: GHC.Base.remInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chRb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chRn; else goto chRo;
       chRn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.remInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chRo: // global
           I64[Sp - 16] = block_chR8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhRu; else goto chR9;
       uhRu: // global
           call _chR8(R1) args: 0, res: 0, upd: 0;
       chR9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chR8() //  [R1]
         { info_tbl: [(chR8,
                       label: block_chR8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chR8: // global
           I64[Sp] = block_chRe_info;
           _sgOz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOz::I64;
           if (R1 & 7 != 0) goto uhRt; else goto chRf;
       uhRt: // global
           call _chRe(R1) args: 0, res: 0, upd: 0;
       chRf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chRe() //  [R1]
         { info_tbl: [(chRe,
                       label: block_chRe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chRe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto chRs; else goto chRr;
       chRs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chRr: // global
           _sgOC::I64 = %MO_S_Rem_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgOC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.758297464 UTC

[section ""data" . GHC.Base.quotInt_closure" {
     GHC.Base.quotInt_closure:
         const GHC.Base.quotInt_info;
 },
 GHC.Base.quotInt_entry() //  [R2, R3]
         { info_tbl: [(chRT,
                       label: GHC.Base.quotInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chRT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chS5; else goto chS6;
       chS5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chS6: // global
           I64[Sp - 16] = block_chRQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhSc; else goto chRR;
       uhSc: // global
           call _chRQ(R1) args: 0, res: 0, upd: 0;
       chRR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chRQ() //  [R1]
         { info_tbl: [(chRQ,
                       label: block_chRQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chRQ: // global
           I64[Sp] = block_chRW_info;
           _sgOG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOG::I64;
           if (R1 & 7 != 0) goto uhSb; else goto chRX;
       uhSb: // global
           call _chRW(R1) args: 0, res: 0, upd: 0;
       chRX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chRW() //  [R1]
         { info_tbl: [(chRW,
                       label: block_chRW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chRW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto chSa; else goto chS9;
       chSa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chS9: // global
           _sgOJ::I64 = %MO_S_Quot_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgOJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.765929739 UTC

[section ""data" . GHC.Base.getTag_closure" {
     GHC.Base.getTag_closure:
         const GHC.Base.getTag_info;
 },
 GHC.Base.getTag_entry() //  [R2]
         { info_tbl: [(chSB,
                       label: GHC.Base.getTag_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chSB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chSC; else goto chSD;
       chSC: // global
           R2 = R2;
           R1 = GHC.Base.getTag_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chSD: // global
           I64[Sp - 8] = block_chSy_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chSy() //  [R1]
         { info_tbl: [(chSy,
                       label: block_chSy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chSy: // global
           R1 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.771216814 UTC

[section ""data" . GHC.Base.$fMonadIO1_closure" {
     GHC.Base.$fMonadIO1_closure:
         const GHC.Base.$fMonadIO1_info;
 },
 GHC.Base.$fMonadIO1_entry() //  [R2, R3]
         { info_tbl: [(chSY,
                       label: GHC.Base.$fMonadIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chSY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chSZ; else goto chT0;
       chSZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chT0: // global
           I64[Sp - 16] = block_chSW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chSW() //  [R1]
         { info_tbl: [(chSW,
                       label: block_chSW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chSW: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.77644631 UTC

[section ""data" . GHC.Base.bindIO_closure" {
     GHC.Base.bindIO_closure:
         const GHC.Base.bindIO_info;
 },
 GHC.Base.bindIO_entry() //  [R2, R3]
         { info_tbl: [(chTf,
                       label: GHC.Base.bindIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chTf: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fMonadIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.779881065 UTC

[section ""data" . GHC.Base.$fApplicativeIO2_closure" {
     GHC.Base.$fApplicativeIO2_closure:
         const GHC.Base.$fApplicativeIO2_info;
 },
 GHC.Base.$fApplicativeIO2_entry() //  [R2, R3]
         { info_tbl: [(chTs,
                       label: GHC.Base.$fApplicativeIO2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chTs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chTt; else goto chTu;
       chTt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chTu: // global
           I64[Sp - 16] = block_chTq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chTq() //  []
         { info_tbl: [(chTq,
                       label: block_chTq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chTq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.785615651 UTC

[section ""data" . GHC.Base.thenIO_closure" {
     GHC.Base.thenIO_closure:
         const GHC.Base.thenIO_info;
 },
 GHC.Base.thenIO_entry() //  [R2, R3]
         { info_tbl: [(chTJ,
                       label: GHC.Base.thenIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chTJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeIO2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.788892302 UTC

[section ""data" . GHC.Base.unIO1_closure" {
     GHC.Base.unIO1_closure:
         const GHC.Base.unIO1_info;
 },
 GHC.Base.unIO1_entry() //  [R2]
         { info_tbl: [(chTU,
                       label: GHC.Base.unIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chTU: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.792566781 UTC

[section ""data" . GHC.Base.unIO_closure" {
     GHC.Base.unIO_closure:
         const GHC.Base.unIO_info;
 },
 GHC.Base.unIO_entry() //  [R2]
         { info_tbl: [(chU5,
                       label: GHC.Base.unIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chU5: // global
           R2 = R2;
           call GHC.Base.unIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.795851032 UTC

[section ""data" . GHC.Base.$fApplicativeIO4_closure" {
     GHC.Base.$fApplicativeIO4_closure:
         const GHC.Base.$fApplicativeIO4_info;
 },
 GHC.Base.$fApplicativeIO4_entry() //  [R2]
         { info_tbl: [(chUg,
                       label: GHC.Base.$fApplicativeIO4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chUg: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.799118118 UTC

[section ""data" . GHC.Base.returnIO_closure" {
     GHC.Base.returnIO_closure:
         const GHC.Base.returnIO_info;
 },
 GHC.Base.returnIO_entry() //  [R2]
         { info_tbl: [(chUs,
                       label: GHC.Base.returnIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chUs: // global
           R2 = R2;
           call GHC.Base.$fApplicativeIO4_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.802489126 UTC

[section ""data" . GHC.Base.$fApplicativeIO3_closure" {
     GHC.Base.$fApplicativeIO3_closure:
         const GHC.Base.$fApplicativeIO3_info;
 },
 GHC.Base.$fApplicativeIO3_entry() //  [R2, R3]
         { info_tbl: [(chUI,
                       label: GHC.Base.$fApplicativeIO3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chUI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chUJ; else goto chUK;
       chUJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chUK: // global
           I64[Sp - 16] = block_chUD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chUD() //  [R1]
         { info_tbl: [(chUD,
                       label: block_chUD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chUD: // global
           I64[Sp] = block_chUF_info;
           _sgP5::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgP5::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chUF() //  [R1]
         { info_tbl: [(chUF,
                       label: block_chUF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chUF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chUO; else goto chUN;
       chUO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chUN: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.809633132 UTC

[section ""data" . GHC.Base.liftA_$sliftA1_closure" {
     GHC.Base.liftA_$sliftA1_closure:
         const GHC.Base.liftA_$sliftA1_info;
 },
 GHC.Base.liftA_$sliftA1_entry() //  [R2, R3]
         { info_tbl: [(chV9,
                       label: GHC.Base.liftA_$sliftA1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chV9: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.813104885 UTC

[section ""data" . GHC.Base.ap1_closure" {
     GHC.Base.ap1_closure:
         const GHC.Base.ap1_info;
 },
 GHC.Base.ap1_entry() //  [R2, R3]
         { info_tbl: [(chVp,
                       label: GHC.Base.ap1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chVp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chVq; else goto chVr;
       chVq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chVr: // global
           I64[Sp - 16] = block_chVk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chVk() //  [R1]
         { info_tbl: [(chVk,
                       label: block_chVk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chVk: // global
           I64[Sp] = block_chVm_info;
           _sgPf::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgPf::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chVm() //  [R1]
         { info_tbl: [(chVm,
                       label: block_chVm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chVm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chVv; else goto chVu;
       chVv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chVu: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.820175665 UTC

[section ""data" . GHC.Base.ap_$sap1_closure" {
     GHC.Base.ap_$sap1_closure:
         const GHC.Base.ap_$sap1_info;
 },
 GHC.Base.ap_$sap1_entry() //  [R2, R3]
         { info_tbl: [(chVQ,
                       label: GHC.Base.ap_$sap1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chVQ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.ap1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.824338442 UTC

[section ""data" . GHC.Base.ap_closure" {
     GHC.Base.ap_closure:
         const GHC.Base.ap_info;
 },
 sat_sgPq_entry() //  [R1, R2]
         { info_tbl: [(chWc,
                       label: sat_sgPq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chWc: // global
           _sgPo::P64 = R2;
           _sgPq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto chWd; else goto chWe;
       chWe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chWg; else goto chWf;
       chWg: // global
           HpAlloc = 32;
           goto chWd;
       chWd: // global
           R2 = _sgPo::P64;
           R1 = _sgPq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chWf: // global
           _sgPk::P64 = P64[_sgPq::P64 + 7];
           _sgPn::P64 = P64[_sgPq::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgPn::P64;
           P64[Hp] = _sgPo::P64;
           R2 = _sgPk::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgPr_entry() //  [R1, R2]
         { info_tbl: [(chWh,
                       label: sat_sgPr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chWh: // global
           _sgPn::P64 = R2;
           _sgPr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto chWi; else goto chWj;
       chWj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto chWl; else goto chWk;
       chWl: // global
           HpAlloc = 24;
           goto chWi;
       chWi: // global
           R2 = _sgPn::P64;
           R1 = _sgPr::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chWk: // global
           _sgPk::P64 = P64[_sgPr::P64 + 7];
           _sgPm::P64 = P64[_sgPr::P64 + 15];
           I64[Hp - 16] = sat_sgPq_info;
           P64[Hp - 8] = _sgPk::P64;
           P64[Hp] = _sgPn::P64;
           R2 = _sgPk::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgPm::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.ap_entry() //  [R2, R3, R4]
         { info_tbl: [(chWm,
                       label: GHC.Base.ap_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chWm: // global
           _sgPm::P64 = R4;
           _sgPl::P64 = R3;
           _sgPk::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto chWn; else goto chWo;
       chWo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto chWq; else goto chWp;
       chWq: // global
           HpAlloc = 24;
           goto chWn;
       chWn: // global
           R4 = _sgPm::P64;
           R3 = _sgPl::P64;
           R2 = _sgPk::P64;
           R1 = GHC.Base.ap_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chWp: // global
           I64[Hp - 16] = sat_sgPr_info;
           P64[Hp - 8] = _sgPk::P64;
           P64[Hp] = _sgPm::P64;
           R2 = _sgPk::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgPl::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.833287373 UTC

[section ""data" . GHC.Base.liftM1_closure" {
     GHC.Base.liftM1_closure:
         const GHC.Base.liftM1_info;
 },
 GHC.Base.liftM1_entry() //  [R2, R3, R4]
         { info_tbl: [(chWW,
                       label: GHC.Base.liftM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chWW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto chWX; else goto chWY;
       chWX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chWY: // global
           I64[Sp - 24] = block_chWR_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chWR() //  [R1]
         { info_tbl: [(chWR,
                       label: block_chWR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chWR: // global
           I64[Sp] = block_chWT_info;
           _sgPy::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgPy::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chWT() //  [R1]
         { info_tbl: [(chWT,
                       label: block_chWT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chWT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto chX2; else goto chX1;
       chX2: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chX1: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.840820347 UTC

[section ""data" . GHC.Base.liftM2_$sliftM1_closure" {
     GHC.Base.liftM2_$sliftM1_closure:
         const GHC.Base.liftM2_$sliftM1_info;
 },
 GHC.Base.liftM2_$sliftM1_entry() //  [R2, R3, R4]
         { info_tbl: [(chXo,
                       label: GHC.Base.liftM2_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chXo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.844492802 UTC

[section ""data" . GHC.Base.liftM2_closure" {
     GHC.Base.liftM2_closure:
         const GHC.Base.liftM2_info;
 },
 sat_sgPK_entry() //  [R1, R2]
         { info_tbl: [(chXK,
                       label: sat_sgPK_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chXK: // global
           _sgPI::P64 = R2;
           _sgPK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto chXL; else goto chXM;
       chXM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto chXO; else goto chXN;
       chXO: // global
           HpAlloc = 40;
           goto chXL;
       chXL: // global
           R2 = _sgPI::P64;
           R1 = _sgPK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chXN: // global
           _sgPD::P64 = P64[_sgPK::P64 + 7];
           _sgPE::P64 = P64[_sgPK::P64 + 15];
           _sgPH::P64 = P64[_sgPK::P64 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sgPE::P64;
           P64[Hp - 8] = _sgPH::P64;
           P64[Hp] = _sgPI::P64;
           R2 = _sgPD::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgPL_entry() //  [R1, R2]
         { info_tbl: [(chXP,
                       label: sat_sgPL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chXP: // global
           _sgPH::P64 = R2;
           _sgPL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto chXQ; else goto chXR;
       chXR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chXT; else goto chXS;
       chXT: // global
           HpAlloc = 32;
           goto chXQ;
       chXQ: // global
           R2 = _sgPH::P64;
           R1 = _sgPL::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chXS: // global
           _sgPD::P64 = P64[_sgPL::P64 + 7];
           _sgPE::P64 = P64[_sgPL::P64 + 15];
           _sgPG::P64 = P64[_sgPL::P64 + 23];
           I64[Hp - 24] = sat_sgPK_info;
           P64[Hp - 16] = _sgPD::P64;
           P64[Hp - 8] = _sgPE::P64;
           P64[Hp] = _sgPH::P64;
           R2 = _sgPD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgPG::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(chXU,
                       label: GHC.Base.liftM2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chXU: // global
           _sgPG::P64 = R5;
           _sgPF::P64 = R4;
           _sgPE::P64 = R3;
           _sgPD::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto chXV; else goto chXW;
       chXW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chXY; else goto chXX;
       chXY: // global
           HpAlloc = 32;
           goto chXV;
       chXV: // global
           R5 = _sgPG::P64;
           R4 = _sgPF::P64;
           R3 = _sgPE::P64;
           R2 = _sgPD::P64;
           R1 = GHC.Base.liftM2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chXX: // global
           I64[Hp - 24] = sat_sgPL_info;
           P64[Hp - 16] = _sgPD::P64;
           P64[Hp - 8] = _sgPE::P64;
           P64[Hp] = _sgPG::P64;
           R2 = _sgPD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgPF::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.854098583 UTC

[section ""data" . $cliftA2_r7PG_closure" {
     $cliftA2_r7PG_closure:
         const $cliftA2_r7PG_info;
 },
 $cliftA2_r7PG_entry() //  [R2, R3, R4]
         { info_tbl: [(chYu,
                       label: $cliftA2_r7PG_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chYu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto chYv; else goto chYw;
       chYv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chYw: // global
           I64[Sp - 24] = block_chYp_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chYp() //  [R1]
         { info_tbl: [(chYp,
                       label: block_chYp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chYp: // global
           I64[Sp] = block_chYr_info;
           _sgPS::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgPS::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chYr() //  [R1]
         { info_tbl: [(chYr,
                       label: block_chYr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chYr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto chYA; else goto chYz;
       chYA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chYz: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.861835634 UTC

[section ""data" . GHC.Base.$fApplicativeIO_$cliftA2_closure" {
     GHC.Base.$fApplicativeIO_$cliftA2_closure:
         const GHC.Base.$fApplicativeIO_$cliftA2_info;
 },
 GHC.Base.$fApplicativeIO_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(chYW,
                       label: GHC.Base.$fApplicativeIO_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chYW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.86547486 UTC

[section ""data" . GHC.Base.liftA1_closure" {
     GHC.Base.liftA1_closure:
         const GHC.Base.liftA1_info;
 },
 GHC.Base.liftA1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(chZe,
                       label: GHC.Base.liftA1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chZe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chZf; else goto chZg;
       chZf: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chZg: // global
           I64[Sp - 32] = block_chZ7_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chZ7() //  [R1]
         { info_tbl: [(chZ7,
                       label: block_chZ7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chZ7: // global
           I64[Sp] = block_chZ9_info;
           _sgQ4::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgQ4::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chZ9() //  [R1]
         { info_tbl: [(chZ9,
                       label: block_chZ9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chZ9: // global
           I64[Sp] = block_chZb_info;
           _sgQ7::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgQ7::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chZb() //  [R1]
         { info_tbl: [(chZb,
                       label: block_chZb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chZb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto chZl; else goto chZk;
       chZl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chZk: // global
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.874325312 UTC

[section ""data" . GHC.Base.liftA3_$sliftA1_closure" {
     GHC.Base.liftA3_$sliftA1_closure:
         const GHC.Base.liftA3_$sliftA1_info;
 },
 GHC.Base.liftA3_$sliftA1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(chZM,
                       label: GHC.Base.liftA3_$sliftA1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chZM: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.877992205 UTC

[section ""data" . GHC.Base.$fSemigroupIO2_closure" {
     GHC.Base.$fSemigroupIO2_closure:
         const GHC.Base.$fSemigroupIO2_info;
 },
 sat_sgQm_entry() //  [R1]
         { info_tbl: [(ci05,
                       label: sat_sgQm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci05: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci06; else goto ci07;
       ci06: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci07: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupIO2_entry() //  [R2, R3, R4]
         { info_tbl: [(ci08,
                       label: GHC.Base.$fSemigroupIO2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci08: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ci09; else goto ci0a;
       ci09: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ci0a: // global
           I64[Sp - 24] = block_chZX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chZX() //  [R1]
         { info_tbl: [(chZX,
                       label: block_chZX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chZX: // global
           I64[Sp] = block_chZZ_info;
           _sgQi::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgQi::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chZZ() //  [R1]
         { info_tbl: [(chZZ,
                       label: block_chZZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       chZZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ci0e; else goto ci0d;
       ci0e: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci0d: // global
           I64[Hp - 32] = sat_sgQm_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.8877461 UTC

[section ""data" . GHC.Base.$w$csconcat4_closure" {
     GHC.Base.$w$csconcat4_closure:
         const GHC.Base.$w$csconcat4_info;
 },
 sat_sgQE_entry() //  [R1]
         { info_tbl: [(ci11,
                       label: sat_sgQE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci11: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci12; else goto ci13;
       ci12: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci13: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_sgQr_entry() //  [R1, R2, R3]
         { info_tbl: [(ci18,
                       label: go_sgQr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci18: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci19; else goto ci1a;
       ci19: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ci1a: // global
           I64[Sp - 32] = block_ci0N_info;
           _sgQr::P64 = R1;
           _sgQn::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 24] = _sgQn::P64;
           P64[Sp - 16] = _sgQr::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ui1i; else goto ci0O;
       ui1i: // global
           call _ci0N(R1) args: 0, res: 0, upd: 0;
       ci0O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci0N() //  [R1]
         { info_tbl: [(ci0N,
                       label: block_ci0N_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci0N: // global
           _sgQs::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ci15; else goto ci16;
       ci15: // global
           R1 = _sgQs::P64;
           Sp = Sp + 32;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       ci16: // global
           I64[Sp - 8] = block_ci0T_info;
           _sgQw::P64 = P64[R1 + 6];
           _sgQx::P64 = P64[R1 + 14];
           R1 = _sgQs::P64;
           P64[Sp] = _sgQx::P64;
           P64[Sp + 24] = _sgQw::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci0T() //  [R1]
         { info_tbl: [(ci0T,
                       label: block_ci0T_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci0T: // global
           _sgQx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ci0V_info;
           R3 = _sgQx::P64;
           R2 = P64[Sp + 32];
           _sgQA::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 32] = _sgQA::P64;
           Sp = Sp + 8;
           call go_sgQr_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci0V() //  [R1]
         { info_tbl: [(ci0V,
                       label: block_ci0V_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci0V: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ci1h; else goto ci1g;
       ci1h: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci1g: // global
           I64[Hp - 32] = sat_sgQE_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat4_entry() //  [R2, R3, R4]
         { info_tbl: [(ci1j,
                       label: GHC.Base.$w$csconcat4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci1j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ci1n; else goto ci1m;
       ci1n: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ci1m: // global
           I64[Hp - 8] = go_sgQr_info;
           P64[Hp] = R2;
           _sgQo::P64 = R3;
           R3 = R4;
           R2 = _sgQo::P64;
           R1 = Hp - 5;
           call go_sgQr_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.901802899 UTC

[section ""data" . GHC.Base.$fSemigroupIO1_closure" {
     GHC.Base.$fSemigroupIO1_closure:
         const GHC.Base.$fSemigroupIO1_info;
 },
 GHC.Base.$fSemigroupIO1_entry() //  [R2, R3]
         { info_tbl: [(ci25,
                       label: GHC.Base.$fSemigroupIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci25: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci26; else goto ci27;
       ci26: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ci27: // global
           I64[Sp - 16] = block_ci22_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ui2b; else goto ci23;
       ui2b: // global
           call _ci22(R1) args: 0, res: 0, upd: 0;
       ci23: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci22() //  [R1]
         { info_tbl: [(ci22,
                       label: block_ci22_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci22: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat4_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.907941881 UTC

[section ""data" . GHC.Base.$fSemigroupIO_closure" {
     GHC.Base.$fSemigroupIO_closure:
         const GHC.Base.$fSemigroupIO_info;
         const 0;
 },
 sat_sgQO_entry() //  [R1, R2]
         { info_tbl: [(ci2v,
                       label: sat_sgQO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci2v: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupIO_$cstimes_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgQN_entry() //  [R1, R2]
         { info_tbl: [(ci2D,
                       label: sat_sgQN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci2D: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroupIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgQM_entry() //  [R1, R2, R3]
         { info_tbl: [(ci2L,
                       label: sat_sgQM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci2L: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroupIO2_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroupIO_entry() //  [R2]
         { info_tbl: [(ci2P,
                       label: GHC.Base.$fSemigroupIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci2P: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ci2T; else goto ci2S;
       ci2T: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci2S: // global
           I64[Hp - 72] = sat_sgQO_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgQN_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgQM_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 54;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.$fSemigroupIO_$cstimes_closure" {
     GHC.Base.$fSemigroupIO_$cstimes_closure:
         const GHC.Base.$fSemigroupIO_$cstimes_info;
         const 0;
 },
 sat_sgQR_entry() //  [R1]
         { info_tbl: [(ci32,
                       label: sat_sgQR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci32: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci33; else goto ci34;
       ci33: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci34: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupIO_$cstimes_entry() //  [R2, R3]
         { info_tbl: [(ci35,
                       label: GHC.Base.$fSemigroupIO_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci35: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci39; else goto ci38;
       ci39: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ci38: // global
           I64[Hp - 16] = sat_sgQR_info;
           P64[Hp] = R2;
           _sgQQ::P64 = R3;
           R3 = Hp - 16;
           R2 = _sgQQ::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.921527264 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cp1Monoid_closure" {
     GHC.Base.$fMonoidIO_$cp1Monoid_closure:
         const GHC.Base.$fMonoidIO_$cp1Monoid_info;
         const 0;
 },
 sat_sgQT_entry() //  [R1]
         { info_tbl: [(ci3O,
                       label: sat_sgQT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci3O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci3P; else goto ci3Q;
       ci3P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci3Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidIO_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(ci3R,
                       label: GHC.Base.$fMonoidIO_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci3R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci3V; else goto ci3U;
       ci3V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci3U: // global
           I64[Hp - 16] = sat_sgQT_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.927334011 UTC

[section ""data" . $cmappend_r7PH_closure" {
     $cmappend_r7PH_closure:
         const $cmappend_r7PH_info;
 },
 sat_sgR5_entry() //  [R1]
         { info_tbl: [(ci4k,
                       label: sat_sgR5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci4k: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci4l; else goto ci4m;
       ci4l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci4m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ci4i_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ci4i() //  [R1]
         { info_tbl: [(ci4i,
                       label: block_ci4i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci4i: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $cmappend_r7PH_entry() //  [R2, R3, R4]
         { info_tbl: [(ci4q,
                       label: $cmappend_r7PH_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci4q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ci4r; else goto ci4s;
       ci4r: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ci4s: // global
           I64[Sp - 24] = block_ci4a_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci4a() //  [R1]
         { info_tbl: [(ci4a,
                       label: block_ci4a_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci4a: // global
           I64[Sp] = block_ci4c_info;
           _sgR0::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgR0::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci4c() //  [R1]
         { info_tbl: [(ci4c,
                       label: block_ci4c_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci4c: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ci4w; else goto ci4v;
       ci4w: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci4v: // global
           I64[Hp - 32] = sat_sgR5_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.938648953 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cmappend_closure" {
     GHC.Base.$fMonoidIO_$cmappend_closure:
         const GHC.Base.$fMonoidIO_$cmappend_info;
 },
 GHC.Base.$fMonoidIO_$cmappend_entry() //  [R2, R3, R4]
         { info_tbl: [(ci54,
                       label: GHC.Base.$fMonoidIO_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci54: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.94197116 UTC

[section ""data" . GHC.Base.$fAlternativeIO1_closure" {
     GHC.Base.$fAlternativeIO1_closure:
         const GHC.Base.$fAlternativeIO1_info;
 },
 GHC.Base.$fAlternativeIO1_entry() //  []
         { info_tbl: [(ci5f,
                       label: GHC.Base.$fAlternativeIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci5f: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.945610802 UTC

[section ""data" . GHC.Base.$fAlternativeIO2_closure" {
     GHC.Base.$fAlternativeIO2_closure:
         const GHC.Base.$fAlternativeIO2_info;
         const 0;
 },
 some_v_sgR9_entry() //  [R1]
         { info_tbl: [(ci5C,
                       label: some_v_sgR9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci5C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci5D; else goto ci5E;
       ci5D: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ci5E: // global
           I64[Sp - 16] = block_ci5x_info;
           _sgR9::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sgR9::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci5x() //  [R1]
         { info_tbl: [(ci5x,
                       label: block_ci5x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci5x: // global
           I64[Sp] = block_ci5z_info;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = P64[Sp + 8];
           _sgRd::P64 = R1;
           R1 = GHC.IO.mplusIO_closure;
           P64[Sp + 8] = _sgRd::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci5z() //  [R1]
         { info_tbl: [(ci5z,
                       label: block_ci5z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci5z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci5I; else goto ci5H;
       ci5I: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci5H: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fAlternativeIO2_entry() //  [R2]
         { info_tbl: [(ci5J,
                       label: GHC.Base.$fAlternativeIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci5J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ci5N; else goto ci5M;
       ci5N: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci5M: // global
           I64[Hp - 8] = some_v_sgR9_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_sgR9_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.955368373 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cmany_closure" {
     GHC.Base.$fAlternativeIO_$cmany_closure:
         const GHC.Base.$fAlternativeIO_$cmany_info;
         const 0;
 },
 sat_sgRs_entry() //  [R1]
         { info_tbl: [(ci6q,
                       label: sat_sgRs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci6q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci6r; else goto ci6s;
       ci6r: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ci6s: // global
           I64[Sp - 16] = block_ci6l_info;
           _sgRj::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sgRj::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci6l() //  [R1]
         { info_tbl: [(ci6l,
                       label: block_ci6l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci6l: // global
           I64[Sp] = block_ci6n_info;
           _sgRn::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgRn::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci6n() //  [R1]
         { info_tbl: [(ci6n,
                       label: block_ci6n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci6n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci6w; else goto ci6v;
       ci6w: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci6v: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v_sgRj_entry() //  [R1]
         { info_tbl: [(ci6x,
                       label: many_v_sgRj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci6x: // global
           _sgRj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ci6y; else goto ci6z;
       ci6z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci6B; else goto ci6A;
       ci6B: // global
           HpAlloc = 24;
           goto ci6y;
       ci6y: // global
           R1 = _sgRj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci6A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgRj::P64;
           _sgRi::P64 = P64[_sgRj::P64 + 16];
           I64[Hp - 16] = sat_sgRs_info;
           P64[Hp - 8] = _sgRi::P64;
           P64[Hp] = _sgRj::P64;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = Hp - 15;
           R1 = GHC.IO.mplusIO_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeIO_$cmany_entry() //  [R2]
         { info_tbl: [(ci6C,
                       label: GHC.Base.$fAlternativeIO_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci6C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci6G; else goto ci6F;
       ci6G: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci6F: // global
           I64[Hp - 16] = many_v_sgRj_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.966816642 UTC

[section ""data" . GHC.Base.liftM9_closure" {
     GHC.Base.liftM9_closure:
         const GHC.Base.liftM9_info;
 },
 GHC.Base.liftM9_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ci7m,
                       label: GHC.Base.liftM9_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci7m: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci7n; else goto ci7o;
       ci7n: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM9_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ci7o: // global
           I64[Sp - 40] = block_ci7b_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci7b() //  [R1]
         { info_tbl: [(ci7b,
                       label: block_ci7b_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci7b: // global
           I64[Sp] = block_ci7d_info;
           _sgRC::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgRC::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci7d() //  [R1]
         { info_tbl: [(ci7d,
                       label: block_ci7d_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci7d: // global
           I64[Sp] = block_ci7f_info;
           _sgRF::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgRF::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci7f() //  [R1]
         { info_tbl: [(ci7f,
                       label: block_ci7f_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci7f: // global
           I64[Sp] = block_ci7h_info;
           _sgRI::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sgRI::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci7h() //  [R1]
         { info_tbl: [(ci7h,
                       label: block_ci7h_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci7h: // global
           I64[Sp] = block_ci7j_info;
           _sgRL::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _sgRL::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ci7j() //  [R1]
         { info_tbl: [(ci7j,
                       label: block_ci7j_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci7j: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ci7v; else goto ci7u;
       ci7v: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci7u: // global
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R1 = Hp - 56;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.979766315 UTC

[section ""data" . GHC.Base.liftM5_$sliftM1_closure" {
     GHC.Base.liftM5_$sliftM1_closure:
         const GHC.Base.liftM5_$sliftM1_info;
 },
 GHC.Base.liftM5_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ci86,
                       label: GHC.Base.liftM5_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci86: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM9_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:56.984330076 UTC

[section ""data" . GHC.Base.liftM5_closure" {
     GHC.Base.liftM5_closure:
         const GHC.Base.liftM5_info;
 },
 GHC.Base.liftM5_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci8e: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.liftM5_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2,
                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgS3_entry() //  [R1, R2]
         { info_tbl: [(ci8I,
                       label: sat_sgS3_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci8I: // global
           _sgS1::P64 = R2;
           _sgS3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ci8J; else goto ci8K;
       ci8K: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ci8M; else goto ci8L;
       ci8M: // global
           HpAlloc = 64;
           goto ci8J;
       ci8J: // global
           R2 = _sgS1::P64;
           R1 = _sgS3::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci8L: // global
           _sgRQ::P64 = P64[_sgS3::P64 + 7];
           _sgRR::P64 = P64[_sgS3::P64 + 15];
           _sgRX::P64 = P64[_sgS3::P64 + 23];
           _sgRY::P64 = P64[_sgS3::P64 + 31];
           _sgRZ::P64 = P64[_sgS3::P64 + 39];
           _sgS0::P64 = P64[_sgS3::P64 + 47];
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = _sgRR::P64;
           P64[Hp - 32] = _sgRX::P64;
           P64[Hp - 24] = _sgRY::P64;
           P64[Hp - 16] = _sgRZ::P64;
           P64[Hp - 8] = _sgS0::P64;
           P64[Hp] = _sgS1::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgS4_entry() //  [R1, R2]
         { info_tbl: [(ci8N,
                       label: sat_sgS4_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci8N: // global
           _sgS0::P64 = R2;
           _sgS4::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ci8O; else goto ci8P;
       ci8P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci8R; else goto ci8Q;
       ci8R: // global
           HpAlloc = 56;
           goto ci8O;
       ci8O: // global
           R2 = _sgS0::P64;
           R1 = _sgS4::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci8Q: // global
           _sgRQ::P64 = P64[_sgS4::P64 + 7];
           _sgRR::P64 = P64[_sgS4::P64 + 15];
           _sgRW::P64 = P64[_sgS4::P64 + 23];
           _sgRX::P64 = P64[_sgS4::P64 + 31];
           _sgRY::P64 = P64[_sgS4::P64 + 39];
           _sgRZ::P64 = P64[_sgS4::P64 + 47];
           I64[Hp - 48] = sat_sgS3_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRX::P64;
           P64[Hp - 16] = _sgRY::P64;
           P64[Hp - 8] = _sgRZ::P64;
           P64[Hp] = _sgS0::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgRW::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgS5_entry() //  [R1, R2]
         { info_tbl: [(ci8S,
                       label: sat_sgS5_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci8S: // global
           _sgRZ::P64 = R2;
           _sgS5::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ci8T; else goto ci8U;
       ci8U: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci8W; else goto ci8V;
       ci8W: // global
           HpAlloc = 56;
           goto ci8T;
       ci8T: // global
           R2 = _sgRZ::P64;
           R1 = _sgS5::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci8V: // global
           _sgRQ::P64 = P64[_sgS5::P64 + 7];
           _sgRR::P64 = P64[_sgS5::P64 + 15];
           _sgRV::P64 = P64[_sgS5::P64 + 23];
           _sgRW::P64 = P64[_sgS5::P64 + 31];
           _sgRX::P64 = P64[_sgS5::P64 + 39];
           _sgRY::P64 = P64[_sgS5::P64 + 47];
           I64[Hp - 48] = sat_sgS4_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRW::P64;
           P64[Hp - 16] = _sgRX::P64;
           P64[Hp - 8] = _sgRY::P64;
           P64[Hp] = _sgRZ::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgRV::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgS6_entry() //  [R1, R2]
         { info_tbl: [(ci8X,
                       label: sat_sgS6_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci8X: // global
           _sgRY::P64 = R2;
           _sgS6::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ci8Y; else goto ci8Z;
       ci8Z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci91; else goto ci90;
       ci91: // global
           HpAlloc = 56;
           goto ci8Y;
       ci8Y: // global
           R2 = _sgRY::P64;
           R1 = _sgS6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci90: // global
           _sgRQ::P64 = P64[_sgS6::P64 + 7];
           _sgRR::P64 = P64[_sgS6::P64 + 15];
           _sgRU::P64 = P64[_sgS6::P64 + 23];
           _sgRV::P64 = P64[_sgS6::P64 + 31];
           _sgRW::P64 = P64[_sgS6::P64 + 39];
           _sgRX::P64 = P64[_sgS6::P64 + 47];
           I64[Hp - 48] = sat_sgS5_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRV::P64;
           P64[Hp - 16] = _sgRW::P64;
           P64[Hp - 8] = _sgRX::P64;
           P64[Hp] = _sgRY::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgRU::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgS7_entry() //  [R1, R2]
         { info_tbl: [(ci92,
                       label: sat_sgS7_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci92: // global
           _sgRX::P64 = R2;
           _sgS7::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ci93; else goto ci94;
       ci94: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci96; else goto ci95;
       ci96: // global
           HpAlloc = 56;
           goto ci93;
       ci93: // global
           R2 = _sgRX::P64;
           R1 = _sgS7::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci95: // global
           _sgRQ::P64 = P64[_sgS7::P64 + 7];
           _sgRR::P64 = P64[_sgS7::P64 + 15];
           _sgRT::P64 = P64[_sgS7::P64 + 23];
           _sgRU::P64 = P64[_sgS7::P64 + 31];
           _sgRV::P64 = P64[_sgS7::P64 + 39];
           _sgRW::P64 = P64[_sgS7::P64 + 47];
           I64[Hp - 48] = sat_sgS6_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRU::P64;
           P64[Hp - 16] = _sgRV::P64;
           P64[Hp - 8] = _sgRW::P64;
           P64[Hp] = _sgRX::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgRT::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ci97,
                       label: GHC.Base.liftM5_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ci97: // global
           _sgRU::P64 = R6;
           _sgRT::P64 = R5;
           _sgRS::P64 = R4;
           _sgRR::P64 = R3;
           _sgRQ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ci98; else goto ci99;
       ci99: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci9b; else goto ci9a;
       ci9b: // global
           HpAlloc = 56;
           goto ci98;
       ci98: // global
           R1 = GHC.Base.liftM5_closure;
           P64[Sp - 40] = _sgRQ::P64;
           P64[Sp - 32] = _sgRR::P64;
           P64[Sp - 24] = _sgRS::P64;
           P64[Sp - 16] = _sgRT::P64;
           P64[Sp - 8] = _sgRU::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ci9a: // global
           I64[Hp - 48] = sat_sgS7_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRT::P64;
           P64[Hp - 16] = _sgRU::P64;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R2 = _sgRQ::P64;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _sgRS::P64;
           P64[Sp + 8] = Hp - 47;
           Sp = Sp - 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.00267811 UTC

[section ""data" . GHC.Base.liftM8_closure" {
     GHC.Base.liftM8_closure:
         const GHC.Base.liftM8_info;
 },
 GHC.Base.liftM8_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ciaa,
                       label: GHC.Base.liftM8_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciaa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciab; else goto ciac;
       ciab: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM8_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciac: // global
           I64[Sp - 40] = block_cia1_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cia1() //  [R1]
         { info_tbl: [(cia1,
                       label: block_cia1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cia1: // global
           I64[Sp] = block_cia3_info;
           _sgSg::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgSg::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cia3() //  [R1]
         { info_tbl: [(cia3,
                       label: block_cia3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cia3: // global
           I64[Sp] = block_cia5_info;
           _sgSj::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgSj::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cia5() //  [R1]
         { info_tbl: [(cia5,
                       label: block_cia5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cia5: // global
           I64[Sp] = block_cia7_info;
           _sgSm::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sgSm::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cia7() //  [R1]
         { info_tbl: [(cia7,
                       label: block_cia7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cia7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciai; else goto ciah;
       ciai: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciah: // global
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R1 = Hp - 48;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.013477263 UTC

[section ""data" . GHC.Base.liftM4_$sliftM1_closure" {
     GHC.Base.liftM4_$sliftM1_closure:
         const GHC.Base.liftM4_$sliftM1_info;
 },
 GHC.Base.liftM4_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ciaO,
                       label: GHC.Base.liftM4_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciaO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM8_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.017895504 UTC

[section ""data" . GHC.Base.liftM4_closure" {
     GHC.Base.liftM4_closure:
         const GHC.Base.liftM4_info;
 },
 sat_sgSC_entry() //  [R1, R2]
         { info_tbl: [(cibk,
                       label: sat_sgSC_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cibk: // global
           _sgSA::P64 = R2;
           _sgSC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cibl; else goto cibm;
       cibm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cibo; else goto cibn;
       cibo: // global
           HpAlloc = 56;
           goto cibl;
       cibl: // global
           R2 = _sgSA::P64;
           R1 = _sgSC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cibn: // global
           _sgSr::P64 = P64[_sgSC::P64 + 7];
           _sgSs::P64 = P64[_sgSC::P64 + 15];
           _sgSx::P64 = P64[_sgSC::P64 + 23];
           _sgSy::P64 = P64[_sgSC::P64 + 31];
           _sgSz::P64 = P64[_sgSC::P64 + 39];
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = _sgSs::P64;
           P64[Hp - 24] = _sgSx::P64;
           P64[Hp - 16] = _sgSy::P64;
           P64[Hp - 8] = _sgSz::P64;
           P64[Hp] = _sgSA::P64;
           R2 = _sgSr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgSD_entry() //  [R1, R2]
         { info_tbl: [(cibp,
                       label: sat_sgSD_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cibp: // global
           _sgSz::P64 = R2;
           _sgSD::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cibq; else goto cibr;
       cibr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cibt; else goto cibs;
       cibt: // global
           HpAlloc = 48;
           goto cibq;
       cibq: // global
           R2 = _sgSz::P64;
           R1 = _sgSD::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cibs: // global
           _sgSr::P64 = P64[_sgSD::P64 + 7];
           _sgSs::P64 = P64[_sgSD::P64 + 15];
           _sgSw::P64 = P64[_sgSD::P64 + 23];
           _sgSx::P64 = P64[_sgSD::P64 + 31];
           _sgSy::P64 = P64[_sgSD::P64 + 39];
           I64[Hp - 40] = sat_sgSC_info;
           P64[Hp - 32] = _sgSr::P64;
           P64[Hp - 24] = _sgSs::P64;
           P64[Hp - 16] = _sgSx::P64;
           P64[Hp - 8] = _sgSy::P64;
           P64[Hp] = _sgSz::P64;
           R2 = _sgSr::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSw::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgSE_entry() //  [R1, R2]
         { info_tbl: [(cibu,
                       label: sat_sgSE_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cibu: // global
           _sgSy::P64 = R2;
           _sgSE::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cibv; else goto cibw;
       cibw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ciby; else goto cibx;
       ciby: // global
           HpAlloc = 48;
           goto cibv;
       cibv: // global
           R2 = _sgSy::P64;
           R1 = _sgSE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cibx: // global
           _sgSr::P64 = P64[_sgSE::P64 + 7];
           _sgSs::P64 = P64[_sgSE::P64 + 15];
           _sgSv::P64 = P64[_sgSE::P64 + 23];
           _sgSw::P64 = P64[_sgSE::P64 + 31];
           _sgSx::P64 = P64[_sgSE::P64 + 39];
           I64[Hp - 40] = sat_sgSD_info;
           P64[Hp - 32] = _sgSr::P64;
           P64[Hp - 24] = _sgSs::P64;
           P64[Hp - 16] = _sgSw::P64;
           P64[Hp - 8] = _sgSx::P64;
           P64[Hp] = _sgSy::P64;
           R2 = _sgSr::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSv::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgSF_entry() //  [R1, R2]
         { info_tbl: [(cibz,
                       label: sat_sgSF_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cibz: // global
           _sgSx::P64 = R2;
           _sgSF::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cibA; else goto cibB;
       cibB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cibD; else goto cibC;
       cibD: // global
           HpAlloc = 48;
           goto cibA;
       cibA: // global
           R2 = _sgSx::P64;
           R1 = _sgSF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cibC: // global
           _sgSr::P64 = P64[_sgSF::P64 + 7];
           _sgSs::P64 = P64[_sgSF::P64 + 15];
           _sgSu::P64 = P64[_sgSF::P64 + 23];
           _sgSv::P64 = P64[_sgSF::P64 + 31];
           _sgSw::P64 = P64[_sgSF::P64 + 39];
           I64[Hp - 40] = sat_sgSE_info;
           P64[Hp - 32] = _sgSr::P64;
           P64[Hp - 24] = _sgSs::P64;
           P64[Hp - 16] = _sgSv::P64;
           P64[Hp - 8] = _sgSw::P64;
           P64[Hp] = _sgSx::P64;
           R2 = _sgSr::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSu::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM4_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cibE,
                       label: GHC.Base.liftM4_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cibE: // global
           _sgSv::P64 = R6;
           _sgSu::P64 = R5;
           _sgSt::P64 = R4;
           _sgSs::P64 = R3;
           _sgSr::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cibF; else goto cibG;
       cibG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cibI; else goto cibH;
       cibI: // global
           HpAlloc = 48;
           goto cibF;
       cibF: // global
           R6 = _sgSv::P64;
           R5 = _sgSu::P64;
           R4 = _sgSt::P64;
           R3 = _sgSs::P64;
           R2 = _sgSr::P64;
           R1 = GHC.Base.liftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cibH: // global
           I64[Hp - 40] = sat_sgSF_info;
           P64[Hp - 32] = _sgSr::P64;
           P64[Hp - 24] = _sgSs::P64;
           P64[Hp - 16] = _sgSu::P64;
           P64[Hp - 8] = _sgSv::P64;
           P64[Hp] = P64[Sp];
           R2 = _sgSr::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _sgSt::P64;
           P64[Sp] = Hp - 39;
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.031505465 UTC

[section ""data" . GHC.Base.liftM3_$sliftM1_closure" {
     GHC.Base.liftM3_$sliftM1_closure:
         const GHC.Base.liftM3_$sliftM1_info;
 },
 GHC.Base.liftM3_$sliftM1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cico,
                       label: GHC.Base.liftM3_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cico: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.035378831 UTC

[section ""data" . GHC.Base.liftM3_closure" {
     GHC.Base.liftM3_closure:
         const GHC.Base.liftM3_info;
 },
 sat_sgSP_entry() //  [R1, R2]
         { info_tbl: [(cicP,
                       label: sat_sgSP_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cicP: // global
           _sgSN::P64 = R2;
           _sgSP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cicQ; else goto cicR;
       cicR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cicT; else goto cicS;
       cicT: // global
           HpAlloc = 48;
           goto cicQ;
       cicQ: // global
           R2 = _sgSN::P64;
           R1 = _sgSP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cicS: // global
           _sgSG::P64 = P64[_sgSP::P64 + 7];
           _sgSH::P64 = P64[_sgSP::P64 + 15];
           _sgSL::P64 = P64[_sgSP::P64 + 23];
           _sgSM::P64 = P64[_sgSP::P64 + 31];
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = _sgSH::P64;
           P64[Hp - 16] = _sgSL::P64;
           P64[Hp - 8] = _sgSM::P64;
           P64[Hp] = _sgSN::P64;
           R2 = _sgSG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgSQ_entry() //  [R1, R2]
         { info_tbl: [(cicU,
                       label: sat_sgSQ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cicU: // global
           _sgSM::P64 = R2;
           _sgSQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cicV; else goto cicW;
       cicW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cicY; else goto cicX;
       cicY: // global
           HpAlloc = 40;
           goto cicV;
       cicV: // global
           R2 = _sgSM::P64;
           R1 = _sgSQ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cicX: // global
           _sgSG::P64 = P64[_sgSQ::P64 + 7];
           _sgSH::P64 = P64[_sgSQ::P64 + 15];
           _sgSK::P64 = P64[_sgSQ::P64 + 23];
           _sgSL::P64 = P64[_sgSQ::P64 + 31];
           I64[Hp - 32] = sat_sgSP_info;
           P64[Hp - 24] = _sgSG::P64;
           P64[Hp - 16] = _sgSH::P64;
           P64[Hp - 8] = _sgSL::P64;
           P64[Hp] = _sgSM::P64;
           R2 = _sgSG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSK::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sgSR_entry() //  [R1, R2]
         { info_tbl: [(cicZ,
                       label: sat_sgSR_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cicZ: // global
           _sgSL::P64 = R2;
           _sgSR::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cid0; else goto cid1;
       cid1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cid3; else goto cid2;
       cid3: // global
           HpAlloc = 40;
           goto cid0;
       cid0: // global
           R2 = _sgSL::P64;
           R1 = _sgSR::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cid2: // global
           _sgSG::P64 = P64[_sgSR::P64 + 7];
           _sgSH::P64 = P64[_sgSR::P64 + 15];
           _sgSJ::P64 = P64[_sgSR::P64 + 23];
           _sgSK::P64 = P64[_sgSR::P64 + 31];
           I64[Hp - 32] = sat_sgSQ_info;
           P64[Hp - 24] = _sgSG::P64;
           P64[Hp - 16] = _sgSH::P64;
           P64[Hp - 8] = _sgSK::P64;
           P64[Hp] = _sgSL::P64;
           R2 = _sgSG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSJ::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cid4,
                       label: GHC.Base.liftM3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cid4: // global
           _sgSK::P64 = R6;
           _sgSJ::P64 = R5;
           _sgSI::P64 = R4;
           _sgSH::P64 = R3;
           _sgSG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cid5; else goto cid6;
       cid6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cid8; else goto cid7;
       cid8: // global
           HpAlloc = 40;
           goto cid5;
       cid5: // global
           R6 = _sgSK::P64;
           R5 = _sgSJ::P64;
           R4 = _sgSI::P64;
           R3 = _sgSH::P64;
           R2 = _sgSG::P64;
           R1 = GHC.Base.liftM3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cid7: // global
           I64[Hp - 32] = sat_sgSR_info;
           P64[Hp - 24] = _sgSG::P64;
           P64[Hp - 16] = _sgSH::P64;
           P64[Hp - 8] = _sgSJ::P64;
           P64[Hp] = _sgSK::P64;
           R2 = _sgSG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSI::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.046694998 UTC

[section ""data" . GHC.Base.liftM_$sliftM1_closure" {
     GHC.Base.liftM_$sliftM1_closure:
         const GHC.Base.liftM_$sliftM1_info;
 },
 GHC.Base.liftM_$sliftM1_entry() //  [R2, R3]
         { info_tbl: [(cidG,
                       label: GHC.Base.liftM_$sliftM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cidG: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.050651325 UTC

[section ""data" . GHC.Base.liftM_closure" {
     GHC.Base.liftM_closure:
         const GHC.Base.liftM_info;
 },
 sat_sgSX_entry() //  [R1, R2]
         { info_tbl: [(cidX,
                       label: sat_sgSX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cidX: // global
           _sgSV::P64 = R2;
           _sgSX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cidY; else goto cidZ;
       cidZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cie1; else goto cie0;
       cie1: // global
           HpAlloc = 32;
           goto cidY;
       cidY: // global
           R2 = _sgSV::P64;
           R1 = _sgSX::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cie0: // global
           _sgSS::P64 = P64[_sgSX::P64 + 7];
           _sgST::P64 = P64[_sgSX::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgST::P64;
           P64[Hp] = _sgSV::P64;
           R2 = _sgSS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.liftM_entry() //  [R2, R3, R4]
         { info_tbl: [(cie2,
                       label: GHC.Base.liftM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cie2: // global
           _sgSU::P64 = R4;
           _sgST::P64 = R3;
           _sgSS::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cie3; else goto cie4;
       cie4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cie6; else goto cie5;
       cie6: // global
           HpAlloc = 24;
           goto cie3;
       cie3: // global
           R4 = _sgSU::P64;
           R3 = _sgST::P64;
           R2 = _sgSS::P64;
           R1 = GHC.Base.liftM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cie5: // global
           I64[Hp - 16] = sat_sgSX_info;
           P64[Hp - 8] = _sgSS::P64;
           P64[Hp] = _sgST::P64;
           R2 = _sgSS::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSU::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.057151016 UTC

[section ""data" . GHC.Base.$!_closure" {
     GHC.Base.$!_closure:
         const GHC.Base.$!_info;
 },
 GHC.Base.$!_entry() //  [R2, R3]
         { info_tbl: [(cies,
                       label: GHC.Base.$!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cies: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciet; else goto cieu;
       ciet: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cieu: // global
           I64[Sp - 16] = block_cieq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cieq() //  [R1]
         { info_tbl: [(cieq,
                       label: block_cieq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cieq: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.062258628 UTC

[section ""data" . GHC.Base.$_closure" {
     GHC.Base.$_closure:
         const GHC.Base.$_info;
 },
 GHC.Base.$_entry() //  [R2, R3]
         { info_tbl: [(cieJ,
                       label: GHC.Base.$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cieJ: // global
           _sgT1::P64 = R2;
           R2 = R3;
           R1 = _sgT1::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.06590004 UTC

[section ""data" . GHC.Base.flip_closure" {
     GHC.Base.flip_closure:
         const GHC.Base.flip_info;
 },
 GHC.Base.flip_entry() //  [R2, R3, R4]
         { info_tbl: [(cieU,
                       label: GHC.Base.flip_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cieU: // global
           R3 = R3;
           _sgT3::P64 = R2;
           R2 = R4;
           R1 = _sgT3::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.069147698 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>_closure" {
     GHC.Base.$fMonad(->)_$c>>_closure:
         const GHC.Base.$fMonad(->)_$c>>_info;
 },
 GHC.Base.$fMonad(->)_$c>>_entry() //  [R3, R4]
         { info_tbl: [(cif5,
                       label: GHC.Base.$fMonad(->)_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cif5: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.072304886 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*_closure" {
     GHC.Base.$fApplicative(->)_$c<*_closure:
         const GHC.Base.$fApplicative(->)_$c<*_info;
 },
 GHC.Base.$fApplicative(->)_$c<*_entry() //  [R2, R4]
         { info_tbl: [(cifg,
                       label: GHC.Base.$fApplicative(->)_$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cifg: // global
           _sgT9::P64 = R2;
           R2 = R4;
           R1 = _sgT9::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.076076177 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>_closure" {
     GHC.Base.$fMonad(,)_$c>>_closure:
         const GHC.Base.$fMonad(,)_$c>>_info;
 },
 sat_sgTm_entry() //  [R1]
         { info_tbl: [(cifH,
                       label: sat_sgTm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cifH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cifI; else goto cifJ;
       cifI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cifJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cifF_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cifF() //  [R1]
         { info_tbl: [(cifF,
                       label: block_cifF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cifF: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_$c>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cifN,
                       label: GHC.Base.$fMonad(,)_$c>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cifN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cifP; else goto cifQ;
       cifP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cifQ: // global
           I64[Sp - 24] = block_cifr_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uifW; else goto cifs;
       uifW: // global
           call _cifr(R1) args: 0, res: 0, upd: 0;
       cifs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cifr() //  [R1]
         { info_tbl: [(cifr,
                       label: block_cifr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cifr: // global
           I64[Sp] = block_cifw_info;
           _sgTg::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgTg::P64;
           if (R1 & 7 != 0) goto uifV; else goto cifx;
       uifV: // global
           call _cifw(R1) args: 0, res: 0, upd: 0;
       cifx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cifw() //  [R1]
         { info_tbl: [(cifw,
                       label: block_cifw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cifw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cifU; else goto cifT;
       cifU: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cifT: // global
           _sgTj::P64 = P64[R1 + 7];
           _sgTk::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sgTm_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgTj::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _sgTk::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.088961775 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*_closure" {
     GHC.Base.$fApplicative(,)_$c<*_closure:
         const GHC.Base.$fApplicative(,)_$c<*_info;
 },
 sat_sgTx_entry() //  [R1]
         { info_tbl: [(cigO,
                       label: sat_sgTx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cigO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cigP; else goto cigQ;
       cigP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cigQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cigM_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cigM() //  [R1]
         { info_tbl: [(cigM,
                       label: block_cigM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cigM: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c<*_entry() //  [R2, R3, R4]
         { info_tbl: [(cigU,
                       label: GHC.Base.$fApplicative(,)_$c<*_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cigU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cigW; else goto cigX;
       cigW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cigX: // global
           I64[Sp - 24] = block_cigy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uih3; else goto cigz;
       uih3: // global
           call _cigy(R1) args: 0, res: 0, upd: 0;
       cigz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cigy() //  [R1]
         { info_tbl: [(cigy,
                       label: block_cigy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cigy: // global
           I64[Sp - 8] = block_cigD_info;
           _sgTr::P64 = P64[R1 + 7];
           _sgTs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgTs::P64;
           P64[Sp + 16] = _sgTr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uih2; else goto cigE;
       uih2: // global
           call _cigD(R1) args: 0, res: 0, upd: 0;
       cigE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cigD() //  [R1]
         { info_tbl: [(cigD,
                       label: block_cigD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cigD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cih1; else goto cih0;
       cih1: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cih0: // global
           _sgTu::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_sgTx_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sgTu::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.100809332 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$c<$_closure" {
     GHC.Base.$fFunctor(,)_$c<$_closure:
         const GHC.Base.$fFunctor(,)_$c<$_info;
 },
 GHC.Base.$fFunctor(,)_$c<$_entry() //  [R2, R3]
         { info_tbl: [(cihJ,
                       label: GHC.Base.$fFunctor(,)_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cihJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cihN; else goto cihO;
       cihN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cihO: // global
           I64[Sp - 16] = block_cihG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uihS; else goto cihH;
       uihS: // global
           call _cihG(R1) args: 0, res: 0, upd: 0;
       cihH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cihG() //  [R1]
         { info_tbl: [(cihG,
                       label: block_cihG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cihG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cihR; else goto cihQ;
       cihR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cihQ: // global
           _sgTB::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sgTB::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.10721435 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_$c<$_closure" {
     GHC.Base.$fFunctorMaybe_$c<$_closure:
         const GHC.Base.$fFunctorMaybe_$c<$_info;
 },
 GHC.Base.$fFunctorMaybe_$c<$_entry() //  [R2, R3]
         { info_tbl: [(ciih,
                       label: GHC.Base.$fFunctorMaybe_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciih: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciii; else goto ciij;
       ciii: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorMaybe_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciij: // global
           I64[Sp - 16] = block_ciia_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiit; else goto ciib;
       uiit: // global
           call _ciia(R1) args: 0, res: 0, upd: 0;
       ciib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciia() //  [R1]
         { info_tbl: [(ciia,
                       label: block_ciia_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciia: // global
           if (R1 & 7 == 1) goto ciie; else goto ciif;
       ciie: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciif: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciis; else goto ciir;
       ciis: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciir: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.113505563 UTC

[section ""data" . GHC.Base.$dm<$_closure" {
     GHC.Base.$dm<$_closure:
         const GHC.Base.$dm<$_info;
 },
 sat_sgTK_entry() //  [R1]
         { info_tbl: [(ciiT,
                       label: sat_sgTK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciiT: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$dm<$_entry() //  [R2, R3]
         { info_tbl: [(ciiW,
                       label: GHC.Base.$dm<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciiW: // global
           _sgTI::P64 = R3;
           _sgTH::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ciiX; else goto ciiY;
       ciiY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cij0; else goto ciiZ;
       cij0: // global
           HpAlloc = 16;
           goto ciiX;
       ciiX: // global
           R3 = _sgTI::P64;
           R2 = _sgTH::P64;
           R1 = GHC.Base.$dm<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciiZ: // global
           I64[Hp - 8] = sat_sgTK_info;
           P64[Hp] = _sgTI::P64;
           R2 = _sgTH::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.119204557 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmappend_closure" {
     GHC.Base.$fMonoid(->)_$cmappend_closure:
         const GHC.Base.$fMonoid(->)_$cmappend_info;
 },
 GHC.Base.$fMonoid(->)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cijk,
                       label: GHC.Base.$fMonoid(->)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cijk: // global
           _sgTO::P64 = R5;
           _sgTN::P64 = R4;
           _sgTM::P64 = R3;
           _sgTL::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cijl; else goto cijm;
       cijm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cijo; else goto cijn;
       cijo: // global
           HpAlloc = 64;
           goto cijl;
       cijl: // global
           R5 = _sgTO::P64;
           R4 = _sgTN::P64;
           R3 = _sgTM::P64;
           R2 = _sgTL::P64;
           R1 = GHC.Base.$fMonoid(->)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cijn: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgTN::P64;
           P64[Hp - 32] = _sgTO::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgTM::P64;
           P64[Hp] = _sgTO::P64;
           I64[Sp - 24] = block_ciji_info;
           R2 = _sgTL::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ciji() //  [R1]
         { info_tbl: [(ciji,
                       label: block_ciji_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciji: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cijg::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cijg::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.126316501 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,)_$cmappend_info;
 },
 sat_sgU5_entry() //  [R1]
         { info_tbl: [(cik1,
                       label: sat_sgU5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cik1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cik2; else goto cik3;
       cik2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cik3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cijZ_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cijZ() //  [R1]
         { info_tbl: [(cijZ,
                       label: block_cijZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cijZ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sgU3_entry() //  [R1]
         { info_tbl: [(cikd,
                       label: sat_sgU3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cikd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cike; else goto cikf;
       cike: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cikf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cikb_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cikb() //  [R1]
         { info_tbl: [(cikb,
                       label: block_cikb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cikb: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cikj,
                       label: GHC.Base.$fMonoid(,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cikj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cikl; else goto cikm;
       cikl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cikm: // global
           I64[Sp - 32] = block_cijL_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiks; else goto cijM;
       uiks: // global
           call _cijL(R1) args: 0, res: 0, upd: 0;
       cijM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cijL() //  [R1]
         { info_tbl: [(cijL,
                       label: block_cijL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cijL: // global
           I64[Sp - 8] = block_cijQ_info;
           _sgTX::P64 = P64[R1 + 7];
           _sgTY::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sgTY::P64;
           P64[Sp + 24] = _sgTX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uikr; else goto cijR;
       uikr: // global
           call _cijQ(R1) args: 0, res: 0, upd: 0;
       cijR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cijQ() //  [R1]
         { info_tbl: [(cijQ,
                       label: block_cijQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cijQ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cikq; else goto cikp;
       cikq: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cikp: // global
           _sgU0::P64 = P64[R1 + 7];
           _sgU1::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgU5_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sgU1::P64;
           I64[Hp - 56] = sat_sgU3_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgU0::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.141332956 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_go_closure" {
     GHC.Base.$fSemigroupOrdering_go_closure:
         const GHC.Base.$fSemigroupOrdering_go_info;
 },
 GHC.Base.$fSemigroupOrdering_go_entry() //  [R2, R3]
         { info_tbl: [(cilr,
                       label: GHC.Base.$fSemigroupOrdering_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cilr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cils; else goto uilS;
       cils: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uilS: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cilh() args: 0, res: 0, upd: 0;
     }
 },
 _cilh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cilh: // global
           I64[Sp - 8] = block_cilk_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uilU; else goto cill;
       uilU: // global
           call _cilk(R1) args: 0, res: 0, upd: 0;
       cill: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cilk() //  [R1]
         { info_tbl: [(cilk,
                       label: block_cilk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cilk: // global
           _sgU6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cilo; else goto cilp;
       cilo: // global
           R1 = _sgU6::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cilp: // global
           I64[Sp] = block_cilz_info;
           _sgU9::P64 = P64[R1 + 6];
           _sgUa::P64 = P64[R1 + 14];
           R1 = _sgU6::P64;
           P64[Sp + 8] = _sgUa::P64;
           P64[Sp + 16] = _sgU9::P64;
           if (R1 & 7 != 0) goto uilV; else goto cilB;
       uilV: // global
           call _cilz(R1) args: 0, res: 0, upd: 0;
       cilB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cilz() //  [R1]
         { info_tbl: [(cilz,
                       label: block_cilz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cilz: // global
           _cilQ::P64 = R1 & 7;
           if (_cilQ::P64 < 3) goto uilR; else goto cilP;
       uilR: // global
           if (_cilQ::P64 < 2) goto cilH; else goto cilL;
       cilH: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cilL: // global
           _sgU7::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sgU7::P64;
           Sp = Sp + 8;
           call _cilh() args: 0, res: 0, upd: 0;
       cilP: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.150251922 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_$csconcat_closure" {
     GHC.Base.$fSemigroupOrdering_$csconcat_closure:
         const GHC.Base.$fSemigroupOrdering_$csconcat_info;
 },
 GHC.Base.$fSemigroupOrdering_$csconcat_entry() //  [R2]
         { info_tbl: [(cimw,
                       label: GHC.Base.$fSemigroupOrdering_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cimw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cimx; else goto cimy;
       cimx: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cimy: // global
           I64[Sp - 8] = block_cimt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uimC; else goto cimu;
       uimC: // global
           call _cimt(R1) args: 0, res: 0, upd: 0;
       cimu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cimt() //  [R1]
         { info_tbl: [(cimt,
                       label: block_cimt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cimt: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupOrdering_go_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.155823499 UTC

[section ""data" . GHC.Base.._closure" {
     GHC.Base.._closure:
         const GHC.Base.._info;
 },
 GHC.Base.._entry() //  [R2, R3, R4]
         { info_tbl: [(cimS,
                       label: GHC.Base.._info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cimS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cimW; else goto cimV;
       cimW: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cimV: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _sgUg::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgUg::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.160155815 UTC

[section ""data" . GHC.Base.mapFB_closure" {
     GHC.Base.mapFB_closure:
         const GHC.Base.mapFB_info;
 },
 GHC.Base.mapFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cin7,
                       label: GHC.Base.mapFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cin7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cinb; else goto cina;
       cinb: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cina: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _sgUk::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgUk::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.163963684 UTC

[section ""data" . GHC.Base.$fFunctor(->)_$c<$_closure" {
     GHC.Base.$fFunctor(->)_$c<$_closure:
         const GHC.Base.$fFunctor(->)_$c<$_info;
 },
 GHC.Base.$fFunctor(->)_$c<$_entry() //  [R2]
         { info_tbl: [(cinl,
                       label: GHC.Base.$fFunctor(->)_$c<$_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cinl: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.167117642 UTC

[section ""data" . GHC.Base.$fFunctor(->)_closure" {
     GHC.Base.$fFunctor(->)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.._closure+3;
         const GHC.Base.$fFunctor(->)_$c<$_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.168984728 UTC

[section ""data" . GHC.Base.const_closure" {
     GHC.Base.const_closure:
         const GHC.Base.const_info;
 },
 GHC.Base.const_entry() //  [R2]
         { info_tbl: [(cinx,
                       label: GHC.Base.const_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cinx: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.172151136 UTC

[section ""data" . GHC.Base.asTypeOf_closure" {
     GHC.Base.asTypeOf_closure:
         const GHC.Base.asTypeOf_info;
 },
 GHC.Base.asTypeOf_entry() //  [R2, R3]
         { info_tbl: [(cinI,
                       label: GHC.Base.asTypeOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cinI: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.175697765 UTC

[section ""data" . GHC.Base.$dm<*_closure" {
     GHC.Base.$dm<*_closure:
         const GHC.Base.$dm<*_info;
 },
 GHC.Base.$dm<*_entry() //  [R2]
         { info_tbl: [(cinT,
                       label: GHC.Base.$dm<*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cinT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cinU; else goto cinV;
       cinU: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cinV: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.const_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.179386485 UTC

[section ""data" . GHC.Base.$fApplicativeIO1_closure" {
     GHC.Base.$fApplicativeIO1_closure:
         const GHC.Base.$fApplicativeIO1_info;
 },
 GHC.Base.$fApplicativeIO1_entry() //  [R2, R3]
         { info_tbl: [(ciob,
                       label: GHC.Base.$fApplicativeIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciob: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cioc; else goto ciod;
       cioc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciod: // global
           I64[Sp - 16] = block_cio7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cio7() //  [R1]
         { info_tbl: [(cio7,
                       label: block_cio7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cio7: // global
           I64[Sp] = block_cio9_info;
           _sgUA::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgUA::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cio9() //  []
         { info_tbl: [(cio9,
                       label: block_cio9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cio9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.185963954 UTC

[section ""data" . GHC.Base.$fApplicativeIO_closure" {
     GHC.Base.$fApplicativeIO_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorIO_closure+1;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fApplicativeIO3_closure+3;
         const GHC.Base.$fApplicativeIO_$cliftA2_closure+4;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.187849501 UTC

[section ""data" . GHC.Base.breakpointCond_closure" {
     GHC.Base.breakpointCond_closure:
         const GHC.Base.breakpointCond_info;
 },
 GHC.Base.breakpointCond_entry() //  [R3]
         { info_tbl: [(cioz,
                       label: GHC.Base.breakpointCond_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cioz: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.191605874 UTC

[section ""data" . GHC.Base.breakpoint_closure" {
     GHC.Base.breakpoint_closure:
         const GHC.Base.breakpoint_info;
 },
 GHC.Base.breakpoint_entry() //  [R2]
         { info_tbl: [(cioK,
                       label: GHC.Base.breakpoint_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cioK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.194698482 UTC

[section ""data" . GHC.Base.assert_closure" {
     GHC.Base.assert_closure:
         const GHC.Base.assert_info;
 },
 GHC.Base.assert_entry() //  [R2, R3]
         { info_tbl: [(cioV,
                       label: GHC.Base.assert_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cioV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.breakpointCond_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.198371484 UTC

[section ""data" . GHC.Base.id_closure" {
     GHC.Base.id_closure:
         const GHC.Base.id_info;
 },
 GHC.Base.id_entry() //  [R2]
         { info_tbl: [(cip6,
                       label: GHC.Base.id_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cip6: // global
           R2 = R2;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.20147201 UTC

[section ""data" . GHC.Base.join_closure" {
     GHC.Base.join_closure:
         const GHC.Base.join_info;
 },
 GHC.Base.join_entry() //  [R2, R3]
         { info_tbl: [(ciph,
                       label: GHC.Base.join_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciph: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cipi; else goto cipj;
       cipi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.join_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cipj: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.205105522 UTC

[section ""data" . GHC.Base.$dm<*>_closure" {
     GHC.Base.$dm<*>_closure:
         const GHC.Base.$dm<*>_info;
 },
 GHC.Base.$dm<*>_entry() //  [R2]
         { info_tbl: [(cipv,
                       label: GHC.Base.$dm<*>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cipv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cipw; else goto cipx;
       cipw: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cipx: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.208864833 UTC

[section ""data" . GHC.Base.$dm*>_closure" {
     GHC.Base.$dm*>_closure:
         const GHC.Base.$dm*>_info;
 },
 sat_sgUO_entry() //  [R1]
         { info_tbl: [(cipP,
                       label: sat_sgUO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cipP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cipQ; else goto cipR;
       cipQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cipR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cipN_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cipN() //  [R1]
         { info_tbl: [(cipN,
                       label: block_cipN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cipN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 8;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dm*>_entry() //  [R2, R3, R4]
         { info_tbl: [(cipV,
                       label: GHC.Base.$dm*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cipV: // global
           _sgUM::P64 = R4;
           _sgUL::P64 = R3;
           _sgUK::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cipW; else goto cipX;
       cipX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cipZ; else goto cipY;
       cipZ: // global
           HpAlloc = 32;
           goto cipW;
       cipW: // global
           R4 = _sgUM::P64;
           R3 = _sgUL::P64;
           R2 = _sgUK::P64;
           R1 = GHC.Base.$dm*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cipY: // global
           I64[Hp - 24] = sat_sgUO_info;
           P64[Hp - 8] = _sgUK::P64;
           P64[Hp] = _sgUL::P64;
           R2 = _sgUK::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgUM::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.21652284 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c*>_closure" {
     GHC.Base.$fApplicative(->)_$c*>_closure:
         const GHC.Base.$fApplicative(->)_$c*>_info;
 },
 GHC.Base.$fApplicative(->)_$c*>_entry() //  [R3, R4]
         { info_tbl: [(ciqo,
                       label: GHC.Base.$fApplicative(->)_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciqo: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.219703328 UTC

[section ""data" . GHC.Base.maxInt_closure" {
     GHC.Base.maxInt_closure:
         const GHC.Types.I#_con_info;
         const 9223372036854775807;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.222189051 UTC

[section ""data" . GHC.Base.minInt_closure" {
     GHC.Base.minInt_closure:
         const GHC.Types.I#_con_info;
         const (-9223372036854775808);
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.22408833 UTC

[section ""data" . GHC.Base.ord_closure" {
     GHC.Base.ord_closure:
         const GHC.Base.ord_info;
 },
 GHC.Base.ord_entry() //  [R2]
         { info_tbl: [(ciqE,
                       label: GHC.Base.ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciqE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ciqL; else goto ciqM;
       ciqL: // global
           R2 = R2;
           R1 = GHC.Base.ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciqM: // global
           I64[Sp - 8] = block_ciqB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uiqQ; else goto ciqC;
       uiqQ: // global
           call _ciqB(R1) args: 0, res: 0, upd: 0;
       ciqC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciqB() //  [R1]
         { info_tbl: [(ciqB,
                       label: block_ciqB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciqB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciqP; else goto ciqO;
       ciqP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciqO: // global
           _sgUV::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgUV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.229999516 UTC

[section ""data" . GHC.Base.unsafeChr_closure" {
     GHC.Base.unsafeChr_closure:
         const GHC.Base.unsafeChr_info;
 },
 GHC.Base.unsafeChr_entry() //  [R2]
         { info_tbl: [(cira,
                       label: GHC.Base.unsafeChr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cira: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cirh; else goto ciri;
       cirh: // global
           R2 = R2;
           R1 = GHC.Base.unsafeChr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciri: // global
           I64[Sp - 8] = block_cir7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uirm; else goto cir8;
       uirm: // global
           call _cir7(R1) args: 0, res: 0, upd: 0;
       cir8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cir7() //  [R1]
         { info_tbl: [(cir7,
                       label: block_cir7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cir7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cirl; else goto cirk;
       cirl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cirk: // global
           _sgUZ::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sgUZ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.235828185 UTC

[section ""data" . GHC.Base.otherwise_closure" {
     GHC.Base.otherwise_closure:
         const GHC.Types.True_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.238049867 UTC

[section ""data" . GHC.Base.until_closure" {
     GHC.Base.until_closure:
         const GHC.Base.until_info;
 },
 GHC.Base.until_entry() //  [R2, R3, R4]
         { info_tbl: [(cirG,
                       label: GHC.Base.until_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cirG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cirH; else goto cirI;
       cirH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.until_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cirI: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cirK() args: 0, res: 0, upd: 0;
     }
 },
 _cirK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cirK: // global
           I64[Sp - 8] = block_cirM_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cirM() //  [R1]
         { info_tbl: [(cirM,
                       label: block_cirM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cirM: // global
           _sgV4::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cirQ; else goto cirZ;
       cirQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cirV; else goto cirU;
       cirV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cirU: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgV4::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call _cirK() args: 0, res: 0, upd: 0;
       cirZ: // global
           R1 = _sgV4::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.24516928 UTC

[section ""data" . GHC.Base.divModInt#_closure" {
     GHC.Base.divModInt#_closure:
         const GHC.Base.divModInt#_info;
 },
 GHC.Base.divModInt#_entry() //  [R2, R3]
         { info_tbl: [(cisv,
                       label: GHC.Base.divModInt#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cisv: // global
           if (%MO_S_Le_W64(R2, 0)) goto cist; else goto cisu;
       cist: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cisF; else goto cisP;
       cisF: // global
           _sgV8::I64 = R3;
           (_cisC::I64, _cisD::I64) = call MO_S_QuotRem W64(R2, _sgV8::I64);
           R2 = _cisD::I64;
           R1 = _cisC::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cisP: // global
           if (%MO_S_Le_W64(R3, 0)) goto cisN; else goto cisO;
       cisN: // global
           _sgV8::I64 = R3;
           (_cisK::I64, _cisL::I64) = call MO_S_QuotRem W64(R2, _sgV8::I64);
           R2 = _cisL::I64;
           R1 = _cisK::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cisO: // global
           _sgV8::I64 = R3;
           (_sgVe::I64, _sgVf::I64) = call MO_S_QuotRem W64(R2 + 1, _sgV8::I64);
           R2 = _sgVf::I64 + _sgV8::I64 - 1;
           R1 = _sgVe::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cisu: // global
           if (%MO_S_Ge_W64(R3, 0)) goto citc; else goto citd;
       citc: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cit0; else goto cita;
       cit0: // global
           _sgV8::I64 = R3;
           (_cisX::I64, _cisY::I64) = call MO_S_QuotRem W64(R2, _sgV8::I64);
           R2 = _cisY::I64;
           R1 = _cisX::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cita: // global
           if (%MO_S_Le_W64(R3, 0)) goto cit8; else goto cit9;
       cit8: // global
           _sgV8::I64 = R3;
           (_cit5::I64, _cit6::I64) = call MO_S_QuotRem W64(R2, _sgV8::I64);
           R2 = _cit6::I64;
           R1 = _cit5::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cit9: // global
           _sgV8::I64 = R3;
           (_sgVo::I64, _sgVp::I64) = call MO_S_QuotRem W64(R2 + 1, _sgV8::I64);
           R2 = _sgVp::I64 + _sgV8::I64 - 1;
           R1 = _sgVo::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       citd: // global
           _sgV8::I64 = R3;
           (_sgVv::I64, _sgVw::I64) = call MO_S_QuotRem W64(R2 - 1, _sgV8::I64);
           R2 = _sgVw::I64 + _sgV8::I64 + 1;
           R1 = _sgVv::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.251863067 UTC

[section ""data" . GHC.Base.divModInt_closure" {
     GHC.Base.divModInt_closure:
         const GHC.Base.divModInt_info;
 },
 GHC.Base.divModInt_entry() //  [R2, R3]
         { info_tbl: [(ciu9,
                       label: GHC.Base.divModInt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciu9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciud; else goto ciue;
       ciud: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divModInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciue: // global
           I64[Sp - 16] = block_ciu6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uivZ; else goto ciu7;
       uivZ: // global
           call _ciu6(R1) args: 0, res: 0, upd: 0;
       ciu7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciu6() //  [R1]
         { info_tbl: [(ciu6,
                       label: block_ciu6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciu6: // global
           I64[Sp] = block_ciuc_info;
           _sgVD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgVD::I64;
           if (R1 & 7 != 0) goto uivY; else goto ciug;
       uivY: // global
           call _ciuc(R1) args: 0, res: 0, upd: 0;
       ciug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciuc() //  [R1]
         { info_tbl: [(ciuc,
                       label: block_ciuc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciuc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cium; else goto ciul;
       cium: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciul: // global
           _sgVD::I64 = I64[Sp + 8];
           _sgVF::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sgVD::I64, 0)) goto civ0; else goto civX;
       civ0: // global
           if (%MO_S_Ge_W64(_sgVD::I64, 0)) goto ciux; else goto ciuY;
       ciux: // global
           (_sgVJ::I64, _sgVK::I64) = call MO_S_QuotRem W64(_sgVD::I64, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgVK::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgVJ::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciuY: // global
           if (%MO_S_Le_W64(_sgVF::I64, 0)) goto ciuG; else goto ciuX;
       ciuG: // global
           (_sgVP::I64, _sgVQ::I64) = call MO_S_QuotRem W64(_sgVD::I64, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgVQ::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgVP::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciuX: // global
           (_sgVV::I64, _sgVW::I64) = call MO_S_QuotRem W64(_sgVD::I64 + 1, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgVW::I64 + _sgVF::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgVV::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       civX: // global
           if (%MO_S_Ge_W64(_sgVF::I64, 0)) goto civF; else goto civW;
       civF: // global
           if (%MO_S_Ge_W64(_sgVD::I64, 0)) goto civc; else goto civD;
       civc: // global
           (_sgW5::I64, _sgW6::I64) = call MO_S_QuotRem W64(_sgVD::I64, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgW6::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgW5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       civD: // global
           if (%MO_S_Le_W64(_sgVF::I64, 0)) goto civl; else goto civC;
       civl: // global
           (_sgWb::I64, _sgWc::I64) = call MO_S_QuotRem W64(_sgVD::I64, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgWc::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgWb::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       civC: // global
           (_sgWh::I64, _sgWi::I64) = call MO_S_QuotRem W64(_sgVD::I64 + 1, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgWi::I64 + _sgVF::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgWh::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       civW: // global
           (_sgWq::I64, _sgWr::I64) = call MO_S_QuotRem W64(_sgVD::I64 - 1, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgWr::I64 + _sgVF::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgWq::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.264004954 UTC

[section ""data" . GHC.Base.shiftL#_closure" {
     GHC.Base.shiftL#_closure:
         const GHC.Base.shiftL#_info;
 },
 GHC.Base.shiftL#_entry() //  [R2, R3]
         { info_tbl: [(cixg,
                       label: GHC.Base.shiftL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cixg: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cixe; else goto cixf;
       cixe: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cixf: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.267791626 UTC

[section ""data" . GHC.Base.shiftRL#_closure" {
     GHC.Base.shiftRL#_closure:
         const GHC.Base.shiftRL#_info;
 },
 GHC.Base.shiftRL#_entry() //  [R2, R3]
         { info_tbl: [(cixB,
                       label: GHC.Base.shiftRL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cixB: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cixz; else goto cixA;
       cixz: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cixA: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.27136473 UTC

[section ""data" . GHC.Base.iShiftL#_closure" {
     GHC.Base.iShiftL#_closure:
         const GHC.Base.iShiftL#_info;
 },
 GHC.Base.iShiftL#_entry() //  [R2, R3]
         { info_tbl: [(cixW,
                       label: GHC.Base.iShiftL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cixW: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cixU; else goto cixV;
       cixU: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cixV: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.274869158 UTC

[section ""data" . GHC.Base.iShiftRA#_closure" {
     GHC.Base.iShiftRA#_closure:
         const GHC.Base.iShiftRA#_info;
 },
 GHC.Base.iShiftRA#_entry() //  [R2, R3]
         { info_tbl: [(ciyh,
                       label: GHC.Base.iShiftRA#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciyh: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ciyf; else goto ciyg;
       ciyf: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciyg: // global
           if (%MO_S_Ge_W64(R2, 0)) goto ciyq; else goto ciyr;
       ciyq: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciyr: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.278715636 UTC

[section ""data" . GHC.Base.iShiftRL#_closure" {
     GHC.Base.iShiftRL#_closure:
         const GHC.Base.iShiftRL#_info;
 },
 GHC.Base.iShiftRL#_entry() //  [R2, R3]
         { info_tbl: [(ciyJ,
                       label: GHC.Base.iShiftRL#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciyJ: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ciyH; else goto ciyI;
       ciyH: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciyI: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.282152037 UTC

[section ""data" . GHC.Base.build_closure" {
     GHC.Base.build_closure:
         const GHC.Base.build_info;
 },
 GHC.Base.build_entry() //  [R2]
         { info_tbl: [(ciyZ,
                       label: GHC.Base.build_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciyZ: // global
           R3 = GHC.Types.[]_closure+1;
           _sgWN::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _sgWN::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.285564611 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cpure_closure" {
     GHC.Base.$fApplicative[]_$cpure_closure:
         const GHC.Base.$fApplicative[]_$cpure_info;
 },
 GHC.Base.$fApplicative[]_$cpure_entry() //  [R2]
         { info_tbl: [(cizd,
                       label: GHC.Base.$fApplicative[]_$cpure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cizd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cizh; else goto cizg;
       cizh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cizg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.289127552 UTC

[section ""data" . GHC.Base.augment_closure" {
     GHC.Base.augment_closure:
         const GHC.Base.augment_info;
 },
 GHC.Base.augment_entry() //  [R2, R3]
         { info_tbl: [(cizu,
                       label: GHC.Base.augment_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cizu: // global
           R3 = R3;
           _sgWP::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _sgWP::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.294088518 UTC

[section ""data" . GHC.Base.++_closure" {
     GHC.Base.++_closure:
         const GHC.Base.++_info;
 },
 sat_sgWW_entry() //  [R1]
         { info_tbl: [(cizQ,
                       label: sat_sgWW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cizQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cizR; else goto cizS;
       cizR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cizS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.++_entry() //  [R2, R3]
         { info_tbl: [(cizX,
                       label: GHC.Base.++_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cizX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cizY; else goto cizZ;
       cizY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.++_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cizZ: // global
           I64[Sp - 16] = block_cizG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiA6; else goto cizH;
       uiA6: // global
           call _cizG(R1) args: 0, res: 0, upd: 0;
       cizH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cizG() //  [R1]
         { info_tbl: [(cizG,
                       label: block_cizG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cizG: // global
           _sgWS::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cizU; else goto cizV;
       cizU: // global
           R1 = _sgWS::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cizV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciA5; else goto ciA4;
       ciA5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciA4: // global
           _sgWU::P64 = P64[R1 + 6];
           _sgWV::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sgWW_info;
           P64[Hp - 32] = _sgWS::P64;
           P64[Hp - 24] = _sgWV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgWU::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.foldr_closure" {
     GHC.Base.foldr_closure:
         const GHC.Base.foldr_info;
 },
 go_sgX0_entry() //  [R1, R2]
         { info_tbl: [(ciAn,
                       label: go_sgX0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciAn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciAo; else goto ciAp;
       ciAo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciAp: // global
           I64[Sp - 32] = block_ciAg_info;
           _sgX0::P64 = R1;
           _sgWX::P64 = P64[R1 + 7];
           _sgWY::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sgWX::P64;
           P64[Sp - 16] = _sgWY::P64;
           P64[Sp - 8] = _sgX0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiAz; else goto ciAh;
       uiAz: // global
           call _ciAg(R1) args: 0, res: 0, upd: 0;
       ciAh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciAg() //  [R1]
         { info_tbl: [(ciAg,
                       label: block_ciAg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciAg: // global
           if (R1 & 7 == 1) goto ciAk; else goto ciAl;
       ciAk: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ciAl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciAy; else goto ciAx;
       ciAy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciAx: // global
           _sgX3::P64 = P64[R1 + 6];
           _sgX4::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sgX4::P64;
           R3 = Hp - 24;
           R2 = _sgX3::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.foldr_entry() //  [R2, R3, R4]
         { info_tbl: [(ciAA,
                       label: GHC.Base.foldr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciAA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciAE; else goto ciAD;
       ciAE: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.foldr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciAD: // global
           I64[Hp - 16] = go_sgX0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go_sgX0_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Base.map_closure" {
     GHC.Base.map_closure:
         const GHC.Base.map_info;
 },
 sat_sgXc_entry() //  [R1]
         { info_tbl: [(ciAT,
                       label: sat_sgXc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciAT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciAU; else goto ciAV;
       ciAU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciAV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.map_entry() //  [R2, R3]
         { info_tbl: [(ciB0,
                       label: GHC.Base.map_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciB0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciB1; else goto ciB2;
       ciB1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciB2: // global
           I64[Sp - 16] = block_ciAJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiBa; else goto ciAK;
       uiBa: // global
           call _ciAJ(R1) args: 0, res: 0, upd: 0;
       ciAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciAJ() //  [R1]
         { info_tbl: [(ciAJ,
                       label: block_ciAJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciAJ: // global
           if (R1 & 7 == 1) goto ciAX; else goto ciAY;
       ciAX: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciAY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ciB9; else goto ciB8;
       ciB9: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciB8: // global
           _sgX9::P64 = P64[R1 + 6];
           _sgXa::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sgXc_info;
           _sgX6::P64 = P64[Sp + 8];
           P64[Hp - 64] = _sgX6::P64;
           P64[Hp - 56] = _sgXa::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgX6::P64;
           P64[Hp - 24] = _sgX9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.316570964 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$c<>_closure" {
     GHC.Base.$fSemigroupNonEmpty_$c<>_closure:
         const GHC.Base.$fSemigroupNonEmpty_$c<>_info;
 },
 sat_sgXr_entry() //  [R1]
         { info_tbl: [(ciCv,
                       label: sat_sgXr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciCv: // global
           _sgXr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciCw; else goto ciCx;
       ciCx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ciCz; else goto ciCy;
       ciCz: // global
           HpAlloc = 72;
           goto ciCw;
       ciCw: // global
           R1 = _sgXr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciCy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgXr::P64;
           _sgXe::P64 = P64[_sgXr::P64 + 16];
           _sgXh::P64 = P64[_sgXr::P64 + 24];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sgXe::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sgXe::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _sgXh::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroupNonEmpty_$c<>_entry() //  [R2, R3]
         { info_tbl: [(ciCA,
                       label: GHC.Base.$fSemigroupNonEmpty_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciCA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciCC; else goto ciCD;
       ciCC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciCD: // global
           I64[Sp - 16] = block_ciCj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiCH; else goto ciCk;
       uiCH: // global
           call _ciCj(R1) args: 0, res: 0, upd: 0;
       ciCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciCj() //  [R1]
         { info_tbl: [(ciCj,
                       label: block_ciCj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciCj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciCG; else goto ciCF;
       ciCG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciCF: // global
           _sgXg::P64 = P64[R1 + 7];
           _sgXh::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_sgXr_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgXh::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sgXg::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.32592412 UTC

[section ""data" . GHC.Base.$wpoly_go_closure" {
     GHC.Base.$wpoly_go_closure:
         const GHC.Base.$wpoly_go_info;
 },
 ds_sgXy_entry() //  [R1]
         { info_tbl: [(ciDs,
                       label: ds_sgXy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciDs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciDy; else goto ciDz;
       ciDy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciDz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ciDp_info;
           _sgXx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sgXx::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiDE; else goto ciDq;
       uiDE: // global
           call _ciDp(R1) args: 0, res: 0, upd: 0;
       ciDq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ciDp() //  [R1]
         { info_tbl: [(ciDp,
                       label: block_ciDp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciDp: // global
           _sgXx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ciDv_info;
           R4 = _sgXx::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ciDv() //  [R1, R2]
         { info_tbl: [(ciDv,
                       label: block_ciDv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciDv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciDD; else goto ciDC;
       ciDD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ciDC: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgXO_entry() //  [R1]
         { info_tbl: [(ciDI,
                       label: sat_sgXO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciDI: // global
           _sgXO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciDJ; else goto ciDK;
       ciDK: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ciDM; else goto ciDL;
       ciDM: // global
           HpAlloc = 104;
           goto ciDJ;
       ciDJ: // global
           R1 = _sgXO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciDL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgXO::P64;
           _sgXt::P64 = P64[_sgXO::P64 + 16];
           _sgXw::P64 = P64[_sgXO::P64 + 24];
           _sgXx::P64 = P64[_sgXO::P64 + 32];
           I64[Hp - 96] = ds_sgXy_info;
           P64[Hp - 80] = _sgXw::P64;
           P64[Hp - 72] = _sgXx::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _ciDl::P64 = Hp - 96;
           P64[Hp - 48] = _ciDl::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _ciDl::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _sgXt::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$wpoly_go_entry() //  [R2, R3, R4]
         { info_tbl: [(ciDR,
                       label: GHC.Base.$wpoly_go_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciDR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciDS; else goto ciDT;
       ciDS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$wpoly_go_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciDT: // global
           I64[Sp - 24] = block_ciDb_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiDZ; else goto ciDc;
       uiDZ: // global
           call _ciDb(R1) args: 0, res: 0, upd: 0;
       ciDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciDb() //  [R1]
         { info_tbl: [(ciDb,
                       label: block_ciDb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciDb: // global
           _sgXs::P64 = P64[Sp + 8];
           _sgXt::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ciDO; else goto ciDP;
       ciDO: // global
           R2 = _sgXt::P64;
           R1 = _sgXs::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ciDP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ciDY; else goto ciDX;
       ciDY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciDX: // global
           _sgXw::P64 = P64[R1 + 6];
           _sgXx::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_sgXO_info;
           P64[Hp - 16] = _sgXt::P64;
           P64[Hp - 8] = _sgXw::P64;
           P64[Hp] = _sgXx::P64;
           R2 = Hp - 32;
           R1 = _sgXs::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.340866297 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty1_closure" {
     GHC.Base.$fSemigroupNonEmpty1_closure:
         const GHC.Base.$fSemigroupNonEmpty1_info;
 },
 GHC.Base.$fSemigroupNonEmpty1_entry() //  [R2, R3]
         { info_tbl: [(ciEN,
                       label: GHC.Base.$fSemigroupNonEmpty1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciEN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciET; else goto ciEU;
       ciET: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciEU: // global
           I64[Sp - 16] = block_ciEK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiEZ; else goto ciEL;
       uiEZ: // global
           call _ciEK(R1) args: 0, res: 0, upd: 0;
       ciEL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciEK() //  [R1]
         { info_tbl: [(ciEK,
                       label: block_ciEK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciEK: // global
           _sgXQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ciEQ_info;
           R4 = _sgXQ::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ciEQ() //  [R1, R2]
         { info_tbl: [(ciEQ,
                       label: block_ciEQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciEQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciEY; else goto ciEX;
       ciEY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ciEX: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.348605654 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$csconcat_closure" {
     GHC.Base.$fSemigroupNonEmpty_$csconcat_closure:
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_info;
 },
 GHC.Base.$fSemigroupNonEmpty_$csconcat_entry() //  [R2]
         { info_tbl: [(ciFn,
                       label: GHC.Base.$fSemigroupNonEmpty_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciFn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ciFo; else goto ciFp;
       ciFo: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciFp: // global
           I64[Sp - 8] = block_ciFk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uiFt; else goto ciFl;
       uiFt: // global
           call _ciFk(R1) args: 0, res: 0, upd: 0;
       ciFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciFk() //  [R1]
         { info_tbl: [(ciFk,
                       label: block_ciFk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciFk: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupNonEmpty1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.353931128 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_closure" {
     GHC.Base.$fSemigroupNonEmpty_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fSemigroupNonEmpty_$c<>_closure+2;
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_closure+1;
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupNonEmpty_$cstimes_closure" {
     GHC.Base.$fSemigroupNonEmpty_$cstimes_closure:
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupNonEmpty_$cstimes_entry() //  [R2]
         { info_tbl: [(ciFI,
                       label: GHC.Base.$fSemigroupNonEmpty_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciFI: // global
           R3 = GHC.Base.$fSemigroupNonEmpty_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.358837438 UTC

[section ""data" . GHC.Base.$fSemigroup[]1_closure" {
     GHC.Base.$fSemigroup[]1_closure:
         const GHC.Base.$fSemigroup[]1_info;
 },
 sat_sgY7_entry() //  [R1]
         { info_tbl: [(ciG4,
                       label: sat_sgY7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciG4: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup[]1_entry() //  [R2, R3]
         { info_tbl: [(ciGb,
                       label: GHC.Base.$fSemigroup[]1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciGb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciGc; else goto ciGd;
       ciGc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciGd: // global
           I64[Sp - 16] = block_ciFU_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiGj; else goto ciFV;
       uiGj: // global
           call _ciFU(R1) args: 0, res: 0, upd: 0;
       ciFV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciFU() //  [R1]
         { info_tbl: [(ciFU,
                       label: block_ciFU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciFU: // global
           _sgY2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ciG8; else goto ciG9;
       ciG8: // global
           R1 = _sgY2::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ciG9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciGi; else goto ciGh;
       ciGi: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciGh: // global
           _sgY5::P64 = P64[R1 + 6];
           _sgY6::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sgY7_info;
           P64[Hp - 8] = _sgY5::P64;
           P64[Hp] = _sgY6::P64;
           R3 = Hp - 24;
           R2 = _sgY2::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.36664454 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$csconcat_closure" {
     GHC.Base.$fSemigroup[]_$csconcat_closure:
         const GHC.Base.$fSemigroup[]_$csconcat_info;
 },
 GHC.Base.$fSemigroup[]_$csconcat_entry() //  [R2]
         { info_tbl: [(ciGJ,
                       label: GHC.Base.$fSemigroup[]_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciGJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ciGK; else goto ciGL;
       ciGK: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciGL: // global
           I64[Sp - 8] = block_ciGG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uiGP; else goto ciGH;
       uiGP: // global
           call _ciGG(R1) args: 0, res: 0, upd: 0;
       ciGH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciGG() //  [R1]
         { info_tbl: [(ciGG,
                       label: block_ciGG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciGG: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.372815975 UTC

[section ""data" . GHC.Base.mapM_closure" {
     GHC.Base.mapM_closure:
         const GHC.Base.mapM_info;
 },
 z_sgYf_entry() //  [R1]
         { info_tbl: [(ciH8,
                       label: z_sgYf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciH8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciH9; else goto ciHa;
       ciH9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciHa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sgYq_entry() //  [R1, R2]
         { info_tbl: [(ciHy,
                       label: sat_sgYq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciHy: // global
           _sgYo::P64 = R2;
           _sgYq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciHz; else goto ciHA;
       ciHA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciHC; else goto ciHB;
       ciHC: // global
           HpAlloc = 24;
           goto ciHz;
       ciHz: // global
           R2 = _sgYo::P64;
           R1 = _sgYq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciHB: // global
           _sgYc::P64 = P64[_sgYq::P64 + 7];
           _sgYn::P64 = P64[_sgYq::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgYn::P64;
           P64[Hp] = _sgYo::P64;
           R2 = _sgYc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgYr_entry() //  [R1, R2]
         { info_tbl: [(ciHD,
                       label: sat_sgYr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciHD: // global
           _sgYn::P64 = R2;
           _sgYr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ciHE; else goto ciHF;
       ciHF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciHH; else goto ciHG;
       ciHH: // global
           HpAlloc = 24;
           goto ciHE;
       ciHE: // global
           R2 = _sgYn::P64;
           R1 = _sgYr::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciHG: // global
           _sgYc::P64 = P64[_sgYr::P64 + 7];
           _sgYl::P64 = P64[_sgYr::P64 + 15];
           I64[Hp - 16] = sat_sgYq_info;
           P64[Hp - 8] = _sgYc::P64;
           P64[Hp] = _sgYn::P64;
           R2 = _sgYc::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgYl::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 go_sgYg_entry() //  [R1, R2]
         { info_tbl: [(ciHM,
                       label: go_sgYg_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciHM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciHN; else goto ciHO;
       ciHN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciHO: // global
           I64[Sp - 40] = block_ciHg_info;
           _sgYg::P64 = R1;
           _sgYc::P64 = P64[R1 + 7];
           _sgYd::P64 = P64[R1 + 15];
           _sgYf::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sgYc::P64;
           P64[Sp - 24] = _sgYd::P64;
           P64[Sp - 16] = _sgYf::P64;
           P64[Sp - 8] = _sgYg::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uiHV; else goto ciHh;
       uiHV: // global
           call _ciHg(R1) args: 0, res: 0, upd: 0;
       ciHh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciHg() //  [R1]
         { info_tbl: [(ciHg,
                       label: block_ciHg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciHg: // global
           if (R1 & 7 == 1) goto ciHJ; else goto ciHK;
       ciHJ: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ciHK: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ciHT; else goto ciHS;
       ciHT: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciHS: // global
           _sgYj::P64 = P64[R1 + 6];
           _sgYk::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _sgYk::P64;
           I64[Hp - 48] = sat_sgYr_info;
           _sgYc::P64 = P64[Sp + 8];
           P64[Hp - 40] = _sgYc::P64;
           P64[Hp - 32] = Hp - 80;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgYj::P64;
           R2 = _sgYc::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 47;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.mapM_entry() //  [R2, R3, R4]
         { info_tbl: [(ciHW,
                       label: GHC.Base.mapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciHW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciI0; else goto ciHZ;
       ciI0: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciHZ: // global
           I64[Hp - 48] = z_sgYf_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sgYg_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R2 = R4;
           R1 = Hp - 23;
           call go_sgYg_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.388428903 UTC

[section ""data" . GHC.Base.sequence_closure" {
     GHC.Base.sequence_closure:
         const GHC.Base.sequence_info;
 },
 GHC.Base.sequence_entry() //  [R2, R3]
         { info_tbl: [(ciIS,
                       label: GHC.Base.sequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciIS: // global
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call GHC.Base.mapM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.392404273 UTC

[section ""data" . GHC.Base.$dmmconcat_closure" {
     GHC.Base.$dmmconcat_closure:
         const GHC.Base.$dmmconcat_info;
 },
 z_sgYv_entry() //  [R1]
         { info_tbl: [(ciJ7,
                       label: z_sgYv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciJ7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciJ8; else goto ciJ9;
       ciJ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciJ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_sgYw_entry() //  [R1, R2]
         { info_tbl: [(ciJm,
                       label: go_sgYw_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciJm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciJn; else goto ciJo;
       ciJn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciJo: // global
           I64[Sp - 32] = block_ciJf_info;
           _sgYw::P64 = R1;
           _sgYt::P64 = P64[R1 + 7];
           _sgYv::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sgYt::P64;
           P64[Sp - 16] = _sgYv::P64;
           P64[Sp - 8] = _sgYw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiJy; else goto ciJg;
       uiJy: // global
           call _ciJf(R1) args: 0, res: 0, upd: 0;
       ciJg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciJf() //  [R1]
         { info_tbl: [(ciJf,
                       label: block_ciJf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciJf: // global
           if (R1 & 7 == 1) goto ciJj; else goto ciJk;
       ciJj: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ciJk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciJw; else goto ciJv;
       ciJw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciJv: // global
           _sgYz::P64 = P64[R1 + 6];
           _sgYA::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sgYA::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _sgYz::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$dmmconcat_entry() //  [R2, R3]
         { info_tbl: [(ciJz,
                       label: GHC.Base.$dmmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciJz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ciJD; else goto ciJC;
       ciJD: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciJC: // global
           I64[Hp - 40] = z_sgYv_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sgYw_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_sgYw_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.403048046 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmconcat_closure" {
     GHC.Base.$fMonoid(->)_$cmconcat_closure:
         const GHC.Base.$fMonoid(->)_$cmconcat_info;
 },
 lvl3_sgYF_entry() //  [R1]
         { info_tbl: [(ciKd,
                       label: lvl3_sgYF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciKd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciKe; else goto ciKf;
       ciKe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciKf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup_sgYG_entry() //  [R1]
         { info_tbl: [(ciKk,
                       label: $dSemigroup_sgYG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciKk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciKl; else goto ciKm;
       ciKl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciKm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_sgYH_entry() //  [R1, R2, R3]
         { info_tbl: [(ciKz,
                       label: go_sgYH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciKz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciKA; else goto ciKB;
       ciKA: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciKB: // global
           I64[Sp - 40] = block_ciKs_info;
           _sgYH::P64 = R1;
           _sgYF::P64 = P64[R1 + 6];
           _sgYG::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _sgYF::P64;
           P64[Sp - 24] = _sgYG::P64;
           P64[Sp - 16] = _sgYH::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uiKM; else goto ciKt;
       uiKM: // global
           call _ciKs(R1) args: 0, res: 0, upd: 0;
       ciKt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciKs() //  [R1]
         { info_tbl: [(ciKs,
                       label: block_ciKs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciKs: // global
           if (R1 & 7 == 1) goto ciKw; else goto ciKx;
       ciKw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ciKx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ciKJ; else goto ciKI;
       ciKJ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciKI: // global
           _sgYL::P64 = P64[R1 + 6];
           _sgYM::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = _sgYM::P64;
           _sgYJ::P64 = P64[Sp + 32];
           P64[Hp - 32] = _sgYJ::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgYL::P64;
           P64[Hp] = _sgYJ::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(->)_$cmconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(ciKN,
                       label: GHC.Base.$fMonoid(->)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciKN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ciKR; else goto ciKQ;
       ciKR: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciKQ: // global
           I64[Hp - 64] = lvl3_sgYF_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = $dSemigroup_sgYG_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sgYH_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           _sgYD::P64 = R3;
           R3 = R4;
           R2 = _sgYD::P64;
           R1 = Hp - 14;
           call go_sgYH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.416169337 UTC

[section ""data" . GHC.Base.$fMonoidIO1_closure" {
     GHC.Base.$fMonoidIO1_closure:
         const GHC.Base.$fMonoidIO1_info;
 },
 $dSemigroup_sgYS_entry() //  [R1]
         { info_tbl: [(ciLA,
                       label: $dSemigroup_sgYS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciLA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciLB; else goto ciLC;
       ciLB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciLC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl3_sgYT_entry() //  [R1]
         { info_tbl: [(ciLH,
                       label: lvl3_sgYT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciLH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciLI; else goto ciLJ;
       ciLI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciLJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgZ6_entry() //  [R1]
         { info_tbl: [(ciM3,
                       label: sat_sgZ6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciM3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciM4; else goto ciM5;
       ciM4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciM5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_sgYU_entry() //  [R1, R2]
         { info_tbl: [(ciMa,
                       label: go_sgYU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciMa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciMb; else goto ciMc;
       ciMb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciMc: // global
           I64[Sp - 32] = block_ciLP_info;
           _sgYU::P64 = R1;
           _sgYS::P64 = P64[R1 + 6];
           _sgYT::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sgYS::P64;
           P64[Sp - 16] = _sgYT::P64;
           P64[Sp - 8] = _sgYU::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiMk; else goto ciLQ;
       uiMk: // global
           call _ciLP(R1) args: 0, res: 0, upd: 0;
       ciLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciLP() //  [R1]
         { info_tbl: [(ciLP,
                       label: block_ciLP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciLP: // global
           if (R1 & 7 == 1) goto ciM7; else goto ciM8;
       ciM7: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciM8: // global
           I64[Sp] = block_ciLV_info;
           _sgYZ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sgYZ::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciLV() //  [R1]
         { info_tbl: [(ciLV,
                       label: block_ciLV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciLV: // global
           I64[Sp] = block_ciLX_info;
           R2 = P64[Sp + 16];
           _sgZ2::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgZ2::P64;
           call go_sgYU_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciLX() //  [R1]
         { info_tbl: [(ciLX,
                       label: block_ciLX_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciLX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ciMj; else goto ciMi;
       ciMj: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciMi: // global
           I64[Hp - 32] = sat_sgZ6_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoidIO1_entry() //  [R2, R3]
         { info_tbl: [(ciMl,
                       label: GHC.Base.$fMonoidIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciMl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ciMp; else goto ciMo;
       ciMp: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciMo: // global
           I64[Hp - 64] = $dSemigroup_sgYS_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl3_sgYT_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sgYU_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 14;
           call go_sgYU_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.434489897 UTC

[section ""data" . GHC.Base.$fMonoidIO_closure" {
     GHC.Base.$fMonoidIO_closure:
         const GHC.Base.$fMonoidIO_info;
         const 0;
 },
 sat_sgZd_entry() //  [R1, R2]
         { info_tbl: [(ciNo,
                       label: sat_sgZd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciNo: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgZc_entry() //  [R1, R2, R3]
         { info_tbl: [(ciNw,
                       label: sat_sgZc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciNw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoidIO_$cmappend_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgZa_entry() //  [R1]
         { info_tbl: [(ciNI,
                       label: sat_sgZa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciNI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciNJ; else goto ciNK;
       ciNJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciNK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sgZb_entry() //  [R1]
         { info_tbl: [(ciNL,
                       label: sat_sgZb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciNL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciNP; else goto ciNO;
       ciNP: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ciNO: // global
           _sgZ7::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sgZa_info;
           P64[Hp] = _sgZ7::P64;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgZ8_entry() //  [R1]
         { info_tbl: [(ciNU,
                       label: sat_sgZ8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciNU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciNV; else goto ciNW;
       ciNV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciNW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoidIO_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidIO_entry() //  [R2]
         { info_tbl: [(ciNY,
                       label: GHC.Base.$fMonoidIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciNY: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ciO2; else goto ciO1;
       ciO2: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciO1: // global
           I64[Hp - 104] = sat_sgZd_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgZc_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgZb_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgZ8_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.447346937 UTC

[section ""data" . GHC.Base.$fFunctor[]_$c<$_closure" {
     GHC.Base.$fFunctor[]_$c<$_closure:
         const GHC.Base.$fFunctor[]_$c<$_info;
 },
 sat_sgZh_entry() //  [R1]
         { info_tbl: [(ciOL,
                       label: sat_sgZh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciOL: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fFunctor[]_$c<$_entry() //  [R2, R3]
         { info_tbl: [(ciOO,
                       label: GHC.Base.$fFunctor[]_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciOO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciOS; else goto ciOR;
       ciOS: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor[]_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciOR: // global
           I64[Hp - 8] = sat_sgZh_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.453131259 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$c<$_closure" {
     GHC.Base.$fFunctorNonEmpty_$c<$_closure:
         const GHC.Base.$fFunctorNonEmpty_$c<$_info;
 },
 sat_sgZo_entry() //  [R1]
         { info_tbl: [(ciPj,
                       label: sat_sgZo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciPj: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sgZp_entry() //  [R1]
         { info_tbl: [(ciPm,
                       label: sat_sgZp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciPm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciPn; else goto ciPo;
       ciPn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciPo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ciP9_info;
           _sgZi::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sgZi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiPs; else goto ciPa;
       uiPs: // global
           call _ciP9(R1) args: 0, res: 0, upd: 0;
       ciPa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ciP9() //  [R1]
         { info_tbl: [(ciP9,
                       label: block_ciP9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciP9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciPr; else goto ciPq;
       ciPr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ciPq: // global
           _sgZm::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sgZo_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _sgZm::P64;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fFunctorNonEmpty_$c<$_entry() //  [R2, R3]
         { info_tbl: [(ciPu,
                       label: GHC.Base.$fFunctorNonEmpty_$c<$_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciPu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciPy; else goto ciPx;
       ciPy: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciPx: // global
           I64[Hp - 48] = sat_sgZp_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.463258248 UTC

[section ""data" . GHC.Base.$fFunctor[]_closure" {
     GHC.Base.$fFunctor[]_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.46588414 UTC

[section ""data" . GHC.Base.$fMonad[]_$c>>=_closure" {
     GHC.Base.$fMonad[]_$c>>=_closure:
         const GHC.Base.$fMonad[]_$c>>=_info;
 },
 sat_sgZy_entry() //  [R1]
         { info_tbl: [(ciQg,
                       label: sat_sgZy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciQg: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sgZs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sgZs_entry() //  [R1, R2]
         { info_tbl: [(ciQn,
                       label: go_sgZs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciQn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciQo; else goto ciQp;
       ciQo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciQp: // global
           I64[Sp - 24] = block_ciQ6_info;
           _sgZs::P64 = R1;
           _sgZr::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sgZr::P64;
           P64[Sp - 8] = _sgZs::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiQA; else goto ciQ7;
       uiQA: // global
           call _ciQ6(R1) args: 0, res: 0, upd: 0;
       ciQ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciQ6() //  [R1]
         { info_tbl: [(ciQ6,
                       label: block_ciQ6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciQ6: // global
           if (R1 & 7 == 1) goto ciQk; else goto ciQl;
       ciQk: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciQl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciQv; else goto ciQu;
       ciQv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciQu: // global
           _sgZv::P64 = P64[R1 + 6];
           _sgZw::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sgZy_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgZw::P64;
           _sgZr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ciQs_info;
           R2 = _sgZv::P64;
           R1 = _sgZr::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciQs() //  [R1]
         { info_tbl: [(ciQs,
                       label: block_ciQs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciQs: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonad[]_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(ciQB,
                       label: GHC.Base.$fMonad[]_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciQB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciQF; else goto ciQE;
       ciQF: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad[]_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciQE: // global
           I64[Hp - 8] = go_sgZs_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgZs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.47717766 UTC

[section ""data" . GHC.Base.=<<_$s=<<_closure" {
     GHC.Base.=<<_$s=<<_closure:
         const GHC.Base.=<<_$s=<<_info;
 },
 GHC.Base.=<<_$s=<<_entry() //  [R2, R3]
         { info_tbl: [(ciRc,
                       label: GHC.Base.=<<_$s=<<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciRc: // global
           _sgZA::P64 = R3;
           R3 = R2;
           R2 = _sgZA::P64;
           call GHC.Base.$fMonad[]_$c>>=_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.480570731 UTC

[section ""data" . GHC.Base.=<<_closure" {
     GHC.Base.=<<_closure:
         const GHC.Base.=<<_info;
 },
 GHC.Base.=<<_entry() //  [R2, R3, R4]
         { info_tbl: [(ciRn,
                       label: GHC.Base.=<<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciRn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciRo; else goto ciRp;
       ciRo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.=<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciRp: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.484642891 UTC

[section ""data" . poly_go_r7PI_closure" {
     poly_go_r7PI_closure:
         const poly_go_r7PI_info;
 },
 sat_sgZI_entry() //  [R1]
         { info_tbl: [(ciRK,
                       label: sat_sgZI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciRK: // global
           R2 = P64[R1 + 16];
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 poly_go_r7PI_entry() //  [R2]
         { info_tbl: [(ciRR,
                       label: poly_go_r7PI_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciRR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ciRS; else goto ciRT;
       ciRS: // global
           R2 = R2;
           R1 = poly_go_r7PI_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciRT: // global
           I64[Sp - 8] = block_ciRA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uiRZ; else goto ciRB;
       uiRZ: // global
           call _ciRA(R1) args: 0, res: 0, upd: 0;
       ciRB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciRA() //  [R1]
         { info_tbl: [(ciRA,
                       label: block_ciRA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciRA: // global
           if (R1 & 7 == 1) goto ciRO; else goto ciRP;
       ciRO: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciRP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciRY; else goto ciRX;
       ciRY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciRX: // global
           _sgZG::P64 = P64[R1 + 6];
           _sgZH::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sgZI_info;
           P64[Hp] = _sgZH::P64;
           R3 = Hp - 16;
           R2 = _sgZG::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.492475296 UTC

[section ""data" . GHC.Base.$fMonoid[]_$cmconcat_closure" {
     GHC.Base.$fMonoid[]_$cmconcat_closure:
         const GHC.Base.$fMonoid[]_$cmconcat_info;
 },
 GHC.Base.$fMonoid[]_$cmconcat_entry() //  [R2]
         { info_tbl: [(ciSm,
                       label: GHC.Base.$fMonoid[]_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciSm: // global
           R2 = R2;
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.496567335 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*>_closure" {
     GHC.Base.$fApplicative[]_$c<*>_closure:
         const GHC.Base.$fApplicative[]_$c<*>_info;
 },
 go1_sgZS_entry() //  [R1, R2]
         { info_tbl: [(ciSV,
                       label: go1_sgZS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciSV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciSW; else goto ciSX;
       ciSW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciSX: // global
           I64[Sp - 32] = block_ciSO_info;
           _sgZS::P64 = R1;
           _sgZP::P64 = P64[R1 + 7];
           _sgZR::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sgZP::P64;
           P64[Sp - 16] = _sgZR::P64;
           P64[Sp - 8] = _sgZS::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiT9; else goto ciSP;
       uiT9: // global
           call _ciSO(R1) args: 0, res: 0, upd: 0;
       ciSP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciSO() //  [R1]
         { info_tbl: [(ciSO,
                       label: block_ciSO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciSO: // global
           if (R1 & 7 == 1) goto ciSS; else goto ciST;
       ciSS: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ciST: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ciT8; else goto ciT7;
       ciT8: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciT7: // global
           _sgZV::P64 = P64[R1 + 6];
           _sgZW::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = _sgZW::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgZV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sgZM_entry() //  [R1, R2]
         { info_tbl: [(ciTe,
                       label: go_sgZM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciTe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciTf; else goto ciTg;
       ciTf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciTg: // global
           I64[Sp - 24] = block_ciSC_info;
           _sgZM::P64 = R1;
           _sgZL::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sgZL::P64;
           P64[Sp - 8] = _sgZM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiTm; else goto ciSD;
       uiTm: // global
           call _ciSC(R1) args: 0, res: 0, upd: 0;
       ciSD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciSC() //  [R1]
         { info_tbl: [(ciSC,
                       label: block_ciSC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciSC: // global
           if (R1 & 7 == 1) goto ciTb; else goto ciTc;
       ciTb: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciTc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciTl; else goto ciTk;
       ciTl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciTk: // global
           _sgZP::P64 = P64[R1 + 6];
           _sgZQ::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgZQ::P64;
           I64[Hp - 16] = go1_sgZS_info;
           P64[Hp - 8] = _sgZP::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_sgZS_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(ciTn,
                       label: GHC.Base.$fApplicative[]_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciTn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciTr; else goto ciTq;
       ciTr: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciTq: // global
           I64[Hp - 8] = go_sgZM_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgZM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.510075436 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cliftA2_closure" {
     GHC.Base.$fApplicative[]_$cliftA2_closure:
         const GHC.Base.$fApplicative[]_$cliftA2_info;
 },
 go1_sh08_entry() //  [R1, R2]
         { info_tbl: [(ciUB,
                       label: go1_sh08_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciUB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciUC; else goto ciUD;
       ciUC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciUD: // global
           I64[Sp - 40] = block_ciUu_info;
           _sh08::P64 = R1;
           _sgZZ::P64 = P64[R1 + 7];
           _sh05::P64 = P64[R1 + 15];
           _sh07::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sgZZ::P64;
           P64[Sp - 24] = _sh05::P64;
           P64[Sp - 16] = _sh07::P64;
           P64[Sp - 8] = _sh08::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uiUP; else goto ciUv;
       uiUP: // global
           call _ciUu(R1) args: 0, res: 0, upd: 0;
       ciUv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciUu() //  [R1]
         { info_tbl: [(ciUu,
                       label: block_ciUu_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciUu: // global
           if (R1 & 7 == 1) goto ciUy; else goto ciUz;
       ciUy: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ciUz: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ciUO; else goto ciUN;
       ciUO: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciUN: // global
           _sh0b::P64 = P64[R1 + 6];
           _sh0c::P64 = P64[R1 + 14];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = _sh0c::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh0b::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sh02_entry() //  [R1, R2]
         { info_tbl: [(ciUU,
                       label: go_sh02_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciUU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciUV; else goto ciUW;
       ciUV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciUW: // global
           I64[Sp - 32] = block_ciUi_info;
           _sh02::P64 = R1;
           _sgZZ::P64 = P64[R1 + 7];
           _sh01::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sgZZ::P64;
           P64[Sp - 16] = _sh01::P64;
           P64[Sp - 8] = _sh02::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiV2; else goto ciUj;
       uiV2: // global
           call _ciUi(R1) args: 0, res: 0, upd: 0;
       ciUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciUi() //  [R1]
         { info_tbl: [(ciUi,
                       label: block_ciUi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciUi: // global
           if (R1 & 7 == 1) goto ciUR; else goto ciUS;
       ciUR: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciUS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ciV1; else goto ciV0;
       ciV1: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciV0: // global
           _sh05::P64 = P64[R1 + 6];
           _sh06::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _sh06::P64;
           I64[Hp - 24] = go1_sh08_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sh05::P64;
           P64[Hp] = Hp - 56;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call go1_sh08_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(ciV3,
                       label: GHC.Base.$fApplicative[]_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciV3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciV7; else goto ciV6;
       ciV7: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciV6: // global
           I64[Hp - 16] = go_sh02_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = R3;
           R1 = Hp - 15;
           call go_sh02_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.523357825 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*_closure" {
     GHC.Base.$fApplicative[]_$c<*_closure:
         const GHC.Base.$fApplicative[]_$c<*_info;
 },
 GHC.Base.$fApplicative[]_$c<*_entry() //  [R2, R3]
         { info_tbl: [(ciVV,
                       label: GHC.Base.$fApplicative[]_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciVV: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.const_closure+2;
           call GHC.Base.$fApplicative[]_$cliftA2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.527357693 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c*>_closure" {
     GHC.Base.$fApplicative[]_$c*>_closure:
         const GHC.Base.$fApplicative[]_$c*>_info;
 },
 sat_sh0m_entry() //  [R1]
         { info_tbl: [(ciWl,
                       label: sat_sh0m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciWl: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sh0h_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sh0h_entry() //  [R1, R2]
         { info_tbl: [(ciWs,
                       label: go_sh0h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciWs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciWt; else goto ciWu;
       ciWt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciWu: // global
           I64[Sp - 24] = block_ciWb_info;
           _sh0h::P64 = R1;
           _sh0g::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sh0g::P64;
           P64[Sp - 8] = _sh0h::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiWA; else goto ciWc;
       uiWA: // global
           call _ciWb(R1) args: 0, res: 0, upd: 0;
       ciWc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciWb() //  [R1]
         { info_tbl: [(ciWb,
                       label: block_ciWb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciWb: // global
           if (R1 & 7 == 1) goto ciWp; else goto ciWq;
       ciWp: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciWq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciWz; else goto ciWy;
       ciWz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciWy: // global
           _sh0l::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sh0m_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sh0l::P64;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative[]_$c*>_entry() //  [R2, R3]
         { info_tbl: [(ciWB,
                       label: GHC.Base.$fApplicative[]_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciWB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciWF; else goto ciWE;
       ciWF: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciWE: // global
           I64[Hp - 8] = go_sh0h_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sh0h_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.537504134 UTC

[section ""data" . GHC.Base.$fApplicative[]_closure" {
     GHC.Base.$fApplicative[]_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor[]_closure+1;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fApplicative[]_$c<*>_closure+2;
         const GHC.Base.$fApplicative[]_$cliftA2_closure+3;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.540002266 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$cfmap_closure" {
     GHC.Base.$fFunctorNonEmpty_$cfmap_closure:
         const GHC.Base.$fFunctorNonEmpty_$cfmap_info;
 },
 sat_sh0x_entry() //  [R1]
         { info_tbl: [(ciXf,
                       label: sat_sh0x_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciXf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciXg; else goto ciXh;
       ciXg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciXh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ciXc_info;
           _sh0n::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sh0n::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiXl; else goto ciXd;
       uiXl: // global
           call _ciXc(R1) args: 0, res: 0, upd: 0;
       ciXd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ciXc() //  [R1]
         { info_tbl: [(ciXc,
                       label: block_ciXc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciXc: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh0t_entry() //  [R1]
         { info_tbl: [(ciXr,
                       label: sat_sh0t_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciXr: // global
           _sh0t::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciXs; else goto ciXt;
       ciXt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciXv; else goto ciXu;
       ciXv: // global
           HpAlloc = 24;
           goto ciXs;
       ciXs: // global
           R1 = _sh0t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciXu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh0t::P64;
           _sh0n::P64 = P64[_sh0t::P64 + 16];
           _sh0o::P64 = P64[_sh0t::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sh0o::P64;
           R2 = Hp - 16;
           R1 = _sh0n::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fFunctorNonEmpty_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(ciXx,
                       label: GHC.Base.$fFunctorNonEmpty_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciXx: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ciXB; else goto ciXA;
       ciXB: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciXA: // global
           I64[Hp - 80] = sat_sh0x_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sh0t_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.549711673 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_closure" {
     GHC.Base.$fFunctorNonEmpty_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorNonEmpty_$cfmap_closure+2;
         const GHC.Base.$fFunctorNonEmpty_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.551357516 UTC

[section ""data" . GHC.Base.$fAlternative[]1_closure" {
     GHC.Base.$fAlternative[]1_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.554448999 UTC

[section ""data" . GHC.Base.$fAlternative[]_$csome_closure" {
     GHC.Base.$fAlternative[]_$csome_closure:
         const GHC.Base.$fAlternative[]_$csome_info;
 },
 ys_sh0A_entry() //  [R1]
         { info_tbl: [(ciYg,
                       label: ys_sh0A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciYh; else goto ciYi;
       ciYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 go1_sh0H_entry() //  [R1, R2]
         { info_tbl: [(ciYH,
                       label: go1_sh0H_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciYH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciYI; else goto ciYJ;
       ciYI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciYJ: // global
           I64[Sp - 32] = block_ciYA_info;
           _sh0H::P64 = R1;
           _sh0E::P64 = P64[R1 + 7];
           _sh0G::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sh0E::P64;
           P64[Sp - 16] = _sh0G::P64;
           P64[Sp - 8] = _sh0H::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiYV; else goto ciYB;
       uiYV: // global
           call _ciYA(R1) args: 0, res: 0, upd: 0;
       ciYB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciYA() //  [R1]
         { info_tbl: [(ciYA,
                       label: block_ciYA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciYA: // global
           if (R1 & 7 == 1) goto ciYE; else goto ciYF;
       ciYE: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ciYF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ciYU; else goto ciYT;
       ciYU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciYT: // global
           _sh0K::P64 = P64[R1 + 6];
           _sh0L::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sh0L::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sh0K::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sh0B_entry() //  [R1, R2]
         { info_tbl: [(ciZ0,
                       label: go_sh0B_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciZ0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciZ1; else goto ciZ2;
       ciZ1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciZ2: // global
           I64[Sp - 24] = block_ciYo_info;
           _sh0B::P64 = R1;
           _sh0A::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sh0A::P64;
           P64[Sp - 8] = _sh0B::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiZ8; else goto ciYp;
       uiZ8: // global
           call _ciYo(R1) args: 0, res: 0, upd: 0;
       ciYp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ciYo() //  [R1]
         { info_tbl: [(ciYo,
                       label: block_ciYo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciYo: // global
           if (R1 & 7 == 1) goto ciYX; else goto ciYY;
       ciYX: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciYY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciZ7; else goto ciZ6;
       ciZ7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciZ6: // global
           _sh0E::P64 = P64[R1 + 6];
           _sh0F::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh0F::P64;
           I64[Hp - 16] = go1_sh0H_info;
           P64[Hp - 8] = _sh0E::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_sh0H_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 some_v_sh0z_entry() //  [R1]
         { info_tbl: [(ciZ9,
                       label: some_v_sh0z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciZ9: // global
           _sh0z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciZa; else goto ciZb;
       ciZb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ciZd; else goto ciZc;
       ciZd: // global
           HpAlloc = 40;
           goto ciZa;
       ciZa: // global
           R1 = _sh0z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciZc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh0z::P64;
           _sh0y::P64 = P64[_sh0z::P64 + 16];
           I64[Hp - 32] = ys_sh0A_info;
           P64[Hp - 16] = _sh0z::P64;
           I64[Hp - 8] = go_sh0B_info;
           P64[Hp] = Hp - 32;
           R2 = _sh0y::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_sh0B_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternative[]_$csome_entry() //  [R2]
         { info_tbl: [(ciZe,
                       label: GHC.Base.$fAlternative[]_$csome_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ciZe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciZi; else goto ciZh;
       ciZi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciZh: // global
           I64[Hp - 16] = some_v_sh0z_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.572229195 UTC

[section ""data" . GHC.Base.$fAlternative[]_$cmany_closure" {
     GHC.Base.$fAlternative[]_$cmany_closure:
         const GHC.Base.$fAlternative[]_$cmany_info;
 },
 go1_sh0W_entry() //  [R1, R2]
         { info_tbl: [(cj0L,
                       label: go1_sh0W_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj0L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cj0M; else goto cj0N;
       cj0M: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj0N: // global
           I64[Sp - 32] = block_cj0E_info;
           _sh0W::P64 = R1;
           _sh0T::P64 = P64[R1 + 7];
           _sh0V::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sh0T::P64;
           P64[Sp - 16] = _sh0V::P64;
           P64[Sp - 8] = _sh0W::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uj0Z; else goto cj0F;
       uj0Z: // global
           call _cj0E(R1) args: 0, res: 0, upd: 0;
       cj0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cj0E() //  [R1]
         { info_tbl: [(cj0E,
                       label: block_cj0E_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj0E: // global
           if (R1 & 7 == 1) goto cj0I; else goto cj0J;
       cj0I: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cj0J: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cj0Y; else goto cj0X;
       cj0Y: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj0X: // global
           _sh0Z::P64 = P64[R1 + 6];
           _sh10::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sh10::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sh0Z::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sh0Q_entry() //  [R1, R2]
         { info_tbl: [(cj14,
                       label: go_sh0Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj14: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cj15; else goto cj16;
       cj15: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj16: // global
           I64[Sp - 24] = block_cj0s_info;
           _sh0Q::P64 = R1;
           _sh0P::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sh0P::P64;
           P64[Sp - 8] = _sh0Q::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uj1c; else goto cj0t;
       uj1c: // global
           call _cj0s(R1) args: 0, res: 0, upd: 0;
       cj0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cj0s() //  [R1]
         { info_tbl: [(cj0s,
                       label: block_cj0s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj0s: // global
           if (R1 & 7 == 1) goto cj11; else goto cj12;
       cj11: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cj12: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cj1b; else goto cj1a;
       cj1b: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj1a: // global
           _sh0T::P64 = P64[R1 + 6];
           _sh0U::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh0U::P64;
           I64[Hp - 16] = go1_sh0W_info;
           P64[Hp - 8] = _sh0T::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_sh0W_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v_sh0P_entry() //  [R1]
         { info_tbl: [(cj1f,
                       label: many_v_sh0P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj1f: // global
           _sh0P::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cj1g; else goto cj1h;
       cj1h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cj1j; else goto cj1i;
       cj1j: // global
           HpAlloc = 16;
           goto cj1g;
       cj1g: // global
           R1 = _sh0P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj1i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh0P::P64;
           _sh0O::P64 = P64[_sh0P::P64 + 16];
           I64[Hp - 8] = go_sh0Q_info;
           P64[Hp] = _sh0P::P64;
           I64[Sp - 24] = block_cj1d_info;
           R2 = _sh0O::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_sh0Q_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cj1d() //  [R1]
         { info_tbl: [(cj1d,
                       label: block_cj1d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj1d: // global
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternative[]_$cmany_entry() //  [R2]
         { info_tbl: [(cj1n,
                       label: GHC.Base.$fAlternative[]_$cmany_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj1n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj1r; else goto cj1q;
       cj1r: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj1q: // global
           I64[Hp - 16] = many_v_sh0P_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.589488607 UTC

[section ""data" . GHC.Base.$fAlternative[]_closure" {
     GHC.Base.$fAlternative[]_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fAlternative[]_$csome_closure+1;
         const GHC.Base.$fAlternative[]_$cmany_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.592874487 UTC

[section ""data" . GHC.Base.$w$c>>=_closure" {
     GHC.Base.$w$c>>=_closure:
         const GHC.Base.$w$c>>=_info;
 },
 ds_sh16_entry() //  [R1]
         { info_tbl: [(cj2v,
                       label: ds_sh16_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj2v: // global
           _sh16::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cj2w; else goto cj2x;
       cj2x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj2z; else goto cj2y;
       cj2z: // global
           HpAlloc = 24;
           goto cj2w;
       cj2w: // global
           R1 = _sh16::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj2y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh16::P64;
           _sh14::P64 = P64[_sh16::P64 + 16];
           _sh15::P64 = P64[_sh16::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sh14::P64;
           R2 = Hp - 16;
           R1 = _sh15::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh1A_entry() //  [R1]
         { info_tbl: [(cj38,
                       label: sat_sh1A_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj38: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sh1l_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sh1l_entry() //  [R1, R2]
         { info_tbl: [(cj3f,
                       label: go_sh1l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj3f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cj3g; else goto cj3h;
       cj3g: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj3h: // global
           I64[Sp - 24] = block_cj2X_info;
           _sh1l::P64 = R1;
           _sh15::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sh15::P64;
           P64[Sp - 8] = _sh1l::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uj3q; else goto cj2Y;
       uj3q: // global
           call _cj2X(R1) args: 0, res: 0, upd: 0;
       cj2Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cj2X() //  [R1]
         { info_tbl: [(cj2X,
                       label: block_cj2X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj2X: // global
           if (R1 & 7 == 1) goto cj3c; else goto cj3d;
       cj3c: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cj3d: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cj3p; else goto cj3o;
       cj3p: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj3o: // global
           _sh1o::P64 = P64[R1 + 6];
           _sh1p::P64 = P64[R1 + 14];
           I64[Hp - 128] = stg_ap_2_upd_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _sh1o::P64;
           I64[Hp - 96] = sat_sh1A_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sh1p::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cj33::P64 = Hp - 128;
           P64[Hp - 48] = _cj33::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cj33::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 96;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh1B_entry() //  [R1]
         { info_tbl: [(cj3r,
                       label: sat_sh1B_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj3r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cj3s; else goto cj3t;
       cj3s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj3t: // global
           I64[Sp - 16] = block_cj2N_info;
           _sh15::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _sh15::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uj3x; else goto cj2O;
       uj3x: // global
           call _cj2N(R1) args: 0, res: 0, upd: 0;
       cj2O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cj2N() //  [R1]
         { info_tbl: [(cj2N,
                       label: block_cj2N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj2N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cj3w; else goto cj3v;
       cj3w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj3v: // global
           _sh1k::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_sh1l_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _sh1k::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_sh1l_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh1C_entry() //  [R1]
         { info_tbl: [(cj3y,
                       label: sat_sh1C_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj3y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cj3z; else goto cj3A;
       cj3z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj3A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cj2E_info;
           _sh14::P64 = P64[R1 + 16];
           _sh15::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sh14::P64;
           P64[Sp - 24] = _sh15::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uj3E; else goto cj2F;
       uj3E: // global
           call _cj2E(R1) args: 0, res: 0, upd: 0;
       cj2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cj2E() //  [R1]
         { info_tbl: [(cj2E,
                       label: block_cj2E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj2E: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cj3D; else goto cj3C;
       cj3D: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cj3C: // global
           _sh1h::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sh1B_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 24;
           R2 = _sh1h::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$w$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cj3G,
                       label: GHC.Base.$w$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj3G: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cj3K; else goto cj3J;
       cj3K: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj3J: // global
           I64[Hp - 88] = ds_sh16_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sh1C_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _cj2q::P64 = Hp - 88;
           P64[Hp - 24] = _cj2q::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cj2q::P64;
           R2 = Hp - 56;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.613406473 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>=_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>=_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>=_info;
 },
 GHC.Base.$fMonadNonEmpty_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cj4T,
                       label: GHC.Base.$fMonadNonEmpty_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj4T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cj4U; else goto cj4V;
       cj4U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj4V: // global
           I64[Sp - 8] = block_cj4Q_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cj4Q() //  [R1, R2]
         { info_tbl: [(cj4Q,
                       label: block_cj4Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj4Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj4Y; else goto cj4X;
       cj4Y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cj4X: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.620008874 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>_info;
 },
 sat_sh1L_entry() //  [R1]
         { info_tbl: [(cj5j,
                       label: sat_sh1L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj5j: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonadNonEmpty_$c>>_entry() //  [R2, R3]
         { info_tbl: [(cj5p,
                       label: GHC.Base.$fMonadNonEmpty_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj5p: // global
           _sh1J::P64 = R3;
           _sh1I::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cj5q; else goto cj5r;
       cj5r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cj5t; else goto cj5s;
       cj5t: // global
           HpAlloc = 16;
           goto cj5q;
       cj5q: // global
           R3 = _sh1J::P64;
           R2 = _sh1I::P64;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj5s: // global
           I64[Hp - 8] = sat_sh1L_info;
           P64[Hp] = _sh1J::P64;
           I64[Sp - 8] = block_cj5m_info;
           R3 = Hp - 7;
           R2 = _sh1I::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cj5m() //  [R1, R2]
         { info_tbl: [(cj5m,
                       label: block_cj5m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj5m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj5w; else goto cj5v;
       cj5w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cj5v: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.627441692 UTC

[section ""data" . GHC.Base.<**>1_closure" {
     GHC.Base.<**>1_closure:
         const GHC.Base.<**>1_info;
 },
 GHC.Base.<**>1_entry() //  [R2, R3]
         { info_tbl: [(cj5S,
                       label: GHC.Base.<**>1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj5S: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.630765513 UTC

[section ""data" . GHC.Base.<**>_closure" {
     GHC.Base.<**>_closure:
         const GHC.Base.<**>_info;
 },
 GHC.Base.<**>_entry() //  [R2]
         { info_tbl: [(cj63,
                       label: GHC.Base.<**>_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj63: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cj64; else goto cj65;
       cj64: // global
           R2 = R2;
           R1 = GHC.Base.<**>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj65: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.<**>1_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.634814365 UTC

[section ""data" . GHC.Base.$dmliftA2_closure" {
     GHC.Base.$dmliftA2_closure:
         const GHC.Base.$dmliftA2_info;
 },
 sat_sh1W_entry() //  [R1]
         { info_tbl: [(cj6n,
                       label: sat_sh1W_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj6n: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cj6o; else goto cj6p;
       cj6o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj6p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cj6l_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cj6l() //  [R1]
         { info_tbl: [(cj6l,
                       label: block_cj6l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj6l: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cj6t,
                       label: GHC.Base.$dmliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj6t: // global
           _sh1U::P64 = R4;
           _sh1T::P64 = R3;
           _sh1S::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cj6u; else goto cj6v;
       cj6v: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cj6x; else goto cj6w;
       cj6x: // global
           HpAlloc = 40;
           goto cj6u;
       cj6u: // global
           R4 = _sh1U::P64;
           R3 = _sh1T::P64;
           R2 = _sh1S::P64;
           R1 = GHC.Base.$dmliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cj6w: // global
           I64[Hp - 32] = sat_sh1W_info;
           P64[Hp - 16] = _sh1S::P64;
           P64[Hp - 8] = _sh1T::P64;
           P64[Hp] = _sh1U::P64;
           R2 = _sh1S::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.643234857 UTC

[section ""data" . GHC.Base.$dmsome_closure" {
     GHC.Base.$dmsome_closure:
         const GHC.Base.$dmsome_info;
 },
 sat_sh21_entry() //  [R1]
         { info_tbl: [(cj7c,
                       label: sat_sh21_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj7c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cj7d; else goto cj7e;
       cj7d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj7e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sh22_entry() //  [R1]
         { info_tbl: [(cj7f,
                       label: sat_sh22_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj7f: // global
           _sh22::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cj7g; else goto cj7h;
       cj7h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj7j; else goto cj7i;
       cj7j: // global
           HpAlloc = 24;
           goto cj7g;
       cj7g: // global
           R1 = _sh22::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj7i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh22::P64;
           _sh1X::P64 = P64[_sh22::P64 + 16];
           _sh1Z::P64 = P64[_sh22::P64 + 24];
           _sh20::P64 = P64[_sh22::P64 + 32];
           I64[Hp - 16] = sat_sh21_info;
           P64[Hp] = _sh20::P64;
           R2 = _sh1X::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sh1Z::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 some_v_sh1Z_entry() //  [R1]
         { info_tbl: [(cj7k,
                       label: some_v_sh1Z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj7k: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cj7l; else goto cj7m;
       cj7l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj7m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cj70_info;
           _sh1X::P64 = P64[R1 + 16];
           R2 = _sh1X::P64;
           P64[Sp - 40] = _sh1X::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cj70() //  [R1]
         { info_tbl: [(cj70,
                       label: block_cj70_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj70: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cj7p; else goto cj7o;
       cj7p: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cj7o: // global
           I64[Hp - 32] = sat_sh22_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 32;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmsome_entry() //  [R2, R3]
         { info_tbl: [(cj7q,
                       label: GHC.Base.$dmsome_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj7q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cj7u; else goto cj7t;
       cj7u: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj7t: // global
           I64[Hp - 24] = some_v_sh1Z_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.656455649 UTC

[section ""data" . GHC.Base.$dmmany_closure" {
     GHC.Base.$dmmany_closure:
         const GHC.Base.$dmmany_info;
 },
 $dApplicative_sh26_entry() //  [R1]
         { info_tbl: [(cj8j,
                       label: $dApplicative_sh26_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj8j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cj8k; else goto cj8l;
       cj8k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj8l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh28_entry() //  [R1]
         { info_tbl: [(cj8q,
                       label: sat_sh28_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj8q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cj8r; else goto cj8s;
       cj8r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj8s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sh27_entry() //  [R1]
         { info_tbl: [(cj8x,
                       label: sat_sh27_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj8x: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cj8y; else goto cj8z;
       cj8y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj8z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 many_v_sh25_entry() //  [R1]
         { info_tbl: [(cj8A,
                       label: many_v_sh25_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj8A: // global
           _sh25::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cj8B; else goto cj8C;
       cj8C: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cj8E; else goto cj8D;
       cj8E: // global
           HpAlloc = 88;
           goto cj8B;
       cj8B: // global
           R1 = _sh25::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj8D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh25::P64;
           _sh23::P64 = P64[_sh25::P64 + 16];
           _sh24::P64 = P64[_sh25::P64 + 24];
           I64[Hp - 80] = $dApplicative_sh26_info;
           P64[Hp - 64] = _sh23::P64;
           I64[Hp - 56] = sat_sh28_info;
           _cj8f::P64 = Hp - 80;
           P64[Hp - 40] = _cj8f::P64;
           I64[Hp - 32] = sat_sh27_info;
           P64[Hp - 16] = _sh24::P64;
           P64[Hp - 8] = _sh25::P64;
           P64[Hp] = _cj8f::P64;
           R2 = _sh23::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$dmmany_entry() //  [R2, R3]
         { info_tbl: [(cj8F,
                       label: GHC.Base.$dmmany_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj8F: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cj8J; else goto cj8I;
       cj8J: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj8I: // global
           I64[Hp - 24] = many_v_sh25_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.669937021 UTC

[section ""data" . GHC.Base.$w$csconcat3_closure" {
     GHC.Base.$w$csconcat3_closure:
         const GHC.Base.$w$csconcat3_info;
 },
 sat_sh2m_entry() //  [R1, R2]
         { info_tbl: [(cj9K,
                       label: sat_sh2m_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj9K: // global
           _sh2j::P64 = R2;
           _sh2m::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cj9L; else goto cj9M;
       cj9M: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cj9O; else goto cj9N;
       cj9O: // global
           HpAlloc = 64;
           goto cj9L;
       cj9L: // global
           R2 = _sh2j::P64;
           R1 = _sh2m::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj9N: // global
           _sh29::P64 = P64[_sh2m::P64 + 7];
           _sh2d::P64 = P64[_sh2m::P64 + 15];
           _sh2i::P64 = P64[_sh2m::P64 + 23];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sh2i::P64;
           P64[Hp - 32] = _sh2j::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sh2d::P64;
           P64[Hp] = _sh2j::P64;
           R2 = _sh29::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 go_sh2c_entry() //  [R1, R2, R3]
         { info_tbl: [(cj9T,
                       label: go_sh2c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj9T: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cj9U; else goto cj9V;
       cj9U: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj9V: // global
           I64[Sp - 32] = block_cj9w_info;
           _sh2c::P64 = R1;
           _sh29::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _sh29::P64;
           P64[Sp - 16] = _sh2c::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uja1; else goto cj9x;
       uja1: // global
           call _cj9w(R1) args: 0, res: 0, upd: 0;
       cj9x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cj9w() //  [R1]
         { info_tbl: [(cj9w,
                       label: block_cj9w_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cj9w: // global
           _sh2d::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cj9Q; else goto cj9R;
       cj9Q: // global
           R1 = _sh2d::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cj9R: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cja0; else goto cj9Z;
       cja0: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj9Z: // global
           _sh2g::P64 = P64[R1 + 6];
           _sh2h::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sh2g::P64;
           P64[Hp - 32] = _sh2h::P64;
           I64[Hp - 24] = sat_sh2m_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sh2d::P64;
           P64[Hp] = Hp - 64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat3_entry() //  [R2, R3, R4]
         { info_tbl: [(cja2,
                       label: GHC.Base.$w$csconcat3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cja2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cja6; else goto cja5;
       cja6: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cja5: // global
           I64[Hp - 8] = go_sh2c_info;
           P64[Hp] = R2;
           _sh2a::P64 = R3;
           R3 = R4;
           R2 = _sh2a::P64;
           R1 = Hp - 6;
           call go_sh2c_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.68116009 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$csconcat_closure" {
     GHC.Base.$fSemigroup(->)_$csconcat_closure:
         const GHC.Base.$fSemigroup(->)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(->)_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(cjaJ,
                       label: GHC.Base.$fSemigroup(->)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjaJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjaK; else goto cjaL;
       cjaK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjaL: // global
           I64[Sp - 16] = block_cjaG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ujaP; else goto cjaH;
       ujaP: // global
           call _cjaG(R1) args: 0, res: 0, upd: 0;
       cjaH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjaG() //  [R1]
         { info_tbl: [(cjaG,
                       label: block_cjaG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjaG: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.68767265 UTC

[section ""data" . GHC.Base.$w$csconcat_closure" {
     GHC.Base.$w$csconcat_closure:
         const GHC.Base.$w$csconcat_info;
 },
 sat_sh2L_entry() //  [R1]
         { info_tbl: [(cjbq,
                       label: sat_sh2L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjbq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjbr; else goto cjbs;
       cjbr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjbs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sh2K_entry() //  [R1]
         { info_tbl: [(cjbx,
                       label: sat_sh2K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjbx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjby; else goto cjbz;
       cjby: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjbz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_sh2x_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cjbE,
                       label: $wgo_sh2x_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjbE: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjbF; else goto cjbG;
       cjbF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjbG: // global
           I64[Sp - 48] = block_cjb9_info;
           _sh2x::P64 = R1;
           _sh2s::P64 = P64[R1 + 5];
           _sh2t::P64 = P64[R1 + 13];
           R1 = R4;
           P64[Sp - 40] = _sh2s::P64;
           P64[Sp - 32] = _sh2t::P64;
           P64[Sp - 24] = _sh2x::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ujbP; else goto cjba;
       ujbP: // global
           call _cjb9(R1) args: 0, res: 0, upd: 0;
       cjba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjb9() //  [R1]
         { info_tbl: [(cjb9,
                       label: block_cjb9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjb9: // global
           if (R1 & 7 == 1) goto cjbB; else goto cjbC;
       cjbB: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cjbC: // global
           I64[Sp - 8] = block_cjbf_info;
           _sh2D::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sh2D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujbO; else goto cjbg;
       ujbO: // global
           call _cjbf(R1) args: 0, res: 0, upd: 0;
       cjbg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjbf() //  [R1]
         { info_tbl: [(cjbf,
                       label: block_cjbf_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjbf: // global
           _sh2D::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cjbk_info;
           R4 = _sh2D::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           Sp = Sp + 8;
           call $wgo_sh2x_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjbk() //  [R1, R2]
         { info_tbl: [(cjbk,
                       label: block_cjbk_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjbk: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cjbN; else goto cjbM;
       cjbN: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cjbM: // global
           I64[Hp - 72] = sat_sh2L_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sh2K_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cjbQ,
                       label: GHC.Base.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjbQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjbU; else goto cjbT;
       cjbU: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjbT: // global
           I64[Hp - 16] = $wgo_sh2x_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sh2u::P64 = R4;
           R4 = R6;
           R3 = R5;
           R2 = _sh2u::P64;
           R1 = Hp - 13;
           call $wgo_sh2x_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.704804955 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,)_$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(cjcP,
                       label: GHC.Base.$fSemigroup(,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjcP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjd0; else goto cjd1;
       cjd0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjd1: // global
           I64[Sp - 24] = block_cjcM_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujd8; else goto cjcN;
       ujd8: // global
           call _cjcM(R1) args: 0, res: 0, upd: 0;
       cjcN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjcM() //  [R1]
         { info_tbl: [(cjcM,
                       label: block_cjcM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjcM: // global
           I64[Sp - 8] = block_cjcS_info;
           _sh2R::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sh2R::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujd7; else goto cjcT;
       ujd7: // global
           call _cjcS(R1) args: 0, res: 0, upd: 0;
       cjcT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjcS() //  [R1]
         { info_tbl: [(cjcS,
                       label: block_cjcS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjcS: // global
           _sh2N::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cjcX_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sh2N::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Base.$w$csconcat_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cjcX() //  [R1, R2]
         { info_tbl: [(cjcX,
                       label: block_cjcX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjcX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjd6; else goto cjd5;
       cjd6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cjd5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.714809937 UTC

[section ""data" . GHC.Base.$dmsconcat_closure" {
     GHC.Base.$dmsconcat_closure:
         const GHC.Base.$dmsconcat_info;
 },
 go_sh33_entry() //  [R1, R2, R3]
         { info_tbl: [(cjdP,
                       label: go_sh33_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjdP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjdQ; else goto cjdR;
       cjdQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjdR: // global
           I64[Sp - 32] = block_cjdI_info;
           _sh33::P64 = R1;
           _sh2Y::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _sh2Y::P64;
           P64[Sp - 16] = _sh33::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uje1; else goto cjdJ;
       uje1: // global
           call _cjdI(R1) args: 0, res: 0, upd: 0;
       cjdJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjdI() //  [R1]
         { info_tbl: [(cjdI,
                       label: block_cjdI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjdI: // global
           _sh34::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cjdM; else goto cjdN;
       cjdM: // global
           R1 = _sh34::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cjdN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cjdZ; else goto cjdY;
       cjdZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjdY: // global
           _sh37::P64 = P64[R1 + 6];
           _sh38::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _sh37::P64;
           P64[Hp] = _sh38::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _sh34::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 GHC.Base.$dmsconcat_entry() //  [R2, R3]
         { info_tbl: [(cje2,
                       label: GHC.Base.$dmsconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cje2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cje3; else goto cje4;
       cje3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cje4: // global
           I64[Sp - 16] = block_cjdy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uje8; else goto cjdz;
       uje8: // global
           call _cjdy(R1) args: 0, res: 0, upd: 0;
       cjdz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjdy() //  [R1]
         { info_tbl: [(cjdy,
                       label: block_cjdy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjdy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cje7; else goto cje6;
       cje7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cje6: // global
           _sh31::P64 = P64[R1 + 7];
           _sh32::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_sh33_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _sh32::P64;
           R2 = _sh31::P64;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call go_sh33_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.725609451 UTC

[section ""data" . GHC.Base.$dmstimes_closure" {
     GHC.Base.$dmstimes_closure:
         const GHC.Base.$dmstimes_info;
         const 0;
 },
 GHC.Base.$dmstimes_entry() //  [R2, R3]
         { info_tbl: [(cjeE,
                       label: GHC.Base.$dmstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjeE: // global
           _sh3b::P64 = R3;
           R3 = R2;
           R2 = _sh3b::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.729326283 UTC

[section ""data" . GHC.Base.$dmmappend_closure" {
     GHC.Base.$dmmappend_closure:
         const GHC.Base.$dmmappend_info;
 },
 GHC.Base.$dmmappend_entry() //  [R2]
         { info_tbl: [(cjeR,
                       label: GHC.Base.$dmmappend_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjeR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cjeS; else goto cjeT;
       cjeS: // global
           R2 = R2;
           R1 = GHC.Base.$dmmappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjeT: // global
           I64[Sp - 8] = block_cjeP_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cjeP() //  [R1]
         { info_tbl: [(cjeP,
                       label: block_cjeP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjeP: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.735133828 UTC

[section ""data" . GHC.Base.$dm>>_closure" {
     GHC.Base.$dm>>_closure:
         const GHC.Base.$dm>>_info;
 },
 sat_sh3i_entry() //  [R1]
         { info_tbl: [(cjff,
                       label: sat_sh3i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjff: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$dm>>_entry() //  [R2, R3, R4]
         { info_tbl: [(cjfi,
                       label: GHC.Base.$dm>>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjfi: // global
           _sh3g::P64 = R4;
           _sh3f::P64 = R3;
           _sh3e::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cjfj; else goto cjfk;
       cjfk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cjfm; else goto cjfl;
       cjfm: // global
           HpAlloc = 16;
           goto cjfj;
       cjfj: // global
           R4 = _sh3g::P64;
           R3 = _sh3f::P64;
           R2 = _sh3e::P64;
           R1 = GHC.Base.$dm>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjfl: // global
           I64[Hp - 8] = sat_sh3i_info;
           P64[Hp] = _sh3g::P64;
           R2 = _sh3e::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sh3f::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.740788919 UTC

[section ""data" . GHC.Base.$dmreturn_closure" {
     GHC.Base.$dmreturn_closure:
         const GHC.Base.$dmreturn_info;
 },
 GHC.Base.$dmreturn_entry() //  [R2]
         { info_tbl: [(cjfE,
                       label: GHC.Base.$dmreturn_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjfE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cjfF; else goto cjfG;
       cjfF: // global
           R2 = R2;
           R1 = GHC.Base.$dmreturn_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjfG: // global
           I64[Sp - 8] = block_cjfC_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cjfC() //  [R1]
         { info_tbl: [(cjfC,
                       label: block_cjfC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjfC: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.746023743 UTC

[section ""data" . GHC.Base.$dmfail_closure" {
     GHC.Base.$dmfail_closure:
         const GHC.Base.$dmfail_info;
         const 0;
 },
 GHC.Base.$dmfail_entry() //  [R3]
         { info_tbl: [(cjfX,
                       label: GHC.Base.$dmfail_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjfX: // global
           R2 = R3;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.749444462 UTC

[section ""data" . GHC.Base.$dmmzero_closure" {
     GHC.Base.$dmmzero_closure:
         const GHC.Base.$dmmzero_info;
 },
 GHC.Base.$dmmzero_entry() //  [R2]
         { info_tbl: [(cjga,
                       label: GHC.Base.$dmmzero_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjga: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cjgb; else goto cjgc;
       cjgb: // global
           R2 = R2;
           R1 = GHC.Base.$dmmzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjgc: // global
           I64[Sp - 8] = block_cjg8_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cjg8() //  [R1]
         { info_tbl: [(cjg8,
                       label: block_cjg8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjg8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.75465947 UTC

[section ""data" . GHC.Base.$dmmplus_closure" {
     GHC.Base.$dmmplus_closure:
         const GHC.Base.$dmmplus_info;
 },
 GHC.Base.$dmmplus_entry() //  [R2]
         { info_tbl: [(cjgv,
                       label: GHC.Base.$dmmplus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjgv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cjgw; else goto cjgx;
       cjgw: // global
           R2 = R2;
           R1 = GHC.Base.$dmmplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjgx: // global
           I64[Sp - 8] = block_cjgt_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cjgt() //  [R1]
         { info_tbl: [(cjgt,
                       label: block_cjgt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjgt: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.760311083 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c==_closure" {
     GHC.Base.$fEqMaybe_$c==_closure:
         const GHC.Base.$fEqMaybe_$c==_info;
 },
 GHC.Base.$fEqMaybe_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(cjgV,
                       label: GHC.Base.$fEqMaybe_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjgV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjgW; else goto cjgX;
       cjgW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjgX: // global
           I64[Sp - 24] = block_cjgO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujhy; else goto cjgP;
       ujhy: // global
           call _cjgO(R1) args: 0, res: 0, upd: 0;
       cjgP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjgO() //  [R1]
         { info_tbl: [(cjgO,
                       label: block_cjgO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjgO: // global
           _sh3t::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjgS; else goto cjgT;
       cjgS: // global
           I64[Sp + 16] = block_cjh0_info;
           R1 = _sh3t::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujhw; else goto cjh2;
       ujhw: // global
           call _cjh0(R1) args: 0, res: 0, upd: 0;
       cjh2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjgT: // global
           I64[Sp] = block_cjhf_info;
           _sh3x::P64 = P64[R1 + 6];
           R1 = _sh3t::P64;
           P64[Sp + 16] = _sh3x::P64;
           if (R1 & 7 != 0) goto ujhx; else goto cjhh;
       ujhx: // global
           call _cjhf(R1) args: 0, res: 0, upd: 0;
       cjhh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjh0() //  [R1]
         { info_tbl: [(cjh0,
                       label: block_cjh0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjh0: // global
           if (R1 & 7 == 1) goto cjh8; else goto ujhv;
       cjh8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ujhv: // global
           Sp = Sp + 8;
           call _cjhn() args: 0, res: 0, upd: 0;
     }
 },
 _cjhf() //  [R1]
         { info_tbl: [(cjhf,
                       label: block_cjhf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjhf: // global
           if (R1 & 7 == 1) goto ujhu; else goto cjhr;
       ujhu: // global
           Sp = Sp + 24;
           call _cjhn() args: 0, res: 0, upd: 0;
       cjhr: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cjhn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjhn: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.771880739 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c/=_closure" {
     GHC.Base.$fEqMaybe_$c/=_closure:
         const GHC.Base.$fEqMaybe_$c/=_info;
 },
 GHC.Base.$fEqMaybe_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(cjil,
                       label: GHC.Base.$fEqMaybe_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjil: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjim; else goto cjin;
       cjim: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjin: // global
           I64[Sp - 24] = block_cjie_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujjd; else goto cjif;
       ujjd: // global
           call _cjie(R1) args: 0, res: 0, upd: 0;
       cjif: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjie() //  [R1]
         { info_tbl: [(cjie,
                       label: block_cjie_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjie: // global
           _sh3C::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjii; else goto cjij;
       cjii: // global
           I64[Sp + 16] = block_cjiq_info;
           R1 = _sh3C::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujjb; else goto cjis;
       ujjb: // global
           call _cjiq(R1) args: 0, res: 0, upd: 0;
       cjis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjij: // global
           I64[Sp] = block_cjiF_info;
           _sh3G::P64 = P64[R1 + 6];
           R1 = _sh3C::P64;
           P64[Sp + 16] = _sh3G::P64;
           if (R1 & 7 != 0) goto ujjc; else goto cjiH;
       ujjc: // global
           call _cjiF(R1) args: 0, res: 0, upd: 0;
       cjiH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjiq() //  [R1]
         { info_tbl: [(cjiq,
                       label: block_cjiq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjiq: // global
           if (R1 & 7 == 1) goto ujj9; else goto ujja;
       ujj9: // global
           Sp = Sp + 8;
           call _cjj2() args: 0, res: 0, upd: 0;
       ujja: // global
           Sp = Sp + 8;
           call _cjiY() args: 0, res: 0, upd: 0;
     }
 },
 _cjiF() //  [R1]
         { info_tbl: [(cjiF,
                       label: block_cjiF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjiF: // global
           if (R1 & 7 == 1) goto ujj6; else goto cjiS;
       ujj6: // global
           Sp = Sp + 24;
           call _cjiY() args: 0, res: 0, upd: 0;
       cjiS: // global
           _sh3G::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjiQ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _sh3G::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjiQ() //  [R1]
         { info_tbl: [(cjiQ,
                       label: block_cjiQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjiQ: // global
           if (R1 & 7 == 1) goto ujj7; else goto ujj8;
       ujj7: // global
           Sp = Sp + 8;
           call _cjiY() args: 0, res: 0, upd: 0;
       ujj8: // global
           Sp = Sp + 8;
           call _cjj2() args: 0, res: 0, upd: 0;
     }
 },
 _cjiY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjiY: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjj2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjj2: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.785568004 UTC

[section ""data" . GHC.Base.$fEqMaybe_closure" {
     GHC.Base.$fEqMaybe_closure:
         const GHC.Base.$fEqMaybe_info;
 },
 sat_sh3M_entry() //  [R1, R2, R3]
         { info_tbl: [(cjk8,
                       label: sat_sh3M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjk8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh3L_entry() //  [R1, R2, R3]
         { info_tbl: [(cjkg,
                       label: sat_sh3L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjkg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fEqMaybe_entry() //  [R2]
         { info_tbl: [(cjkk,
                       label: GHC.Base.$fEqMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjkk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cjko; else goto cjkn;
       cjko: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjkn: // global
           I64[Hp - 48] = sat_sh3M_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sh3L_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.792850784 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cp1Ord_closure" {
     GHC.Base.$fOrdMaybe_$cp1Ord_closure:
         const GHC.Base.$fOrdMaybe_$cp1Ord_info;
 },
 sat_sh3O_entry() //  [R1]
         { info_tbl: [(cjkN,
                       label: sat_sh3O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjkN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjkO; else goto cjkP;
       cjkO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjkP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdMaybe_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cjkQ,
                       label: GHC.Base.$fOrdMaybe_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjkQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjkU; else goto cjkT;
       cjkU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjkT: // global
           I64[Hp - 16] = sat_sh3O_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqMaybe_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.798742135 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$ccompare_closure" {
     GHC.Base.$fOrdMaybe_$ccompare_closure:
         const GHC.Base.$fOrdMaybe_$ccompare_info;
 },
 GHC.Base.$fOrdMaybe_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(cjlg,
                       label: GHC.Base.$fOrdMaybe_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjlg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjlh; else goto cjli;
       cjlh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjli: // global
           I64[Sp - 24] = block_cjl9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujlR; else goto cjla;
       ujlR: // global
           call _cjl9(R1) args: 0, res: 0, upd: 0;
       cjla: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjl9() //  [R1]
         { info_tbl: [(cjl9,
                       label: block_cjl9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjl9: // global
           _sh3R::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjld; else goto cjle;
       cjld: // global
           I64[Sp + 16] = block_cjll_info;
           R1 = _sh3R::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujlP; else goto cjln;
       ujlP: // global
           call _cjll(R1) args: 0, res: 0, upd: 0;
       cjln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjle: // global
           I64[Sp] = block_cjlA_info;
           _sh3V::P64 = P64[R1 + 6];
           R1 = _sh3R::P64;
           P64[Sp + 16] = _sh3V::P64;
           if (R1 & 7 != 0) goto ujlQ; else goto cjlC;
       ujlQ: // global
           call _cjlA(R1) args: 0, res: 0, upd: 0;
       cjlC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjll() //  [R1]
         { info_tbl: [(cjll,
                       label: block_cjll_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjll: // global
           if (R1 & 7 == 1) goto cjlt; else goto cjlx;
       cjlt: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjlx: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjlA() //  [R1]
         { info_tbl: [(cjlA,
                       label: block_cjlA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjlA: // global
           if (R1 & 7 == 1) goto cjlI; else goto cjlM;
       cjlI: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjlM: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.809734706 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<_closure" {
     GHC.Base.$fOrdMaybe_$c<_closure:
         const GHC.Base.$fOrdMaybe_$c<_info;
 },
 GHC.Base.$fOrdMaybe_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(cjmC,
                       label: GHC.Base.$fOrdMaybe_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjmC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjmD; else goto cjmE;
       cjmD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjmE: // global
           I64[Sp - 24] = block_cjmv_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujnf; else goto cjmw;
       ujnf: // global
           call _cjmv(R1) args: 0, res: 0, upd: 0;
       cjmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjmv() //  [R1]
         { info_tbl: [(cjmv,
                       label: block_cjmv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjmv: // global
           _sh40::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjmz; else goto cjmA;
       cjmz: // global
           I64[Sp + 16] = block_cjmH_info;
           R1 = _sh40::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujnd; else goto cjmJ;
       ujnd: // global
           call _cjmH(R1) args: 0, res: 0, upd: 0;
       cjmJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjmA: // global
           I64[Sp] = block_cjmW_info;
           _sh44::P64 = P64[R1 + 6];
           R1 = _sh40::P64;
           P64[Sp + 16] = _sh44::P64;
           if (R1 & 7 != 0) goto ujne; else goto cjmY;
       ujne: // global
           call _cjmW(R1) args: 0, res: 0, upd: 0;
       cjmY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjmH() //  [R1]
         { info_tbl: [(cjmH,
                       label: block_cjmH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjmH: // global
           if (R1 & 7 == 1) goto ujnc; else goto cjmT;
       ujnc: // global
           Sp = Sp + 8;
           call _cjn4() args: 0, res: 0, upd: 0;
       cjmT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjmW() //  [R1]
         { info_tbl: [(cjmW,
                       label: block_cjmW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjmW: // global
           if (R1 & 7 == 1) goto ujnb; else goto cjn8;
       ujnb: // global
           Sp = Sp + 24;
           call _cjn4() args: 0, res: 0, upd: 0;
       cjn8: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cjn4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjn4: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.820773636 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<=_closure" {
     GHC.Base.$fOrdMaybe_$c<=_closure:
         const GHC.Base.$fOrdMaybe_$c<=_info;
 },
 GHC.Base.$fOrdMaybe_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(cjo2,
                       label: GHC.Base.$fOrdMaybe_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjo2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjo3; else goto cjo4;
       cjo3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjo4: // global
           I64[Sp - 24] = block_cjnV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujoU; else goto cjnW;
       ujoU: // global
           call _cjnV(R1) args: 0, res: 0, upd: 0;
       cjnW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjnV() //  [R1]
         { info_tbl: [(cjnV,
                       label: block_cjnV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjnV: // global
           _sh48::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjnZ; else goto cjo0;
       cjnZ: // global
           I64[Sp + 16] = block_cjo7_info;
           R1 = _sh48::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujoS; else goto cjo9;
       ujoS: // global
           call _cjo7(R1) args: 0, res: 0, upd: 0;
       cjo9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjo0: // global
           I64[Sp] = block_cjom_info;
           _sh4d::P64 = P64[R1 + 6];
           R1 = _sh48::P64;
           P64[Sp + 16] = _sh4d::P64;
           if (R1 & 7 != 0) goto ujoT; else goto cjoo;
       ujoT: // global
           call _cjom(R1) args: 0, res: 0, upd: 0;
       cjoo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjo7() //  [R1]
         { info_tbl: [(cjo7,
                       label: block_cjo7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjo7: // global
           if (R1 & 7 == 1) goto ujoQ; else goto ujoR;
       ujoQ: // global
           Sp = Sp + 8;
           call _cjoF() args: 0, res: 0, upd: 0;
       ujoR: // global
           Sp = Sp + 8;
           call _cjoJ() args: 0, res: 0, upd: 0;
     }
 },
 _cjom() //  [R1]
         { info_tbl: [(cjom,
                       label: block_cjom_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjom: // global
           if (R1 & 7 == 1) goto ujoN; else goto cjoz;
       ujoN: // global
           Sp = Sp + 24;
           call _cjoF() args: 0, res: 0, upd: 0;
       cjoz: // global
           _sh4d::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjox_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _sh4d::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjox() //  [R1]
         { info_tbl: [(cjox,
                       label: block_cjox_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjox: // global
           if (R1 & 7 == 1) goto ujoO; else goto ujoP;
       ujoO: // global
           Sp = Sp + 8;
           call _cjoF() args: 0, res: 0, upd: 0;
       ujoP: // global
           Sp = Sp + 8;
           call _cjoJ() args: 0, res: 0, upd: 0;
     }
 },
 _cjoF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjoF: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjoJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjoJ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.834205143 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmax_closure" {
     GHC.Base.$fOrdMaybe_$cmax_closure:
         const GHC.Base.$fOrdMaybe_$cmax_info;
 },
 GHC.Base.$fOrdMaybe_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(cjpR,
                       label: GHC.Base.$fOrdMaybe_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjpR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cjpS; else goto cjpT;
       cjpS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjpT: // global
           I64[Sp - 24] = block_cjpK_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujqs; else goto cjpL;
       ujqs: // global
           call _cjpK(R1) args: 0, res: 0, upd: 0;
       cjpL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjpK() //  [R1]
         { info_tbl: [(cjpK,
                       label: block_cjpK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjpK: // global
           _sh4i::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjpO; else goto cjpP;
       cjpO: // global
           R1 = _sh4i::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjpP: // global
           I64[Sp - 8] = block_cjpZ_info;
           _sh4k::P64 = R1;
           _sh4l::P64 = P64[R1 + 6];
           R1 = _sh4i::P64;
           P64[Sp] = _sh4l::P64;
           P64[Sp + 16] = _sh4k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujqr; else goto cjq1;
       ujqr: // global
           call _cjpZ(R1) args: 0, res: 0, upd: 0;
       cjq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjpZ() //  [R1]
         { info_tbl: [(cjpZ,
                       label: block_cjpZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjpZ: // global
           if (R1 & 7 == 1) goto ujqp; else goto cjqc;
       ujqp: // global
           Sp = Sp + 24;
           call _cjqi() args: 0, res: 0, upd: 0;
       cjqc: // global
           _sh4l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cjqa_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _sh4l::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjqa() //  [R1]
         { info_tbl: [(cjqa,
                       label: block_cjqa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjqa: // global
           if (R1 & 7 == 1) goto ujqq; else goto cjqm;
       ujqq: // global
           Sp = Sp + 16;
           call _cjqi() args: 0, res: 0, upd: 0;
       cjqm: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjqi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjqi: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.845669315 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmin_closure" {
     GHC.Base.$fOrdMaybe_$cmin_closure:
         const GHC.Base.$fOrdMaybe_$cmin_info;
 },
 GHC.Base.$fOrdMaybe_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(cjrf,
                       label: GHC.Base.$fOrdMaybe_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjrf: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cjrg; else goto cjrh;
       cjrg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjrh: // global
           I64[Sp - 24] = block_cjr8_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujrV; else goto cjr9;
       ujrV: // global
           call _cjr8(R1) args: 0, res: 0, upd: 0;
       cjr9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjr8() //  [R1]
         { info_tbl: [(cjr8,
                       label: block_cjr8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjr8: // global
           _sh4q::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjrc; else goto cjrd;
       cjrc: // global
           I64[Sp + 16] = block_cjrk_info;
           R1 = _sh4q::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujrT; else goto cjrm;
       ujrT: // global
           call _cjrk() args: 0, res: 0, upd: 0;
       cjrm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjrd: // global
           I64[Sp - 8] = block_cjrt_info;
           _sh4s::P64 = R1;
           _sh4u::P64 = P64[R1 + 6];
           R1 = _sh4q::P64;
           P64[Sp] = _sh4u::P64;
           P64[Sp + 16] = _sh4s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujrU; else goto cjrv;
       ujrU: // global
           call _cjrt(R1) args: 0, res: 0, upd: 0;
       cjrv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjrk() //  []
         { info_tbl: [(cjrk,
                       label: block_cjrk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjrk: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjrt() //  [R1]
         { info_tbl: [(cjrt,
                       label: block_cjrt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjrt: // global
           if (R1 & 7 == 1) goto cjrB; else goto cjrG;
       cjrB: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjrG: // global
           _sh4u::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cjrE_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _sh4u::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjrE() //  [R1]
         { info_tbl: [(cjrE,
                       label: block_cjrE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjrE: // global
           if (R1 & 7 == 1) goto cjrM; else goto cjrQ;
       cjrM: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjrQ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.858649389 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c>=_closure" {
     GHC.Base.$fOrdMaybe_$c>=_closure:
         const GHC.Base.$fOrdMaybe_$c>=_info;
 },
 GHC.Base.$fOrdMaybe_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cjsJ,
                       label: GHC.Base.$fOrdMaybe_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjsJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjsK; else goto cjsL;
       cjsK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjsL: // global
           I64[Sp - 24] = block_cjsC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujtB; else goto cjsD;
       ujtB: // global
           call _cjsC(R1) args: 0, res: 0, upd: 0;
       cjsD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjsC() //  [R1]
         { info_tbl: [(cjsC,
                       label: block_cjsC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjsC: // global
           _sh4A::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjsG; else goto cjsH;
       cjsG: // global
           I64[Sp + 16] = block_cjsO_info;
           R1 = _sh4A::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujtz; else goto cjsQ;
       ujtz: // global
           call _cjsO(R1) args: 0, res: 0, upd: 0;
       cjsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjsH: // global
           I64[Sp] = block_cjt3_info;
           _sh4E::P64 = P64[R1 + 6];
           R1 = _sh4A::P64;
           P64[Sp + 16] = _sh4E::P64;
           if (R1 & 7 != 0) goto ujtA; else goto cjt5;
       ujtA: // global
           call _cjt3(R1) args: 0, res: 0, upd: 0;
       cjt5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjsO() //  [R1]
         { info_tbl: [(cjsO,
                       label: block_cjsO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjsO: // global
           if (R1 & 7 == 1) goto ujtx; else goto ujty;
       ujtx: // global
           Sp = Sp + 8;
           call _cjtm() args: 0, res: 0, upd: 0;
       ujty: // global
           Sp = Sp + 8;
           call _cjtq() args: 0, res: 0, upd: 0;
     }
 },
 _cjt3() //  [R1]
         { info_tbl: [(cjt3,
                       label: block_cjt3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjt3: // global
           if (R1 & 7 == 1) goto ujtu; else goto cjtg;
       ujtu: // global
           Sp = Sp + 24;
           call _cjtm() args: 0, res: 0, upd: 0;
       cjtg: // global
           _sh4E::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjte_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _sh4E::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjte() //  [R1]
         { info_tbl: [(cjte,
                       label: block_cjte_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjte: // global
           if (R1 & 7 == 1) goto ujtv; else goto ujtw;
       ujtv: // global
           Sp = Sp + 8;
           call _cjtm() args: 0, res: 0, upd: 0;
       ujtw: // global
           Sp = Sp + 8;
           call _cjtq() args: 0, res: 0, upd: 0;
     }
 },
 _cjtm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjtm: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjtq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjtq: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.872424275 UTC

[section ""data" . GHC.Base.$fOrdMaybe_closure" {
     GHC.Base.$fOrdMaybe_closure:
         const GHC.Base.$fOrdMaybe_info;
 },
 sat_sh4S_entry() //  [R1, R2, R3]
         { info_tbl: [(cjuw,
                       label: sat_sh4S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjuw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh4R_entry() //  [R1, R2, R3]
         { info_tbl: [(cjuE,
                       label: sat_sh4R_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjuE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh4Q_entry() //  [R1, R2, R3]
         { info_tbl: [(cjuM,
                       label: sat_sh4Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjuM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh4P_entry() //  [R1, R2, R3]
         { info_tbl: [(cjuU,
                       label: sat_sh4P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjuU: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh4M_entry() //  [R1, R2, R3]
         { info_tbl: [(cjv2,
                       label: sat_sh4M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjv2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh4L_entry() //  [R1, R2, R3]
         { info_tbl: [(cjva,
                       label: sat_sh4L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjva: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh4K_entry() //  [R1, R2, R3]
         { info_tbl: [(cjvi,
                       label: sat_sh4K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjvi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh4J_entry() //  [R1]
         { info_tbl: [(cjvp,
                       label: sat_sh4J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjvp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjvq; else goto cjvr;
       cjvq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjvr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdMaybe_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdMaybe_entry() //  [R2]
         { info_tbl: [(cjvt,
                       label: GHC.Base.$fOrdMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjvt: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cjvx; else goto cjvw;
       cjvx: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjvw: // global
           I64[Hp - 200] = sat_sh4S_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sh4R_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sh4Q_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sh4P_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sh4M_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sh4L_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sh4K_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sh4J_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.890810322 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c/=_closure" {
     GHC.Base.$fEqNonEmpty_$c/=_closure:
         const GHC.Base.$fEqNonEmpty_$c/=_info;
 },
 GHC.Base.$fEqNonEmpty_$c/=_entry() //  [R2, R3, R4]
         { info_tbl: [(cjwr,
                       label: GHC.Base.$fEqNonEmpty_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjwr: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjwv; else goto cjww;
       cjwv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjww: // global
           I64[Sp - 24] = block_cjwo_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujx4; else goto cjwp;
       ujx4: // global
           call _cjwo(R1) args: 0, res: 0, upd: 0;
       cjwp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjwo() //  [R1]
         { info_tbl: [(cjwo,
                       label: block_cjwo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjwo: // global
           I64[Sp - 8] = block_cjwu_info;
           _sh4X::P64 = P64[R1 + 7];
           _sh4Y::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh4Y::P64;
           P64[Sp + 16] = _sh4X::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujx3; else goto cjwy;
       ujx3: // global
           call _cjwu(R1) args: 0, res: 0, upd: 0;
       cjwy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjwu() //  [R1]
         { info_tbl: [(cjwu,
                       label: block_cjwu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjwu: // global
           I64[Sp] = block_cjwC_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjwC() //  [R1]
         { info_tbl: [(cjwC,
                       label: block_cjwC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjwC: // global
           if (R1 & 7 == 1) goto ujx1; else goto cjwO;
       ujx1: // global
           Sp = Sp + 32;
           call _cjwU() args: 0, res: 0, upd: 0;
       cjwO: // global
           _sh51::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cjwM_info;
           R4 = _sh51::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cjwM() //  [R1]
         { info_tbl: [(cjwM,
                       label: block_cjwM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjwM: // global
           if (R1 & 7 == 1) goto ujx2; else goto cjwY;
       ujx2: // global
           Sp = Sp + 8;
           call _cjwU() args: 0, res: 0, upd: 0;
       cjwY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjwU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjwU: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.902831759 UTC

[section ""data" . GHC.Base.$w$c==_closure" {
     GHC.Base.$w$c==_closure:
         const GHC.Base.$w$c==_info;
 },
 GHC.Base.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cjxS,
                       label: GHC.Base.$w$c==_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjxS: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjxT; else goto cjxU;
       cjxT: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjxU: // global
           I64[Sp - 32] = block_cjxM_info;
           _sh54::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _sh54::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjxM() //  [R1]
         { info_tbl: [(cjxM,
                       label: block_cjxM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjxM: // global
           if (R1 & 7 == 1) goto cjxP; else goto cjxQ;
       cjxP: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjxQ: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.909207739 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c==_closure" {
     GHC.Base.$fEqNonEmpty_$c==_closure:
         const GHC.Base.$fEqNonEmpty_$c==_info;
 },
 GHC.Base.$fEqNonEmpty_$c==_entry() //  [R2, R3, R4]
         { info_tbl: [(cjym,
                       label: GHC.Base.$fEqNonEmpty_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjym: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjyq; else goto cjyr;
       cjyq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjyr: // global
           I64[Sp - 24] = block_cjyj_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujyz; else goto cjyk;
       ujyz: // global
           call _cjyj(R1) args: 0, res: 0, upd: 0;
       cjyk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjyj() //  [R1]
         { info_tbl: [(cjyj,
                       label: block_cjyj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjyj: // global
           I64[Sp - 8] = block_cjyp_info;
           _sh5e::P64 = P64[R1 + 7];
           _sh5f::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh5f::P64;
           P64[Sp + 16] = _sh5e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujyy; else goto cjyt;
       ujyy: // global
           call _cjyp(R1) args: 0, res: 0, upd: 0;
       cjyt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjyp() //  [R1]
         { info_tbl: [(cjyp,
                       label: block_cjyp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjyp: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c==_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.917233681 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_closure" {
     GHC.Base.$fEqNonEmpty_closure:
         const GHC.Base.$fEqNonEmpty_info;
 },
 sat_sh5l_entry() //  [R1, R2, R3]
         { info_tbl: [(cjyY,
                       label: sat_sh5l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjyY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c/=_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh5k_entry() //  [R1, R2, R3]
         { info_tbl: [(cjz6,
                       label: sat_sh5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjz6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c==_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fEqNonEmpty_entry() //  [R2]
         { info_tbl: [(cjza,
                       label: GHC.Base.$fEqNonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjza: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cjze; else goto cjzd;
       cjze: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjzd: // global
           I64[Hp - 48] = sat_sh5l_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sh5k_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.925421064 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cp1Ord_closure" {
     GHC.Base.$fOrdNonEmpty_$cp1Ord_closure:
         const GHC.Base.$fOrdNonEmpty_$cp1Ord_info;
 },
 sat_sh5n_entry() //  [R1]
         { info_tbl: [(cjzD,
                       label: sat_sh5n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjzD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjzE; else goto cjzF;
       cjzE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjzF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdNonEmpty_$cp1Ord_entry() //  [R2]
         { info_tbl: [(cjzG,
                       label: GHC.Base.$fOrdNonEmpty_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjzG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjzK; else goto cjzJ;
       cjzK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjzJ: // global
           I64[Hp - 16] = sat_sh5n_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqNonEmpty_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.93135362 UTC

[section ""data" . GHC.Base.$w$ccompare_closure" {
     GHC.Base.$w$ccompare_closure:
         const GHC.Base.$w$ccompare_info;
 },
 GHC.Base.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cjA6,
                       label: GHC.Base.$w$ccompare_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjA6: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjA7; else goto cjA8;
       cjA7: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjA8: // global
           I64[Sp - 32] = block_cjzZ_info;
           _sh5o::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _sh5o::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjzZ() //  [R1]
         { info_tbl: [(cjzZ,
                       label: block_cjzZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjzZ: // global
           _cjA5::P64 = R1 & 7;
           if (_cjA5::P64 < 3) goto ujAi; else goto cjA4;
       ujAi: // global
           if (_cjA5::P64 < 2) goto cjA2; else goto cjA3;
       cjA2: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjA3: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
       cjA4: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.937843781 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$ccompare_closure" {
     GHC.Base.$fOrdNonEmpty_$ccompare_closure:
         const GHC.Base.$fOrdNonEmpty_$ccompare_info;
 },
 GHC.Base.$fOrdNonEmpty_$ccompare_entry() //  [R2, R3, R4]
         { info_tbl: [(cjAF,
                       label: GHC.Base.$fOrdNonEmpty_$ccompare_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjAF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjAJ; else goto cjAK;
       cjAJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjAK: // global
           I64[Sp - 24] = block_cjAC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujAS; else goto cjAD;
       ujAS: // global
           call _cjAC(R1) args: 0, res: 0, upd: 0;
       cjAD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjAC() //  [R1]
         { info_tbl: [(cjAC,
                       label: block_cjAC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjAC: // global
           I64[Sp - 8] = block_cjAI_info;
           _sh5y::P64 = P64[R1 + 7];
           _sh5z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh5z::P64;
           P64[Sp + 16] = _sh5y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujAR; else goto cjAM;
       ujAR: // global
           call _cjAI(R1) args: 0, res: 0, upd: 0;
       cjAM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjAI() //  [R1]
         { info_tbl: [(cjAI,
                       label: block_cjAI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjAI: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.945696923 UTC

[section ""data" . GHC.Base.$w$c<_closure" {
     GHC.Base.$w$c<_closure:
         const GHC.Base.$w$c<_info;
 },
 GHC.Base.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cjBj,
                       label: GHC.Base.$w$c<_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjBj: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjBk; else goto cjBl;
       cjBk: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjBl: // global
           I64[Sp - 32] = block_cjBc_info;
           _sh5D::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _sh5D::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjBc() //  [R1]
         { info_tbl: [(cjBc,
                       label: block_cjBc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjBc: // global
           _cjBi::P64 = R1 & 7;
           if (_cjBi::P64 < 3) goto ujBv; else goto cjBh;
       ujBv: // global
           if (_cjBi::P64 < 2) goto cjBf; else goto cjBg;
       cjBf: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjBg: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       cjBh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.95215498 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<_closure" {
     GHC.Base.$fOrdNonEmpty_$c<_closure:
         const GHC.Base.$fOrdNonEmpty_$c<_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<_entry() //  [R2, R3, R4]
         { info_tbl: [(cjBS,
                       label: GHC.Base.$fOrdNonEmpty_$c<_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjBS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjBW; else goto cjBX;
       cjBW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjBX: // global
           I64[Sp - 24] = block_cjBP_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujC5; else goto cjBQ;
       ujC5: // global
           call _cjBP(R1) args: 0, res: 0, upd: 0;
       cjBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjBP() //  [R1]
         { info_tbl: [(cjBP,
                       label: block_cjBP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjBP: // global
           I64[Sp - 8] = block_cjBV_info;
           _sh5N::P64 = P64[R1 + 7];
           _sh5O::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh5O::P64;
           P64[Sp + 16] = _sh5N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujC4; else goto cjBZ;
       ujC4: // global
           call _cjBV(R1) args: 0, res: 0, upd: 0;
       cjBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjBV() //  [R1]
         { info_tbl: [(cjBV,
                       label: block_cjBV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjBV: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.959874472 UTC

[section ""data" . GHC.Base.$w$c<=_closure" {
     GHC.Base.$w$c<=_closure:
         const GHC.Base.$w$c<=_info;
 },
 GHC.Base.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cjCw,
                       label: GHC.Base.$w$c<=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjCw: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjCx; else goto cjCy;
       cjCx: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjCy: // global
           I64[Sp - 32] = block_cjCp_info;
           _sh5S::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R5;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _sh5S::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjCp() //  [R1]
         { info_tbl: [(cjCp,
                       label: block_cjCp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjCp: // global
           _cjCv::P64 = R1 & 7;
           if (_cjCv::P64 < 3) goto ujCU; else goto ujCV;
       ujCU: // global
           if (_cjCv::P64 < 2) goto ujCW; else goto cjCt;
       ujCW: // global
           Sp = Sp + 32;
           call _cjCP() args: 0, res: 0, upd: 0;
       cjCt: // global
           _sh5W::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cjCE_info;
           R4 = P64[Sp + 16];
           R3 = _sh5W::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ujCV: // global
           Sp = Sp + 32;
           call _cjCu() args: 0, res: 0, upd: 0;
     }
 },
 _cjCE() //  [R1]
         { info_tbl: [(cjCE,
                       label: block_cjCE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjCE: // global
           if (R1 & 7 == 1) goto ujCX; else goto ujCY;
       ujCX: // global
           Sp = Sp + 8;
           call _cjCP() args: 0, res: 0, upd: 0;
       ujCY: // global
           Sp = Sp + 8;
           call _cjCu() args: 0, res: 0, upd: 0;
     }
 },
 _cjCP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjCP: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjCu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjCu: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.970129132 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<=_closure" {
     GHC.Base.$fOrdNonEmpty_$c<=_closure:
         const GHC.Base.$fOrdNonEmpty_$c<=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<=_entry() //  [R2, R3, R4]
         { info_tbl: [(cjDz,
                       label: GHC.Base.$fOrdNonEmpty_$c<=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjDz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjDD; else goto cjDE;
       cjDD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjDE: // global
           I64[Sp - 24] = block_cjDw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujDM; else goto cjDx;
       ujDM: // global
           call _cjDw(R1) args: 0, res: 0, upd: 0;
       cjDx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjDw() //  [R1]
         { info_tbl: [(cjDw,
                       label: block_cjDw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjDw: // global
           I64[Sp - 8] = block_cjDC_info;
           _sh63::P64 = P64[R1 + 7];
           _sh64::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh64::P64;
           P64[Sp + 16] = _sh63::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujDL; else goto cjDG;
       ujDL: // global
           call _cjDC(R1) args: 0, res: 0, upd: 0;
       cjDG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjDC() //  [R1]
         { info_tbl: [(cjDC,
                       label: block_cjDC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjDC: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.978273544 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmax_closure" {
     GHC.Base.$fOrdNonEmpty_$cmax_closure:
         const GHC.Base.$fOrdNonEmpty_$cmax_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmax_entry() //  [R2, R3, R4]
         { info_tbl: [(cjE9,
                       label: GHC.Base.$fOrdNonEmpty_$cmax_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjE9: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cjEd; else goto cjEe;
       cjEd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjEe: // global
           I64[Sp - 24] = block_cjE6_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujET; else goto cjE7;
       ujET: // global
           call _cjE6(R1) args: 0, res: 0, upd: 0;
       cjE7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjE6() //  [R1]
         { info_tbl: [(cjE6,
                       label: block_cjE6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjE6: // global
           I64[Sp - 16] = block_cjEc_info;
           _sh6b::P64 = R1;
           _sh6c::P64 = P64[R1 + 7];
           _sh6d::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _sh6d::P64;
           P64[Sp] = _sh6c::P64;
           P64[Sp + 16] = _sh6b::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ujES; else goto cjEg;
       ujES: // global
           call _cjEc(R1) args: 0, res: 0, upd: 0;
       cjEg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjEc() //  [R1]
         { info_tbl: [(cjEc,
                       label: block_cjEc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjEc: // global
           I64[Sp - 8] = block_cjEk_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjEk() //  [R1]
         { info_tbl: [(cjEk,
                       label: block_cjEk_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjEk: // global
           _cjEL::P64 = R1 & 7;
           if (_cjEL::P64 < 3) goto ujEN; else goto ujEO;
       ujEN: // global
           if (_cjEL::P64 < 2) goto ujEP; else goto cjEw;
       ujEP: // global
           Sp = Sp + 40;
           call _cjEG() args: 0, res: 0, upd: 0;
       cjEw: // global
           _sh6d::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjEu_info;
           R4 = _sh6d::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ujEO: // global
           Sp = Sp + 24;
           call _cjEK() args: 0, res: 0, upd: 0;
     }
 },
 _cjEu() //  [R1]
         { info_tbl: [(cjEu,
                       label: block_cjEu_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjEu: // global
           if (R1 & 7 == 1) goto ujEQ; else goto ujER;
       ujEQ: // global
           Sp = Sp + 24;
           call _cjEG() args: 0, res: 0, upd: 0;
       ujER: // global
           Sp = Sp + 8;
           call _cjEK() args: 0, res: 0, upd: 0;
     }
 },
 _cjEG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjEG: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjEK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjEK: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:57.99134726 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmin_closure" {
     GHC.Base.$fOrdNonEmpty_$cmin_closure:
         const GHC.Base.$fOrdNonEmpty_$cmin_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmin_entry() //  [R2, R3, R4]
         { info_tbl: [(cjFH,
                       label: GHC.Base.$fOrdNonEmpty_$cmin_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjFH: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cjFL; else goto cjFM;
       cjFL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjFM: // global
           I64[Sp - 24] = block_cjFE_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujGr; else goto cjFF;
       ujGr: // global
           call _cjFE(R1) args: 0, res: 0, upd: 0;
       cjFF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjFE() //  [R1]
         { info_tbl: [(cjFE,
                       label: block_cjFE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjFE: // global
           I64[Sp - 16] = block_cjFK_info;
           _sh6m::P64 = R1;
           _sh6n::P64 = P64[R1 + 7];
           _sh6o::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _sh6o::P64;
           P64[Sp] = _sh6n::P64;
           P64[Sp + 16] = _sh6m::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ujGq; else goto cjFO;
       ujGq: // global
           call _cjFK(R1) args: 0, res: 0, upd: 0;
       cjFO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjFK() //  [R1]
         { info_tbl: [(cjFK,
                       label: block_cjFK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjFK: // global
           I64[Sp - 8] = block_cjFS_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjFS() //  [R1]
         { info_tbl: [(cjFS,
                       label: block_cjFS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjFS: // global
           _cjGj::P64 = R1 & 7;
           if (_cjGj::P64 < 3) goto ujGl; else goto ujGm;
       ujGl: // global
           if (_cjGj::P64 < 2) goto ujGn; else goto cjG4;
       ujGn: // global
           Sp = Sp + 24;
           call _cjGe() args: 0, res: 0, upd: 0;
       cjG4: // global
           _sh6o::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjG2_info;
           R4 = _sh6o::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ujGm: // global
           Sp = Sp + 40;
           call _cjGi() args: 0, res: 0, upd: 0;
     }
 },
 _cjG2() //  [R1]
         { info_tbl: [(cjG2,
                       label: block_cjG2_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjG2: // global
           if (R1 & 7 == 1) goto ujGo; else goto ujGp;
       ujGo: // global
           Sp = Sp + 8;
           call _cjGe() args: 0, res: 0, upd: 0;
       ujGp: // global
           Sp = Sp + 24;
           call _cjGi() args: 0, res: 0, upd: 0;
     }
 },
 _cjGe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjGe: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjGi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjGi: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.006591665 UTC

[section ""data" . GHC.Base.$w$c>=_closure" {
     GHC.Base.$w$c>=_closure:
         const GHC.Base.$w$c>=_info;
 },
 GHC.Base.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cjHj,
                       label: GHC.Base.$w$c>=_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjHj: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjHk; else goto cjHl;
       cjHk: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjHl: // global
           I64[Sp - 32] = block_cjHc_info;
           _sh6u::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _sh6u::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cjHc() //  [R1]
         { info_tbl: [(cjHc,
                       label: block_cjHc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjHc: // global
           _cjHi::P64 = R1 & 7;
           if (_cjHi::P64 < 3) goto ujHH; else goto ujHI;
       ujHH: // global
           if (_cjHi::P64 < 2) goto ujHJ; else goto cjHg;
       ujHJ: // global
           Sp = Sp + 32;
           call _cjHC() args: 0, res: 0, upd: 0;
       cjHg: // global
           _sh6y::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cjHr_info;
           R4 = _sh6y::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ujHI: // global
           Sp = Sp + 32;
           call _cjHh() args: 0, res: 0, upd: 0;
     }
 },
 _cjHr() //  [R1]
         { info_tbl: [(cjHr,
                       label: block_cjHr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjHr: // global
           if (R1 & 7 == 1) goto ujHK; else goto ujHL;
       ujHK: // global
           Sp = Sp + 8;
           call _cjHC() args: 0, res: 0, upd: 0;
       ujHL: // global
           Sp = Sp + 8;
           call _cjHh() args: 0, res: 0, upd: 0;
     }
 },
 _cjHC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjHC: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjHh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjHh: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.016237101 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c>=_closure" {
     GHC.Base.$fOrdNonEmpty_$c>=_closure:
         const GHC.Base.$fOrdNonEmpty_$c>=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cjIm,
                       label: GHC.Base.$fOrdNonEmpty_$c>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjIm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjIq; else goto cjIr;
       cjIq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjIr: // global
           I64[Sp - 24] = block_cjIj_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujIz; else goto cjIk;
       ujIz: // global
           call _cjIj(R1) args: 0, res: 0, upd: 0;
       cjIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjIj() //  [R1]
         { info_tbl: [(cjIj,
                       label: block_cjIj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjIj: // global
           I64[Sp - 8] = block_cjIp_info;
           _sh6F::P64 = P64[R1 + 7];
           _sh6G::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh6G::P64;
           P64[Sp + 16] = _sh6F::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujIy; else goto cjIt;
       ujIy: // global
           call _cjIp(R1) args: 0, res: 0, upd: 0;
       cjIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjIp() //  [R1]
         { info_tbl: [(cjIp,
                       label: block_cjIp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjIp: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c>=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.024484674 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_closure" {
     GHC.Base.$fOrdNonEmpty_closure:
         const GHC.Base.$fOrdNonEmpty_info;
 },
 sat_sh6U_entry() //  [R1, R2, R3]
         { info_tbl: [(cjIY,
                       label: sat_sh6U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjIY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmin_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh6T_entry() //  [R1, R2, R3]
         { info_tbl: [(cjJ6,
                       label: sat_sh6T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjJ6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmax_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh6S_entry() //  [R1, R2, R3]
         { info_tbl: [(cjJe,
                       label: sat_sh6S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjJe: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c>=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh6R_entry() //  [R1, R2, R3]
         { info_tbl: [(cjJm,
                       label: sat_sh6R_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjJm: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh6O_entry() //  [R1, R2, R3]
         { info_tbl: [(cjJu,
                       label: sat_sh6O_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjJu: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh6N_entry() //  [R1, R2, R3]
         { info_tbl: [(cjJC,
                       label: sat_sh6N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjJC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh6M_entry() //  [R1, R2, R3]
         { info_tbl: [(cjJK,
                       label: sat_sh6M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjJK: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$ccompare_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh6L_entry() //  [R1]
         { info_tbl: [(cjJR,
                       label: sat_sh6L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjJR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjJS; else goto cjJT;
       cjJS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjJT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdNonEmpty_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fOrdNonEmpty_entry() //  [R2]
         { info_tbl: [(cjJV,
                       label: GHC.Base.$fOrdNonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjJV: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cjJZ; else goto cjJY;
       cjJZ: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjJY: // global
           I64[Hp - 200] = sat_sh6U_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sh6T_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sh6S_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sh6R_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sh6O_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sh6N_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sh6M_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sh6L_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.042680787 UTC

[section ""data" . GHC.Base.$fMonadIO_$cfail_closure" {
     GHC.Base.$fMonadIO_$cfail_closure:
         const GHC.Base.$fMonadIO_$cfail_info;
         const 0;
 },
 GHC.Base.$fMonadIO_$cfail_entry() //  [R2]
         { info_tbl: [(cjKQ,
                       label: GHC.Base.$fMonadIO_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjKQ: // global
           R2 = R2;
           R1 = GHC.IO.failIO_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.046015019 UTC

[section ""data" . GHC.Base.$fMonadIO_closure" {
     GHC.Base.$fMonadIO_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fMonadIO1_closure+3;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fMonadIO_$cfail_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.047904597 UTC

[section ""data" . GHC.Base.$fMonad[]_$cfail_closure" {
     GHC.Base.$fMonad[]_$cfail_closure:
         const GHC.Base.$fMonad[]_$cfail_info;
 },
 GHC.Base.$fMonad[]_$cfail_entry() //  []
         { info_tbl: [(cjL2,
                       label: GHC.Base.$fMonad[]_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjL2: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.051022908 UTC

[section ""data" . GHC.Base.$fMonad[]_closure" {
     GHC.Base.$fMonad[]_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Base.$fMonad[]_$c>>=_closure+2;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fMonad[]_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.05279811 UTC

[section ""data" . GHC.Base.$fMonadPlus[]_closure" {
     GHC.Base.$fMonadPlus[]_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternative[]_closure+1;
         const GHC.Base.$fMonad[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.054951323 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$c>>=_closure" {
     GHC.Base.$fMonadMaybe_$c>>=_closure:
         const GHC.Base.$fMonadMaybe_$c>>=_info;
 },
 GHC.Base.$fMonadMaybe_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(cjLo,
                       label: GHC.Base.$fMonadMaybe_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjLo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjLp; else goto cjLq;
       cjLp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadMaybe_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjLq: // global
           I64[Sp - 16] = block_cjLh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ujLx; else goto cjLi;
       ujLx: // global
           call _cjLh(R1) args: 0, res: 0, upd: 0;
       cjLi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjLh() //  [R1]
         { info_tbl: [(cjLh,
                       label: block_cjLh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjLh: // global
           if (R1 & 7 == 1) goto cjLl; else goto cjLm;
       cjLl: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjLm: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.060612502 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$cfail_closure" {
     GHC.Base.$fMonadMaybe_$cfail_closure:
         const GHC.Base.$fMonadMaybe_$cfail_info;
 },
 GHC.Base.$fMonadMaybe_$cfail_entry() //  []
         { info_tbl: [(cjLP,
                       label: GHC.Base.$fMonadMaybe_$cfail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjLP: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.064062839 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>=_closure" {
     GHC.Base.$fMonad(->)_$c>>=_closure:
         const GHC.Base.$fMonad(->)_$c>>=_info;
 },
 GHC.Base.$fMonad(->)_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cjM2,
                       label: GHC.Base.$fMonad(->)_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjM2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cjM6; else goto cjM5;
       cjM6: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(->)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjM5: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sh73::P64 = R3;
           R3 = R4;
           R2 = Hp - 24;
           R1 = _sh73::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.068253991 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>=_closure" {
     GHC.Base.$fMonad(,)_$c>>=_closure:
         const GHC.Base.$fMonad(,)_$c>>=_info;
 },
 sat_sh7g_entry() //  [R1]
         { info_tbl: [(cjMv,
                       label: sat_sh7g_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjMv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjMw; else goto cjMx;
       cjMw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjMx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cjMt_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cjMt() //  [R1]
         { info_tbl: [(cjMt,
                       label: block_cjMt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjMt: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_$c>>=_entry() //  [R2, R3, R4]
         { info_tbl: [(cjMB,
                       label: GHC.Base.$fMonad(,)_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjMB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjMD; else goto cjME;
       cjMD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjME: // global
           I64[Sp - 24] = block_cjMg_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujMJ; else goto cjMh;
       ujMJ: // global
           call _cjMg(R1) args: 0, res: 0, upd: 0;
       cjMh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjMg() //  [R1]
         { info_tbl: [(cjMg,
                       label: block_cjMg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjMg: // global
           I64[Sp] = block_cjMl_info;
           R2 = P64[R1 + 15];
           _sh7a::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sh7a::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjMl() //  [R1]
         { info_tbl: [(cjMl,
                       label: block_cjMl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjMl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cjMI; else goto cjMH;
       cjMI: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjMH: // global
           _sh7d::P64 = P64[R1 + 7];
           _sh7e::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sh7g_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh7d::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _sh7e::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.080006345 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*>_closure" {
     GHC.Base.$fApplicative(,)_$c<*>_closure:
         const GHC.Base.$fApplicative(,)_$c<*>_info;
 },
 sat_sh7r_entry() //  [R1]
         { info_tbl: [(cjNB,
                       label: sat_sh7r_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjNB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjNC; else goto cjND;
       cjNC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjND: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cjNz_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cjNz() //  [R1]
         { info_tbl: [(cjNz,
                       label: block_cjNz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjNz: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(cjNH,
                       label: GHC.Base.$fApplicative(,)_$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjNH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjNJ; else goto cjNK;
       cjNJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjNK: // global
           I64[Sp - 24] = block_cjNk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujNQ; else goto cjNl;
       ujNQ: // global
           call _cjNk(R1) args: 0, res: 0, upd: 0;
       cjNl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjNk() //  [R1]
         { info_tbl: [(cjNk,
                       label: block_cjNk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjNk: // global
           I64[Sp - 8] = block_cjNp_info;
           _sh7l::P64 = P64[R1 + 7];
           _sh7m::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh7m::P64;
           P64[Sp + 16] = _sh7l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujNP; else goto cjNq;
       ujNP: // global
           call _cjNp(R1) args: 0, res: 0, upd: 0;
       cjNq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjNp() //  [R1]
         { info_tbl: [(cjNp,
                       label: block_cjNp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjNp: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cjNO; else goto cjNN;
       cjNO: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjNN: // global
           _sh7o::P64 = P64[R1 + 7];
           _sh7p::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sh7p::P64;
           I64[Hp - 56] = sat_sh7r_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sh7o::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.091699188 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c*>_closure" {
     GHC.Base.$fApplicative(,)_$c*>_closure:
         const GHC.Base.$fApplicative(,)_$c*>_info;
 },
 sat_sh7D_entry() //  [R1]
         { info_tbl: [(cjOL,
                       label: sat_sh7D_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjOM; else goto cjON;
       cjOM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjON: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cjOJ_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cjOJ() //  [R1]
         { info_tbl: [(cjOJ,
                       label: block_cjOJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$c*>_entry() //  [R2, R3, R4]
         { info_tbl: [(cjOR,
                       label: GHC.Base.$fApplicative(,)_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjOT; else goto cjOU;
       cjOT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjOU: // global
           I64[Sp - 24] = block_cjOv_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujP0; else goto cjOw;
       ujP0: // global
           call _cjOv(R1) args: 0, res: 0, upd: 0;
       cjOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjOv() //  [R1]
         { info_tbl: [(cjOv,
                       label: block_cjOv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOv: // global
           I64[Sp] = block_cjOA_info;
           _sh7x::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sh7x::P64;
           if (R1 & 7 != 0) goto ujOZ; else goto cjOB;
       ujOZ: // global
           call _cjOA(R1) args: 0, res: 0, upd: 0;
       cjOB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjOA() //  [R1]
         { info_tbl: [(cjOA,
                       label: block_cjOA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjOA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cjOY; else goto cjOX;
       cjOY: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjOX: // global
           _sh7A::P64 = P64[R1 + 7];
           _sh7B::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sh7D_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh7A::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _sh7B::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.103234285 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$cliftA2_closure" {
     GHC.Base.$fApplicative(,)_$cliftA2_closure:
         const GHC.Base.$fApplicative(,)_$cliftA2_info;
 },
 sat_sh7P_entry() //  [R1]
         { info_tbl: [(cjPT,
                       label: sat_sh7P_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjPU; else goto cjPV;
       cjPU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjPV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cjPR_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cjPR() //  [R1]
         { info_tbl: [(cjPR,
                       label: block_cjPR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPR: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicative(,)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cjPZ,
                       label: GHC.Base.$fApplicative(,)_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjQ1; else goto cjQ2;
       cjQ1: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjQ2: // global
           I64[Sp - 32] = block_cjPC_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ujQ8; else goto cjPD;
       ujQ8: // global
           call _cjPC(R1) args: 0, res: 0, upd: 0;
       cjPD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjPC() //  [R1]
         { info_tbl: [(cjPC,
                       label: block_cjPC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPC: // global
           I64[Sp - 8] = block_cjPH_info;
           _sh7J::P64 = P64[R1 + 7];
           _sh7K::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sh7K::P64;
           P64[Sp + 24] = _sh7J::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujQ7; else goto cjPI;
       ujQ7: // global
           call _cjPH(R1) args: 0, res: 0, upd: 0;
       cjPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjPH() //  [R1]
         { info_tbl: [(cjPH,
                       label: block_cjPH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjPH: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cjQ6; else goto cjQ5;
       cjQ6: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjQ5: // global
           _sh7M::P64 = P64[R1 + 7];
           _sh7N::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sh7N::P64;
           I64[Hp - 56] = sat_sh7P_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sh7M::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.116263508 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmempty_info;
 },
 sat_sh80_entry() //  [R1]
         { info_tbl: [(cjQS,
                       label: sat_sh80_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjQS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjQT; else goto cjQU;
       cjQT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjQU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh7Z_entry() //  [R1]
         { info_tbl: [(cjQZ,
                       label: sat_sh7Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjQZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjR0; else goto cjR1;
       cjR0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjR1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh7Y_entry() //  [R1]
         { info_tbl: [(cjR6,
                       label: sat_sh7Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjR6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjR7; else goto cjR8;
       cjR7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjR8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh7X_entry() //  [R1]
         { info_tbl: [(cjRd,
                       label: sat_sh7X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjRd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjRe; else goto cjRf;
       cjRe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjRf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh7W_entry() //  [R1]
         { info_tbl: [(cjRk,
                       label: sat_sh7W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjRk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjRl; else goto cjRm;
       cjRl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjRm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cmempty_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cjRo,
                       label: GHC.Base.$fMonoid(,,,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjRo: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cjRs; else goto cjRr;
       cjRs: // global
           HpAlloc = 168;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmempty_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjRr: // global
           I64[Hp - 160] = sat_sh80_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_sh7Z_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_sh7Y_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sh7X_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sh7W_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.129901944 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,)_$cmempty_info;
 },
 sat_sh88_entry() //  [R1]
         { info_tbl: [(cjSg,
                       label: sat_sh88_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjSg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjSh; else goto cjSi;
       cjSh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjSi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh87_entry() //  [R1]
         { info_tbl: [(cjSn,
                       label: sat_sh87_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjSn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjSo; else goto cjSp;
       cjSo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjSp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh86_entry() //  [R1]
         { info_tbl: [(cjSu,
                       label: sat_sh86_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjSu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjSv; else goto cjSw;
       cjSv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjSw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh85_entry() //  [R1]
         { info_tbl: [(cjSB,
                       label: sat_sh85_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjSB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjSC; else goto cjSD;
       cjSC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjSD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_$cmempty_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cjSF,
                       label: GHC.Base.$fMonoid(,,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjSF: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cjSJ; else goto cjSI;
       cjSJ: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmempty_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjSI: // global
           I64[Hp - 128] = sat_sh88_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_sh87_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_sh86_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sh85_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.142418219 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,)_$cmempty_info;
 },
 sat_sh8e_entry() //  [R1]
         { info_tbl: [(cjTq,
                       label: sat_sh8e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjTq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjTr; else goto cjTs;
       cjTr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjTs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh8d_entry() //  [R1]
         { info_tbl: [(cjTx,
                       label: sat_sh8d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjTx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjTy; else goto cjTz;
       cjTy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjTz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh8c_entry() //  [R1]
         { info_tbl: [(cjTE,
                       label: sat_sh8c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjTE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjTF; else goto cjTG;
       cjTF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjTG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmempty_entry() //  [R2, R3, R4]
         { info_tbl: [(cjTI,
                       label: GHC.Base.$fMonoid(,,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjTI: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cjTM; else goto cjTL;
       cjTM: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmempty_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjTL: // global
           I64[Hp - 96] = sat_sh8e_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sh8d_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sh8c_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.153157177 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,)_$cmempty_info;
 },
 sat_sh8i_entry() //  [R1]
         { info_tbl: [(cjUm,
                       label: sat_sh8i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjUm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjUn; else goto cjUo;
       cjUn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjUo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh8h_entry() //  [R1]
         { info_tbl: [(cjUt,
                       label: sat_sh8h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjUt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjUu; else goto cjUv;
       cjUu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjUv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cmempty_entry() //  [R2, R3]
         { info_tbl: [(cjUx,
                       label: GHC.Base.$fMonoid(,)_$cmempty_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjUx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cjUB; else goto cjUA;
       cjUB: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjUA: // global
           I64[Hp - 64] = sat_sh8i_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sh8h_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.16222305 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,)_$cmconcat_info;
 },
 $dSemigroup_sh8m_entry() //  [R1]
         { info_tbl: [(cjV4,
                       label: $dSemigroup_sh8m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjV4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjV5; else goto cjV6;
       cjV5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjV6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup1_sh8n_entry() //  [R1]
         { info_tbl: [(cjVb,
                       label: $dSemigroup1_sh8n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjVc; else goto cjVd;
       cjVc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjVd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_sh8o_entry() //  [R1]
         { info_tbl: [(cjVi,
                       label: z_sh8o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjVj; else goto cjVk;
       cjVj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjVk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_sh8p_entry() //  [R1]
         { info_tbl: [(cjVp,
                       label: z1_sh8p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjVq; else goto cjVr;
       cjVq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjVr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sh8D_entry() //  [R1]
         { info_tbl: [(cjVR,
                       label: sat_sh8D_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjVS; else goto cjVT;
       cjVS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjVT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sh8C_entry() //  [R1]
         { info_tbl: [(cjVY,
                       label: sat_sh8C_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjVZ; else goto cjW0;
       cjVZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjW0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_sh8r_entry() //  [R1, R2]
         { info_tbl: [(cjW5,
                       label: go_sh8r_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjW5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjW6; else goto cjW7;
       cjW6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjW7: // global
           I64[Sp - 40] = block_cjVy_info;
           _sh8r::P64 = R1;
           _sh8m::P64 = P64[R1 + 7];
           _sh8n::P64 = P64[R1 + 15];
           _sh8q::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sh8m::P64;
           P64[Sp - 24] = _sh8n::P64;
           P64[Sp - 16] = _sh8q::P64;
           P64[Sp - 8] = _sh8r::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ujWh; else goto cjVz;
       ujWh: // global
           call _cjVy(R1) args: 0, res: 0, upd: 0;
       cjVz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjVy() //  [R1]
         { info_tbl: [(cjVy,
                       label: block_cjVy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVy: // global
           if (R1 & 7 == 1) goto cjW2; else goto cjW3;
       cjW2: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjW3: // global
           I64[Sp] = block_cjVE_info;
           _sh8v::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sh8v::P64;
           if (R1 & 7 != 0) goto ujWg; else goto cjVF;
       ujWg: // global
           call _cjVE(R1) args: 0, res: 0, upd: 0;
       cjVF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjVE() //  [R1]
         { info_tbl: [(cjVE,
                       label: block_cjVE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVE: // global
           I64[Sp] = block_cjVJ_info;
           R2 = P64[Sp + 24];
           _sh8x::P64 = P64[R1 + 7];
           _sh8y::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sh8y::P64;
           P64[Sp + 32] = _sh8x::P64;
           call go_sh8r_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjVJ() //  [R1]
         { info_tbl: [(cjVJ,
                       label: block_cjVJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjVJ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cjWf; else goto cjWe;
       cjWf: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjWe: // global
           _sh8A::P64 = P64[R1 + 7];
           _sh8B::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sh8D_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = _sh8B::P64;
           I64[Hp - 56] = sat_sh8C_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sh8A::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,)_$cmconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(cjWi,
                       label: GHC.Base.$fMonoid(,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjWi: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cjWm; else goto cjWl;
       cjWm: // global
           HpAlloc = 152;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjWl: // global
           I64[Hp - 144] = $dSemigroup_sh8m_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = $dSemigroup1_sh8n_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = z_sh8o_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = z1_sh8p_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = Hp - 96;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = go_sh8r_info;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 47;
           R2 = R4;
           R1 = Hp - 23;
           call go_sh8r_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.185144224 UTC

[section ""data" . GHC.Base.$fMonoid()_$cmconcat_closure" {
     GHC.Base.$fMonoid()_$cmconcat_closure:
         const GHC.Base.$fMonoid()_$cmconcat_info;
 },
 GHC.Base.$fMonoid()_$cmconcat_entry() //  []
         { info_tbl: [(cjXL,
                       label: GHC.Base.$fMonoid()_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjXL: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.189075348 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$c<>_closure" {
     GHC.Base.$fMonoidMaybe_$c<>_closure:
         const GHC.Base.$fMonoidMaybe_$c<>_info;
 },
 sat_sh8M_entry() //  [R1]
         { info_tbl: [(cjYe,
                       label: sat_sh8M_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjYe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjYf; else goto cjYg;
       cjYf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjYg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidMaybe_$c<>_entry() //  [R2, R3, R4]
         { info_tbl: [(cjYl,
                       label: GHC.Base.$fMonoidMaybe_$c<>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjYl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjYm; else goto cjYn;
       cjYm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjYn: // global
           I64[Sp - 24] = block_cjXY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujYC; else goto cjXZ;
       ujYC: // global
           call _cjXY(R1) args: 0, res: 0, upd: 0;
       cjXZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjXY() //  [R1]
         { info_tbl: [(cjXY,
                       label: block_cjXY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjXY: // global
           _sh8H::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjYi; else goto cjYj;
       cjYi: // global
           R1 = _sh8H::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjYj: // global
           I64[Sp - 8] = block_cjY4_info;
           _sh8I::P64 = R1;
           _sh8J::P64 = P64[R1 + 6];
           R1 = _sh8H::P64;
           P64[Sp] = _sh8J::P64;
           P64[Sp + 16] = _sh8I::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujYB; else goto cjY5;
       ujYB: // global
           call _cjY4(R1) args: 0, res: 0, upd: 0;
       cjY5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjY4() //  [R1]
         { info_tbl: [(cjY4,
                       label: block_cjY4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjY4: // global
           if (R1 & 7 == 1) goto cjYu; else goto cjYw;
       cjYu: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjYw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cjYz; else goto cjYy;
       cjYz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjYy: // global
           _sh8L::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sh8M_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sh8L::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.200675366 UTC

[section ""data" . GHC.Base.$w$csconcat5_closure" {
     GHC.Base.$w$csconcat5_closure:
         const GHC.Base.$w$csconcat5_info;
 },
 sat_sh90_entry() //  [R1]
         { info_tbl: [(cjZI,
                       label: sat_sh90_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjZI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjZJ; else goto cjZK;
       cjZJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjZK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_sh8Q_entry() //  [R1, R2, R3]
         { info_tbl: [(cjZP,
                       label: go_sh8Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjZP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjZQ; else goto uk0c;
       cjZQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uk0c: // global
           P64[Sp - 24] = R1;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cjZk() args: 0, res: 0, upd: 0;
     }
 },
 _cjZk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjZk: // global
           _sh8N::P64 = P64[P64[Sp] + 6];
           I64[Sp - 8] = block_cjZn_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sh8N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk0e; else goto cjZo;
       uk0e: // global
           call _cjZn(R1) args: 0, res: 0, upd: 0;
       cjZo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjZn() //  [R1]
         { info_tbl: [(cjZn,
                       label: block_cjZn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjZn: // global
           _sh8R::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjZM; else goto cjZN;
       cjZM: // global
           R1 = _sh8R::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjZN: // global
           I64[Sp - 8] = block_cjZt_info;
           _sh8U::P64 = P64[R1 + 6];
           _sh8V::P64 = P64[R1 + 14];
           R1 = _sh8R::P64;
           P64[Sp] = _sh8V::P64;
           P64[Sp + 16] = _sh8U::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk0f; else goto cjZu;
       uk0f: // global
           call _cjZt(R1) args: 0, res: 0, upd: 0;
       cjZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjZt() //  [R1]
         { info_tbl: [(cjZt,
                       label: block_cjZt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjZt: // global
           _sh8U::P64 = P64[Sp + 24];
           _sh8V::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cjZY; else goto ck00;
       cjZY: // global
           P64[Sp + 24] = _sh8U::P64;
           P64[Sp + 32] = _sh8V::P64;
           Sp = Sp + 16;
           call _cjZk() args: 0, res: 0, upd: 0;
       ck00: // global
           I64[Sp + 8] = block_cjZz_info;
           R3 = _sh8V::P64;
           R2 = _sh8U::P64;
           _sh8W::P64 = R1;
           _sh8X::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sh8X::P64;
           P64[Sp + 24] = _sh8W::P64;
           Sp = Sp + 8;
           call go_sh8Q_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjZz() //  [R1]
         { info_tbl: [(cjZz,
                       label: block_cjZz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cjZz: // global
           if (R1 & 7 == 1) goto ck04; else goto ck06;
       ck04: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ck06: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ck09; else goto ck08;
       ck09: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ck08: // global
           _sh8Z::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sh90_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sh8Z::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat5_entry() //  [R2, R3, R4]
         { info_tbl: [(ck0i,
                       label: GHC.Base.$w$csconcat5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck0i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ck0m; else goto ck0l;
       ck0m: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ck0l: // global
           I64[Hp - 8] = go_sh8Q_info;
           P64[Hp] = R2;
           _sh8O::P64 = R3;
           R3 = R4;
           R2 = _sh8O::P64;
           R1 = Hp - 6;
           call go_sh8Q_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.215590659 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_$csconcat_closure" {
     GHC.Base.$fSemigroupMaybe_$csconcat_closure:
         const GHC.Base.$fSemigroupMaybe_$csconcat_info;
 },
 GHC.Base.$fSemigroupMaybe_$csconcat_entry() //  [R2, R3]
         { info_tbl: [(ck1i,
                       label: GHC.Base.$fSemigroupMaybe_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck1i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck1j; else goto ck1k;
       ck1j: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ck1k: // global
           I64[Sp - 16] = block_ck1f_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uk1o; else goto ck1g;
       uk1o: // global
           call _ck1f(R1) args: 0, res: 0, upd: 0;
       ck1g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck1f() //  [R1]
         { info_tbl: [(ck1f,
                       label: block_ck1f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck1f: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat5_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.221366985 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_closure" {
     GHC.Base.$fSemigroupMaybe_closure:
         const GHC.Base.$fSemigroupMaybe_info;
         const 0;
 },
 sat_sh9a_entry() //  [R1, R2]
         { info_tbl: [(ck1I,
                       label: sat_sh9a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck1I: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh98_entry() //  [R1, R2]
         { info_tbl: [(ck1Q,
                       label: sat_sh98_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck1Q: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupMaybe_$csconcat_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh97_entry() //  [R1, R2, R3]
         { info_tbl: [(ck1Y,
                       label: sat_sh97_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck1Y: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroupMaybe_entry() //  [R2]
         { info_tbl: [(ck22,
                       label: GHC.Base.$fSemigroupMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck22: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ck26; else goto ck25;
       ck26: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck25: // global
           I64[Hp - 72] = sat_sh9a_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sh98_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sh97_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.23126957 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$cmconcat_closure" {
     GHC.Base.$fMonoidMaybe_$cmconcat_closure:
         const GHC.Base.$fMonoidMaybe_$cmconcat_info;
 },
 sat_sh9m_entry() //  [R1]
         { info_tbl: [(ck2W,
                       label: sat_sh9m_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck2W: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck2X; else goto ck2Y;
       ck2X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck2Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_sh9d_entry() //  [R1, R2]
         { info_tbl: [(ck33,
                       label: go_sh9d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck33: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ck34; else goto uk3q;
       ck34: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uk3q: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _ck2y() args: 0, res: 0, upd: 0;
     }
 },
 _ck2y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck2y: // global
           _sh9b::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_ck2B_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sh9b::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk3s; else goto ck2C;
       uk3s: // global
           call _ck2B(R1) args: 0, res: 0, upd: 0;
       ck2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck2B() //  [R1]
         { info_tbl: [(ck2B,
                       label: block_ck2B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck2B: // global
           if (R1 & 7 == 1) goto ck30; else goto ck31;
       ck30: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck31: // global
           I64[Sp - 8] = block_ck2H_info;
           _sh9h::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sh9h::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk3t; else goto ck2I;
       uk3t: // global
           call _ck2H(R1) args: 0, res: 0, upd: 0;
       ck2I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck2H() //  [R1]
         { info_tbl: [(ck2H,
                       label: block_ck2H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck2H: // global
           _sh9h::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ck3c; else goto ck3e;
       ck3c: // global
           P64[Sp + 24] = _sh9h::P64;
           Sp = Sp + 16;
           call _ck2y() args: 0, res: 0, upd: 0;
       ck3e: // global
           I64[Sp] = block_ck2N_info;
           R2 = _sh9h::P64;
           _sh9i::P64 = R1;
           _sh9j::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _sh9j::P64;
           P64[Sp + 16] = _sh9i::P64;
           call go_sh9d_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck2N() //  [R1]
         { info_tbl: [(ck2N,
                       label: block_ck2N_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck2N: // global
           if (R1 & 7 == 1) goto ck3i; else goto ck3k;
       ck3i: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ck3k: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ck3n; else goto ck3m;
       ck3n: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ck3m: // global
           _sh9l::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sh9m_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sh9l::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoidMaybe_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(ck3w,
                       label: GHC.Base.$fMonoidMaybe_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck3w: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ck3A; else goto ck3z;
       ck3A: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ck3z: // global
           I64[Hp - 8] = go_sh9d_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_sh9d_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.246415646 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_closure" {
     GHC.Base.$fMonoidMaybe_closure:
         const GHC.Base.$fMonoidMaybe_info;
         const 0;
 },
 sat_sh9q_entry() //  [R1, R2]
         { info_tbl: [(ck4x,
                       label: sat_sh9q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck4x: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoidMaybe_$cmconcat_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh9p_entry() //  [R1, R2, R3]
         { info_tbl: [(ck4F,
                       label: sat_sh9p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck4F: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sh9o_entry() //  [R1]
         { info_tbl: [(ck4M,
                       label: sat_sh9o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck4M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck4N; else goto ck4O;
       ck4N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck4O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoidMaybe_entry() //  [R2]
         { info_tbl: [(ck4Q,
                       label: GHC.Base.$fMonoidMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck4Q: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ck4U; else goto ck4T;
       ck4U: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck4T: // global
           I64[Hp - 88] = sat_sh9q_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sh9p_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sh9o_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.255426581 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_$c<>_closure" {
     GHC.Base.$fMonoidOrdering_$c<>_closure:
         const GHC.Base.$fMonoidOrdering_$c<>_info;
 },
 GHC.Base.$fMonoidOrdering_$c<>_entry() //  [R2, R3]
         { info_tbl: [(ck5v,
                       label: GHC.Base.$fMonoidOrdering_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck5v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck5w; else goto ck5x;
       ck5w: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ck5x: // global
           I64[Sp - 16] = block_ck5n_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uk5I; else goto ck5o;
       uk5I: // global
           call _ck5n(R1) args: 0, res: 0, upd: 0;
       ck5o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck5n() //  [R1]
         { info_tbl: [(ck5n,
                       label: block_ck5n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck5n: // global
           _ck5u::P64 = R1 & 7;
           if (_ck5u::P64 < 3) goto uk5H; else goto ck5t;
       uk5H: // global
           if (_ck5u::P64 < 2) goto ck5r; else goto ck5s;
       ck5r: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck5s: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ck5t: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.261690587 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_go_closure" {
     GHC.Base.$fMonoidOrdering_go_closure:
         const GHC.Base.$fMonoidOrdering_go_info;
 },
 GHC.Base.$fMonoidOrdering_go_entry() //  [R2]
         { info_tbl: [(ck6b,
                       label: GHC.Base.$fMonoidOrdering_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck6b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck6c; else goto uk6C;
       ck6c: // global
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uk6C: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _ck61() args: 0, res: 0, upd: 0;
     }
 },
 _ck61() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck61: // global
           _sh9u::P64 = P64[Sp];
           I64[Sp] = block_ck64_info;
           R1 = _sh9u::P64;
           if (R1 & 7 != 0) goto uk6E; else goto ck65;
       uk6E: // global
           call _ck64(R1) args: 0, res: 0, upd: 0;
       ck65: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck64() //  [R1]
         { info_tbl: [(ck64,
                       label: block_ck64_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck64: // global
           if (R1 & 7 == 1) goto ck68; else goto ck69;
       ck68: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck69: // global
           I64[Sp - 8] = block_ck6j_info;
           _sh9x::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sh9x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk6F; else goto ck6l;
       uk6F: // global
           call _ck6j(R1) args: 0, res: 0, upd: 0;
       ck6l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck6j() //  [R1]
         { info_tbl: [(ck6j,
                       label: block_ck6j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck6j: // global
           _ck6A::P64 = R1 & 7;
           if (_ck6A::P64 < 3) goto uk6B; else goto ck6z;
       uk6B: // global
           if (_ck6A::P64 < 2) goto ck6r; else goto ck6v;
       ck6r: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck6v: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _ck61() args: 0, res: 0, upd: 0;
       ck6z: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.270896604 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_closure" {
     GHC.Base.$fSemigroupOrdering_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fSemigroupOrdering_$csconcat_closure+1;
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fMonoidOrdering_closure" {
     GHC.Base.$fMonoidOrdering_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroupOrdering_closure+1;
         const GHC.Types.EQ_closure+2;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fMonoidOrdering_go_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupOrdering_$cstimes_closure" {
     GHC.Base.$fSemigroupOrdering_$cstimes_closure:
         const GHC.Base.$fSemigroupOrdering_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupOrdering_$cstimes_entry() //  [R2]
         { info_tbl: [(ck7d,
                       label: GHC.Base.$fSemigroupOrdering_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck7d: // global
           R3 = GHC.Base.$fMonoidOrdering_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.277060272 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,,)_$c<>_info;
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck7n: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sh9X_entry() //  [R1]
         { info_tbl: [(ck7F,
                       label: sat_sh9X_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck7F: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck7G; else goto ck7H;
       ck7G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck7H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sh9W_entry() //  [R1]
         { info_tbl: [(ck7M,
                       label: sat_sh9W_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck7M: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck7N; else goto ck7O;
       ck7N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck7O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sh9V_entry() //  [R1]
         { info_tbl: [(ck7T,
                       label: sat_sh9V_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck7T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck7U; else goto ck7V;
       ck7U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck7V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sh9U_entry() //  [R1]
         { info_tbl: [(ck80,
                       label: sat_sh9U_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck80: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck81; else goto ck82;
       ck81: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck82: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sh9T_entry() //  [R1]
         { info_tbl: [(ck87,
                       label: sat_sh9T_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck87: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck88; else goto ck89;
       ck88: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck89: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ck8a,
                       label: GHC.Base.$fMonoid(,,,,)_$c<>_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck8a: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ck8c; else goto ck8d;
       ck8c: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$c<>_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ck8d: // global
           I64[Sp - 40] = block_ck7r_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uk8j; else goto ck7s;
       uk8j: // global
           call _ck7r(R1) args: 0, res: 0, upd: 0;
       ck7s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck7r() //  [R1]
         { info_tbl: [(ck7r,
                       label: block_ck7r_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck7r: // global
           I64[Sp - 32] = block_ck7w_info;
           _sh9I::P64 = P64[R1 + 7];
           _sh9J::P64 = P64[R1 + 15];
           _sh9K::P64 = P64[R1 + 23];
           _sh9L::P64 = P64[R1 + 31];
           _sh9M::P64 = P64[R1 + 39];
           R1 = P64[Sp + 48];
           P64[Sp - 24] = _sh9K::P64;
           P64[Sp - 16] = _sh9L::P64;
           P64[Sp - 8] = _sh9M::P64;
           P64[Sp] = _sh9J::P64;
           P64[Sp + 48] = _sh9I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uk8i; else goto ck7x;
       uk8i: // global
           call _ck7w(R1) args: 0, res: 0, upd: 0;
       ck7x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck7w() //  [R1]
         { info_tbl: [(ck7w,
                       label: block_ck7w_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck7w: // global
           Hp = Hp + 248;
           if (Hp > HpLim) (likely: False) goto ck8h; else goto ck8g;
       ck8h: // global
           HpAlloc = 248;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ck8g: // global
           _sh9O::P64 = P64[R1 + 7];
           _sh9P::P64 = P64[R1 + 15];
           _sh9Q::P64 = P64[R1 + 23];
           _sh9R::P64 = P64[R1 + 31];
           _sh9S::P64 = P64[R1 + 39];
           I64[Hp - 240] = sat_sh9X_info;
           P64[Hp - 224] = P64[Sp + 64];
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _sh9S::P64;
           I64[Hp - 200] = sat_sh9W_info;
           P64[Hp - 184] = P64[Sp + 56];
           P64[Hp - 176] = P64[Sp + 16];
           P64[Hp - 168] = _sh9R::P64;
           I64[Hp - 160] = sat_sh9V_info;
           P64[Hp - 144] = P64[Sp + 48];
           P64[Hp - 136] = P64[Sp + 8];
           P64[Hp - 128] = _sh9Q::P64;
           I64[Hp - 120] = sat_sh9U_info;
           P64[Hp - 104] = P64[Sp + 40];
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = _sh9P::P64;
           I64[Hp - 80] = sat_sh9T_info;
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = _sh9O::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 160;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 240;
           R1 = Hp - 39;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.299952397 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$csconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$csconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$csconcat_info;
 },
 sat_shaD_entry() //  [R1]
         { info_tbl: [(ckad,
                       label: sat_shaD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckad: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckae; else goto ckaf;
       ckae: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckaf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shaC_entry() //  [R1]
         { info_tbl: [(ckak,
                       label: sat_shaC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckak: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckal; else goto ckam;
       ckal: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckam: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shaB_entry() //  [R1]
         { info_tbl: [(ckar,
                       label: sat_shaB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckar: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckas; else goto ckat;
       ckas: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckat: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shaA_entry() //  [R1]
         { info_tbl: [(ckay,
                       label: sat_shaA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckay: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckaz; else goto ckaA;
       ckaz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckaA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shaz_entry() //  [R1]
         { info_tbl: [(ckaF,
                       label: sat_shaz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckaF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckaG; else goto ckaH;
       ckaG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckaH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_shad_entry() //  [R1, R2, R3, R4, R5, R6]
         { info_tbl: [(ckaM,
                       label: $wgo_shad_info
                       rep:HeapRep 5 ptrs { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckaM: // global
           if ((Sp + -120) < SpLim) (likely: False) goto ckaN; else goto ckaO;
       ckaN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ckaO: // global
           I64[Sp - 88] = block_ck9U_info;
           _shad::P64 = R1;
           _sh9Y::P64 = P64[R1 + 2];
           _sh9Z::P64 = P64[R1 + 10];
           _sha0::P64 = P64[R1 + 18];
           _sha1::P64 = P64[R1 + 26];
           _sha2::P64 = P64[R1 + 34];
           R1 = P64[Sp];
           P64[Sp - 80] = _sh9Z::P64;
           P64[Sp - 72] = _sha0::P64;
           P64[Sp - 64] = _sha1::P64;
           P64[Sp - 56] = _sha2::P64;
           P64[Sp - 48] = _shad::P64;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = _sh9Y::P64;
           Sp = Sp - 88;
           if (R1 & 7 != 0) goto ukaZ; else goto ck9V;
       ukaZ: // global
           call _ck9U(R1) args: 0, res: 0, upd: 0;
       ck9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck9U() //  [R1]
         { info_tbl: [(ck9U,
                       label: block_ck9U_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck9U: // global
           if (R1 & 7 == 1) goto ckaJ; else goto ckaK;
       ckaJ: // global
           R5 = P64[Sp + 80];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckaK: // global
           I64[Sp - 8] = block_cka0_info;
           _sham::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sham::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukaX; else goto cka1;
       ukaX: // global
           call _cka0(R1) args: 0, res: 0, upd: 0;
       cka1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cka0() //  [R1]
         { info_tbl: [(cka0,
                       label: block_cka0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cka0: // global
           _sham::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cka5_info;
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp] = _sham::P64;
           call $wgo_shad_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 _cka5() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cka5,
                       label: block_cka5_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cka5: // global
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R2;
           P64[Sp + 40] = R1;
           Sp = Sp - 32;
           call _cka6() args: 0, res: 0, upd: 0;
     }
 },
 _cka6() //  []
         { info_tbl: [(cka6,
                       label: block_cka6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cka6: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto ckaV; else goto ckaU;
       ckaV: // global
           HpAlloc = 200;
           I64[Sp] = block_cka6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ckaU: // global
           I64[Hp - 192] = sat_shaD_info;
           P64[Hp - 176] = P64[Sp + 64];
           P64[Hp - 168] = P64[Sp + 112];
           P64[Hp - 160] = P64[Sp + 24];
           I64[Hp - 152] = sat_shaC_info;
           P64[Hp - 136] = P64[Sp + 56];
           P64[Hp - 128] = P64[Sp + 104];
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = sat_shaB_info;
           P64[Hp - 96] = P64[Sp + 48];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = sat_shaA_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 32];
           I64[Hp - 32] = sat_shaz_info;
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 80];
           P64[Hp] = P64[Sp + 72];
           R5 = Hp - 192;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckb0,
                       label: GHC.Base.$fMonoid(,,,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckb0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckb6; else goto ckb7;
       ckb6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ckb7: // global
           I64[Sp - 40] = block_ck9F_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukbh; else goto ck9G;
       ukbh: // global
           call _ck9F(R1) args: 0, res: 0, upd: 0;
       ck9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck9F() //  [R1]
         { info_tbl: [(ck9F,
                       label: block_ck9F_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck9F: // global
           I64[Sp - 8] = block_ck9K_info;
           _sha6::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sha6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukbg; else goto ck9L;
       ukbg: // global
           call _ck9K(R1) args: 0, res: 0, upd: 0;
       ck9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck9K() //  [R1]
         { info_tbl: [(ck9K,
                       label: block_ck9K_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ck9K: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ckbb; else goto ckba;
       ckbb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckba: // global
           _sha8::P64 = P64[R1 + 7];
           _sha9::P64 = P64[R1 + 15];
           _shaa::P64 = P64[R1 + 23];
           _shab::P64 = P64[R1 + 31];
           _shac::P64 = P64[R1 + 39];
           I64[Hp - 40] = $wgo_shad_info;
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 48] = block_ckb1_info;
           R6 = _shac::P64;
           R5 = _shab::P64;
           R4 = _shaa::P64;
           R3 = _sha9::P64;
           R2 = _sha8::P64;
           R1 = Hp - 34;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call $wgo_shad_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 _ckb1() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(ckb1,
                       label: block_ckb1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckb1: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call _ckb2() args: 0, res: 0, upd: 0;
     }
 },
 _ckb2() //  []
         { info_tbl: [(ckb2,
                       label: block_ckb2_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckb2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ckbe; else goto ckbd;
       ckbe: // global
           HpAlloc = 48;
           I64[Sp] = block_ckb2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ckbd: // global
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.334940596 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cstimes_closure" {
     GHC.Base.$fMonoid(,,,,)_$cstimes_closure:
         const GHC.Base.$fMonoid(,,,,)_$cstimes_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckdj: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_shb2_entry() //  [R1]
         { info_tbl: [(ckdw,
                       label: sat_shb2_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckdw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdx; else goto ckdy;
       ckdx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shb1_entry() //  [R1]
         { info_tbl: [(ckdD,
                       label: sat_shb1_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckdD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdE; else goto ckdF;
       ckdE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shb0_entry() //  [R1]
         { info_tbl: [(ckdK,
                       label: sat_shb0_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckdK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdL; else goto ckdM;
       ckdL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shaZ_entry() //  [R1]
         { info_tbl: [(ckdR,
                       label: sat_shaZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckdR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdS; else goto ckdT;
       ckdS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shaY_entry() //  [R1]
         { info_tbl: [(ckdY,
                       label: sat_shaY_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckdY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdZ; else goto cke0;
       ckdZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cke0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cke1,
                       label: GHC.Base.$fMonoid(,,,,)_$cstimes_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cke1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cke3; else goto cke4;
       cke3: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cke4: // global
           I64[Sp - 40] = block_ckdn_info;
           R1 = P64[Sp + 16];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 16] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uke8; else goto ckdo;
       uke8: // global
           call _ckdn(R1) args: 0, res: 0, upd: 0;
       ckdo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckdn() //  [R1]
         { info_tbl: [(ckdn,
                       label: block_ckdn_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckdn: // global
           Hp = Hp + 288;
           if (Hp > HpLim) (likely: False) goto cke7; else goto cke6;
       cke7: // global
           HpAlloc = 288;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cke6: // global
           _shaT::P64 = P64[R1 + 7];
           _shaU::P64 = P64[R1 + 15];
           _shaV::P64 = P64[R1 + 23];
           _shaW::P64 = P64[R1 + 31];
           _shaX::P64 = P64[R1 + 39];
           I64[Hp - 280] = sat_shb2_info;
           P64[Hp - 264] = P64[Sp + 32];
           _shaP::P64 = P64[Sp + 40];
           P64[Hp - 256] = _shaP::P64;
           _shaQ::P64 = P64[Sp + 48];
           P64[Hp - 248] = _shaQ::P64;
           P64[Hp - 240] = _shaX::P64;
           I64[Hp - 232] = sat_shb1_info;
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _shaP::P64;
           P64[Hp - 200] = _shaQ::P64;
           P64[Hp - 192] = _shaW::P64;
           I64[Hp - 184] = sat_shb0_info;
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _shaP::P64;
           P64[Hp - 152] = _shaQ::P64;
           P64[Hp - 144] = _shaV::P64;
           I64[Hp - 136] = sat_shaZ_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _shaP::P64;
           P64[Hp - 104] = _shaQ::P64;
           P64[Hp - 96] = _shaU::P64;
           I64[Hp - 88] = sat_shaY_info;
           P64[Hp - 72] = P64[Sp + 56];
           P64[Hp - 64] = _shaP::P64;
           P64[Hp - 56] = _shaQ::P64;
           P64[Hp - 48] = _shaT::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 88;
           P64[Hp - 24] = Hp - 136;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 280;
           R1 = Hp - 39;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.353200992 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,,)_closure" {
     GHC.Base.$fSemigroup(,,,,)_closure:
         const GHC.Base.$fSemigroup(,,,,)_info;
 },
 sat_shba_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ckfu,
                       label: sat_shba_info
                       rep:HeapRep 5 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckfu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ckfv; else goto ckfw;
       ckfv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckfw: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_shb9_entry() //  [R1, R2]
         { info_tbl: [(ckfC,
                       label: sat_shb9_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckfC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckfD; else goto ckfE;
       ckfD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckfE: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_shb8_entry() //  [R1, R2, R3]
         { info_tbl: [(ckfK,
                       label: sat_shb8_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckfK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckfL; else goto ckfM;
       ckfL: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckfM: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckfO,
                       label: GHC.Base.$fSemigroup(,,,,)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckfO: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ckfS; else goto ckfR;
       ckfS: // global
           HpAlloc = 176;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckfR: // global
           I64[Hp - 168] = sat_shba_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = sat_shb9_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_shb8_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 165;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.36718074 UTC

[section ""data" . GHC.Base.$w$cp1Monoid1_closure" {
     GHC.Base.$w$cp1Monoid1_closure:
         const GHC.Base.$w$cp1Monoid1_info;
 },
 sat_shbw_entry() //  [R1]
         { info_tbl: [(ckgp,
                       label: sat_shbw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckgp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgq; else goto ckgr;
       ckgq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbv_entry() //  [R1]
         { info_tbl: [(ckgw,
                       label: sat_shbv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckgw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgx; else goto ckgy;
       ckgx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbu_entry() //  [R1]
         { info_tbl: [(ckgD,
                       label: sat_shbu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckgD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgE; else goto ckgF;
       ckgE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbt_entry() //  [R1]
         { info_tbl: [(ckgK,
                       label: sat_shbt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckgK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgL; else goto ckgM;
       ckgL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbs_entry() //  [R1]
         { info_tbl: [(ckgR,
                       label: sat_shbs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckgR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgS; else goto ckgT;
       ckgS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbx_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ckgZ,
                       label: sat_shbx_info
                       rep:HeapRep 5 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckgZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ckh0; else goto ckh1;
       ckh0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckh1: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_shbq_entry() //  [R1]
         { info_tbl: [(ckh6,
                       label: sat_shbq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckh6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckh7; else goto ckh8;
       ckh7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckh8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbp_entry() //  [R1]
         { info_tbl: [(ckhd,
                       label: sat_shbp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckhd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhe; else goto ckhf;
       ckhe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbo_entry() //  [R1]
         { info_tbl: [(ckhk,
                       label: sat_shbo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckhk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhl; else goto ckhm;
       ckhl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbn_entry() //  [R1]
         { info_tbl: [(ckhr,
                       label: sat_shbn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckhr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhs; else goto ckht;
       ckhs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckht: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbm_entry() //  [R1]
         { info_tbl: [(ckhy,
                       label: sat_shbm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckhy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhz; else goto ckhA;
       ckhz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbr_entry() //  [R1, R2]
         { info_tbl: [(ckhG,
                       label: sat_shbr_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckhG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckhH; else goto ckhI;
       ckhH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckhI: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_shbk_entry() //  [R1]
         { info_tbl: [(ckhN,
                       label: sat_shbk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckhN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhO; else goto ckhP;
       ckhO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbj_entry() //  [R1]
         { info_tbl: [(ckhU,
                       label: sat_shbj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckhU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhV; else goto ckhW;
       ckhV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbi_entry() //  [R1]
         { info_tbl: [(cki1,
                       label: sat_shbi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cki1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cki2; else goto cki3;
       cki2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cki3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbh_entry() //  [R1]
         { info_tbl: [(cki8,
                       label: sat_shbh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cki8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cki9; else goto ckia;
       cki9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbg_entry() //  [R1]
         { info_tbl: [(ckif,
                       label: sat_shbg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckif: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckig; else goto ckih;
       ckig: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckih: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shbl_entry() //  [R1, R2, R3]
         { info_tbl: [(ckin,
                       label: sat_shbl_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckin: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckio; else goto ckip;
       ckio: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckip: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cp1Monoid1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckiq,
                       label: GHC.Base.$w$cp1Monoid1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckiq: // global
           Hp = Hp + 504;
           if (Hp > HpLim) (likely: False) goto ckiu; else goto ckit;
       ckiu: // global
           HpAlloc = 504;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckit: // global
           I64[Hp - 496] = sat_shbw_info;
           P64[Hp - 480] = R6;
           I64[Hp - 472] = sat_shbv_info;
           P64[Hp - 456] = R5;
           I64[Hp - 448] = sat_shbu_info;
           P64[Hp - 432] = R4;
           I64[Hp - 424] = sat_shbt_info;
           P64[Hp - 408] = R3;
           I64[Hp - 400] = sat_shbs_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_shbx_info;
           P64[Hp - 368] = Hp - 400;
           P64[Hp - 360] = Hp - 424;
           P64[Hp - 352] = Hp - 448;
           P64[Hp - 344] = Hp - 472;
           P64[Hp - 336] = Hp - 496;
           I64[Hp - 328] = sat_shbq_info;
           P64[Hp - 312] = R6;
           I64[Hp - 304] = sat_shbp_info;
           P64[Hp - 288] = R5;
           I64[Hp - 280] = sat_shbo_info;
           P64[Hp - 264] = R4;
           I64[Hp - 256] = sat_shbn_info;
           P64[Hp - 240] = R3;
           I64[Hp - 232] = sat_shbm_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_shbr_info;
           P64[Hp - 200] = Hp - 232;
           P64[Hp - 192] = Hp - 256;
           P64[Hp - 184] = Hp - 280;
           P64[Hp - 176] = Hp - 304;
           P64[Hp - 168] = Hp - 328;
           I64[Hp - 160] = sat_shbk_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_shbj_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_shbi_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_shbh_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_shbg_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_shbl_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R3 = Hp - 373;
           R2 = Hp - 207;
           R1 = Hp - 38;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.405837213 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckkD,
                       label: GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckkD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckkE; else goto ckkF;
       ckkE: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckkF: // global
           I64[Sp - 8] = block_ckkA_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ckkA() //  [R1, R2, R3]
         { info_tbl: [(ckkA,
                       label: block_ckkA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckkA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckkI; else goto ckkH;
       ckkI: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckkH: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.411753283 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckl0,
                       label: GHC.Base.$fMonoid(,,,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckl0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckl1; else goto ckl2;
       ckl1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckl2: // global
           I64[Sp - 8] = block_ckkY_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ckkY() //  [R1]
         { info_tbl: [(ckkY,
                       label: block_ckkY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckkY: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.418490008 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmconcat_info;
 },
 k_shbV_entry() //  [R1]
         { info_tbl: [(cklo,
                       label: k_shbV_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cklo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cklp; else goto cklq;
       cklp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklq: // global
           I64[Sp - 8] = block_ckll_info;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ckll() //  [R1, R2, R3]
         { info_tbl: [(ckll,
                       label: block_ckll_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckll: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cklt; else goto ckls;
       cklt: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckls: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 k1_shc0_entry() //  [R1]
         { info_tbl: [(ckly,
                       label: k1_shc0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckly: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cklz; else goto cklA;
       cklz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_shc1_entry() //  [R1]
         { info_tbl: [(cklF,
                       label: z_shc1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cklF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cklG; else goto cklH;
       cklG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_shc2_entry() //  [R1]
         { info_tbl: [(cklM,
                       label: z1_shc2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cklM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cklN; else goto cklO;
       cklN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_shc3_entry() //  [R1]
         { info_tbl: [(cklT,
                       label: z2_shc3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cklT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cklU; else goto cklV;
       cklU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z3_shc4_entry() //  [R1]
         { info_tbl: [(ckm0,
                       label: z3_shc4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckm0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckm1; else goto ckm2;
       ckm1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckm2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z4_shc5_entry() //  [R1]
         { info_tbl: [(ckm7,
                       label: z4_shc5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckm7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckm8; else goto ckm9;
       ckm8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckm9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_shc7_entry() //  [R1, R2]
         { info_tbl: [(ckmn,
                       label: go_shc7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckmn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckmo; else goto ckmp;
       ckmo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckmp: // global
           I64[Sp - 32] = block_ckmg_info;
           _shc7::P64 = R1;
           _shc0::P64 = P64[R1 + 7];
           _shc6::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _shc0::P64;
           P64[Sp - 16] = _shc6::P64;
           P64[Sp - 8] = _shc7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ukmz; else goto ckmh;
       ukmz: // global
           call _ckmg(R1) args: 0, res: 0, upd: 0;
       ckmh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckmg() //  [R1]
         { info_tbl: [(ckmg,
                       label: block_ckmg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckmg: // global
           if (R1 & 7 == 1) goto ckmk; else goto ckml;
       ckmk: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckml: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckmy; else goto ckmx;
       ckmy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckmx: // global
           _shca::P64 = P64[R1 + 6];
           _shcb::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _shcb::P64;
           R3 = Hp - 24;
           R2 = _shca::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,,)_$cmconcat_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckmA,
                       label: GHC.Base.$fMonoid(,,,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckmA: // global
           Hp = Hp + 272;
           if (Hp > HpLim) (likely: False) goto ckmE; else goto ckmD;
       ckmE: // global
           HpAlloc = 272;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckmD: // global
           I64[Hp - 264] = k_shbV_info;
           P64[Hp - 248] = R2;
           P64[Hp - 240] = R3;
           P64[Hp - 232] = R4;
           P64[Hp - 224] = R5;
           P64[Hp - 216] = R6;
           I64[Hp - 208] = k1_shc0_info;
           P64[Hp - 192] = Hp - 264;
           I64[Hp - 184] = z_shc1_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = z1_shc2_info;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = z2_shc3_info;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = z3_shc4_info;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = z4_shc5_info;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = (,,,,)_con_info;
           P64[Hp - 56] = Hp - 184;
           P64[Hp - 48] = Hp - 160;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = go_shc7_info;
           P64[Hp - 8] = Hp - 208;
           P64[Hp] = Hp - 63;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.443111605 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_closure" {
     GHC.Base.$fMonoid(,,,,)_closure:
         const GHC.Base.$fMonoid(,,,,)_info;
 },
 sat_shcl_entry() //  [R1]
         { info_tbl: [(cko1,
                       label: sat_shcl_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cko1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cko2; else goto cko3;
       cko2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cko3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shck_entry() //  [R1]
         { info_tbl: [(cko8,
                       label: sat_shck_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cko8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cko9; else goto ckoa;
       cko9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckoa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmappend_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shcj_entry() //  [R1]
         { info_tbl: [(ckof,
                       label: sat_shcj_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckof: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckog; else goto ckoh;
       ckog: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckoh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmempty_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shci_entry() //  [R1]
         { info_tbl: [(ckom,
                       label: sat_shci_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckom: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckon; else goto ckoo;
       ckon: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckoo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckoq,
                       label: GHC.Base.$fMonoid(,,,,)_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckoq: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto ckou; else goto ckot;
       ckou: // global
           HpAlloc = 264;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckot: // global
           I64[Hp - 256] = sat_shcl_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           P64[Hp - 224] = R4;
           P64[Hp - 216] = R5;
           P64[Hp - 208] = R6;
           I64[Hp - 200] = sat_shck_info;
           P64[Hp - 184] = R2;
           P64[Hp - 176] = R3;
           P64[Hp - 168] = R4;
           P64[Hp - 160] = R5;
           P64[Hp - 152] = R6;
           I64[Hp - 144] = sat_shcj_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           P64[Hp - 104] = R5;
           P64[Hp - 96] = R6;
           I64[Hp - 88] = sat_shci_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 256;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.457536454 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,)_$c<>_info;
 },
 sat_shcF_entry() //  [R1]
         { info_tbl: [(ckpl,
                       label: sat_shcF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckpl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckpm; else goto ckpn;
       ckpm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckpn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shcE_entry() //  [R1]
         { info_tbl: [(ckps,
                       label: sat_shcE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckps: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckpt; else goto ckpu;
       ckpt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckpu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shcD_entry() //  [R1]
         { info_tbl: [(ckpz,
                       label: sat_shcD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckpz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckpA; else goto ckpB;
       ckpA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckpB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shcC_entry() //  [R1]
         { info_tbl: [(ckpG,
                       label: sat_shcC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckpG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckpH; else goto ckpI;
       ckpH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckpI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckpJ,
                       label: GHC.Base.$fMonoid(,,,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckpJ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ckpL; else goto ckpM;
       ckpL: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ckpM: // global
           I64[Sp - 40] = block_ckp7_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukpS; else goto ckp8;
       ukpS: // global
           call _ckp7(R1) args: 0, res: 0, upd: 0;
       ckp8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckp7() //  [R1]
         { info_tbl: [(ckp7,
                       label: block_ckp7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckp7: // global
           I64[Sp - 24] = block_ckpc_info;
           _shct::P64 = P64[R1 + 7];
           _shcu::P64 = P64[R1 + 15];
           _shcv::P64 = P64[R1 + 23];
           _shcw::P64 = P64[R1 + 31];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _shcv::P64;
           P64[Sp - 8] = _shcw::P64;
           P64[Sp] = _shcu::P64;
           P64[Sp + 40] = _shct::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ukpR; else goto ckpd;
       ukpR: // global
           call _ckpc(R1) args: 0, res: 0, upd: 0;
       ckpd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckpc() //  [R1]
         { info_tbl: [(ckpc,
                       label: block_ckpc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckpc: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto ckpQ; else goto ckpP;
       ckpQ: // global
           HpAlloc = 200;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckpP: // global
           _shcy::P64 = P64[R1 + 7];
           _shcz::P64 = P64[R1 + 15];
           _shcA::P64 = P64[R1 + 23];
           _shcB::P64 = P64[R1 + 31];
           I64[Hp - 192] = sat_shcF_info;
           P64[Hp - 176] = P64[Sp + 56];
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _shcB::P64;
           I64[Hp - 152] = sat_shcE_info;
           P64[Hp - 136] = P64[Sp + 48];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = _shcA::P64;
           I64[Hp - 112] = sat_shcD_info;
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = _shcz::P64;
           I64[Hp - 72] = sat_shcC_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = _shcy::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.478011224 UTC

[section ""data" . GHC.Base.$w$csconcat2_closure" {
     GHC.Base.$w$csconcat2_closure:
         const GHC.Base.$w$csconcat2_info;
 },
 GHC.Base.$w$csconcat2_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckqX: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_shdb_entry() //  [R1]
         { info_tbl: [(ckrn,
                       label: sat_shdb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckrn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckro; else goto ckrp;
       ckro: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckrp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shda_entry() //  [R1]
         { info_tbl: [(ckru,
                       label: sat_shda_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckru: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckrv; else goto ckrw;
       ckrv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckrw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shd9_entry() //  [R1]
         { info_tbl: [(ckrB,
                       label: sat_shd9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckrB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckrC; else goto ckrD;
       ckrC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckrD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shd8_entry() //  [R1]
         { info_tbl: [(ckrI,
                       label: sat_shd8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckrI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckrJ; else goto ckrK;
       ckrJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckrK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_shcP_entry() //  [R1, R2, R3, R4, R5, R6]
         { info_tbl: [(ckrP,
                       label: $wgo_shcP_info
                       rep:HeapRep 4 ptrs { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckrP: // global
           if ((Sp + -88) < SpLim) (likely: False) goto ckrQ; else goto ckrR;
       ckrQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckrR: // global
           I64[Sp - 80] = block_ckr6_info;
           _shcP::P64 = R1;
           _shcG::P64 = P64[R1 + 3];
           _shcH::P64 = P64[R1 + 11];
           _shcI::P64 = P64[R1 + 19];
           _shcJ::P64 = P64[R1 + 27];
           R1 = R6;
           P64[Sp - 72] = _shcG::P64;
           P64[Sp - 64] = _shcH::P64;
           P64[Sp - 56] = _shcI::P64;
           P64[Sp - 48] = _shcJ::P64;
           P64[Sp - 40] = _shcP::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto uks0; else goto ckr7;
       uks0: // global
           call _ckr6(R1) args: 0, res: 0, upd: 0;
       ckr7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckr6() //  [R1]
         { info_tbl: [(ckr6,
                       label: block_ckr6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckr6: // global
           if (R1 & 7 == 1) goto ckrM; else goto ckrN;
       ckrM: // global
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckrN: // global
           I64[Sp - 8] = block_ckrc_info;
           _shcX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _shcX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukrZ; else goto ckrd;
       ukrZ: // global
           call _ckrc(R1) args: 0, res: 0, upd: 0;
       ckrd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckrc() //  [R1]
         { info_tbl: [(ckrc,
                       label: block_ckrc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckrc: // global
           _shcX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ckrh_info;
           R6 = _shcX::P64;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           Sp = Sp + 8;
           call $wgo_shcP_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckrh() //  [R1, R2, R3, R4]
         { info_tbl: [(ckrh,
                       label: block_ckrh_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckrh: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ckrY; else goto ckrX;
       ckrY: // global
           HpAlloc = 160;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ckrX: // global
           I64[Hp - 152] = sat_shdb_info;
           P64[Hp - 136] = P64[Sp + 32];
           P64[Hp - 128] = P64[Sp + 72];
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_shda_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_shd9_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_shd8_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat2_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cks1,
                       label: GHC.Base.$w$csconcat2_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cks1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cks5; else goto cks4;
       cks5: // global
           HpAlloc = 40;
           R1 = GHC.Base.$w$csconcat2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cks4: // global
           I64[Hp - 32] = $wgo_shcP_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _shcK::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _shcK::P64;
           R1 = Hp - 27;
           Sp = Sp + 32;
           call $wgo_shcP_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.502665237 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,,)_$csconcat_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { info_tbl: [(ckto,
                       label: GHC.Base.$fSemigroup(,,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckto: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cktz; else goto cktA;
       cktz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cktA: // global
           I64[Sp - 40] = block_cktl_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uktH; else goto cktm;
       uktH: // global
           call _cktl(R1) args: 0, res: 0, upd: 0;
       cktm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cktl() //  [R1]
         { info_tbl: [(cktl,
                       label: block_cktl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cktl: // global
           I64[Sp - 8] = block_cktr_info;
           _shdj::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _shdj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uktG; else goto ckts;
       uktG: // global
           call _cktr(R1) args: 0, res: 0, upd: 0;
       ckts: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cktr() //  [R1]
         { info_tbl: [(cktr,
                       label: block_cktr_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cktr: // global
           _shdf::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cktw_info;
           R6 = P64[R1 + 7];
           R5 = _shdf::P64;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           _shdj::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _shdj::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 _cktw() //  [R1, R2, R3, R4]
         { info_tbl: [(cktw,
                       label: block_cktw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cktw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cktF; else goto cktE;
       cktF: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cktE: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.516909876 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,,)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cku7: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_shdJ_entry() //  [R1]
         { info_tbl: [(ckuk,
                       label: sat_shdJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckuk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckul; else goto ckum;
       ckul: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckum: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shdI_entry() //  [R1]
         { info_tbl: [(ckur,
                       label: sat_shdI_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckur: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckus; else goto ckut;
       ckus: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckut: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shdH_entry() //  [R1]
         { info_tbl: [(ckuy,
                       label: sat_shdH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckuy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckuz; else goto ckuA;
       ckuz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckuA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shdG_entry() //  [R1]
         { info_tbl: [(ckuF,
                       label: sat_shdG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckuF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckuG; else goto ckuH;
       ckuG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckuH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckuI,
                       label: GHC.Base.$fSemigroup(,,,)_$cstimes_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckuI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckuK; else goto ckuL;
       ckuK: // global
           R1 = GHC.Base.$fSemigroup(,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ckuL: // global
           I64[Sp - 40] = block_ckub_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukuP; else goto ckuc;
       ukuP: // global
           call _ckub(R1) args: 0, res: 0, upd: 0;
       ckuc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckub() //  [R1]
         { info_tbl: [(ckub,
                       label: block_ckub_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckub: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ckuO; else goto ckuN;
       ckuO: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckuN: // global
           _shdC::P64 = P64[R1 + 7];
           _shdD::P64 = P64[R1 + 15];
           _shdE::P64 = P64[R1 + 23];
           _shdF::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_shdJ_info;
           P64[Hp - 208] = P64[Sp + 24];
           _shdy::P64 = P64[Sp + 32];
           P64[Hp - 200] = _shdy::P64;
           _shdz::P64 = P64[Sp + 40];
           P64[Hp - 192] = _shdz::P64;
           P64[Hp - 184] = _shdF::P64;
           I64[Hp - 176] = sat_shdI_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _shdy::P64;
           P64[Hp - 144] = _shdz::P64;
           P64[Hp - 136] = _shdE::P64;
           I64[Hp - 128] = sat_shdH_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _shdy::P64;
           P64[Hp - 96] = _shdz::P64;
           P64[Hp - 88] = _shdD::P64;
           I64[Hp - 80] = sat_shdG_info;
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = _shdy::P64;
           P64[Hp - 48] = _shdz::P64;
           P64[Hp - 40] = _shdC::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.535852709 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_closure" {
     GHC.Base.$fSemigroup(,,,)_closure:
         const GHC.Base.$fSemigroup(,,,)_info;
 },
 sat_shdQ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ckvZ,
                       label: sat_shdQ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckvZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckw0; else goto ckw1;
       ckw0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckw1: // global
           R6 = R2;
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_shdP_entry() //  [R1, R2]
         { info_tbl: [(ckw7,
                       label: sat_shdP_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckw7: // global
           R6 = R2;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,,)_$csconcat_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shdO_entry() //  [R1, R2, R3]
         { info_tbl: [(ckwf,
                       label: sat_shdO_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckwf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckwg; else goto ckwh;
       ckwg: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckwh: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ckwj,
                       label: GHC.Base.$fSemigroup(,,,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckwj: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckwn; else goto ckwm;
       ckwn: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckwm: // global
           I64[Hp - 144] = sat_shdQ_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_shdP_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_shdO_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 62;
           P64[Hp - 8] = Hp - 103;
           P64[Hp] = Hp - 141;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.55091557 UTC

[section ""data" . GHC.Base.$w$cp1Monoid_closure" {
     GHC.Base.$w$cp1Monoid_closure:
         const GHC.Base.$w$cp1Monoid_info;
 },
 w4_shej_entry() //  [R1]
         { info_tbl: [(ckwT,
                       label: w4_shej_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckwT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckwU; else goto ckwV;
       ckwU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckwV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_shek_entry() //  [R1]
         { info_tbl: [(ckx0,
                       label: w5_shek_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckx0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckx1; else goto ckx2;
       ckx1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckx2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_shel_entry() //  [R1]
         { info_tbl: [(ckx7,
                       label: w6_shel_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckx7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckx8; else goto ckx9;
       ckx8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckx9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_shem_entry() //  [R1]
         { info_tbl: [(ckxe,
                       label: w7_shem_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckxe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckxf; else goto ckxg;
       ckxf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shey_entry() //  [R1]
         { info_tbl: [(ckxv,
                       label: sat_shey_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckxv: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckxw; else goto ckxx;
       ckxw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shex_entry() //  [R1]
         { info_tbl: [(ckxC,
                       label: sat_shex_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckxC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckxD; else goto ckxE;
       ckxD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shew_entry() //  [R1]
         { info_tbl: [(ckxJ,
                       label: sat_shew_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckxJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckxK; else goto ckxL;
       ckxK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shev_entry() //  [R1]
         { info_tbl: [(ckxQ,
                       label: sat_shev_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckxQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckxR; else goto ckxS;
       ckxR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shez_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ckxT,
                       label: sat_shez_info
                       rep:HeapRep 4 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckxT: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ckxV; else goto ckxW;
       ckxV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckxW: // global
           I64[Sp - 56] = block_ckxm_info;
           _shej::P64 = P64[R1 + 5];
           _shek::P64 = P64[R1 + 13];
           _shel::P64 = P64[R1 + 21];
           _shem::P64 = P64[R1 + 29];
           R1 = R4;
           P64[Sp - 48] = _shej::P64;
           P64[Sp - 40] = _shek::P64;
           P64[Sp - 32] = _shel::P64;
           P64[Sp - 24] = _shem::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uky0; else goto ckxn;
       uky0: // global
           call _ckxm(R1) args: 0, res: 0, upd: 0;
       ckxn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckxm() //  [R1]
         { info_tbl: [(ckxm,
                       label: block_ckxm_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckxm: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ckxZ; else goto ckxY;
       ckxZ: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckxY: // global
           _sher::P64 = P64[R1 + 7];
           _shes::P64 = P64[R1 + 15];
           _shet::P64 = P64[R1 + 23];
           _sheu::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_shey_info;
           P64[Hp - 208] = P64[Sp + 8];
           _shen::P64 = P64[Sp + 40];
           P64[Hp - 200] = _shen::P64;
           _sheo::P64 = P64[Sp + 48];
           P64[Hp - 192] = _sheo::P64;
           P64[Hp - 184] = _sheu::P64;
           I64[Hp - 176] = sat_shex_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _shen::P64;
           P64[Hp - 144] = _sheo::P64;
           P64[Hp - 136] = _shet::P64;
           I64[Hp - 128] = sat_shew_info;
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = _shen::P64;
           P64[Hp - 96] = _sheo::P64;
           P64[Hp - 88] = _shes::P64;
           I64[Hp - 80] = sat_shev_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _shen::P64;
           P64[Hp - 48] = _sheo::P64;
           P64[Hp - 40] = _sher::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 w4_she0_entry() //  [R1]
         { info_tbl: [(cky5,
                       label: w4_she0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cky5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cky6; else goto cky7;
       cky6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cky7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_she1_entry() //  [R1]
         { info_tbl: [(ckyc,
                       label: w5_she1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckyc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckyd; else goto ckye;
       ckyd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckye: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_she2_entry() //  [R1]
         { info_tbl: [(ckyj,
                       label: w6_she2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckyj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckyk; else goto ckyl;
       ckyk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckyl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_she3_entry() //  [R1]
         { info_tbl: [(ckyq,
                       label: w7_she3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckyq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckyr; else goto ckys;
       ckyr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckys: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shei_entry() //  [R1, R2]
         { info_tbl: [(ckyB,
                       label: sat_shei_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckyB: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckyM; else goto ckyN;
       ckyM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckyN: // global
           I64[Sp - 40] = block_ckyy_info;
           _she0::P64 = P64[R1 + 7];
           _she1::P64 = P64[R1 + 15];
           _she2::P64 = P64[R1 + 23];
           _she3::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _she0::P64;
           P64[Sp - 24] = _she1::P64;
           P64[Sp - 16] = _she2::P64;
           P64[Sp - 8] = _she3::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukyU; else goto ckyz;
       ukyU: // global
           call _ckyy(R1) args: 0, res: 0, upd: 0;
       ckyz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckyy() //  [R1]
         { info_tbl: [(ckyy,
                       label: block_ckyy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckyy: // global
           I64[Sp - 8] = block_ckyE_info;
           _she7::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _she7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukyT; else goto ckyF;
       ukyT: // global
           call _ckyE(R1) args: 0, res: 0, upd: 0;
       ckyF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckyE() //  [R1]
         { info_tbl: [(ckyE,
                       label: block_ckyE_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckyE: // global
           _she3::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_ckyJ_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = _she3::P64;
           _she7::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _she7::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 _ckyJ() //  [R1, R2, R3, R4]
         { info_tbl: [(ckyJ,
                       label: block_ckyJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckyJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ckyS; else goto ckyR;
       ckyS: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ckyR: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_shdY_entry() //  [R1]
         { info_tbl: [(ckyZ,
                       label: sat_shdY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckyZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckz0; else goto ckz1;
       ckz0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckz1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shdX_entry() //  [R1]
         { info_tbl: [(ckz6,
                       label: sat_shdX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckz6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckz7; else goto ckz8;
       ckz7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckz8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shdW_entry() //  [R1]
         { info_tbl: [(ckzd,
                       label: sat_shdW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckzd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckze; else goto ckzf;
       ckze: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckzf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shdV_entry() //  [R1]
         { info_tbl: [(ckzk,
                       label: sat_shdV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckzk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckzl; else goto ckzm;
       ckzl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckzm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shdZ_entry() //  [R1, R2, R3]
         { info_tbl: [(ckzs,
                       label: sat_shdZ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckzs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckzt; else goto ckzu;
       ckzt: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckzu: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ckzv,
                       label: GHC.Base.$w$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckzv: // global
           Hp = Hp + 408;
           if (Hp > HpLim) (likely: False) goto ckzz; else goto ckzy;
       ckzz: // global
           HpAlloc = 408;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckzy: // global
           I64[Hp - 400] = w4_shej_info;
           P64[Hp - 384] = R5;
           I64[Hp - 376] = w5_shek_info;
           P64[Hp - 360] = R4;
           I64[Hp - 352] = w6_shel_info;
           P64[Hp - 336] = R3;
           I64[Hp - 328] = w7_shem_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_shez_info;
           P64[Hp - 296] = Hp - 400;
           P64[Hp - 288] = Hp - 376;
           P64[Hp - 280] = Hp - 352;
           P64[Hp - 272] = Hp - 328;
           I64[Hp - 264] = w4_she0_info;
           P64[Hp - 248] = R5;
           I64[Hp - 240] = w5_she1_info;
           P64[Hp - 224] = R4;
           I64[Hp - 216] = w6_she2_info;
           P64[Hp - 200] = R3;
           I64[Hp - 192] = w7_she3_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_shei_info;
           P64[Hp - 160] = Hp - 264;
           P64[Hp - 152] = Hp - 240;
           P64[Hp - 144] = Hp - 216;
           P64[Hp - 136] = Hp - 192;
           I64[Hp - 128] = sat_shdY_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_shdX_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_shdW_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_shdV_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_shdZ_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R3 = Hp - 301;
           R2 = Hp - 167;
           R1 = Hp - 30;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.605591495 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ckCz,
                       label: GHC.Base.$fMonoid(,,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckCz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckCA; else goto ckCB;
       ckCA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckCB: // global
           I64[Sp - 8] = block_ckCw_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _ckCw() //  [R1, R2, R3]
         { info_tbl: [(ckCw,
                       label: block_ckCw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckCw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckCE; else goto ckCD;
       ckCE: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckCD: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.612868386 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ckCW,
                       label: GHC.Base.$fMonoid(,,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckCW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckCX; else goto ckCY;
       ckCX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckCY: // global
           I64[Sp - 8] = block_ckCU_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _ckCU() //  [R1]
         { info_tbl: [(ckCU,
                       label: block_ckCU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckCU: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.619871488 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,)_$cmconcat_info;
 },
 k_sheU_entry() //  [R1]
         { info_tbl: [(ckDk,
                       label: k_sheU_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckDk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckDl; else goto ckDm;
       ckDl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDm: // global
           I64[Sp - 8] = block_ckDh_info;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _ckDh() //  [R1, R2, R3]
         { info_tbl: [(ckDh,
                       label: block_ckDh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckDh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckDp; else goto ckDo;
       ckDp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckDo: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 k1_sheZ_entry() //  [R1]
         { info_tbl: [(ckDu,
                       label: k1_sheZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckDu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDv; else goto ckDw;
       ckDv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_shf0_entry() //  [R1]
         { info_tbl: [(ckDB,
                       label: z_shf0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckDB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDC; else goto ckDD;
       ckDC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_shf1_entry() //  [R1]
         { info_tbl: [(ckDI,
                       label: z1_shf1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckDI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDJ; else goto ckDK;
       ckDJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_shf2_entry() //  [R1]
         { info_tbl: [(ckDP,
                       label: z2_shf2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckDP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDQ; else goto ckDR;
       ckDQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z3_shf3_entry() //  [R1]
         { info_tbl: [(ckDW,
                       label: z3_shf3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckDW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDX; else goto ckDY;
       ckDX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_shf5_entry() //  [R1, R2]
         { info_tbl: [(ckEc,
                       label: go_shf5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckEc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckEd; else goto ckEe;
       ckEd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckEe: // global
           I64[Sp - 32] = block_ckE5_info;
           _shf5::P64 = R1;
           _sheZ::P64 = P64[R1 + 7];
           _shf4::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sheZ::P64;
           P64[Sp - 16] = _shf4::P64;
           P64[Sp - 8] = _shf5::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ukEo; else goto ckE6;
       ukEo: // global
           call _ckE5(R1) args: 0, res: 0, upd: 0;
       ckE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckE5() //  [R1]
         { info_tbl: [(ckE5,
                       label: block_ckE5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckE5: // global
           if (R1 & 7 == 1) goto ckE9; else goto ckEa;
       ckE9: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckEa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckEn; else goto ckEm;
       ckEn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckEm: // global
           _shf8::P64 = P64[R1 + 6];
           _shf9::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _shf9::P64;
           R3 = Hp - 24;
           R2 = _shf8::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ckEp,
                       label: GHC.Base.$fMonoid(,,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckEp: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ckEt; else goto ckEs;
       ckEt: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckEs: // global
           I64[Hp - 224] = k_sheU_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = k1_sheZ_info;
           P64[Hp - 160] = Hp - 224;
           I64[Hp - 152] = z_shf0_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = z1_shf1_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = z2_shf2_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = z3_shf3_info;
           P64[Hp - 64] = R5;
           I64[Hp - 56] = (,,,)_con_info;
           P64[Hp - 48] = Hp - 152;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 104;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = go_shf5_info;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.644496693 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_closure" {
     GHC.Base.$fMonoid(,,,)_closure:
         const GHC.Base.$fMonoid(,,,)_info;
 },
 sat_shfi_entry() //  [R1]
         { info_tbl: [(ckFJ,
                       label: sat_shfi_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckFJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckFK; else goto ckFL;
       ckFK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckFL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmconcat_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shfh_entry() //  [R1]
         { info_tbl: [(ckFQ,
                       label: sat_shfh_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckFQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckFR; else goto ckFS;
       ckFR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckFS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmappend_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shfg_entry() //  [R1]
         { info_tbl: [(ckFX,
                       label: sat_shfg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckFX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckFY; else goto ckFZ;
       ckFY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckFZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmempty_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shff_entry() //  [R1]
         { info_tbl: [(ckG4,
                       label: sat_shff_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckG4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckG5; else goto ckG6;
       ckG5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckG6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,,)_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ckG8,
                       label: GHC.Base.$fMonoid(,,,)_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckG8: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ckGc; else goto ckGb;
       ckGc: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckGb: // global
           I64[Hp - 224] = sat_shfi_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = sat_shfh_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           I64[Hp - 128] = sat_shfg_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           I64[Hp - 80] = sat_shff_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.665596505 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,)_$c<>_info;
 },
 sat_shfy_entry() //  [R1]
         { info_tbl: [(ckH3,
                       label: sat_shfy_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckH3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckH4; else goto ckH5;
       ckH4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckH5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shfx_entry() //  [R1]
         { info_tbl: [(ckHa,
                       label: sat_shfx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckHa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckHb; else goto ckHc;
       ckHb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckHc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shfw_entry() //  [R1]
         { info_tbl: [(ckHh,
                       label: sat_shfw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckHh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckHi; else goto ckHj;
       ckHi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckHj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckHk,
                       label: GHC.Base.$fMonoid(,,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckHk: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ckHm; else goto ckHn;
       ckHm: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckHn: // global
           I64[Sp - 40] = block_ckGP_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukHt; else goto ckGQ;
       ukHt: // global
           call _ckGP(R1) args: 0, res: 0, upd: 0;
       ckGQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckGP() //  [R1]
         { info_tbl: [(ckGP,
                       label: block_ckGP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckGP: // global
           I64[Sp - 16] = block_ckGU_info;
           _shfp::P64 = P64[R1 + 7];
           _shfq::P64 = P64[R1 + 15];
           _shfr::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _shfr::P64;
           P64[Sp] = _shfq::P64;
           P64[Sp + 32] = _shfp::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ukHs; else goto ckGV;
       ukHs: // global
           call _ckGU(R1) args: 0, res: 0, upd: 0;
       ckGV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckGU() //  [R1]
         { info_tbl: [(ckGU,
                       label: block_ckGU_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckGU: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckHr; else goto ckHq;
       ckHr: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckHq: // global
           _shft::P64 = P64[R1 + 7];
           _shfu::P64 = P64[R1 + 15];
           _shfv::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_shfy_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _shfv::P64;
           I64[Hp - 104] = sat_shfx_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _shfu::P64;
           I64[Hp - 64] = sat_shfw_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _shft::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.687065828 UTC

[section ""data" . GHC.Base.$w$csconcat1_closure" {
     GHC.Base.$w$csconcat1_closure:
         const GHC.Base.$w$csconcat1_info;
 },
 GHC.Base.$w$csconcat1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckIm: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_shfY_entry() //  [R1]
         { info_tbl: [(ckIM,
                       label: sat_shfY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckIM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckIN; else goto ckIO;
       ckIN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckIO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shfX_entry() //  [R1]
         { info_tbl: [(ckIT,
                       label: sat_shfX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckIT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckIU; else goto ckIV;
       ckIU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckIV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shfW_entry() //  [R1]
         { info_tbl: [(ckJ0,
                       label: sat_shfW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckJ0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckJ1; else goto ckJ2;
       ckJ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckJ2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 $wgo_shfG_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(ckJ7,
                       label: $wgo_shfG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckJ7: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ckJ8; else goto ckJ9;
       ckJ8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckJ9: // global
           I64[Sp - 64] = block_ckIv_info;
           _shfG::P64 = R1;
           _shfz::P64 = P64[R1 + 4];
           _shfA::P64 = P64[R1 + 12];
           _shfB::P64 = P64[R1 + 20];
           R1 = R5;
           P64[Sp - 56] = _shfz::P64;
           P64[Sp - 48] = _shfA::P64;
           P64[Sp - 40] = _shfB::P64;
           P64[Sp - 32] = _shfG::P64;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ukJi; else goto ckIw;
       ukJi: // global
           call _ckIv(R1) args: 0, res: 0, upd: 0;
       ckIw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckIv() //  [R1]
         { info_tbl: [(ckIv,
                       label: block_ckIv_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckIv: // global
           if (R1 & 7 == 1) goto ckJ4; else goto ckJ5;
       ckJ4: // global
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckJ5: // global
           I64[Sp - 8] = block_ckIB_info;
           _shfN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _shfN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukJh; else goto ckIC;
       ukJh: // global
           call _ckIB(R1) args: 0, res: 0, upd: 0;
       ckIC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckIB() //  [R1]
         { info_tbl: [(ckIB,
                       label: block_ckIB_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckIB: // global
           _shfN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ckIG_info;
           R5 = _shfN::P64;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wgo_shfG_entry(R5, R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckIG() //  [R1, R2, R3]
         { info_tbl: [(ckIG,
                       label: block_ckIG_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckIG: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ckJg; else goto ckJf;
       ckJg: // global
           HpAlloc = 120;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckJf: // global
           I64[Hp - 112] = sat_shfY_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 56];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_shfX_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_shfW_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$csconcat1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckJj,
                       label: GHC.Base.$w$csconcat1_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckJj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckJn; else goto ckJm;
       ckJn: // global
           HpAlloc = 32;
           R1 = GHC.Base.$w$csconcat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ckJm: // global
           I64[Hp - 24] = $wgo_shfG_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _shfC::P64 = R5;
           R5 = P64[Sp + 8];
           R4 = P64[Sp];
           R3 = R6;
           R2 = _shfC::P64;
           R1 = Hp - 20;
           Sp = Sp + 16;
           call $wgo_shfG_entry(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.707420023 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,)_$csconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ckKv,
                       label: GHC.Base.$fSemigroup(,,)_$csconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckKv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckKG; else goto ckKH;
       ckKG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$csconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckKH: // global
           I64[Sp - 32] = block_ckKs_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ukKO; else goto ckKt;
       ukKO: // global
           call _ckKs(R1) args: 0, res: 0, upd: 0;
       ckKt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckKs() //  [R1]
         { info_tbl: [(ckKs,
                       label: block_ckKs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckKs: // global
           I64[Sp - 8] = block_ckKy_info;
           _shg5::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _shg5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukKN; else goto ckKz;
       ukKN: // global
           call _ckKy(R1) args: 0, res: 0, upd: 0;
       ckKz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckKy() //  [R1]
         { info_tbl: [(ckKy,
                       label: block_ckKy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckKy: // global
           _shg1::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_ckKD_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = _shg1::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 24, res: 8, upd: 8;
     }
 },
 _ckKD() //  [R1, R2, R3]
         { info_tbl: [(ckKD,
                       label: block_ckKD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckKD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckKM; else goto ckKL;
       ckKM: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckKL: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.718547617 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,)_$cmappend_info;
 },
 sat_shgw_entry() //  [R1]
         { info_tbl: [(ckLw,
                       label: sat_shgw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckLw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckLx; else goto ckLy;
       ckLx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckLy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ckLu_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ckLu() //  [R1]
         { info_tbl: [(ckLu,
                       label: block_ckLu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckLu: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shgu_entry() //  [R1]
         { info_tbl: [(ckLI,
                       label: sat_shgu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckLI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckLJ; else goto ckLK;
       ckLJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckLK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ckLG_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ckLG() //  [R1]
         { info_tbl: [(ckLG,
                       label: block_ckLG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckLG: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shgs_entry() //  [R1]
         { info_tbl: [(ckLU,
                       label: sat_shgs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckLU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckLV; else goto ckLW;
       ckLV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckLW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ckLS_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ckLS() //  [R1]
         { info_tbl: [(ckLS,
                       label: block_ckLS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckLS: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckM0,
                       label: GHC.Base.$fMonoid(,,)_$cmappend_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckM0: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ckM2; else goto ckM3;
       ckM2: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckM3: // global
           I64[Sp - 40] = block_ckLg_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukM9; else goto ckLh;
       ukM9: // global
           call _ckLg(R1) args: 0, res: 0, upd: 0;
       ckLh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckLg() //  [R1]
         { info_tbl: [(ckLg,
                       label: block_ckLg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckLg: // global
           I64[Sp - 16] = block_ckLl_info;
           _shgk::P64 = P64[R1 + 7];
           _shgl::P64 = P64[R1 + 15];
           _shgm::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _shgm::P64;
           P64[Sp] = _shgl::P64;
           P64[Sp + 32] = _shgk::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ukM8; else goto ckLm;
       ukM8: // global
           call _ckLl(R1) args: 0, res: 0, upd: 0;
       ckLm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckLl() //  [R1]
         { info_tbl: [(ckLl,
                       label: block_ckLl_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckLl: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckM7; else goto ckM6;
       ckM7: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckM6: // global
           _shgo::P64 = P64[R1 + 7];
           _shgp::P64 = P64[R1 + 15];
           _shgq::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_shgw_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _shgq::P64;
           I64[Hp - 104] = sat_shgu_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _shgp::P64;
           I64[Hp - 64] = sat_shgs_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _shgo::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.739854816 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,)_$cmconcat_info;
 },
 $dSemigroup_shgB_entry() //  [R1]
         { info_tbl: [(ckNl,
                       label: $dSemigroup_shgB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNm; else goto ckNn;
       ckNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup1_shgC_entry() //  [R1]
         { info_tbl: [(ckNs,
                       label: $dSemigroup1_shgC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckNs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNt; else goto ckNu;
       ckNt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dSemigroup2_shgD_entry() //  [R1]
         { info_tbl: [(ckNz,
                       label: $dSemigroup2_shgD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckNz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNA; else goto ckNB;
       ckNA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_shgE_entry() //  [R1]
         { info_tbl: [(ckNG,
                       label: z_shgE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckNG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNH; else goto ckNI;
       ckNH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z1_shgF_entry() //  [R1]
         { info_tbl: [(ckNN,
                       label: z1_shgF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckNN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNO; else goto ckNP;
       ckNO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z2_shgG_entry() //  [R1]
         { info_tbl: [(ckNU,
                       label: z2_shgG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckNU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNV; else goto ckNW;
       ckNV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shgX_entry() //  [R1]
         { info_tbl: [(ckOm,
                       label: sat_shgX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckOm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckOn; else goto ckOo;
       ckOn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckOo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shgW_entry() //  [R1]
         { info_tbl: [(ckOt,
                       label: sat_shgW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckOt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckOu; else goto ckOv;
       ckOu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckOv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shgV_entry() //  [R1]
         { info_tbl: [(ckOA,
                       label: sat_shgV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckOA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckOB; else goto ckOC;
       ckOB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckOC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 go_shgI_entry() //  [R1, R2]
         { info_tbl: [(ckOH,
                       label: go_shgI_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckOH: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ckOI; else goto ckOJ;
       ckOI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckOJ: // global
           I64[Sp - 48] = block_ckO3_info;
           _shgI::P64 = R1;
           _shgB::P64 = P64[R1 + 7];
           _shgC::P64 = P64[R1 + 15];
           _shgD::P64 = P64[R1 + 23];
           _shgH::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _shgB::P64;
           P64[Sp - 32] = _shgC::P64;
           P64[Sp - 24] = _shgD::P64;
           P64[Sp - 16] = _shgH::P64;
           P64[Sp - 8] = _shgI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ukOT; else goto ckO4;
       ukOT: // global
           call _ckO3(R1) args: 0, res: 0, upd: 0;
       ckO4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckO3() //  [R1]
         { info_tbl: [(ckO3,
                       label: block_ckO3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckO3: // global
           if (R1 & 7 == 1) goto ckOE; else goto ckOF;
       ckOE: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckOF: // global
           I64[Sp] = block_ckO9_info;
           _shgM::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 32] = _shgM::P64;
           if (R1 & 7 != 0) goto ukOS; else goto ckOa;
       ukOS: // global
           call _ckO9(R1) args: 0, res: 0, upd: 0;
       ckOa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckO9() //  [R1]
         { info_tbl: [(ckO9,
                       label: block_ckO9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckO9: // global
           I64[Sp - 8] = block_ckOe_info;
           R2 = P64[Sp + 32];
           _shgO::P64 = P64[R1 + 7];
           _shgP::P64 = P64[R1 + 15];
           _shgQ::P64 = P64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp] = _shgQ::P64;
           P64[Sp + 32] = _shgP::P64;
           P64[Sp + 40] = _shgO::P64;
           Sp = Sp - 8;
           call go_shgI_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckOe() //  [R1]
         { info_tbl: [(ckOe,
                       label: block_ckOe_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckOe: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckOR; else goto ckOQ;
       ckOR: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckOQ: // global
           _shgS::P64 = P64[R1 + 7];
           _shgT::P64 = P64[R1 + 15];
           _shgU::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_shgX_info;
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _shgU::P64;
           I64[Hp - 104] = sat_shgW_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = _shgT::P64;
           I64[Hp - 64] = sat_shgV_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _shgS::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fMonoid(,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ckOU,
                       label: GHC.Base.$fMonoid(,,)_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckOU: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto ckOY; else goto ckOX;
       ckOY: // global
           HpAlloc = 216;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckOX: // global
           I64[Hp - 208] = $dSemigroup_shgB_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = $dSemigroup1_shgC_info;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = $dSemigroup2_shgD_info;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = z_shgE_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = z1_shgF_info;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = z2_shgG_info;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = (,,)_con_info;
           P64[Hp - 56] = Hp - 136;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 88;
           I64[Hp - 32] = go_shgI_info;
           P64[Hp - 24] = Hp - 208;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 160;
           P64[Hp] = Hp - 63;
           R2 = R5;
           R1 = Hp - 31;
           call go_shgI_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.770389059 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,)_$cstimes_info;
 },
 sat_shha_entry() //  [R1]
         { info_tbl: [(ckQW,
                       label: sat_shha_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckQW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckQX; else goto ckQY;
       ckQX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckQY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shh9_entry() //  [R1]
         { info_tbl: [(ckR3,
                       label: sat_shh9_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckR3: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckR4; else goto ckR5;
       ckR4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shh8_entry() //  [R1]
         { info_tbl: [(ckRa,
                       label: sat_shh8_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckRa: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckRb; else goto ckRc;
       ckRb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckRc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckRd,
                       label: GHC.Base.$fSemigroup(,,)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckRd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckRf; else goto ckRg;
       ckRf: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ckRg: // global
           I64[Sp - 40] = block_ckQN_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukRk; else goto ckQO;
       ukRk: // global
           call _ckQN(R1) args: 0, res: 0, upd: 0;
       ckQO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckQN() //  [R1]
         { info_tbl: [(ckQN,
                       label: block_ckQN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckQN: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ckRj; else goto ckRi;
       ckRj: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckRi: // global
           _shh5::P64 = P64[R1 + 7];
           _shh6::P64 = P64[R1 + 15];
           _shh7::P64 = P64[R1 + 23];
           I64[Hp - 168] = sat_shha_info;
           P64[Hp - 152] = P64[Sp + 16];
           _shh1::P64 = P64[Sp + 24];
           P64[Hp - 144] = _shh1::P64;
           _shh2::P64 = P64[Sp + 32];
           P64[Hp - 136] = _shh2::P64;
           P64[Hp - 128] = _shh7::P64;
           I64[Hp - 120] = sat_shh9_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = _shh1::P64;
           P64[Hp - 88] = _shh2::P64;
           P64[Hp - 80] = _shh6::P64;
           I64[Hp - 72] = sat_shh8_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = _shh1::P64;
           P64[Hp - 40] = _shh2::P64;
           P64[Hp - 32] = _shh5::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 168;
           R1 = Hp - 23;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.784360401 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_closure" {
     GHC.Base.$fSemigroup(,,)_closure:
         const GHC.Base.$fSemigroup(,,)_info;
 },
 sat_shhg_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ckSg,
                       label: sat_shhg_info
                       rep:HeapRep 3 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckSg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckSh; else goto ckSi;
       ckSh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckSi: // global
           R6 = R3;
           R5 = R2;
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fSemigroup(,,)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 sat_shhf_entry() //  [R1, R2]
         { info_tbl: [(ckSo,
                       label: sat_shhf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckSo: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,)_$csconcat_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shhe_entry() //  [R1, R2, R3]
         { info_tbl: [(ckSw,
                       label: sat_shhe_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckSw: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$c<>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,,)_entry() //  [R2, R3, R4]
         { info_tbl: [(ckSA,
                       label: GHC.Base.$fSemigroup(,,)_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckSA: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ckSE; else goto ckSD;
       ckSE: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckSD: // global
           I64[Hp - 120] = sat_shhg_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_shhf_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_shhe_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 117;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.794613255 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,)_$cp1Monoid_info;
 },
 sat_shhm_entry() //  [R1]
         { info_tbl: [(ckT9,
                       label: sat_shhm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckT9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckTa; else goto ckTb;
       ckTa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckTb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shhl_entry() //  [R1]
         { info_tbl: [(ckTg,
                       label: sat_shhl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckTh; else goto ckTi;
       ckTh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckTi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shhk_entry() //  [R1]
         { info_tbl: [(ckTn,
                       label: sat_shhk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckTn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckTo; else goto ckTp;
       ckTo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckTp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_$cp1Monoid_entry() //  [R2, R3, R4]
         { info_tbl: [(ckTq,
                       label: GHC.Base.$fMonoid(,,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckTq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ckTu; else goto ckTt;
       ckTu: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckTt: // global
           I64[Hp - 64] = sat_shhm_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_shhl_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_shhk_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,,)_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.804249871 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_closure" {
     GHC.Base.$fMonoid(,,)_closure:
         const GHC.Base.$fMonoid(,,)_info;
 },
 sat_shht_entry() //  [R1, R2]
         { info_tbl: [(ckU0,
                       label: sat_shht_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckU0: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,,)_$cmconcat_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shhs_entry() //  [R1, R2, R3]
         { info_tbl: [(ckU8,
                       label: sat_shhs_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckU8: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$cmappend_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shhr_entry() //  [R1]
         { info_tbl: [(ckUf,
                       label: sat_shhr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckUf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckUg; else goto ckUh;
       ckUg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckUh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cmempty_entry(R4,
                                                     R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shhq_entry() //  [R1]
         { info_tbl: [(ckUm,
                       label: sat_shhq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckUm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckUn; else goto ckUo;
       ckUn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckUo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cp1Monoid_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,,)_entry() //  [R2, R3, R4]
         { info_tbl: [(ckUq,
                       label: GHC.Base.$fMonoid(,,)_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckUq: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ckUu; else goto ckUt;
       ckUu: // global
           HpAlloc = 184;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckUt: // global
           I64[Hp - 176] = sat_shht_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           P64[Hp - 152] = R4;
           I64[Hp - 144] = sat_shhs_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_shhr_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_shhq_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 142;
           P64[Hp] = Hp - 175;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.816783622 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$c<>_closure" {
     GHC.Base.$fSemigroup(,)_$c<>_closure:
         const GHC.Base.$fSemigroup(,)_$c<>_info;
 },
 sat_shhF_entry() //  [R1]
         { info_tbl: [(ckVh,
                       label: sat_shhF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckVh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckVi; else goto ckVj;
       ckVi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_shhE_entry() //  [R1]
         { info_tbl: [(ckVo,
                       label: sat_shhE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckVo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckVp; else goto ckVq;
       ckVp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,)_$c<>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(ckVr,
                       label: GHC.Base.$fSemigroup(,)_$c<>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckVr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckVt; else goto ckVu;
       ckVt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckVu: // global
           I64[Sp - 32] = block_ckV3_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ukVA; else goto ckV4;
       ukVA: // global
           call _ckV3(R1) args: 0, res: 0, upd: 0;
       ckV4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckV3() //  [R1]
         { info_tbl: [(ckV3,
                       label: block_ckV3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckV3: // global
           I64[Sp - 8] = block_ckV8_info;
           _shhz::P64 = P64[R1 + 7];
           _shhA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _shhA::P64;
           P64[Sp + 24] = _shhz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukVz; else goto ckV9;
       ukVz: // global
           call _ckV8(R1) args: 0, res: 0, upd: 0;
       ckV9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckV8() //  [R1]
         { info_tbl: [(ckV8,
                       label: block_ckV8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckV8: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ckVy; else goto ckVx;
       ckVy: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckVx: // global
           _shhC::P64 = P64[R1 + 7];
           _shhD::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_shhF_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _shhD::P64;
           I64[Hp - 56] = sat_shhE_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _shhC::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.830411569 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,)_$cstimes_info;
 },
 sat_shhP_entry() //  [R1]
         { info_tbl: [(ckWt,
                       label: sat_shhP_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckWt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckWu; else goto ckWv;
       ckWu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_shhO_entry() //  [R1]
         { info_tbl: [(ckWA,
                       label: sat_shhO_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckWA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckWB; else goto ckWC;
       ckWB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.$fSemigroup(,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ckWD,
                       label: GHC.Base.$fSemigroup(,)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckWD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckWF; else goto ckWG;
       ckWF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckWG: // global
           I64[Sp - 40] = block_ckWk_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukWK; else goto ckWl;
       ukWK: // global
           call _ckWk(R1) args: 0, res: 0, upd: 0;
       ckWl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ckWk() //  [R1]
         { info_tbl: [(ckWk,
                       label: block_ckWk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckWk: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ckWJ; else goto ckWI;
       ckWJ: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckWI: // global
           _shhM::P64 = P64[R1 + 7];
           _shhN::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_shhP_info;
           P64[Hp - 96] = P64[Sp + 16];
           _shhI::P64 = P64[Sp + 24];
           P64[Hp - 88] = _shhI::P64;
           _shhJ::P64 = P64[Sp + 32];
           P64[Hp - 80] = _shhJ::P64;
           P64[Hp - 72] = _shhN::P64;
           I64[Hp - 64] = sat_shhO_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _shhI::P64;
           P64[Hp - 32] = _shhJ::P64;
           P64[Hp - 24] = _shhM::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.841309691 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_closure" {
     GHC.Base.$fSemigroup(,)_closure:
         const GHC.Base.$fSemigroup(,)_info;
 },
 sat_shhU_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(ckXu,
                       label: sat_shhU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckXu: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shhT_entry() //  [R1, R2]
         { info_tbl: [(ckXC,
                       label: sat_shhT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckXC: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,)_$csconcat_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shhS_entry() //  [R1, R2, R3]
         { info_tbl: [(ckXK,
                       label: sat_shhS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckXK: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroup(,)_$c<>_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(,)_entry() //  [R2, R3]
         { info_tbl: [(ckXO,
                       label: GHC.Base.$fSemigroup(,)_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckXO: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ckXS; else goto ckXR;
       ckXS: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckXR: // global
           I64[Hp - 96] = sat_shhU_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_shhT_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_shhS_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 46;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 93;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.850546615 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,)_$cp1Monoid_info;
 },
 sat_shhY_entry() //  [R1]
         { info_tbl: [(ckYm,
                       label: sat_shhY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckYn; else goto ckYo;
       ckYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shhX_entry() //  [R1]
         { info_tbl: [(ckYt,
                       label: sat_shhX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckYt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckYu; else goto ckYv;
       ckYu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckYv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_$cp1Monoid_entry() //  [R2, R3]
         { info_tbl: [(ckYw,
                       label: GHC.Base.$fMonoid(,)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckYw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ckYA; else goto ckYz;
       ckYA: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckYz: // global
           I64[Hp - 40] = sat_shhY_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_shhX_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,)_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.859169474 UTC

[section ""data" . GHC.Base.$fMonoid(,)_closure" {
     GHC.Base.$fMonoid(,)_closure:
         const GHC.Base.$fMonoid(,)_info;
 },
 sat_shi4_entry() //  [R1, R2]
         { info_tbl: [(ckZ0,
                       label: sat_shi4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckZ0: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,)_$cmconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shi3_entry() //  [R1, R2, R3]
         { info_tbl: [(ckZ8,
                       label: sat_shi3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckZ8: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,)_$cmappend_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shi2_entry() //  [R1]
         { info_tbl: [(ckZf,
                       label: sat_shi2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckZf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckZg; else goto ckZh;
       ckZg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cmempty_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shi1_entry() //  [R1]
         { info_tbl: [(ckZm,
                       label: sat_shi1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckZm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckZn; else goto ckZo;
       ckZn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cp1Monoid_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(,)_entry() //  [R2, R3]
         { info_tbl: [(ckZq,
                       label: GHC.Base.$fMonoid(,)_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ckZq: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckZu; else goto ckZt;
       ckZu: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckZt: // global
           I64[Hp - 144] = sat_shi4_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_shi3_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_shi2_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_shi1_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 143;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.871024955 UTC

[section ""data" . GHC.Base.$fMonoid()_$c<>_closure" {
     GHC.Base.$fMonoid()_$c<>_closure:
         const GHC.Base.$fMonoid()_$c<>_info;
 },
 GHC.Base.$fMonoid()_$c<>_entry() //  []
         { info_tbl: [(cl03,
                       label: GHC.Base.$fMonoid()_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl03: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.874579745 UTC

[section ""data" . GHC.Base.$fSemigroup()_$csconcat_closure" {
     GHC.Base.$fSemigroup()_$csconcat_closure:
         const GHC.Base.$fSemigroup()_$csconcat_info;
 },
 GHC.Base.$fSemigroup()_$csconcat_entry() //  []
         { info_tbl: [(cl0g,
                       label: GHC.Base.$fSemigroup()_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl0g: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.877767587 UTC

[section ""data" . GHC.Base.$fSemigroup()_$cstimes_closure" {
     GHC.Base.$fSemigroup()_$cstimes_closure:
         const GHC.Base.$fSemigroup()_$cstimes_info;
 },
 GHC.Base.$fSemigroup()_$cstimes_entry() //  []
         { info_tbl: [(cl0t,
                       label: GHC.Base.$fSemigroup()_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl0t: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.880971685 UTC

[section ""data" . GHC.Base.$fSemigroup()_closure" {
     GHC.Base.$fSemigroup()_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fSemigroup()_$csconcat_closure+1;
         const GHC.Base.$fSemigroup()_$cstimes_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.882767286 UTC

[section ""data" . GHC.Base.$fMonoid()_closure" {
     GHC.Base.$fMonoid()_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup()_closure+1;
         const GHC.Tuple.()_closure+1;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fMonoid()_$cmconcat_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.884873333 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$c<>_closure" {
     GHC.Base.$fSemigroup(->)_$c<>_closure:
         const GHC.Base.$fSemigroup(->)_$c<>_info;
 },
 GHC.Base.$fSemigroup(->)_$c<>_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cl0K,
                       label: GHC.Base.$fSemigroup(->)_$c<>_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl0K: // global
           _shie::P64 = R5;
           _shid::P64 = R4;
           _shic::P64 = R3;
           _shib::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cl0L; else goto cl0M;
       cl0M: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cl0O; else goto cl0N;
       cl0O: // global
           HpAlloc = 64;
           goto cl0L;
       cl0L: // global
           R5 = _shie::P64;
           R4 = _shid::P64;
           R3 = _shic::P64;
           R2 = _shib::P64;
           R1 = GHC.Base.$fSemigroup(->)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cl0N: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _shid::P64;
           P64[Hp - 32] = _shie::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _shic::P64;
           P64[Hp] = _shie::P64;
           R2 = _shib::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.890256372 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$cstimes_closure" {
     GHC.Base.$fSemigroup(->)_$cstimes_closure:
         const GHC.Base.$fSemigroup(->)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(->)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cl14,
                       label: GHC.Base.$fSemigroup(->)_$cstimes_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl14: // global
           _shil::P64 = R6;
           _shik::P64 = R5;
           _shij::P64 = R4;
           _shii::P64 = R3;
           _shih::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cl15; else goto cl16;
       cl16: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cl18; else goto cl17;
       cl18: // global
           HpAlloc = 32;
           goto cl15;
       cl15: // global
           R6 = _shil::P64;
           R5 = _shik::P64;
           R4 = _shij::P64;
           R3 = _shii::P64;
           R2 = _shih::P64;
           R1 = GHC.Base.$fSemigroup(->)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cl17: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _shik::P64;
           P64[Hp] = _shil::P64;
           R2 = _shih::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _shii::P64;
           P64[Sp - 16] = _shij::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.894977412 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_closure" {
     GHC.Base.$fSemigroup(->)_closure:
         const GHC.Base.$fSemigroup(->)_info;
 },
 sat_shiq_entry() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cl1q,
                       label: sat_shiq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl1q: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_ship_entry() //  [R1, R2]
         { info_tbl: [(cl1y,
                       label: sat_ship_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl1y: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shio_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cl1G,
                       label: sat_shio_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl1G: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fSemigroup(->)_entry() //  [R2]
         { info_tbl: [(cl1K,
                       label: GHC.Base.$fSemigroup(->)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl1K: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cl1O; else goto cl1N;
       cl1O: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl1N: // global
           I64[Hp - 72] = sat_shiq_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_ship_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_shio_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.904771301 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(->)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(->)_$cp1Monoid_info;
 },
 sat_shis_entry() //  [R1]
         { info_tbl: [(cl2i,
                       label: sat_shis_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cl2j; else goto cl2k;
       cl2j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl2k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(->)_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(cl2l,
                       label: GHC.Base.$fMonoid(->)_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl2l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl2p; else goto cl2o;
       cl2p: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl2o: // global
           I64[Hp - 16] = sat_shis_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(->)_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.91089639 UTC

[section ""data" . GHC.Base.$fMonoid(->)_closure" {
     GHC.Base.$fMonoid(->)_closure:
         const GHC.Base.$fMonoid(->)_info;
 },
 lvl3_shiu_entry() //  [R1]
         { info_tbl: [(cl2I,
                       label: lvl3_shiu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl2I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cl2J; else goto cl2K;
       cl2J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl2K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shiz_entry() //  [R1, R2, R3]
         { info_tbl: [(cl2Q,
                       label: sat_shiz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl2Q: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shiy_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cl2Y,
                       label: sat_shiy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl2Y: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shix_entry() //  [R1]
         { info_tbl: [(cl36,
                       label: sat_shix_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl36: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_shiv_entry() //  [R1]
         { info_tbl: [(cl3d,
                       label: sat_shiv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl3d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cl3e; else goto cl3f;
       cl3e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl3f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(->)_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonoid(->)_entry() //  [R2]
         { info_tbl: [(cl3h,
                       label: GHC.Base.$fMonoid(->)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl3h: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cl3l; else goto cl3k;
       cl3l: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl3k: // global
           I64[Hp - 128] = lvl3_shiu_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_shiz_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_shiy_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_shix_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_shiv_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.923074716 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$cstimes_closure" {
     GHC.Base.$fSemigroup[]_$cstimes_closure:
         const GHC.Base.$fSemigroup[]_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroup[]_$cstimes_entry() //  [R2]
         { info_tbl: [(cl3Z,
                       label: GHC.Base.$fSemigroup[]_$cstimes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl3Z: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.92636426 UTC

[section ""data" . GHC.Base.$fSemigroup[]_closure" {
     GHC.Base.$fSemigroup[]_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fSemigroup[]_$csconcat_closure+1;
         const GHC.Base.$fSemigroup[]_$cstimes_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.928058593 UTC

[section ""data" . GHC.Base.$fMonoid[]_closure" {
     GHC.Base.$fMonoid[]_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fMonoid[]_$cmconcat_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.930483659 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cpure_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cpure_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cpure_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cpure_entry() //  [R2]
         { info_tbl: [(cl4d,
                       label: GHC.Base.$fApplicativeNonEmpty_$cpure_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl4d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl4h; else goto cl4g;
       cl4h: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl4g: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.935005742 UTC

[section ""data" . GHC.Base.$w$cliftA2_closure" {
     GHC.Base.$w$cliftA2_closure:
         const GHC.Base.$w$cliftA2_info;
 },
 sat_shiI_entry() //  [R1, R2]
         { info_tbl: [(cl4G,
                       label: sat_shiI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl4G: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cl4K; else goto cl4J;
       cl4K: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl4J: // global
           _shiC::P64 = P64[R1 + 7];
           _shiF::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _shiC::P64;
           P64[Hp - 32] = _shiF::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_shiM_entry() //  [R1, R2]
         { info_tbl: [(cl4O,
                       label: sat_shiM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl4O: // global
           _shiF::P64 = R2;
           _shiM::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cl4P; else goto cl4Q;
       cl4Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl4S; else goto cl4R;
       cl4S: // global
           HpAlloc = 24;
           goto cl4P;
       cl4P: // global
           R2 = _shiF::P64;
           R1 = _shiM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl4R: // global
           _shiC::P64 = P64[_shiM::P64 + 7];
           _shiE::P64 = P64[_shiM::P64 + 15];
           I64[Hp - 16] = sat_shiI_info;
           P64[Hp - 8] = _shiC::P64;
           P64[Hp] = _shiF::P64;
           I64[Sp - 8] = block_cl4L_info;
           R3 = Hp - 15;
           R2 = _shiE::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cl4L() //  [R1, R2]
         { info_tbl: [(cl4L,
                       label: block_cl4L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl4L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl4V; else goto cl4U;
       cl4V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl4U: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cl4W,
                       label: GHC.Base.$w$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl4W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl50; else goto cl4Z;
       cl50: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cl4Z: // global
           I64[Hp - 16] = sat_shiM_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _shiD::P64 = R3;
           R3 = Hp - 15;
           R2 = _shiD::P64;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.945467719 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(cl5x,
                       label: GHC.Base.$fApplicativeNonEmpty_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl5x: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cl5y; else goto cl5z;
       cl5y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cl5z: // global
           I64[Sp - 8] = block_cl5u_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cliftA2_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cl5u() //  [R1, R2]
         { info_tbl: [(cl5u,
                       label: block_cl5u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl5u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl5C; else goto cl5B;
       cl5C: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl5B: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.951800833 UTC

[section ""data" . GHC.Base.$w$c<*_closure" {
     GHC.Base.$w$c<*_closure:
         const GHC.Base.$w$c<*_info;
 },
 sat_shiY_entry() //  [R1]
         { info_tbl: [(cl63,
                       label: sat_shiY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl63: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_shj2_entry() //  [R1, R2]
         { info_tbl: [(cl69,
                       label: sat_shj2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl69: // global
           _shiV::P64 = R2;
           _shj2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cl6a; else goto cl6b;
       cl6b: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cl6d; else goto cl6c;
       cl6d: // global
           HpAlloc = 40;
           goto cl6a;
       cl6a: // global
           R2 = _shiV::P64;
           R1 = _shj2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl6c: // global
           _shiU::P64 = P64[_shj2::P64 + 7];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _shiV::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = sat_shiY_info;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_cl66_info;
           R3 = Hp - 7;
           R2 = _shiU::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cl66() //  [R1, R2]
         { info_tbl: [(cl66,
                       label: block_cl66_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl66: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl6g; else goto cl6f;
       cl6g: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl6f: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$c<*_entry() //  [R2, R3]
         { info_tbl: [(cl6h,
                       label: GHC.Base.$w$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl6h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cl6l; else goto cl6k;
       cl6l: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl6k: // global
           I64[Hp - 8] = sat_shj2_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.96123135 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*_entry() //  [R2, R3]
         { info_tbl: [(cl6R,
                       label: GHC.Base.$fApplicativeNonEmpty_$c<*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl6R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cl6S; else goto cl6T;
       cl6S: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl6T: // global
           I64[Sp - 8] = block_cl6O_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cl6O() //  [R1, R2]
         { info_tbl: [(cl6O,
                       label: block_cl6O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl6O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl6W; else goto cl6V;
       cl6W: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl6V: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.967375299 UTC

[section ""data" . GHC.Base.$w$c<*>_closure" {
     GHC.Base.$w$c<*>_closure:
         const GHC.Base.$w$c<*>_info;
 },
 sat_shjd_entry() //  [R1, R2]
         { info_tbl: [(cl7o,
                       label: sat_shjd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl7o: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cl7s; else goto cl7r;
       cl7s: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl7r: // global
           _shja::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _shja::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_shjh_entry() //  [R1, R2]
         { info_tbl: [(cl7w,
                       label: sat_shjh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl7w: // global
           _shja::P64 = R2;
           _shjh::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cl7x; else goto cl7y;
       cl7y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cl7A; else goto cl7z;
       cl7A: // global
           HpAlloc = 16;
           goto cl7x;
       cl7x: // global
           R2 = _shja::P64;
           R1 = _shjh::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl7z: // global
           _shj9::P64 = P64[_shjh::P64 + 7];
           I64[Hp - 8] = sat_shjd_info;
           P64[Hp] = _shja::P64;
           I64[Sp - 8] = block_cl7t_info;
           R3 = Hp - 7;
           R2 = _shj9::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cl7t() //  [R1, R2]
         { info_tbl: [(cl7t,
                       label: block_cl7t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl7t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl7D; else goto cl7C;
       cl7D: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl7C: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$w$c<*>_entry() //  [R2, R3]
         { info_tbl: [(cl7E,
                       label: GHC.Base.$w$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl7E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cl7I; else goto cl7H;
       cl7I: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl7H: // global
           I64[Hp - 8] = sat_shjh_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.977908406 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(cl8f,
                       label: GHC.Base.$fApplicativeNonEmpty_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl8f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cl8g; else goto cl8h;
       cl8g: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl8h: // global
           I64[Sp - 8] = block_cl8c_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cl8c() //  [R1, R2]
         { info_tbl: [(cl8c,
                       label: block_cl8c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl8c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl8k; else goto cl8j;
       cl8k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl8j: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.983210328 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty1_closure" {
     GHC.Base.$fApplicativeNonEmpty1_closure:
         const GHC.Base.$fApplicativeNonEmpty1_info;
 },
 GHC.Base.$fApplicativeNonEmpty1_entry() //  [R3]
         { info_tbl: [(cl8A,
                       label: GHC.Base.$fApplicativeNonEmpty1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl8A: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.986864395 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c*>_info;
 },
 sat_shju_entry() //  [R1]
         { info_tbl: [(cl8S,
                       label: sat_shju_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl8S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cl8T; else goto cl8U;
       cl8T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cl8P_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ul8Y; else goto cl8Q;
       ul8Y: // global
           call _cl8P(R1) args: 0, res: 0, upd: 0;
       cl8Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cl8P() //  [R1]
         { info_tbl: [(cl8P,
                       label: block_cl8P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl8P: // global
           R3 = P64[R1 + 15];
           R2 = GHC.Base.$fApplicativeNonEmpty1_closure+2;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fApplicativeNonEmpty_$c*>_entry() //  [R2, R3]
         { info_tbl: [(cl93,
                       label: GHC.Base.$fApplicativeNonEmpty_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl93: // global
           _shjq::P64 = R3;
           _shjp::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cl94; else goto cl95;
       cl95: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cl97; else goto cl96;
       cl97: // global
           HpAlloc = 48;
           goto cl94;
       cl94: // global
           R3 = _shjq::P64;
           R2 = _shjp::P64;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl96: // global
           I64[Hp - 40] = sat_shju_info;
           P64[Hp - 24] = _shjp::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = GHC.Base.breakpoint_closure+1;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_cl90_info;
           R3 = _shjq::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cl90() //  [R1, R2]
         { info_tbl: [(cl90,
                       label: block_cl90_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl90: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl9a; else goto cl99;
       cl9a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl99: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.995864348 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_closure" {
     GHC.Base.$fApplicativeNonEmpty_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeNonEmpty_$c*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:58.997889974 UTC

[section ""data" . lvl_r7PJ_closure" {
     lvl_r7PJ_closure:
         const lvl_r7PJ_info;
         const 0;
 },
 lvl_r7PJ_entry() //  [R2]
         { info_tbl: [(cl9F,
                       label: lvl_r7PJ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl9F: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.000888435 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_closure" {
     GHC.Base.$fMonadNonEmpty_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeNonEmpty_closure+1;
         const GHC.Base.$fMonadNonEmpty_$c>>=_closure+2;
         const GHC.Base.$fMonadNonEmpty_$c>>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const lvl_r7PJ_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.003305212 UTC

[section ""cstring" . GHC.Base.$fAlternativeIO4_bytes" {
     GHC.Base.$fAlternativeIO4_bytes:
         I8[] [109,122,101,114,111]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.005170022 UTC

[section ""data" . GHC.Base.$fAlternativeIO3_closure" {
     GHC.Base.$fAlternativeIO3_closure:
         const GHC.Base.$fAlternativeIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO3_entry() //  [R1]
         { info_tbl: [(cl9U,
                       label: GHC.Base.$fAlternativeIO3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cl9U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cl9V; else goto cl9W;
       cl9V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9W: // global
           (_cl9R::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cl9R::I64 == 0) goto cl9T; else goto cl9S;
       cl9T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cl9S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cl9R::I64;
           R2 = GHC.Base.$fAlternativeIO4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.009450848 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cempty_closure" {
     GHC.Base.$fAlternativeIO_$cempty_closure:
         const GHC.Base.$fAlternativeIO_$cempty_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO_$cempty_entry() //  [R1]
         { info_tbl: [(clab,
                       label: GHC.Base.$fAlternativeIO_$cempty_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clab: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clac; else goto clad;
       clac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clad: // global
           (_cla8::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cla8::I64 == 0) goto claa; else goto cla9;
       claa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cla9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cla8::I64;
           R2 = GHC.Base.$fAlternativeIO3_closure;
           R1 = GHC.IO.failIO_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.013087692 UTC

[section ""data" . GHC.Base.$fAlternativeIO_closure" {
     GHC.Base.$fAlternativeIO_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure+2;
         const GHC.Base.$fAlternativeIO_$cmany_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.015929326 UTC

[section ""data" . GHC.Base.$fMonadPlusIO_closure" {
     GHC.Base.$fMonadPlusIO_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeIO_closure+1;
         const GHC.Base.$fMonadIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.018088885 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$c<|>_closure" {
     GHC.Base.$fAlternativeMaybe_$c<|>_closure:
         const GHC.Base.$fAlternativeMaybe_$c<|>_info;
 },
 GHC.Base.$fAlternativeMaybe_$c<|>_entry() //  [R2, R3]
         { info_tbl: [(claz,
                       label: GHC.Base.$fAlternativeMaybe_$c<|>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       claz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto claA; else goto claB;
       claA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$c<|>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       claB: // global
           I64[Sp - 16] = block_clas_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulaI; else goto clat;
       ulaI: // global
           call _clas(R1) args: 0, res: 0, upd: 0;
       clat: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clas() //  [R1]
         { info_tbl: [(clas,
                       label: block_clas_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clas: // global
           if (R1 & 7 == 1) goto claw; else goto clax;
       claw: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       clax: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.02412725 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cliftA2_closure" {
     GHC.Base.$fApplicativeMaybe_$cliftA2_closure:
         const GHC.Base.$fApplicativeMaybe_$cliftA2_info;
 },
 GHC.Base.$fApplicativeMaybe_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(clba,
                       label: GHC.Base.$fApplicativeMaybe_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clba: // global
           if ((Sp + -24) < SpLim) (likely: False) goto clbb; else goto clbc;
       clbb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clbc: // global
           I64[Sp - 24] = block_clb3_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ulbE; else goto clb4;
       ulbE: // global
           call _clb3(R1) args: 0, res: 0, upd: 0;
       clb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clb3() //  [R1]
         { info_tbl: [(clb3,
                       label: block_clb3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clb3: // global
           if (R1 & 7 == 1) goto ulbA; else goto clb8;
       ulbA: // global
           Sp = Sp + 24;
           call _clbq() args: 0, res: 0, upd: 0;
       clb8: // global
           I64[Sp] = block_clbi_info;
           _shjI::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _shjI::P64;
           if (R1 & 7 != 0) goto ulbC; else goto clbk;
       ulbC: // global
           call _clbi(R1) args: 0, res: 0, upd: 0;
       clbk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clbi() //  [R1]
         { info_tbl: [(clbi,
                       label: block_clbi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clbi: // global
           if (R1 & 7 == 1) goto ulbB; else goto clbv;
       ulbB: // global
           Sp = Sp + 24;
           call _clbq() args: 0, res: 0, upd: 0;
       clbv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto clby; else goto clbx;
       clby: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       clbx: // global
           _shjK::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _shjK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _clbq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clbq: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.034118806 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c*>_entry() //  [R2, R3]
         { info_tbl: [(clcj,
                       label: GHC.Base.$fApplicativeMaybe_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clcj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clck; else goto clcl;
       clck: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clcl: // global
           I64[Sp - 16] = block_clcc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulcs; else goto clcd;
       ulcs: // global
           call _clcc(R1) args: 0, res: 0, upd: 0;
       clcd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clcc() //  [R1]
         { info_tbl: [(clcc,
                       label: block_clcc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clcc: // global
           if (R1 & 7 == 1) goto clcg; else goto clch;
       clcg: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       clch: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.04010451 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*>_closure" {
     GHC.Base.$fApplicative(->)_$c<*>_closure:
         const GHC.Base.$fApplicative(->)_$c<*>_info;
 },
 GHC.Base.$fApplicative(->)_$c<*>_entry() //  [R2, R3, R4]
         { info_tbl: [(clcN,
                       label: GHC.Base.$fApplicative(->)_$c<*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clcN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto clcR; else goto clcQ;
       clcR: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clcQ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 24;
           _shjQ::P64 = R2;
           R2 = R4;
           R1 = _shjQ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.044384345 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$cliftA2_closure" {
     GHC.Base.$fApplicative(->)_$cliftA2_closure:
         const GHC.Base.$fApplicative(->)_$cliftA2_info;
 },
 GHC.Base.$fApplicative(->)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cld3,
                       label: GHC.Base.$fApplicative(->)_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cld3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cld7; else goto cld6;
       cld7: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cld6: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _shjU::P64 = R2;
           R2 = Hp - 24;
           R1 = _shjU::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.04813833 UTC

[section ""data" . GHC.Base.$fApplicative(->)_closure" {
     GHC.Base.$fApplicative(->)_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor(->)_closure+1;
         const GHC.Base.const_closure+2;
         const GHC.Base.$fApplicative(->)_$c<*>_closure+3;
         const GHC.Base.$fApplicative(->)_$cliftA2_closure+4;
         const GHC.Base.$fApplicative(->)_$c*>_closure+3;
         const GHC.Base.$fApplicative(->)_$c<*_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.050022524 UTC

[section ""data" . lvl1_r7PK_closure" {
     lvl1_r7PK_closure:
         const lvl1_r7PK_info;
         const 0;
 },
 lvl1_r7PK_entry() //  [R2]
         { info_tbl: [(cldj,
                       label: lvl1_r7PK_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cldj: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.052960709 UTC

[section ""data" . GHC.Base.$fMonad(->)_closure" {
     GHC.Base.$fMonad(->)_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative(->)_closure+1;
         const GHC.Base.$fMonad(->)_$c>>=_closure+3;
         const GHC.Base.$fMonad(->)_$c>>_closure+3;
         const GHC.Base.const_closure+2;
         const lvl1_r7PK_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.055227146 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cfmap_closure" {
     GHC.Base.$fApplicativeMaybe_$cfmap_closure:
         const GHC.Base.$fApplicativeMaybe_$cfmap_info;
 },
 GHC.Base.$fApplicativeMaybe_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(cldC,
                       label: GHC.Base.$fApplicativeMaybe_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cldC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cldD; else goto cldE;
       cldD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cldE: // global
           I64[Sp - 16] = block_cldv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uldP; else goto cldw;
       uldP: // global
           call _cldv(R1) args: 0, res: 0, upd: 0;
       cldw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cldv() //  [R1]
         { info_tbl: [(cldv,
                       label: block_cldv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cldv: // global
           if (R1 & 7 == 1) goto cldz; else goto cldA;
       cldz: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cldA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cldO; else goto cldN;
       cldO: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cldN: // global
           _shk4::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _shk4::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.061210244 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_closure" {
     GHC.Base.$fFunctorMaybe_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.063257086 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*>_entry() //  [R2, R3]
         { info_tbl: [(clek,
                       label: GHC.Base.$fApplicativeMaybe_$c<*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clek: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clel; else goto clem;
       clel: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clem: // global
           I64[Sp - 16] = block_cled_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulet; else goto clee;
       ulet: // global
           call _cled(R1) args: 0, res: 0, upd: 0;
       clee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cled() //  [R1]
         { info_tbl: [(cled,
                       label: block_cled_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cled: // global
           if (R1 & 7 == 1) goto cleh; else goto clei;
       cleh: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       clei: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.069109834 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_closure" {
     GHC.Base.$fApplicativeMaybe_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorMaybe_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.070863515 UTC

[section ""data" . GHC.Base.$fMonadMaybe_closure" {
     GHC.Base.$fMonadMaybe_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.07309282 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_closure" {
     GHC.Base.$fAlternativeMaybe_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const GHC.Base.$fAlternativeMaybe_$csome_closure+1;
         const GHC.Base.$fAlternativeMaybe_$cmany_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.075175401 UTC

[section ""data" . GHC.Base.$fMonadPlusMaybe_closure" {
     GHC.Base.$fMonadPlusMaybe_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.077782348 UTC

[section ""data" . GHC.Base.liftA3_$sliftA3_closure" {
     GHC.Base.liftA3_$sliftA3_closure:
         const GHC.Base.liftA3_$sliftA3_info;
 },
 GHC.Base.liftA3_$sliftA3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cleW,
                       label: GHC.Base.liftA3_$sliftA3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cleW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cleX; else goto cleY;
       cleX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA3_$sliftA3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cleY: // global
           I64[Sp - 32] = block_cleP_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ulfE; else goto cleQ;
       ulfE: // global
           call _cleP(R1) args: 0, res: 0, upd: 0;
       cleQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cleP() //  [R1]
         { info_tbl: [(cleP,
                       label: block_cleP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cleP: // global
           if (R1 & 7 == 1) goto ulfz; else goto cleU;
       ulfz: // global
           Sp = Sp + 32;
           call _clfo() args: 0, res: 0, upd: 0;
       cleU: // global
           I64[Sp] = block_clf4_info;
           _shkf::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _shkf::P64;
           if (R1 & 7 != 0) goto ulfC; else goto clf6;
       ulfC: // global
           call _clf4(R1) args: 0, res: 0, upd: 0;
       clf6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clf4() //  [R1]
         { info_tbl: [(clf4,
                       label: block_clf4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clf4: // global
           if (R1 & 7 == 1) goto ulfA; else goto clfh;
       ulfA: // global
           Sp = Sp + 32;
           call _clfo() args: 0, res: 0, upd: 0;
       clfh: // global
           I64[Sp] = block_clff_info;
           _shkh::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _shkh::P64;
           if (R1 & 7 != 0) goto ulfF; else goto clfi;
       ulfF: // global
           call _clff(R1) args: 0, res: 0, upd: 0;
       clfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clff() //  [R1]
         { info_tbl: [(clff,
                       label: block_clff_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clff: // global
           if (R1 & 7 == 1) goto ulfB; else goto clft;
       ulfB: // global
           Sp = Sp + 32;
           call _clfo() args: 0, res: 0, upd: 0;
       clft: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto clfw; else goto clfv;
       clfw: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       clfv: // global
           _shkj::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _shkj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _clfo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clfo: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.088926953 UTC

[section ""data" . GHC.Base.liftA3_closure" {
     GHC.Base.liftA3_closure:
         const GHC.Base.liftA3_info;
 },
 sat_shkq_entry() //  [R1]
         { info_tbl: [(clgq,
                       label: sat_shkq_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clgq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto clgr; else goto clgs;
       clgr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clgs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 GHC.Base.liftA3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(clgt,
                       label: GHC.Base.liftA3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clgt: // global
           _shkp::P64 = R6;
           _shko::P64 = R5;
           _shkn::P64 = R4;
           _shkm::P64 = R3;
           _shkl::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto clgu; else goto clgv;
       clgv: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto clgx; else goto clgw;
       clgx: // global
           HpAlloc = 48;
           goto clgu;
       clgu: // global
           R6 = _shkp::P64;
           R5 = _shko::P64;
           R4 = _shkn::P64;
           R3 = _shkm::P64;
           R2 = _shkl::P64;
           R1 = GHC.Base.liftA3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clgw: // global
           I64[Hp - 40] = sat_shkq_info;
           P64[Hp - 24] = _shkl::P64;
           P64[Hp - 16] = _shkm::P64;
           P64[Hp - 8] = _shkn::P64;
           P64[Hp] = _shko::P64;
           R2 = _shkl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = _shkp::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.094904665 UTC

[section ""data" . GHC.Base.liftA_$sliftA_closure" {
     GHC.Base.liftA_$sliftA_closure:
         const GHC.Base.liftA_$sliftA_info;
 },
 GHC.Base.liftA_$sliftA_entry() //  [R2, R3]
         { info_tbl: [(clgT,
                       label: GHC.Base.liftA_$sliftA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clgT: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.098398279 UTC

[section ""data" . GHC.Base.liftA_closure" {
     GHC.Base.liftA_closure:
         const GHC.Base.liftA_info;
 },
 sat_shku_entry() //  [R1]
         { info_tbl: [(clh8,
                       label: sat_shku_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clh8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto clh9; else goto clha;
       clh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clha: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Base.liftA_entry() //  [R2, R3, R4]
         { info_tbl: [(clhb,
                       label: GHC.Base.liftA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clhb: // global
           _shkt::P64 = R4;
           _shks::P64 = R3;
           _shkr::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto clhc; else goto clhd;
       clhd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto clhf; else goto clhe;
       clhf: // global
           HpAlloc = 32;
           goto clhc;
       clhc: // global
           R4 = _shkt::P64;
           R3 = _shks::P64;
           R2 = _shkr::P64;
           R1 = GHC.Base.liftA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clhe: // global
           I64[Hp - 24] = sat_shku_info;
           P64[Hp - 8] = _shkr::P64;
           P64[Hp] = _shks::P64;
           R2 = _shkr::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _shkt::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.104347659 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$cfmap_closure" {
     GHC.Base.$fFunctor(,)_$cfmap_closure:
         const GHC.Base.$fFunctor(,)_$cfmap_info;
 },
 GHC.Base.$fFunctor(,)_$cfmap_entry() //  [R2, R3]
         { info_tbl: [(clhC,
                       label: GHC.Base.$fFunctor(,)_$cfmap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clhC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clhH; else goto clhI;
       clhH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clhI: // global
           I64[Sp - 16] = block_clhz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulhM; else goto clhA;
       ulhM: // global
           call _clhz(R1) args: 0, res: 0, upd: 0;
       clhA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clhz() //  [R1]
         { info_tbl: [(clhz,
                       label: block_clhz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clhz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto clhL; else goto clhK;
       clhL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       clhK: // global
           _shky::P64 = P64[R1 + 7];
           _shkz::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _shkz::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _shky::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.110723875 UTC

[section ""data" . GHC.Base.$fFunctor(,)_closure" {
     GHC.Base.$fFunctor(,)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctor(,)_$cfmap_closure+2;
         const GHC.Base.$fFunctor(,)_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.113344018 UTC

[section ""data" . GHC.Base.$fApplicative(,)_closure" {
     GHC.Base.$fApplicative(,)_closure:
         const GHC.Base.$fApplicative(,)_info;
 },
 lvl3_shkC_entry() //  [R1]
         { info_tbl: [(clib,
                       label: lvl3_shkC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clib: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clic; else goto clid;
       clic: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clid: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shkI_entry() //  [R1, R2, R3]
         { info_tbl: [(clij,
                       label: sat_shkI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clij: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shkH_entry() //  [R1, R2, R3]
         { info_tbl: [(clir,
                       label: sat_shkH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clir: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c*>_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shkG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cliz,
                       label: sat_shkG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cliz: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fApplicative(,)_$cliftA2_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shkF_entry() //  [R1, R2, R3]
         { info_tbl: [(cliH,
                       label: sat_shkF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cliH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*>_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shkE_entry() //  [R1, R2]
         { info_tbl: [(cliQ,
                       label: sat_shkE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cliQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cliU; else goto cliT;
       cliU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cliT: // global
           _shkC::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _shkC::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Base.$fApplicative(,)_entry() //  [R2]
         { info_tbl: [(cliW,
                       label: GHC.Base.$fApplicative(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cliW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto clj0; else goto cliZ;
       clj0: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cliZ: // global
           I64[Hp - 152] = lvl3_shkC_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_shkI_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_shkH_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_shkG_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_shkF_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_shkE_info;
           P64[Hp - 56] = Hp - 152;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = GHC.Base.$fFunctor(,)_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 93;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 126;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.127299169 UTC

[section ""data" . lvl2_r7PL_closure" {
     lvl2_r7PL_closure:
         const lvl2_r7PL_info;
         const 0;
 },
 lvl2_r7PL_entry() //  [R2]
         { info_tbl: [(cljK,
                       label: lvl2_r7PL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cljK: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.131253325 UTC

[section ""data" . GHC.Base.$fMonad(,)_closure" {
     GHC.Base.$fMonad(,)_closure:
         const GHC.Base.$fMonad(,)_info;
         const 0;
 },
 lvl3_shkL_entry() //  [R1]
         { info_tbl: [(cljZ,
                       label: lvl3_shkL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cljZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clk0; else goto clk1;
       clk0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clk1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_shkQ_entry() //  [R1, R2]
         { info_tbl: [(clk8,
                       label: sat_shkQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clk8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto clkc; else goto clkb;
       clkc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clkb: // global
           _shkL::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _shkL::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_shkO_entry() //  [R1, R2, R3]
         { info_tbl: [(clki,
                       label: sat_shkO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clki: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shkN_entry() //  [R1, R2, R3]
         { info_tbl: [(clkq,
                       label: sat_shkN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clkq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>=_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_shkM_entry() //  [R1]
         { info_tbl: [(clkx,
                       label: sat_shkM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clkx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clky; else goto clkz;
       clky: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clkz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fApplicative(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fMonad(,)_entry() //  [R2]
         { info_tbl: [(clkB,
                       label: GHC.Base.$fMonad(,)_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clkB: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto clkF; else goto clkE;
       clkF: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clkE: // global
           I64[Hp - 136] = lvl3_shkL_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_shkQ_info;
           P64[Hp - 104] = Hp - 136;
           I64[Hp - 96] = sat_shkO_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_shkN_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_shkM_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl2_r7PL_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.144802145 UTC

[section ""data" . GHC.Base.C:Monad_closure" {
     GHC.Base.C:Monad_closure:
         const GHC.Base.C:Monad_info;
 },
 GHC.Base.C:Monad_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(clln,
                       label: GHC.Base.C:Monad_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clln: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cllr; else goto cllq;
       cllr: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monad_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cllq: // global
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.148907715 UTC

[section ""data" . GHC.Base.C:Functor_closure" {
     GHC.Base.C:Functor_closure:
         const GHC.Base.C:Functor_info;
 },
 GHC.Base.C:Functor_entry() //  [R2, R3]
         { info_tbl: [(cllD,
                       label: GHC.Base.C:Functor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cllD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cllH; else goto cllG;
       cllH: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Functor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cllG: // global
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.153216409 UTC

[section ""data" . GHC.Base.C:Applicative_closure" {
     GHC.Base.C:Applicative_closure:
         const GHC.Base.C:Applicative_info;
 },
 GHC.Base.C:Applicative_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cllT,
                       label: GHC.Base.C:Applicative_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cllT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cllX; else goto cllW;
       cllX: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Applicative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cllW: // global
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.157104428 UTC

[section ""data" . GHC.Base.C:Semigroup_closure" {
     GHC.Base.C:Semigroup_closure:
         const GHC.Base.C:Semigroup_info;
 },
 GHC.Base.C:Semigroup_entry() //  [R2, R3, R4]
         { info_tbl: [(clma,
                       label: GHC.Base.C:Semigroup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clma: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto clme; else goto clmd;
       clme: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Semigroup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clmd: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.161109985 UTC

[section ""data" . GHC.Base.C:Monoid_closure" {
     GHC.Base.C:Monoid_closure:
         const GHC.Base.C:Monoid_info;
 },
 GHC.Base.C:Monoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(clmq,
                       label: GHC.Base.C:Monoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clmq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto clmu; else goto clmt;
       clmu: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clmt: // global
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.164669715 UTC

[section ""data" . GHC.Base.Nothing_closure" {
     GHC.Base.Nothing_closure:
         const GHC.Base.Nothing_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.166511423 UTC

[section ""data" . GHC.Base.Just_closure" {
     GHC.Base.Just_closure:
         const GHC.Base.Just_info;
 },
 GHC.Base.Just_entry() //  [R2]
         { info_tbl: [(clmH,
                       label: GHC.Base.Just_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clmH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto clmL; else goto clmK;
       clmL: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.Just_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clmK: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.170152524 UTC

[section ""data" . GHC.Base.O_closure" {
     GHC.Base.O_closure:
         const GHC.Base.O_info;
 },
 GHC.Base.O_entry() //  [R2]
         { info_tbl: [(clmX,
                       label: GHC.Base.O_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clmX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cln1; else goto cln0;
       cln1: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.O_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cln0: // global
           I64[Hp - 8] = GHC.Base.O_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.17402876 UTC

[section ""data" . GHC.Base.:|_closure" {
     GHC.Base.:|_closure:
         const GHC.Base.:|_info;
 },
 GHC.Base.:|_entry() //  [R2, R3]
         { info_tbl: [(clnd,
                       label: GHC.Base.:|_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clnd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto clnh; else goto clng;
       clnh: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.:|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clng: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.178412392 UTC

[section ""data" . GHC.Base.C:MonadPlus_closure" {
     GHC.Base.C:MonadPlus_closure:
         const GHC.Base.C:MonadPlus_info;
 },
 GHC.Base.C:MonadPlus_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(clnt,
                       label: GHC.Base.C:MonadPlus_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clnt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto clnx; else goto clnw;
       clnx: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:MonadPlus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clnw: // global
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.182953263 UTC

[section ""data" . GHC.Base.C:Alternative_closure" {
     GHC.Base.C:Alternative_closure:
         const GHC.Base.C:Alternative_info;
 },
 GHC.Base.C:Alternative_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(clnJ,
                       label: GHC.Base.C:Alternative_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clnJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto clnN; else goto clnM;
       clnN: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Alternative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clnM: // global
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.186989115 UTC

[GHC.Base.C:Monad_con_entry() //  [R1]
         { info_tbl: [(clnU,
                       label: GHC.Base.C:Monad_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clnU: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.190446183 UTC

[GHC.Base.C:Functor_con_entry() //  [R1]
         { info_tbl: [(clo1,
                       label: GHC.Base.C:Functor_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,70,117,110,99,116,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clo1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.193646958 UTC

[GHC.Base.C:Applicative_con_entry() //  [R1]
         { info_tbl: [(clo8,
                       label: GHC.Base.C:Applicative_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,112,112,108,105,99,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clo8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.196731607 UTC

[GHC.Base.C:Semigroup_con_entry() //  [R1]
         { info_tbl: [(clof,
                       label: GHC.Base.C:Semigroup_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,83,101,109,105,103,114,111,117,112]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clof: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.199737013 UTC

[GHC.Base.C:Monoid_con_entry() //  [R1]
         { info_tbl: [(clom,
                       label: GHC.Base.C:Monoid_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,111,105,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clom: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.202840656 UTC

[GHC.Base.Nothing_con_entry() //  [R1]
         { info_tbl: [(clot,
                       label: GHC.Base.Nothing_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,78,111,116,104,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clot: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.206016954 UTC

[GHC.Base.Just_con_entry() //  [R1]
         { info_tbl: [(cloA,
                       label: GHC.Base.Just_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,74,117,115,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cloA: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.210103541 UTC

[GHC.Base.O_con_entry() //  [R1]
         { info_tbl: [(cloH,
                       label: GHC.Base.O_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,79]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cloH: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.21319344 UTC

[GHC.Base.:|_con_entry() //  [R1]
         { info_tbl: [(cloO,
                       label: GHC.Base.:|_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,58,124]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cloO: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.216221811 UTC

[GHC.Base.C:MonadPlus_con_entry() //  [R1]
         { info_tbl: [(cloV,
                       label: GHC.Base.C:MonadPlus_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100,80,108,117,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cloV: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.219406008 UTC

[GHC.Base.C:Alternative_con_entry() //  [R1]
         { info_tbl: [(clp2,
                       label: GHC.Base.C:Alternative_con_info
                       rep:HeapRep 5 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,108,116,101,114,110,97,116,105,118,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clp2: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.22286681 UTC

[section ""relreadonly" . Si3a_srt" {
     Si3a_srt:
         const GHC.Base.$fSemigroupIO_$cstimes_closure;
         const GHC.Base.$fSemigroupIO_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const GHC.Base.$fMonoidIO_$cp1Monoid_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure;
         const GHC.Base.$fAlternativeIO_$cmany_closure;
         const GHC.Base.$fSemigroupNonEmpty_closure;
         const GHC.Base.$fMonoidIO_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.failIO_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const GHC.Base.$fSemigroupMaybe_closure;
         const GHC.Base.$fMonoidMaybe_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const GHC.Base.$fAlternativeIO3_closure;
         const GHC.Base.$fMonad(,)_closure;
         const lvl2_r7PL_closure;
 }]

