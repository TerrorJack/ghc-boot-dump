
==================== Tidy Core ====================
2018-03-16 16:07:27.083145083 UTC

Result size of Tidy Core
  = {terms: 1,341, types: 608, coercions: 60, joins: 5/29}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder11 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.ByteOrder.$fReadByteOrder11 = "BigEndian"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder10 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.ByteOrder.$fReadByteOrder10
  = GHC.CString.unpackCString# GHC.ByteOrder.$fReadByteOrder11

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder7 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.ByteOrder.$fReadByteOrder7 = "LittleEndian"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.ByteOrder.$fReadByteOrder6
  = GHC.CString.unpackCString# GHC.ByteOrder.$fReadByteOrder7

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fShowByteOrder_$cshowsPrec
  :: Int -> ByteOrder -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_dcxRq [Occ=Once!] :: ByteOrder)
                 (eta_B1 [Occ=Once*] :: String) ->
                 case ds1_dcxRq of {
                   BigEndian ->
                     GHC.Base.augment
                       @ Char
                       (\ (@ b_i7JbU)
                          (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                          (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                          GHC.Base.foldr
                            @ Char @ b_i7JbU c_i7JbV n_i7JbW GHC.ByteOrder.$fReadByteOrder10)
                       eta_B1;
                   LittleEndian ->
                     GHC.Base.augment
                       @ Char
                       (\ (@ b_i7JbU)
                          (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                          (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                          GHC.Base.foldr
                            @ Char @ b_i7JbU c_i7JbV n_i7JbW GHC.ByteOrder.$fReadByteOrder6)
                       eta_B1
                 }}]
GHC.ByteOrder.$fShowByteOrder_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_dcxRq :: ByteOrder) (eta_B1 :: String) ->
      case ds1_dcxRq of {
        BigEndian -> ++ @ Char GHC.ByteOrder.$fReadByteOrder10 eta_B1;
        LittleEndian -> ++ @ Char GHC.ByteOrder.$fReadByteOrder6 eta_B1
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fShowByteOrder_$cshow :: ByteOrder -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once!] :: ByteOrder) ->
                 case x_i7Jay of {
                   BigEndian -> GHC.ByteOrder.$fReadByteOrder10;
                   LittleEndian -> GHC.ByteOrder.$fReadByteOrder6
                 }}]
GHC.ByteOrder.$fShowByteOrder_$cshow
  = \ (x_i7Jay :: ByteOrder) ->
      case x_i7Jay of {
        BigEndian -> GHC.ByteOrder.$fReadByteOrder10;
        LittleEndian -> GHC.ByteOrder.$fReadByteOrder6
      }

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fShowByteOrder1 :: ByteOrder -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dcxRq [Occ=Once!] :: ByteOrder)
                 (eta_B1 [Occ=Once*] :: String) ->
                 case ds_dcxRq of {
                   BigEndian ->
                     GHC.Base.augment
                       @ Char
                       (\ (@ b_i7JbU)
                          (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                          (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                          GHC.Base.foldr
                            @ Char @ b_i7JbU c_i7JbV n_i7JbW GHC.ByteOrder.$fReadByteOrder10)
                       eta_B1;
                   LittleEndian ->
                     GHC.Base.augment
                       @ Char
                       (\ (@ b_i7JbU)
                          (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                          (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                          GHC.Base.foldr
                            @ Char @ b_i7JbU c_i7JbV n_i7JbW GHC.ByteOrder.$fReadByteOrder6)
                       eta_B1
                 }}]
GHC.ByteOrder.$fShowByteOrder1
  = \ (ds_dcxRq :: ByteOrder) (eta_B1 :: String) ->
      case ds_dcxRq of {
        BigEndian -> ++ @ Char GHC.ByteOrder.$fReadByteOrder10 eta_B1;
        LittleEndian -> ++ @ Char GHC.ByteOrder.$fReadByteOrder6 eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fShowByteOrder_$cshowList :: [ByteOrder] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [ByteOrder])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ ByteOrder GHC.ByteOrder.$fShowByteOrder1 ls_i7JaB s_i7JaC}]
GHC.ByteOrder.$fShowByteOrder_$cshowList
  = \ (ls_i7JaB :: [ByteOrder]) (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ ByteOrder GHC.ByteOrder.$fShowByteOrder1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fShowByteOrder [InlPrag=NOUSERINLINE CONLIKE]
  :: Show ByteOrder
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: ByteOrder
                       GHC.ByteOrder.$fShowByteOrder_$cshowsPrec
                       GHC.ByteOrder.$fShowByteOrder_$cshow
                       GHC.ByteOrder.$fShowByteOrder_$cshowList]
GHC.ByteOrder.$fShowByteOrder
  = GHC.Show.C:Show
      @ ByteOrder
      GHC.ByteOrder.$fShowByteOrder_$cshowsPrec
      GHC.ByteOrder.$fShowByteOrder_$cshow
      GHC.ByteOrder.$fShowByteOrder_$cshowList

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder9
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (ByteOrder -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_i816N)
                 (k_i816O [Occ=Once!]
                    :: ByteOrder -> Text.ParserCombinators.ReadP.P b_i816N) ->
                 k_i816O GHC.ByteOrder.BigEndian}]
GHC.ByteOrder.$fReadByteOrder9
  = \ _ [Occ=Dead]
      (@ b_i816N)
      (k_i816O :: ByteOrder -> Text.ParserCombinators.ReadP.P b_i816N) ->
      k_i816O GHC.ByteOrder.BigEndian

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder8
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.ByteOrder.$fReadByteOrder8
  = (GHC.ByteOrder.$fReadByteOrder10,
     GHC.ByteOrder.$fReadByteOrder9
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <ByteOrder>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <ByteOrder>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (ByteOrder -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b :: *)
                ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder5
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (ByteOrder -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_i816N)
                 (k_i816O [Occ=Once!]
                    :: ByteOrder -> Text.ParserCombinators.ReadP.P b_i816N) ->
                 k_i816O GHC.ByteOrder.LittleEndian}]
GHC.ByteOrder.$fReadByteOrder5
  = \ _ [Occ=Dead]
      (@ b_i816N)
      (k_i816O :: ByteOrder -> Text.ParserCombinators.ReadP.P b_i816N) ->
      k_i816O GHC.ByteOrder.LittleEndian

-- RHS size: {terms: 3, types: 4, coercions: 9, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder4
  :: ([Char], Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder)
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.ByteOrder.$fReadByteOrder4
  = (GHC.ByteOrder.$fReadByteOrder6,
     GHC.ByteOrder.$fReadByteOrder5
     `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
              ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                            <ByteOrder>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <ByteOrder>_R)
             :: (Text.ParserCombinators.ReadPrec.Prec
                 -> forall b.
                    (ByteOrder -> Text.ParserCombinators.ReadP.P b)
                    -> Text.ParserCombinators.ReadP.P b :: *)
                ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder :: *)))

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder3
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.ByteOrder.$fReadByteOrder3
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder)
      GHC.ByteOrder.$fReadByteOrder4
      (GHC.Types.[]
         @ (String, Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder_sps
  :: [(String, Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder)]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.ByteOrder.$fReadByteOrder_sps
  = GHC.Types.:
      @ (String, Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder)
      GHC.ByteOrder.$fReadByteOrder8
      GHC.ByteOrder.$fReadByteOrder3

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder2
  :: Text.ParserCombinators.ReadPrec.Prec
     -> Text.ParserCombinators.ReadP.ReadP ByteOrder
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (eta_i816r [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.Prec) ->
                 GHC.Read.choose2
                   @ ByteOrder GHC.ByteOrder.$fReadByteOrder_sps eta_i816r}]
GHC.ByteOrder.$fReadByteOrder2
  = \ (eta_i816r :: Text.ParserCombinators.ReadPrec.Prec) ->
      GHC.Read.choose2
        @ ByteOrder GHC.ByteOrder.$fReadByteOrder_sps eta_i816r

-- RHS size: {terms: 2, types: 1, coercions: 3, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (ByteOrder -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.ByteOrder.$fReadByteOrder1
  = GHC.Read.list3
      @ ByteOrder
      (GHC.ByteOrder.$fReadByteOrder2
       `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <ByteOrder>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> Text.ParserCombinators.ReadP.ReadP ByteOrder :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder :: *)))

-- RHS size: {terms: 6, types: 5, coercions: 3, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder_$creadsPrec :: Int -> ReadS ByteOrder
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i8156 [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ ByteOrder
                   (GHC.Read.list3
                      @ ByteOrder
                      (GHC.ByteOrder.$fReadByteOrder2
                       `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                        <ByteOrder>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> Text.ParserCombinators.ReadP.ReadP ByteOrder :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder :: *)))
                      n_i8156
                      @ ByteOrder
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ ByteOrder))}]
GHC.ByteOrder.$fReadByteOrder_$creadsPrec
  = \ (n_i8156 :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ ByteOrder
        (GHC.Read.list3
           @ ByteOrder
           (GHC.ByteOrder.$fReadByteOrder2
            `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <ByteOrder>_R)
                    :: (Text.ParserCombinators.ReadPrec.Prec
                        -> Text.ParserCombinators.ReadP.ReadP ByteOrder :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder :: *)))
           n_i8156
           @ ByteOrder
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ ByteOrder))

-- RHS size: {terms: 2, types: 1, coercions: 9, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [ByteOrder]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.ByteOrder.$fReadByteOrder_$creadListPrec
  = GHC.Read.list
      @ ByteOrder
      (GHC.ByteOrder.$fReadByteOrder1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <ByteOrder>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <ByteOrder>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (ByteOrder -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 6, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder12
  :: Text.ParserCombinators.ReadP.P [ByteOrder]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
GHC.ByteOrder.$fReadByteOrder12
  = (((GHC.ByteOrder.$fReadByteOrder_$creadListPrec
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                   <[ByteOrder]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [ByteOrder] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [ByteOrder] :: *)))
        GHC.Read.$fRead()7)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[ByteOrder]>_R
             :: (Text.ParserCombinators.ReadP.ReadP [ByteOrder] :: *)
                ~R# (forall b.
                     ([ByteOrder] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)))
      @ [ByteOrder]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [ByteOrder])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder_$creadList :: ReadS [ByteOrder]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.ByteOrder.$fReadByteOrder_$creadList
  = Text.ParserCombinators.ReadP.run
      @ [ByteOrder] GHC.ByteOrder.$fReadByteOrder12

-- RHS size: {terms: 5, types: 1, coercions: 9, joins: 0/0}
GHC.ByteOrder.$fReadByteOrder [InlPrag=NOUSERINLINE CONLIKE]
  :: Read ByteOrder
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: ByteOrder
                       GHC.ByteOrder.$fReadByteOrder_$creadsPrec
                       GHC.ByteOrder.$fReadByteOrder_$creadList
                       GHC.ByteOrder.$fReadByteOrder1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <ByteOrder>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <ByteOrder>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (ByteOrder -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder :: *))
                       GHC.ByteOrder.$fReadByteOrder_$creadListPrec]
GHC.ByteOrder.$fReadByteOrder
  = GHC.Read.C:Read
      @ ByteOrder
      GHC.ByteOrder.$fReadByteOrder_$creadsPrec
      GHC.ByteOrder.$fReadByteOrder_$creadList
      (GHC.ByteOrder.$fReadByteOrder1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <ByteOrder>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <ByteOrder>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (ByteOrder -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec ByteOrder :: *)))
      GHC.ByteOrder.$fReadByteOrder_$creadListPrec

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fBoundedByteOrder [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded ByteOrder
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: ByteOrder
                          GHC.ByteOrder.BigEndian
                          GHC.ByteOrder.LittleEndian]
GHC.ByteOrder.$fBoundedByteOrder
  = GHC.Enum.C:Bounded
      @ ByteOrder GHC.ByteOrder.BigEndian GHC.ByteOrder.LittleEndian

-- RHS size: {terms: 16, types: 5, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fOrdByteOrder_$c< :: ByteOrder -> ByteOrder -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_acxML [Occ=Once!] :: ByteOrder)
                 (b_acxMM [Occ=Once*] :: ByteOrder) ->
                 case a_acxML of {
                   BigEndian ->
                     case b_acxMM of {
                       BigEndian -> GHC.Types.False;
                       LittleEndian -> GHC.Types.True
                     };
                   LittleEndian -> case b_acxMM of { __DEFAULT -> GHC.Types.False }
                 }}]
GHC.ByteOrder.$fOrdByteOrder_$c<
  = \ (a_acxML :: ByteOrder) (b_acxMM :: ByteOrder) ->
      case a_acxML of {
        BigEndian ->
          case b_acxMM of {
            BigEndian -> GHC.Types.False;
            LittleEndian -> GHC.Types.True
          };
        LittleEndian -> case b_acxMM of { __DEFAULT -> GHC.Types.False }
      }

-- RHS size: {terms: 18, types: 5, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fOrdByteOrder_$ccompare
  :: ByteOrder -> ByteOrder -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_acxMJ [Occ=Once!] :: ByteOrder)
                 (b_acxMK [Occ=Once*!] :: ByteOrder) ->
                 case a_acxMJ of {
                   BigEndian ->
                     case b_acxMK of {
                       BigEndian -> GHC.Types.EQ;
                       LittleEndian -> GHC.Types.LT
                     };
                   LittleEndian ->
                     case b_acxMK of {
                       BigEndian -> GHC.Types.GT;
                       LittleEndian -> GHC.Types.EQ
                     }
                 }}]
GHC.ByteOrder.$fOrdByteOrder_$ccompare
  = \ (a_acxMJ :: ByteOrder) (b_acxMK :: ByteOrder) ->
      case a_acxMJ of {
        BigEndian ->
          case b_acxMK of {
            BigEndian -> GHC.Types.EQ;
            LittleEndian -> GHC.Types.LT
          };
        LittleEndian ->
          case b_acxMK of {
            BigEndian -> GHC.Types.GT;
            LittleEndian -> GHC.Types.EQ
          }
      }

-- RHS size: {terms: 18, types: 5, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEqByteOrder_$c== :: ByteOrder -> ByteOrder -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dcxQZ [Occ=Once!] :: ByteOrder)
                 (ds1_dcxR0 [Occ=Once*!] :: ByteOrder) ->
                 case ds_dcxQZ of {
                   BigEndian ->
                     case ds1_dcxR0 of {
                       BigEndian -> GHC.Types.True;
                       LittleEndian -> GHC.Types.False
                     };
                   LittleEndian ->
                     case ds1_dcxR0 of {
                       BigEndian -> GHC.Types.False;
                       LittleEndian -> GHC.Types.True
                     }
                 }}]
GHC.ByteOrder.$fEqByteOrder_$c==
  = \ (ds_dcxQZ :: ByteOrder) (ds1_dcxR0 :: ByteOrder) ->
      case ds_dcxQZ of {
        BigEndian ->
          case ds1_dcxR0 of {
            BigEndian -> GHC.Types.True;
            LittleEndian -> GHC.Types.False
          };
        LittleEndian ->
          case ds1_dcxR0 of {
            BigEndian -> GHC.Types.False;
            LittleEndian -> GHC.Types.True
          }
      }

-- RHS size: {terms: 18, types: 5, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEqByteOrder_$c/= [InlPrag=INLINE (sat-args=2)]
  :: ByteOrder -> ByteOrder -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once!] :: ByteOrder)
                 (y_a22c [Occ=Once*!] :: ByteOrder) ->
                 case x_a22b of {
                   BigEndian ->
                     case y_a22c of {
                       BigEndian -> GHC.Types.False;
                       LittleEndian -> GHC.Types.True
                     };
                   LittleEndian ->
                     case y_a22c of {
                       BigEndian -> GHC.Types.True;
                       LittleEndian -> GHC.Types.False
                     }
                 }}]
GHC.ByteOrder.$fEqByteOrder_$c/=
  = \ (eta_B2 :: ByteOrder) (eta1_B1 :: ByteOrder) ->
      case eta_B2 of {
        BigEndian ->
          case eta1_B1 of {
            BigEndian -> GHC.Types.False;
            LittleEndian -> GHC.Types.True
          };
        LittleEndian ->
          case eta1_B1 of {
            BigEndian -> GHC.Types.True;
            LittleEndian -> GHC.Types.False
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEqByteOrder [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq ByteOrder
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: ByteOrder
                        GHC.ByteOrder.$fEqByteOrder_$c==
                        GHC.ByteOrder.$fEqByteOrder_$c/=]
GHC.ByteOrder.$fEqByteOrder
  = GHC.Classes.C:Eq
      @ ByteOrder
      GHC.ByteOrder.$fEqByteOrder_$c==
      GHC.ByteOrder.$fEqByteOrder_$c/=

-- RHS size: {terms: 16, types: 5, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fOrdByteOrder_$c<= :: ByteOrder -> ByteOrder -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_acxMN [Occ=Once*] :: ByteOrder)
                 (b_acxMO [Occ=Once!] :: ByteOrder) ->
                 case b_acxMO of {
                   BigEndian ->
                     case a_acxMN of {
                       BigEndian -> GHC.Types.True;
                       LittleEndian -> GHC.Types.False
                     };
                   LittleEndian -> case a_acxMN of { __DEFAULT -> GHC.Types.True }
                 }}]
GHC.ByteOrder.$fOrdByteOrder_$c<=
  = \ (a_acxMN :: ByteOrder) (b_acxMO :: ByteOrder) ->
      case b_acxMO of {
        BigEndian ->
          case a_acxMN of {
            BigEndian -> GHC.Types.True;
            LittleEndian -> GHC.Types.False
          };
        LittleEndian -> case a_acxMN of { __DEFAULT -> GHC.Types.True }
      }

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fOrdByteOrder_$cmax
  :: ByteOrder -> ByteOrder -> ByteOrder
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once*] :: ByteOrder)
                 (y_a55e [Occ=Once!] :: ByteOrder) ->
                 case y_a55e of {
                   BigEndian -> x_a55d;
                   LittleEndian ->
                     case x_a55d of { __DEFAULT -> GHC.ByteOrder.LittleEndian }
                 }}]
GHC.ByteOrder.$fOrdByteOrder_$cmax
  = \ (x_a55d :: ByteOrder) (y_a55e :: ByteOrder) ->
      case y_a55e of {
        BigEndian -> x_a55d;
        LittleEndian ->
          case x_a55d of { __DEFAULT -> GHC.ByteOrder.LittleEndian }
      }

-- RHS size: {terms: 16, types: 5, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fOrdByteOrder_$c>= :: ByteOrder -> ByteOrder -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_acxMR [Occ=Once!] :: ByteOrder)
                 (b_acxMS [Occ=Once*] :: ByteOrder) ->
                 case a_acxMR of {
                   BigEndian ->
                     case b_acxMS of {
                       BigEndian -> GHC.Types.True;
                       LittleEndian -> GHC.Types.False
                     };
                   LittleEndian -> case b_acxMS of { __DEFAULT -> GHC.Types.True }
                 }}]
GHC.ByteOrder.$fOrdByteOrder_$c>=
  = \ (a_acxMR :: ByteOrder) (b_acxMS :: ByteOrder) ->
      case a_acxMR of {
        BigEndian ->
          case b_acxMS of {
            BigEndian -> GHC.Types.True;
            LittleEndian -> GHC.Types.False
          };
        LittleEndian -> case b_acxMS of { __DEFAULT -> GHC.Types.True }
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fOrdByteOrder_$c> :: ByteOrder -> ByteOrder -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (a_acxMP [Occ=Once] :: ByteOrder)
                 (b_acxMQ [Occ=Once] :: ByteOrder) ->
                 GHC.ByteOrder.$fOrdByteOrder_$c< b_acxMQ a_acxMP}]
GHC.ByteOrder.$fOrdByteOrder_$c>
  = \ (a_acxMP :: ByteOrder) (b_acxMQ :: ByteOrder) ->
      GHC.ByteOrder.$fOrdByteOrder_$c< b_acxMQ a_acxMP

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fOrdByteOrder_$cmin
  :: ByteOrder -> ByteOrder -> ByteOrder
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once*] :: ByteOrder)
                 (y_a55n [Occ=Once!] :: ByteOrder) ->
                 case y_a55n of {
                   BigEndian ->
                     case x_a55m of { __DEFAULT -> GHC.ByteOrder.BigEndian };
                   LittleEndian -> x_a55m
                 }}]
GHC.ByteOrder.$fOrdByteOrder_$cmin
  = \ (x_a55m :: ByteOrder) (y_a55n :: ByteOrder) ->
      case y_a55n of {
        BigEndian ->
          case x_a55m of { __DEFAULT -> GHC.ByteOrder.BigEndian };
        LittleEndian -> x_a55m
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fOrdByteOrder [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord ByteOrder
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: ByteOrder
                         GHC.ByteOrder.$fEqByteOrder
                         GHC.ByteOrder.$fOrdByteOrder_$ccompare
                         GHC.ByteOrder.$fOrdByteOrder_$c<
                         GHC.ByteOrder.$fOrdByteOrder_$c<=
                         GHC.ByteOrder.$fOrdByteOrder_$c>
                         GHC.ByteOrder.$fOrdByteOrder_$c>=
                         GHC.ByteOrder.$fOrdByteOrder_$cmax
                         GHC.ByteOrder.$fOrdByteOrder_$cmin]
GHC.ByteOrder.$fOrdByteOrder
  = GHC.Classes.C:Ord
      @ ByteOrder
      GHC.ByteOrder.$fEqByteOrder
      GHC.ByteOrder.$fOrdByteOrder_$ccompare
      GHC.ByteOrder.$fOrdByteOrder_$c<
      GHC.ByteOrder.$fOrdByteOrder_$c<=
      GHC.ByteOrder.$fOrdByteOrder_$c>
      GHC.ByteOrder.$fOrdByteOrder_$c>=
      GHC.ByteOrder.$fOrdByteOrder_$cmax
      GHC.ByteOrder.$fOrdByteOrder_$cmin

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
targetByteOrder :: ByteOrder
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.ByteOrder.LittleEndian}]
targetByteOrder = GHC.ByteOrder.LittleEndian

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_rcykn :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl_rcykn = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl1_rcyko :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl1_rcyko = GHC.Types.I# 1#

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder_$cfromEnum :: ByteOrder -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_acxN4 [Occ=Once!] :: ByteOrder) ->
                 case a_acxN4 of {
                   BigEndian -> GHC.Types.I# 0#;
                   LittleEndian -> GHC.Types.I# 1#
                 }}]
GHC.ByteOrder.$fEnumByteOrder_$cfromEnum
  = \ (a_acxN4 :: ByteOrder) ->
      case a_acxN4 of {
        BigEndian -> lvl_rcykn;
        LittleEndian -> lvl1_rcyko
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2_rcykp :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl2_rcykp = "error"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl3_rcykq :: [Char]
[GblId]
lvl3_rcykq = GHC.CString.unpackCString# lvl2_rcykp

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.ByteOrder.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl4_rcykr :: [Char]
[GblId]
lvl4_rcykr = GHC.CString.unpackCString# GHC.ByteOrder.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.ByteOrder.$trModule2 = "GHC.ByteOrder"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl5_rcyks :: [Char]
[GblId]
lvl5_rcyks = GHC.CString.unpackCString# GHC.ByteOrder.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl6_rcykt :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl6_rcykt = "./GHC/ByteOrder.hs"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl7_rcyku :: [Char]
[GblId]
lvl7_rcyku = GHC.CString.unpackCString# lvl6_rcykt

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl8_rcykv :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl8_rcykv = GHC.Types.I# 26#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl9_rcykw :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl9_rcykw = GHC.Types.I# 16#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl10_rcykx :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl10_rcykx = GHC.Types.I# 20#

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
lvl11_rcyky :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []]
lvl11_rcyky
  = GHC.Stack.Types.SrcLoc
      lvl4_rcykr
      lvl5_rcyks
      lvl7_rcyku
      lvl8_rcykv
      lvl9_rcykw
      lvl8_rcykv
      lvl10_rcykx

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
lvl12_rcykz :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []]
lvl12_rcykz
  = GHC.Stack.Types.PushCallStack
      lvl3_rcykq lvl11_rcyky GHC.Stack.Types.EmptyCallStack

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl13_rcykA :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl13_rcykA
  = "pred{ByteOrder}: tried to take `pred' of first tag in enumeration"#

-- RHS size: {terms: 4, types: 2, coercions: 4, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder3 :: ByteOrder
[GblId, Str=x]
GHC.ByteOrder.$fEnumByteOrder3
  = error
      @ 'GHC.Types.LiftedRep
      @ ByteOrder
      (lvl12_rcykz
       `cast` (Sym (GHC.Classes.N:IP[0]
                        <"callStack">_N <GHC.Stack.Types.CallStack>_N)
               :: (GHC.Stack.Types.CallStack :: *)
                  ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))
      (GHC.CString.unpackCString# lvl13_rcykA)

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder_$cpred :: ByteOrder -> ByteOrder
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_acxMV [Occ=Once!] :: ByteOrder) ->
                 case a_acxMV of {
                   BigEndian -> GHC.ByteOrder.$fEnumByteOrder3;
                   LittleEndian -> GHC.ByteOrder.BigEndian
                 }}]
GHC.ByteOrder.$fEnumByteOrder_$cpred
  = \ (a_acxMV :: ByteOrder) ->
      case a_acxMV of {
        BigEndian -> GHC.ByteOrder.$fEnumByteOrder3;
        LittleEndian -> GHC.ByteOrder.BigEndian
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl14_rcykB :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl14_rcykB
  = "succ{ByteOrder}: tried to take `succ' of last tag in enumeration"#

-- RHS size: {terms: 4, types: 2, coercions: 4, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder4 :: ByteOrder
[GblId, Str=x]
GHC.ByteOrder.$fEnumByteOrder4
  = error
      @ 'GHC.Types.LiftedRep
      @ ByteOrder
      (lvl12_rcykz
       `cast` (Sym (GHC.Classes.N:IP[0]
                        <"callStack">_N <GHC.Stack.Types.CallStack>_N)
               :: (GHC.Stack.Types.CallStack :: *)
                  ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))
      (GHC.CString.unpackCString# lvl14_rcykB)

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder_$csucc :: ByteOrder -> ByteOrder
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_acxMT [Occ=Once!] :: ByteOrder) ->
                 case a_acxMT of {
                   BigEndian -> GHC.ByteOrder.LittleEndian;
                   LittleEndian -> GHC.ByteOrder.$fEnumByteOrder4
                 }}]
GHC.ByteOrder.$fEnumByteOrder_$csucc
  = \ (a_acxMT :: ByteOrder) ->
      case a_acxMT of {
        BigEndian -> GHC.ByteOrder.LittleEndian;
        LittleEndian -> GHC.ByteOrder.$fEnumByteOrder4
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl15_rcykC :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl15_rcykC = ") is outside of enumeration's range (0,"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl16_rcykD :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl16_rcykD = ")"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl17_rcykE :: [Char]
[GblId]
lvl17_rcykE = GHC.CString.unpackCString# lvl16_rcykD

-- RHS size: {terms: 9, types: 10, coercions: 0, joins: 0/0}
lvl18_rcykF :: [Char]
[GblId]
lvl18_rcykF
  = case GHC.Show.$wshowSignedInt 0# 1# lvl17_rcykE of
    { (# ww5_i7NVe, ww6_i7NVf #) ->
    GHC.Types.: @ Char ww5_i7NVe ww6_i7NVf
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
lvl19_rcykG :: [Char]
[GblId]
lvl19_rcykG
  = GHC.CString.unpackAppendCString# lvl15_rcykC lvl18_rcykF

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl20_rcykH :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl20_rcykH = "toEnum{ByteOrder}: tag ("#

-- RHS size: {terms: 14, types: 13, coercions: 4, joins: 0/0}
GHC.ByteOrder.$wlvl [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> ByteOrder
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.ByteOrder.$wlvl
  = \ (ww_scy8s :: GHC.Prim.Int#) ->
      error
        @ 'GHC.Types.LiftedRep
        @ ByteOrder
        (lvl12_rcykz
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: (GHC.Stack.Types.CallStack :: *)
                    ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))
        (GHC.CString.unpackAppendCString#
           lvl20_rcykH
           (case GHC.Show.$wshowSignedInt 0# ww_scy8s lvl19_rcykG of
            { (# ww5_i7NVe, ww6_i7NVf #) ->
            GHC.Types.: @ Char ww5_i7NVe ww6_i7NVf
            }))

-- RHS size: {terms: 19, types: 4, coercions: 0, joins: 0/0}
GHC.ByteOrder.$w$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> ByteOrder
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 83 0}]
GHC.ByteOrder.$w$ctoEnum
  = \ (ww_scy8y :: GHC.Prim.Int#) ->
      case GHC.Prim.>=# ww_scy8y 0# of {
        __DEFAULT -> GHC.ByteOrder.$wlvl ww_scy8y;
        1# ->
          case GHC.Prim.<=# ww_scy8y 1# of {
            __DEFAULT -> GHC.ByteOrder.$wlvl ww_scy8y;
            1# -> GHC.Prim.tagToEnum# @ ByteOrder ww_scy8y
          }
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: Int -> ByteOrder
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_scy8v [Occ=Once!] :: Int) ->
                 case w_scy8v of { GHC.Types.I# ww1_scy8y [Occ=Once] ->
                 GHC.ByteOrder.$w$ctoEnum ww1_scy8y
                 }}]
GHC.ByteOrder.$fEnumByteOrder_$ctoEnum
  = \ (w_scy8v :: Int) ->
      case w_scy8v of { GHC.Types.I# ww1_scy8y ->
      GHC.ByteOrder.$w$ctoEnum ww1_scy8y
      }

Rec {
-- RHS size: {terms: 13, types: 5, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder_go2 [Occ=LoopBreaker]
  :: GHC.Prim.Int# -> [ByteOrder]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []]
GHC.ByteOrder.$fEnumByteOrder_go2
  = \ (x_i819P :: GHC.Prim.Int#) ->
      GHC.Types.:
        @ ByteOrder
        (GHC.Prim.tagToEnum# @ ByteOrder x_i819P)
        (case x_i819P of wild_X2H {
           __DEFAULT ->
             GHC.ByteOrder.$fEnumByteOrder_go2 (GHC.Prim.+# wild_X2H 1#);
           1# -> GHC.Types.[] @ ByteOrder
         })
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder2 :: [ByteOrder]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.ByteOrder.$fEnumByteOrder2
  = GHC.ByteOrder.$fEnumByteOrder_go2 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder1 :: [ByteOrder]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.ByteOrder.$fEnumByteOrder1
  = GHC.ByteOrder.$fEnumByteOrder_go2 1#

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder_$cenumFrom
  :: ByteOrder -> [ByteOrder]
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
GHC.ByteOrder.$fEnumByteOrder_$cenumFrom
  = \ (a_acxMY :: ByteOrder) ->
      case a_acxMY of {
        BigEndian -> GHC.ByteOrder.$fEnumByteOrder2;
        LittleEndian -> GHC.ByteOrder.$fEnumByteOrder1
      }

-- RHS size: {terms: 236, types: 95, coercions: 0, joins: 2/14}
GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen
  :: ByteOrder -> ByteOrder -> [ByteOrder]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []]
GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen
  = \ (a_acxN0 :: ByteOrder) (b_acxN1 :: ByteOrder) ->
      join {
        $j_scxWp [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> [ByteOrder]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_scxWp (a#_acxN2 [OS=OneShot]
                    :: GHC.Prim.Int#
                    Unf=OtherCon [])
          = join {
              $j1_scxWn [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> [ByteOrder]
              [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
              $j1_scxWn (b#_acxN3 [OS=OneShot]
                           :: GHC.Prim.Int#
                           Unf=OtherCon [])
                = case GHC.Prim.># a#_acxN2 b#_acxN3 of {
                    __DEFAULT ->
                      case GHC.Prim.>=# b#_acxN3 a#_acxN2 of {
                        __DEFAULT ->
                          case GHC.Prim.># 1# b#_acxN3 of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ ByteOrder
                                (GHC.Prim.tagToEnum# @ ByteOrder a#_acxN2)
                                (let {
                                   delta_i81tM [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   delta_i81tM = GHC.Prim.-# b#_acxN3 a#_acxN2 } in
                                 let {
                                   y'_i81tN [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   y'_i81tN = GHC.Prim.-# 1# delta_i81tM } in
                                 letrec {
                                   go_dn_i81tO [Occ=LoopBreaker] :: GHC.Prim.Int# -> [ByteOrder]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_i81tO
                                     = \ (x_i81tP :: GHC.Prim.Int#) ->
                                         case GHC.Prim.<# x_i81tP y'_i81tN of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (GHC.Prim.tagToEnum# @ ByteOrder x_i81tP)
                                               (go_dn_i81tO (GHC.Prim.+# x_i81tP delta_i81tM));
                                           1# ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (GHC.Prim.tagToEnum# @ ByteOrder x_i81tP)
                                               (GHC.Types.[] @ ByteOrder)
                                         }; } in
                                 go_dn_i81tO b#_acxN3);
                            1# ->
                              case GHC.Prim.># 1# a#_acxN2 of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ ByteOrder
                                    (GHC.Prim.tagToEnum# @ ByteOrder a#_acxN2)
                                    (GHC.Types.[] @ ByteOrder);
                                1# -> GHC.Types.[] @ ByteOrder
                              }
                          };
                        1# ->
                          case GHC.Prim.<# 1# b#_acxN3 of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ ByteOrder
                                (GHC.Prim.tagToEnum# @ ByteOrder a#_acxN2)
                                (let {
                                   delta_i81u2 [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   delta_i81u2 = GHC.Prim.-# b#_acxN3 a#_acxN2 } in
                                 let {
                                   y'_i81u3 [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   y'_i81u3 = GHC.Prim.-# 1# delta_i81u2 } in
                                 letrec {
                                   go_up_i81u4 [Occ=LoopBreaker] :: GHC.Prim.Int# -> [ByteOrder]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_i81u4
                                     = \ (x_i81u5 :: GHC.Prim.Int#) ->
                                         case GHC.Prim.># x_i81u5 y'_i81u3 of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (GHC.Prim.tagToEnum# @ ByteOrder x_i81u5)
                                               (go_up_i81u4 (GHC.Prim.+# x_i81u5 delta_i81u2));
                                           1# ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (GHC.Prim.tagToEnum# @ ByteOrder x_i81u5)
                                               (GHC.Types.[] @ ByteOrder)
                                         }; } in
                                 go_up_i81u4 b#_acxN3);
                            1# ->
                              case GHC.Prim.<# 1# a#_acxN2 of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ ByteOrder
                                    (GHC.Prim.tagToEnum# @ ByteOrder a#_acxN2)
                                    (GHC.Types.[] @ ByteOrder);
                                1# -> GHC.Types.[] @ ByteOrder
                              }
                          }
                      };
                    1# ->
                      case GHC.Prim.>=# b#_acxN3 a#_acxN2 of {
                        __DEFAULT ->
                          case GHC.Prim.># 0# b#_acxN3 of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ ByteOrder
                                (GHC.Prim.tagToEnum# @ ByteOrder a#_acxN2)
                                (let {
                                   delta_i81tM [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   delta_i81tM = GHC.Prim.-# b#_acxN3 a#_acxN2 } in
                                 let {
                                   y'_i81tN [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   y'_i81tN = GHC.Prim.-# 0# delta_i81tM } in
                                 letrec {
                                   go_dn_i81tO [Occ=LoopBreaker] :: GHC.Prim.Int# -> [ByteOrder]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_i81tO
                                     = \ (x_i81tP :: GHC.Prim.Int#) ->
                                         case GHC.Prim.<# x_i81tP y'_i81tN of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (GHC.Prim.tagToEnum# @ ByteOrder x_i81tP)
                                               (go_dn_i81tO (GHC.Prim.+# x_i81tP delta_i81tM));
                                           1# ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (GHC.Prim.tagToEnum# @ ByteOrder x_i81tP)
                                               (GHC.Types.[] @ ByteOrder)
                                         }; } in
                                 go_dn_i81tO b#_acxN3);
                            1# ->
                              case GHC.Prim.># 0# a#_acxN2 of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ ByteOrder
                                    (GHC.Prim.tagToEnum# @ ByteOrder a#_acxN2)
                                    (GHC.Types.[] @ ByteOrder);
                                1# -> GHC.Types.[] @ ByteOrder
                              }
                          };
                        1# ->
                          case GHC.Prim.<# 0# b#_acxN3 of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ ByteOrder
                                (GHC.Prim.tagToEnum# @ ByteOrder a#_acxN2)
                                (let {
                                   delta_i81u2 [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   delta_i81u2 = GHC.Prim.-# b#_acxN3 a#_acxN2 } in
                                 let {
                                   y'_i81u3 [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   y'_i81u3 = GHC.Prim.-# 0# delta_i81u2 } in
                                 letrec {
                                   go_up_i81u4 [Occ=LoopBreaker] :: GHC.Prim.Int# -> [ByteOrder]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_i81u4
                                     = \ (x_i81u5 :: GHC.Prim.Int#) ->
                                         case GHC.Prim.># x_i81u5 y'_i81u3 of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (GHC.Prim.tagToEnum# @ ByteOrder x_i81u5)
                                               (go_up_i81u4 (GHC.Prim.+# x_i81u5 delta_i81u2));
                                           1# ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (GHC.Prim.tagToEnum# @ ByteOrder x_i81u5)
                                               (GHC.Types.[] @ ByteOrder)
                                         }; } in
                                 go_up_i81u4 b#_acxN3);
                            1# ->
                              case GHC.Prim.<# 0# a#_acxN2 of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ ByteOrder
                                    (GHC.Prim.tagToEnum# @ ByteOrder a#_acxN2)
                                    (GHC.Types.[] @ ByteOrder);
                                1# -> GHC.Types.[] @ ByteOrder
                              }
                          }
                      }
                  } } in
            case b_acxN1 of {
              BigEndian -> jump $j1_scxWn 0#;
              LittleEndian -> jump $j1_scxWn 1#
            } } in
      case a_acxN0 of {
        BigEndian -> jump $j_scxWp 0#;
        LittleEndian -> jump $j_scxWp 1#
      }

Rec {
-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder_go1 [Occ=LoopBreaker]
  :: GHC.Prim.Int# -> [ByteOrder]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.ByteOrder.$fEnumByteOrder_go1
  = \ (x_i819P :: GHC.Prim.Int#) ->
      GHC.Types.:
        @ ByteOrder
        (case GHC.Prim.>=# x_i819P 0# of {
           __DEFAULT -> GHC.ByteOrder.$wlvl x_i819P;
           1# ->
             case GHC.Prim.<=# x_i819P 1# of {
               __DEFAULT -> GHC.ByteOrder.$wlvl x_i819P;
               1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i819P
             }
         })
        (case x_i819P of wild_X2P {
           __DEFAULT ->
             GHC.ByteOrder.$fEnumByteOrder_go1 (GHC.Prim.+# wild_X2P 1#);
           0# -> GHC.Types.[] @ ByteOrder
         })
end Rec }

Rec {
-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder_go [Occ=LoopBreaker]
  :: GHC.Prim.Int# -> [ByteOrder]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.ByteOrder.$fEnumByteOrder_go
  = \ (x_i819P :: GHC.Prim.Int#) ->
      GHC.Types.:
        @ ByteOrder
        (case GHC.Prim.>=# x_i819P 0# of {
           __DEFAULT -> GHC.ByteOrder.$wlvl x_i819P;
           1# ->
             case GHC.Prim.<=# x_i819P 1# of {
               __DEFAULT -> GHC.ByteOrder.$wlvl x_i819P;
               1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i819P
             }
         })
        (case x_i819P of wild_X2P {
           __DEFAULT ->
             GHC.ByteOrder.$fEnumByteOrder_go (GHC.Prim.+# wild_X2P 1#);
           1# -> GHC.Types.[] @ ByteOrder
         })
end Rec }

-- RHS size: {terms: 34, types: 12, coercions: 0, joins: 1/1}
GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo
  :: ByteOrder -> ByteOrder -> [ByteOrder]
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [34 71] 130 0}]
GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo
  = \ (x_i814s :: ByteOrder) (y_i814t :: ByteOrder) ->
      join {
        $j_scxWs [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> [ByteOrder]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_scxWs (x1_i814z [OS=OneShot] :: GHC.Prim.Int#)
          = case y_i814t of {
              BigEndian ->
                case GHC.Prim.># x1_i814z 0# of {
                  __DEFAULT -> GHC.ByteOrder.$fEnumByteOrder_go1 x1_i814z;
                  1# -> GHC.Types.[] @ ByteOrder
                };
              LittleEndian ->
                case GHC.Prim.># x1_i814z 1# of {
                  __DEFAULT -> GHC.ByteOrder.$fEnumByteOrder_go x1_i814z;
                  1# -> GHC.Types.[] @ ByteOrder
                }
            } } in
      case x_i814s of {
        BigEndian -> jump $j_scxWs 0#;
        LittleEndian -> jump $j_scxWs 1#
      }

-- RHS size: {terms: 491, types: 128, coercions: 0, joins: 2/14}
GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo
  :: ByteOrder -> ByteOrder -> ByteOrder -> [ByteOrder]
[GblId, Arity=3, Str=<S,1*U><S,1*U><S,1*U>, Unf=OtherCon []]
GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo
  = \ (x1_i814J :: ByteOrder)
      (x2_i814K :: ByteOrder)
      (y_i814L :: ByteOrder) ->
      join {
        $j_scxWx [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> [ByteOrder]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_scxWx (x4_i814R [OS=OneShot] :: GHC.Prim.Int#)
          = join {
              $j1_scxWv [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> [ByteOrder]
              [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
              $j1_scxWv (x5_i814V [OS=OneShot] :: GHC.Prim.Int#)
                = case y_i814L of {
                    BigEndian ->
                      case GHC.Prim.>=# x5_i814V x4_i814R of {
                        __DEFAULT ->
                          case GHC.Prim.># 0# x5_i814V of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ ByteOrder
                                (case GHC.Prim.>=# x4_i814R 0# of {
                                   __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                   1# ->
                                     case GHC.Prim.<=# x4_i814R 1# of {
                                       __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                       1# -> GHC.Prim.tagToEnum# @ ByteOrder x4_i814R
                                     }
                                 })
                                (let {
                                   delta_i81tM [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   delta_i81tM = GHC.Prim.-# x5_i814V x4_i814R } in
                                 let {
                                   y'_i81tN [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   y'_i81tN = GHC.Prim.-# 0# delta_i81tM } in
                                 letrec {
                                   go_dn_i81tO [Occ=LoopBreaker] :: GHC.Prim.Int# -> [ByteOrder]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_i81tO
                                     = \ (x_i81tP :: GHC.Prim.Int#) ->
                                         case GHC.Prim.<# x_i81tP y'_i81tN of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (case GHC.Prim.>=# x_i81tP 0# of {
                                                  __DEFAULT -> GHC.ByteOrder.$wlvl x_i81tP;
                                                  1# ->
                                                    case GHC.Prim.<=# x_i81tP 1# of {
                                                      __DEFAULT -> GHC.ByteOrder.$wlvl x_i81tP;
                                                      1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i81tP
                                                    }
                                                })
                                               (go_dn_i81tO (GHC.Prim.+# x_i81tP delta_i81tM));
                                           1# ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (case GHC.Prim.>=# x_i81tP 0# of {
                                                  __DEFAULT -> GHC.ByteOrder.$wlvl x_i81tP;
                                                  1# ->
                                                    case GHC.Prim.<=# x_i81tP 1# of {
                                                      __DEFAULT -> GHC.ByteOrder.$wlvl x_i81tP;
                                                      1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i81tP
                                                    }
                                                })
                                               (GHC.Types.[] @ ByteOrder)
                                         }; } in
                                 go_dn_i81tO x5_i814V);
                            1# ->
                              case GHC.Prim.># 0# x4_i814R of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ ByteOrder
                                    (case GHC.Prim.>=# x4_i814R 0# of {
                                       __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                       1# ->
                                         case GHC.Prim.<=# x4_i814R 1# of {
                                           __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                           1# -> GHC.Prim.tagToEnum# @ ByteOrder x4_i814R
                                         }
                                     })
                                    (GHC.Types.[] @ ByteOrder);
                                1# -> GHC.Types.[] @ ByteOrder
                              }
                          };
                        1# ->
                          case GHC.Prim.<# 0# x5_i814V of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ ByteOrder
                                (case GHC.Prim.>=# x4_i814R 0# of {
                                   __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                   1# ->
                                     case GHC.Prim.<=# x4_i814R 1# of {
                                       __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                       1# -> GHC.Prim.tagToEnum# @ ByteOrder x4_i814R
                                     }
                                 })
                                (let {
                                   delta_i81u2 [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   delta_i81u2 = GHC.Prim.-# x5_i814V x4_i814R } in
                                 let {
                                   y'_i81u3 [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   y'_i81u3 = GHC.Prim.-# 0# delta_i81u2 } in
                                 letrec {
                                   go_up_i81u4 [Occ=LoopBreaker] :: GHC.Prim.Int# -> [ByteOrder]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_i81u4
                                     = \ (x_i81u5 :: GHC.Prim.Int#) ->
                                         case GHC.Prim.># x_i81u5 y'_i81u3 of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (case GHC.Prim.>=# x_i81u5 0# of {
                                                  __DEFAULT -> GHC.ByteOrder.$wlvl x_i81u5;
                                                  1# ->
                                                    case GHC.Prim.<=# x_i81u5 1# of {
                                                      __DEFAULT -> GHC.ByteOrder.$wlvl x_i81u5;
                                                      1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i81u5
                                                    }
                                                })
                                               (go_up_i81u4 (GHC.Prim.+# x_i81u5 delta_i81u2));
                                           1# ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (case GHC.Prim.>=# x_i81u5 0# of {
                                                  __DEFAULT -> GHC.ByteOrder.$wlvl x_i81u5;
                                                  1# ->
                                                    case GHC.Prim.<=# x_i81u5 1# of {
                                                      __DEFAULT -> GHC.ByteOrder.$wlvl x_i81u5;
                                                      1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i81u5
                                                    }
                                                })
                                               (GHC.Types.[] @ ByteOrder)
                                         }; } in
                                 go_up_i81u4 x5_i814V);
                            1# ->
                              case GHC.Prim.<# 0# x4_i814R of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ ByteOrder
                                    (case GHC.Prim.>=# x4_i814R 0# of {
                                       __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                       1# ->
                                         case GHC.Prim.<=# x4_i814R 1# of {
                                           __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                           1# -> GHC.Prim.tagToEnum# @ ByteOrder x4_i814R
                                         }
                                     })
                                    (GHC.Types.[] @ ByteOrder);
                                1# -> GHC.Types.[] @ ByteOrder
                              }
                          }
                      };
                    LittleEndian ->
                      case GHC.Prim.>=# x5_i814V x4_i814R of {
                        __DEFAULT ->
                          case GHC.Prim.># 1# x5_i814V of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ ByteOrder
                                (case GHC.Prim.>=# x4_i814R 0# of {
                                   __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                   1# ->
                                     case GHC.Prim.<=# x4_i814R 1# of {
                                       __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                       1# -> GHC.Prim.tagToEnum# @ ByteOrder x4_i814R
                                     }
                                 })
                                (let {
                                   delta_i81tM [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   delta_i81tM = GHC.Prim.-# x5_i814V x4_i814R } in
                                 let {
                                   y'_i81tN [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   y'_i81tN = GHC.Prim.-# 1# delta_i81tM } in
                                 letrec {
                                   go_dn_i81tO [Occ=LoopBreaker] :: GHC.Prim.Int# -> [ByteOrder]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_i81tO
                                     = \ (x_i81tP :: GHC.Prim.Int#) ->
                                         case GHC.Prim.<# x_i81tP y'_i81tN of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (case GHC.Prim.>=# x_i81tP 0# of {
                                                  __DEFAULT -> GHC.ByteOrder.$wlvl x_i81tP;
                                                  1# ->
                                                    case GHC.Prim.<=# x_i81tP 1# of {
                                                      __DEFAULT -> GHC.ByteOrder.$wlvl x_i81tP;
                                                      1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i81tP
                                                    }
                                                })
                                               (go_dn_i81tO (GHC.Prim.+# x_i81tP delta_i81tM));
                                           1# ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (case GHC.Prim.>=# x_i81tP 0# of {
                                                  __DEFAULT -> GHC.ByteOrder.$wlvl x_i81tP;
                                                  1# ->
                                                    case GHC.Prim.<=# x_i81tP 1# of {
                                                      __DEFAULT -> GHC.ByteOrder.$wlvl x_i81tP;
                                                      1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i81tP
                                                    }
                                                })
                                               (GHC.Types.[] @ ByteOrder)
                                         }; } in
                                 go_dn_i81tO x5_i814V);
                            1# ->
                              case GHC.Prim.># 1# x4_i814R of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ ByteOrder
                                    (case GHC.Prim.>=# x4_i814R 0# of {
                                       __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                       1# ->
                                         case GHC.Prim.<=# x4_i814R 1# of {
                                           __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                           1# -> GHC.Prim.tagToEnum# @ ByteOrder x4_i814R
                                         }
                                     })
                                    (GHC.Types.[] @ ByteOrder);
                                1# -> GHC.Types.[] @ ByteOrder
                              }
                          };
                        1# ->
                          case GHC.Prim.<# 1# x5_i814V of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ ByteOrder
                                (case GHC.Prim.>=# x4_i814R 0# of {
                                   __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                   1# ->
                                     case GHC.Prim.<=# x4_i814R 1# of {
                                       __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                       1# -> GHC.Prim.tagToEnum# @ ByteOrder x4_i814R
                                     }
                                 })
                                (let {
                                   delta_i81u2 [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   delta_i81u2 = GHC.Prim.-# x5_i814V x4_i814R } in
                                 let {
                                   y'_i81u3 [Dmd=<S,U>] :: GHC.Prim.Int#
                                   [LclId]
                                   y'_i81u3 = GHC.Prim.-# 1# delta_i81u2 } in
                                 letrec {
                                   go_up_i81u4 [Occ=LoopBreaker] :: GHC.Prim.Int# -> [ByteOrder]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_i81u4
                                     = \ (x_i81u5 :: GHC.Prim.Int#) ->
                                         case GHC.Prim.># x_i81u5 y'_i81u3 of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (case GHC.Prim.>=# x_i81u5 0# of {
                                                  __DEFAULT -> GHC.ByteOrder.$wlvl x_i81u5;
                                                  1# ->
                                                    case GHC.Prim.<=# x_i81u5 1# of {
                                                      __DEFAULT -> GHC.ByteOrder.$wlvl x_i81u5;
                                                      1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i81u5
                                                    }
                                                })
                                               (go_up_i81u4 (GHC.Prim.+# x_i81u5 delta_i81u2));
                                           1# ->
                                             GHC.Types.:
                                               @ ByteOrder
                                               (case GHC.Prim.>=# x_i81u5 0# of {
                                                  __DEFAULT -> GHC.ByteOrder.$wlvl x_i81u5;
                                                  1# ->
                                                    case GHC.Prim.<=# x_i81u5 1# of {
                                                      __DEFAULT -> GHC.ByteOrder.$wlvl x_i81u5;
                                                      1# -> GHC.Prim.tagToEnum# @ ByteOrder x_i81u5
                                                    }
                                                })
                                               (GHC.Types.[] @ ByteOrder)
                                         }; } in
                                 go_up_i81u4 x5_i814V);
                            1# ->
                              case GHC.Prim.<# 1# x4_i814R of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ ByteOrder
                                    (case GHC.Prim.>=# x4_i814R 0# of {
                                       __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                       1# ->
                                         case GHC.Prim.<=# x4_i814R 1# of {
                                           __DEFAULT -> GHC.ByteOrder.$wlvl x4_i814R;
                                           1# -> GHC.Prim.tagToEnum# @ ByteOrder x4_i814R
                                         }
                                     })
                                    (GHC.Types.[] @ ByteOrder);
                                1# -> GHC.Types.[] @ ByteOrder
                              }
                          }
                      }
                  } } in
            case x2_i814K of {
              BigEndian -> jump $j1_scxWv 0#;
              LittleEndian -> jump $j1_scxWv 1#
            } } in
      case x1_i814J of {
        BigEndian -> jump $j_scxWx 0#;
        LittleEndian -> jump $j_scxWx 1#
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.ByteOrder.$fEnumByteOrder [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum ByteOrder
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: ByteOrder
                       GHC.ByteOrder.$fEnumByteOrder_$csucc
                       GHC.ByteOrder.$fEnumByteOrder_$cpred
                       GHC.ByteOrder.$fEnumByteOrder_$ctoEnum
                       GHC.ByteOrder.$fEnumByteOrder_$cfromEnum
                       GHC.ByteOrder.$fEnumByteOrder_$cenumFrom
                       GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen
                       GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo
                       GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo]
GHC.ByteOrder.$fEnumByteOrder
  = GHC.Enum.C:Enum
      @ ByteOrder
      GHC.ByteOrder.$fEnumByteOrder_$csucc
      GHC.ByteOrder.$fEnumByteOrder_$cpred
      GHC.ByteOrder.$fEnumByteOrder_$ctoEnum
      GHC.ByteOrder.$fEnumByteOrder_$cfromEnum
      GHC.ByteOrder.$fEnumByteOrder_$cenumFrom
      GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen
      GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo
      GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.ByteOrder.$trModule3
  = GHC.Types.TrNameS GHC.ByteOrder.$trModule4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.ByteOrder.$trModule1
  = GHC.Types.TrNameS GHC.ByteOrder.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.ByteOrder.$trModule
  = GHC.Types.Module
      GHC.ByteOrder.$trModule3 GHC.ByteOrder.$trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tcByteOrder2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.ByteOrder.$tcByteOrder2 = "ByteOrder"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tcByteOrder1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.ByteOrder.$tcByteOrder1
  = GHC.Types.TrNameS GHC.ByteOrder.$tcByteOrder2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tcByteOrder :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.ByteOrder.$tcByteOrder
  = GHC.Types.TyCon
      16811050684449662084##
      17273005335247024091##
      GHC.ByteOrder.$trModule
      GHC.ByteOrder.$tcByteOrder1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tc'BigEndian1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.ByteOrder.$tc'BigEndian1
  = GHC.Types.KindRepTyConApp
      GHC.ByteOrder.$tcByteOrder (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tc'BigEndian3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.ByteOrder.$tc'BigEndian3 = "'BigEndian"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tc'BigEndian2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.ByteOrder.$tc'BigEndian2
  = GHC.Types.TrNameS GHC.ByteOrder.$tc'BigEndian3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tc'BigEndian :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.ByteOrder.$tc'BigEndian
  = GHC.Types.TyCon
      2645192688778293591##
      7455668807059762078##
      GHC.ByteOrder.$trModule
      GHC.ByteOrder.$tc'BigEndian2
      0#
      GHC.ByteOrder.$tc'BigEndian1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tc'LittleEndian2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.ByteOrder.$tc'LittleEndian2 = "'LittleEndian"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tc'LittleEndian1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.ByteOrder.$tc'LittleEndian1
  = GHC.Types.TrNameS GHC.ByteOrder.$tc'LittleEndian2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.ByteOrder.$tc'LittleEndian :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.ByteOrder.$tc'LittleEndian
  = GHC.Types.TyCon
      8702700204875460152##
      10337679016369298147##
      GHC.ByteOrder.$trModule
      GHC.ByteOrder.$tc'LittleEndian1
      0#
      GHC.ByteOrder.$tc'BigEndian1


