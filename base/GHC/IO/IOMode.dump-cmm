
==================== Output Cmm ====================
2018-03-16 15:59:38.867011896 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:38.86763133 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode21_bytes" {
     GHC.IO.IOMode.$fReadIOMode21_bytes:
         I8[] [82,101,97,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.868527419 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode20_closure" {
     GHC.IO.IOMode.$fReadIOMode20_closure:
         const GHC.IO.IOMode.$fReadIOMode20_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode20_entry() //  [R1]
         { info_tbl: [(c4L7h,
                       label: GHC.IO.IOMode.$fReadIOMode20_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L7h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4L7i; else goto c4L7j;
       c4L7i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4L7j: // global
           (_c4L7e::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4L7e::I64 == 0) goto c4L7g; else goto c4L7f;
       c4L7g: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4L7f: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4L7e::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode21_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.869581987 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode17_bytes" {
     GHC.IO.IOMode.$fReadIOMode17_bytes:
         I8[] [87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.870347066 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode16_closure" {
     GHC.IO.IOMode.$fReadIOMode16_closure:
         const GHC.IO.IOMode.$fReadIOMode16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode16_entry() //  [R1]
         { info_tbl: [(c4L7q,
                       label: GHC.IO.IOMode.$fReadIOMode16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L7q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4L7r; else goto c4L7s;
       c4L7r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4L7s: // global
           (_c4L7n::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4L7n::I64 == 0) goto c4L7p; else goto c4L7o;
       c4L7p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4L7o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4L7n::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.871250556 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode13_bytes" {
     GHC.IO.IOMode.$fReadIOMode13_bytes:
         I8[] [65,112,112,101,110,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.872037787 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode12_closure" {
     GHC.IO.IOMode.$fReadIOMode12_closure:
         const GHC.IO.IOMode.$fReadIOMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode12_entry() //  [R1]
         { info_tbl: [(c4L7z,
                       label: GHC.IO.IOMode.$fReadIOMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L7z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4L7A; else goto c4L7B;
       c4L7A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4L7B: // global
           (_c4L7w::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4L7w::I64 == 0) goto c4L7y; else goto c4L7x;
       c4L7y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4L7x: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4L7w::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.873007683 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode9_bytes" {
     GHC.IO.IOMode.$fReadIOMode9_bytes:
         I8[] [82,101,97,100,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.873833869 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode8_closure" {
     GHC.IO.IOMode.$fReadIOMode8_closure:
         const GHC.IO.IOMode.$fReadIOMode8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode8_entry() //  [R1]
         { info_tbl: [(c4L7I,
                       label: GHC.IO.IOMode.$fReadIOMode8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L7I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4L7J; else goto c4L7K;
       c4L7J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4L7K: // global
           (_c4L7F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4L7F::I64 == 0) goto c4L7H; else goto c4L7G;
       c4L7H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4L7G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4L7F::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.875212967 UTC

[section ""data" . GHC.IO.IOMode.$w$cshowsPrec_closure" {
     GHC.IO.IOMode.$w$cshowsPrec_closure:
         const GHC.IO.IOMode.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.IOMode.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4L7Y,
                       label: GHC.IO.IOMode.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L7Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4L7Z; else goto c4L80;
       c4L7Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4L80: // global
           I64[Sp - 16] = block_c4L7P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4L8f; else goto c4L7Q;
       u4L8f: // global
           call _c4L7P(R1) args: 0, res: 0, upd: 0;
       c4L7Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4L7P() //  [R1]
         { info_tbl: [(c4L7P,
                       label: block_c4L7P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L7P: // global
           _s4KZ9::P64 = P64[Sp + 8];
           _c4L7X::P64 = R1 & 7;
           if (_c4L7X::P64 < 3) goto u4L8d; else goto u4L8e;
       u4L8d: // global
           if (_c4L7X::P64 < 2) goto c4L7T; else goto c4L7U;
       c4L7T: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode20_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c4L7U: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode16_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4L8e: // global
           if (_c4L7X::P64 < 4) goto c4L7V; else goto c4L7W;
       c4L7V: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode12_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c4L7W: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode8_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.876780967 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c4L8l,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L8l: // global
           _s4KZc::P64 = R3;
           R3 = R4;
           R2 = _s4KZc::P64;
           call GHC.IO.IOMode.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.878027278 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshow_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshow_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshow_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshow_entry() //  [R2]
         { info_tbl: [(c4L8B,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L8B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4L8C; else goto c4L8D;
       c4L8C: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fShowIOMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4L8D: // global
           I64[Sp - 8] = block_c4L8s_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4L8S; else goto c4L8t;
       u4L8S: // global
           call _c4L8s(R1) args: 0, res: 0, upd: 0;
       c4L8t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4L8s() //  [R1]
         { info_tbl: [(c4L8s,
                       label: block_c4L8s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L8s: // global
           _c4L8A::P64 = R1 & 7;
           if (_c4L8A::P64 < 3) goto u4L8Q; else goto u4L8R;
       u4L8Q: // global
           if (_c4L8A::P64 < 2) goto c4L8w; else goto c4L8x;
       c4L8w: // global
           R1 = GHC.IO.IOMode.$fReadIOMode20_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4L8x: // global
           R1 = GHC.IO.IOMode.$fReadIOMode16_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u4L8R: // global
           if (_c4L8A::P64 < 4) goto c4L8y; else goto c4L8z;
       c4L8y: // global
           R1 = GHC.IO.IOMode.$fReadIOMode12_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4L8z: // global
           R1 = GHC.IO.IOMode.$fReadIOMode8_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.879456057 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshowList_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshowList_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshowList_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4L8X,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L8X: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.IOMode.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.880263284 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_closure" {
     GHC.IO.IOMode.$fShowIOMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure+3;
         const GHC.IO.IOMode.$fShowIOMode_$cshow_closure+1;
         const GHC.IO.IOMode.$fShowIOMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.881000864 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode19_closure" {
     GHC.IO.IOMode.$fReadIOMode19_closure:
         const GHC.IO.IOMode.$fReadIOMode19_info;
 },
 GHC.IO.IOMode.$fReadIOMode19_entry() //  [R3]
         { info_tbl: [(c4L94,
                       label: GHC.IO.IOMode.$fReadIOMode19_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L94: // global
           R2 = GHC.IO.IOMode.ReadMode_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.881764014 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode18_closure" {
     GHC.IO.IOMode.$fReadIOMode18_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode20_closure;
         const GHC.IO.IOMode.$fReadIOMode19_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.882522415 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode15_closure" {
     GHC.IO.IOMode.$fReadIOMode15_closure:
         const GHC.IO.IOMode.$fReadIOMode15_info;
 },
 GHC.IO.IOMode.$fReadIOMode15_entry() //  [R3]
         { info_tbl: [(c4L9b,
                       label: GHC.IO.IOMode.$fReadIOMode15_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L9b: // global
           R2 = GHC.IO.IOMode.WriteMode_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.883248429 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode14_closure" {
     GHC.IO.IOMode.$fReadIOMode14_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode16_closure;
         const GHC.IO.IOMode.$fReadIOMode15_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.883967799 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode11_closure" {
     GHC.IO.IOMode.$fReadIOMode11_closure:
         const GHC.IO.IOMode.$fReadIOMode11_info;
 },
 GHC.IO.IOMode.$fReadIOMode11_entry() //  [R3]
         { info_tbl: [(c4L9i,
                       label: GHC.IO.IOMode.$fReadIOMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L9i: // global
           R2 = GHC.IO.IOMode.AppendMode_closure+3;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.88472568 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode10_closure" {
     GHC.IO.IOMode.$fReadIOMode10_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode12_closure;
         const GHC.IO.IOMode.$fReadIOMode11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.885491196 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode7_closure" {
     GHC.IO.IOMode.$fReadIOMode7_closure:
         const GHC.IO.IOMode.$fReadIOMode7_info;
 },
 GHC.IO.IOMode.$fReadIOMode7_entry() //  [R3]
         { info_tbl: [(c4L9p,
                       label: GHC.IO.IOMode.$fReadIOMode7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L9p: // global
           R2 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.88622375 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode6_closure" {
     GHC.IO.IOMode.$fReadIOMode6_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode8_closure;
         const GHC.IO.IOMode.$fReadIOMode7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.886788175 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode5_closure" {
     GHC.IO.IOMode.$fReadIOMode5_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.887336228 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode4_closure" {
     GHC.IO.IOMode.$fReadIOMode4_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode10_closure+1;
         const GHC.IO.IOMode.$fReadIOMode5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.887916946 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode3_closure" {
     GHC.IO.IOMode.$fReadIOMode3_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode14_closure+1;
         const GHC.IO.IOMode.$fReadIOMode4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.888510492 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_sps_closure" {
     GHC.IO.IOMode.$fReadIOMode_sps_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode18_closure+1;
         const GHC.IO.IOMode.$fReadIOMode3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.889338648 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode2_closure" {
     GHC.IO.IOMode.$fReadIOMode2_closure:
         const GHC.IO.IOMode.$fReadIOMode2_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode2_entry() //  [R2]
         { info_tbl: [(c4L9w,
                       label: GHC.IO.IOMode.$fReadIOMode2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L9w: // global
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.890244662 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode1_closure" {
     GHC.IO.IOMode.$fReadIOMode1_closure:
         const GHC.IO.IOMode.$fReadIOMode1_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode1_entry() //  [R2, R3]
         { info_tbl: [(c4L9D,
                       label: GHC.IO.IOMode.$fReadIOMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L9D: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.891317554 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_info;
         const 0;
 },
 sat_s4KZs_entry() //  [R1]
         { info_tbl: [(c4L9O,
                       label: sat_s4KZs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L9O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4L9P; else goto c4L9Q;
       c4L9P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4L9Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.IOMode.$fReadIOMode2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fReadIOMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c4L9R,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4L9R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4L9V; else goto c4L9U;
       c4L9V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4L9U: // global
           I64[Hp - 16] = sat_s4KZs_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.892638713 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c4La2,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4La2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4La3; else goto c4La4;
       c4La3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4La4: // global
           (_c4L9Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4L9Z::I64 == 0) goto c4La1; else goto c4La0;
       c4La1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4La0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4L9Z::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.893881846 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode22_closure" {
     GHC.IO.IOMode.$fReadIOMode22_closure:
         const GHC.IO.IOMode.$fReadIOMode22_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode22_entry() //  [R1]
         { info_tbl: [(c4Lab,
                       label: GHC.IO.IOMode.$fReadIOMode22_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lab: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Lac; else goto c4Lad;
       c4Lac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Lad: // global
           (_c4La8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4La8::I64 == 0) goto c4Laa; else goto c4La9;
       c4Laa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4La9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4La8::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.89505438 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadList_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadList_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadList_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode_$creadList_entry() //  [R2]
         { info_tbl: [(c4Lai,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lai: // global
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode22_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.895824685 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_closure" {
     GHC.IO.IOMode.$fReadIOMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure+1;
         const GHC.IO.IOMode.$fReadIOMode_$creadList_closure+1;
         const GHC.IO.IOMode.$fReadIOMode1_closure+2;
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.897424412 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_$c==_closure" {
     GHC.IO.IOMode.$fEqIOMode_$c==_closure:
         const GHC.IO.IOMode.$fEqIOMode_$c==_info;
 },
 GHC.IO.IOMode.$fEqIOMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c4Lay,
                       label: GHC.IO.IOMode.$fEqIOMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lay: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Laz; else goto c4LaA;
       c4Laz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEqIOMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LaA: // global
           I64[Sp - 16] = block_c4Lap_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LbR; else goto c4Laq;
       u4LbR: // global
           call _c4Lap(R1) args: 0, res: 0, upd: 0;
       c4Laq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lap() //  [R1]
         { info_tbl: [(c4Lap,
                       label: block_c4Lap_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lap: // global
           _s4KZu::P64 = P64[Sp + 8];
           _c4Lax::P64 = R1 & 7;
           if (_c4Lax::P64 < 3) goto u4LbD; else goto u4LbE;
       u4LbD: // global
           if (_c4Lax::P64 < 2) goto c4Lat; else goto c4Lau;
       c4Lat: // global
           I64[Sp + 8] = block_c4LaD_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LbN; else goto c4LaF;
       u4LbN: // global
           call _c4LaD(R1) args: 0, res: 0, upd: 0;
       c4LaF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Lau: // global
           I64[Sp + 8] = block_c4LaS_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LbO; else goto c4LaU;
       u4LbO: // global
           call _c4LaS(R1) args: 0, res: 0, upd: 0;
       c4LaU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4LbE: // global
           if (_c4Lax::P64 < 4) goto c4Lav; else goto c4Law;
       c4Lav: // global
           I64[Sp + 8] = block_c4Lb7_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LbP; else goto c4Lb9;
       u4LbP: // global
           call _c4Lb7(R1) args: 0, res: 0, upd: 0;
       c4Lb9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Law: // global
           I64[Sp + 8] = block_c4Lbm_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LbQ; else goto c4Lbo;
       u4LbQ: // global
           call _c4Lbm(R1) args: 0, res: 0, upd: 0;
       c4Lbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LaD() //  [R1]
         { info_tbl: [(c4LaD,
                       label: block_c4LaD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LaD: // global
           if (R1 & 7 == 1) goto u4LbF; else goto u4LbG;
       u4LbF: // global
           Sp = Sp + 8;
           call _c4Lby() args: 0, res: 0, upd: 0;
       u4LbG: // global
           Sp = Sp + 8;
           call _c4Lbu() args: 0, res: 0, upd: 0;
     }
 },
 _c4LaS() //  [R1]
         { info_tbl: [(c4LaS,
                       label: block_c4LaS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LaS: // global
           if (R1 & 7 == 2) goto u4LbH; else goto u4LbI;
       u4LbH: // global
           Sp = Sp + 8;
           call _c4Lby() args: 0, res: 0, upd: 0;
       u4LbI: // global
           Sp = Sp + 8;
           call _c4Lbu() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lb7() //  [R1]
         { info_tbl: [(c4Lb7,
                       label: block_c4Lb7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lb7: // global
           if (R1 & 7 == 3) goto u4LbJ; else goto u4LbK;
       u4LbJ: // global
           Sp = Sp + 8;
           call _c4Lby() args: 0, res: 0, upd: 0;
       u4LbK: // global
           Sp = Sp + 8;
           call _c4Lbu() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lbm() //  [R1]
         { info_tbl: [(c4Lbm,
                       label: block_c4Lbm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lbm: // global
           if (R1 & 7 == 4) goto u4LbL; else goto u4LbM;
       u4LbL: // global
           Sp = Sp + 8;
           call _c4Lby() args: 0, res: 0, upd: 0;
       u4LbM: // global
           Sp = Sp + 8;
           call _c4Lbu() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lby() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lby: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lbu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lbu: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.900710904 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_$c/=_closure" {
     GHC.IO.IOMode.$fEqIOMode_$c/=_closure:
         const GHC.IO.IOMode.$fEqIOMode_$c/=_info;
 },
 GHC.IO.IOMode.$fEqIOMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c4Lcd,
                       label: GHC.IO.IOMode.$fEqIOMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lcd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Lce; else goto c4Lcf;
       c4Lce: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEqIOMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Lcf: // global
           I64[Sp - 16] = block_c4Lc4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ldw; else goto c4Lc5;
       u4Ldw: // global
           call _c4Lc4(R1) args: 0, res: 0, upd: 0;
       c4Lc5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lc4() //  [R1]
         { info_tbl: [(c4Lc4,
                       label: block_c4Lc4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lc4: // global
           _s4KZB::P64 = P64[Sp + 8];
           _c4Lcc::P64 = R1 & 7;
           if (_c4Lcc::P64 < 3) goto u4Ldi; else goto u4Ldj;
       u4Ldi: // global
           if (_c4Lcc::P64 < 2) goto c4Lc8; else goto c4Lc9;
       c4Lc8: // global
           I64[Sp + 8] = block_c4Lci_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lds; else goto c4Lck;
       u4Lds: // global
           call _c4Lci(R1) args: 0, res: 0, upd: 0;
       c4Lck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Lc9: // global
           I64[Sp + 8] = block_c4Lcx_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ldt; else goto c4Lcz;
       u4Ldt: // global
           call _c4Lcx(R1) args: 0, res: 0, upd: 0;
       c4Lcz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Ldj: // global
           if (_c4Lcc::P64 < 4) goto c4Lca; else goto c4Lcb;
       c4Lca: // global
           I64[Sp + 8] = block_c4LcM_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ldu; else goto c4LcO;
       u4Ldu: // global
           call _c4LcM(R1) args: 0, res: 0, upd: 0;
       c4LcO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Lcb: // global
           I64[Sp + 8] = block_c4Ld1_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ldv; else goto c4Ld3;
       u4Ldv: // global
           call _c4Ld1(R1) args: 0, res: 0, upd: 0;
       c4Ld3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lci() //  [R1]
         { info_tbl: [(c4Lci,
                       label: block_c4Lci_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lci: // global
           if (R1 & 7 == 1) goto u4Ldk; else goto u4Ldl;
       u4Ldk: // global
           Sp = Sp + 8;
           call _c4Ldd() args: 0, res: 0, upd: 0;
       u4Ldl: // global
           Sp = Sp + 8;
           call _c4Ld9() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lcx() //  [R1]
         { info_tbl: [(c4Lcx,
                       label: block_c4Lcx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lcx: // global
           if (R1 & 7 == 2) goto u4Ldm; else goto u4Ldn;
       u4Ldm: // global
           Sp = Sp + 8;
           call _c4Ldd() args: 0, res: 0, upd: 0;
       u4Ldn: // global
           Sp = Sp + 8;
           call _c4Ld9() args: 0, res: 0, upd: 0;
     }
 },
 _c4LcM() //  [R1]
         { info_tbl: [(c4LcM,
                       label: block_c4LcM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LcM: // global
           if (R1 & 7 == 3) goto u4Ldo; else goto u4Ldp;
       u4Ldo: // global
           Sp = Sp + 8;
           call _c4Ldd() args: 0, res: 0, upd: 0;
       u4Ldp: // global
           Sp = Sp + 8;
           call _c4Ld9() args: 0, res: 0, upd: 0;
     }
 },
 _c4Ld1() //  [R1]
         { info_tbl: [(c4Ld1,
                       label: block_c4Ld1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ld1: // global
           if (R1 & 7 == 4) goto u4Ldq; else goto u4Ldr;
       u4Ldq: // global
           Sp = Sp + 8;
           call _c4Ldd() args: 0, res: 0, upd: 0;
       u4Ldr: // global
           Sp = Sp + 8;
           call _c4Ld9() args: 0, res: 0, upd: 0;
     }
 },
 _c4Ldd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ldd: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Ld9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ld9: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.903581249 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_closure" {
     GHC.IO.IOMode.$fEqIOMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.IOMode.$fEqIOMode_$c==_closure+2;
         const GHC.IO.IOMode.$fEqIOMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.905474057 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$ccompare_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4LdS,
                       label: GHC.IO.IOMode.$fOrdIOMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LdS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LdT; else goto c4LdU;
       c4LdT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LdU: // global
           I64[Sp - 16] = block_c4LdJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LfD; else goto c4LdK;
       u4LfD: // global
           call _c4LdJ(R1) args: 0, res: 0, upd: 0;
       c4LdK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LdJ() //  [R1]
         { info_tbl: [(c4LdJ,
                       label: block_c4LdJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LdJ: // global
           _s4KZI::P64 = P64[Sp + 8];
           _c4LdR::P64 = R1 & 7;
           if (_c4LdR::P64 < 3) goto u4Lfh; else goto u4Lfi;
       u4Lfh: // global
           if (_c4LdR::P64 < 2) goto c4LdN; else goto c4LdO;
       c4LdN: // global
           I64[Sp + 8] = block_c4LdX_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lfz; else goto c4LdZ;
       u4Lfz: // global
           call _c4LdX(R1) args: 0, res: 0, upd: 0;
       c4LdZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LdO: // global
           I64[Sp + 8] = block_c4Lek_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LfA; else goto c4Lem;
       u4LfA: // global
           call _c4Lek(R1) args: 0, res: 0, upd: 0;
       c4Lem: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Lfi: // global
           if (_c4LdR::P64 < 4) goto c4LdP; else goto c4LdQ;
       c4LdP: // global
           I64[Sp + 8] = block_c4LeH_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LfB; else goto c4LeJ;
       u4LfB: // global
           call _c4LeH(R1) args: 0, res: 0, upd: 0;
       c4LeJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LdQ: // global
           I64[Sp + 8] = block_c4Lf0_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LfC; else goto c4Lf2;
       u4LfC: // global
           call _c4Lf0(R1) args: 0, res: 0, upd: 0;
       c4Lf2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LdX() //  [R1]
         { info_tbl: [(c4LdX,
                       label: block_c4LdX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LdX: // global
           _c4Lfg::P64 = R1 & 7;
           if (_c4Lfg::P64 < 2) goto u4Lfn; else goto u4Lfj;
       u4Lfn: // global
           Sp = Sp + 8;
           call _c4Lfc() args: 0, res: 0, upd: 0;
       u4Lfj: // global
           if (_c4Lfg::P64 != 3) goto u4Lfp; else goto u4Lfp;
       u4Lfp: // global
           Sp = Sp + 8;
           call _c4LeX() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lek() //  [R1]
         { info_tbl: [(c4Lek,
                       label: block_c4Lek_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lek: // global
           _c4Lff::P64 = R1 & 7;
           if (_c4Lff::P64 < 3) goto u4Lfk; else goto u4Lfl;
       u4Lfk: // global
           if (_c4Lff::P64 < 2) goto u4Lfr; else goto u4Lfq;
       u4Lfr: // global
           Sp = Sp + 8;
           call _c4Lf8() args: 0, res: 0, upd: 0;
       u4Lfq: // global
           Sp = Sp + 8;
           call _c4Lfc() args: 0, res: 0, upd: 0;
       u4Lfl: // global
           if (_c4Lff::P64 < 4) goto u4Lft; else goto u4Lft;
       u4Lft: // global
           Sp = Sp + 8;
           call _c4LeX() args: 0, res: 0, upd: 0;
     }
 },
 _c4LeH() //  [R1]
         { info_tbl: [(c4LeH,
                       label: block_c4LeH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LeH: // global
           _c4Lfe::P64 = R1 & 7;
           if (_c4Lfe::P64 != 3) goto u4Lfm; else goto u4Lfu;
       u4Lfm: // global
           if (_c4Lfe::P64 != 4) goto u4Lfw; else goto u4Lfv;
       u4Lfw: // global
           Sp = Sp + 8;
           call _c4Lf8() args: 0, res: 0, upd: 0;
       u4Lfv: // global
           Sp = Sp + 8;
           call _c4LeX() args: 0, res: 0, upd: 0;
       u4Lfu: // global
           Sp = Sp + 8;
           call _c4Lfc() args: 0, res: 0, upd: 0;
     }
 },
 _c4LeX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LeX: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lf0() //  [R1]
         { info_tbl: [(c4Lf0,
                       label: block_c4Lf0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lf0: // global
           if (R1 & 7 == 4) goto u4Lfx; else goto u4Lfy;
       u4Lfx: // global
           Sp = Sp + 8;
           call _c4Lfc() args: 0, res: 0, upd: 0;
       u4Lfy: // global
           Sp = Sp + 8;
           call _c4Lf8() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lfc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lfc: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lf8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lf8: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.909218478 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c<_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c<_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c<_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c4Lg1,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lg1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Lg2; else goto c4Lg3;
       c4Lg2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Lg3: // global
           I64[Sp - 16] = block_c4LfS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Lhr; else goto c4LfT;
       u4Lhr: // global
           call _c4LfS(R1) args: 0, res: 0, upd: 0;
       c4LfT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LfS() //  [R1]
         { info_tbl: [(c4LfS,
                       label: block_c4LfS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LfS: // global
           _s4KZP::P64 = P64[Sp + 8];
           _c4Lg0::P64 = R1 & 7;
           if (_c4Lg0::P64 < 3) goto u4Lhb; else goto u4Lhc;
       u4Lhb: // global
           if (_c4Lg0::P64 < 2) goto c4LfW; else goto c4LfX;
       c4LfW: // global
           I64[Sp + 8] = block_c4Lg6_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lhn; else goto c4Lg8;
       u4Lhn: // global
           call _c4Lg6(R1) args: 0, res: 0, upd: 0;
       c4Lg8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LfX: // global
           I64[Sp + 8] = block_c4Lgt_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lho; else goto c4Lgv;
       u4Lho: // global
           call _c4Lgt(R1) args: 0, res: 0, upd: 0;
       c4Lgv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Lhc: // global
           if (_c4Lg0::P64 < 4) goto c4LfY; else goto c4LfZ;
       c4LfY: // global
           I64[Sp + 8] = block_c4LgM_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lhp; else goto c4LgO;
       u4Lhp: // global
           call _c4LgM(R1) args: 0, res: 0, upd: 0;
       c4LgO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LfZ: // global
           I64[Sp + 8] = block_c4Lh1_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lhq; else goto c4Lh3;
       u4Lhq: // global
           call _c4Lh1() args: 0, res: 0, upd: 0;
       c4Lh3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lg6() //  [R1]
         { info_tbl: [(c4Lg6,
                       label: block_c4Lg6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lg6: // global
           _c4Lha::P64 = R1 & 7;
           if (_c4Lha::P64 < 2) goto u4Lhf; else goto u4Lhd;
       u4Lhf: // global
           Sp = Sp + 8;
           call _c4LgU() args: 0, res: 0, upd: 0;
       u4Lhd: // global
           if (_c4Lha::P64 != 3) goto u4Lhh; else goto u4Lhh;
       u4Lhh: // global
           Sp = Sp + 8;
           call _c4LgY() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lgt() //  [R1]
         { info_tbl: [(c4Lgt,
                       label: block_c4Lgt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lgt: // global
           _c4Lh9::P64 = R1 & 7;
           if (_c4Lh9::P64 != 3) goto u4Lhe; else goto u4Lhi;
       u4Lhe: // global
           if (_c4Lh9::P64 != 4) goto u4Lhk; else goto u4Lhj;
       u4Lhk: // global
           Sp = Sp + 8;
           call _c4LgU() args: 0, res: 0, upd: 0;
       u4Lhj: // global
           Sp = Sp + 8;
           goto u4Lhv;
       u4Lhi: // global
           Sp = Sp + 8;
           goto u4Lhv;
       u4Lhv: // global
           call _c4LgY() args: 0, res: 0, upd: 0;
     }
 },
 _c4LgM() //  [R1]
         { info_tbl: [(c4LgM,
                       label: block_c4LgM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LgM: // global
           if (R1 & 7 == 4) goto u4Lhl; else goto u4Lhm;
       u4Lhl: // global
           Sp = Sp + 8;
           call _c4LgY() args: 0, res: 0, upd: 0;
       u4Lhm: // global
           Sp = Sp + 8;
           call _c4LgU() args: 0, res: 0, upd: 0;
     }
 },
 _c4LgY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LgY: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LgU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LgU: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lh1() //  []
         { info_tbl: [(c4Lh1,
                       label: block_c4Lh1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lh1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.914461336 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c<=_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c<=_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c<=_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c4LhM,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LhM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LhN; else goto c4LhO;
       c4LhN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LhO: // global
           I64[Sp - 16] = block_c4LhD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ljc; else goto c4LhE;
       u4Ljc: // global
           call _c4LhD(R1) args: 0, res: 0, upd: 0;
       c4LhE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LhD() //  [R1]
         { info_tbl: [(c4LhD,
                       label: block_c4LhD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LhD: // global
           _s4KZV::P64 = P64[Sp + 8];
           _c4LhL::P64 = R1 & 7;
           if (_c4LhL::P64 < 3) goto u4LiW; else goto u4LiX;
       u4LiW: // global
           if (_c4LhL::P64 < 2) goto c4LhH; else goto c4LhI;
       c4LhH: // global
           I64[Sp + 8] = block_c4LhR_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lj8; else goto c4LhT;
       u4Lj8: // global
           call _c4LhR(R1) args: 0, res: 0, upd: 0;
       c4LhT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LhI: // global
           I64[Sp + 8] = block_c4Lie_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lj9; else goto c4Lig;
       u4Lj9: // global
           call _c4Lie(R1) args: 0, res: 0, upd: 0;
       c4Lig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4LiX: // global
           if (_c4LhL::P64 < 4) goto c4LhJ; else goto c4LhK;
       c4LhJ: // global
           I64[Sp + 8] = block_c4Lix_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lja; else goto c4Liz;
       u4Lja: // global
           call _c4Lix(R1) args: 0, res: 0, upd: 0;
       c4Liz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LhK: // global
           I64[Sp + 8] = block_c4LiM_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ljb; else goto c4LiO;
       u4Ljb: // global
           call _c4LiM() args: 0, res: 0, upd: 0;
       c4LiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LhR() //  [R1]
         { info_tbl: [(c4LhR,
                       label: block_c4LhR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LhR: // global
           _c4LiV::P64 = R1 & 7;
           if (_c4LiV::P64 < 2) goto u4Lj0; else goto u4LiY;
       u4Lj0: // global
           Sp = Sp + 8;
           call _c4LiF() args: 0, res: 0, upd: 0;
       u4LiY: // global
           if (_c4LiV::P64 != 3) goto u4Lj2; else goto u4Lj2;
       u4Lj2: // global
           Sp = Sp + 8;
           call _c4LiJ() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lie() //  [R1]
         { info_tbl: [(c4Lie,
                       label: block_c4Lie_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lie: // global
           _c4LiU::P64 = R1 & 7;
           if (_c4LiU::P64 != 3) goto u4LiZ; else goto u4Lj3;
       u4LiZ: // global
           if (_c4LiU::P64 != 4) goto u4Lj5; else goto u4Lj4;
       u4Lj5: // global
           Sp = Sp + 8;
           call _c4LiF() args: 0, res: 0, upd: 0;
       u4Lj4: // global
           Sp = Sp + 8;
           goto u4Ljg;
       u4Lj3: // global
           Sp = Sp + 8;
           goto u4Ljg;
       u4Ljg: // global
           call _c4LiJ() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lix() //  [R1]
         { info_tbl: [(c4Lix,
                       label: block_c4Lix_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lix: // global
           if (R1 & 7 == 4) goto u4Lj6; else goto u4Lj7;
       u4Lj6: // global
           Sp = Sp + 8;
           call _c4LiJ() args: 0, res: 0, upd: 0;
       u4Lj7: // global
           Sp = Sp + 8;
           call _c4LiF() args: 0, res: 0, upd: 0;
     }
 },
 _c4LiJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LiJ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LiF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LiF: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LiM() //  []
         { info_tbl: [(c4LiM,
                       label: block_c4LiM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LiM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.917818968 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$cmax_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$cmax_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$cmax_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4Ljx,
                       label: GHC.IO.IOMode.$fOrdIOMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ljx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ljy; else goto c4Ljz;
       c4Ljy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ljz: // global
           I64[Sp - 16] = block_c4Ljo_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Lkw; else goto c4Ljp;
       u4Lkw: // global
           call _c4Ljo(R1) args: 0, res: 0, upd: 0;
       c4Ljp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ljo() //  [R1]
         { info_tbl: [(c4Ljo,
                       label: block_c4Ljo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ljo: // global
           _s4L02::P64 = P64[Sp + 8];
           _c4Ljw::P64 = R1 & 7;
           if (_c4Ljw::P64 < 3) goto u4Lkm; else goto u4Lkn;
       u4Lkm: // global
           if (_c4Ljw::P64 < 2) goto c4Ljs; else goto c4Ljt;
       c4Ljs: // global
           R1 = _s4L02::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4Ljt: // global
           I64[Sp + 8] = block_c4LjF_info;
           R1 = _s4L02::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lkt; else goto c4LjH;
       u4Lkt: // global
           call _c4LjF(R1) args: 0, res: 0, upd: 0;
       c4LjH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Lkn: // global
           if (_c4Ljw::P64 < 4) goto c4Lju; else goto c4Ljv;
       c4Lju: // global
           I64[Sp + 8] = block_c4LjY_info;
           R1 = _s4L02::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lku; else goto c4Lk0;
       u4Lku: // global
           call _c4LjY(R1) args: 0, res: 0, upd: 0;
       c4Lk0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Ljv: // global
           I64[Sp + 8] = block_c4Lkd_info;
           R1 = _s4L02::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lkv; else goto c4Lkf;
       u4Lkv: // global
           call _c4Lkd() args: 0, res: 0, upd: 0;
       c4Lkf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LjF() //  [R1]
         { info_tbl: [(c4LjF,
                       label: block_c4LjF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LjF: // global
           _c4Lkl::P64 = R1 & 7;
           if (_c4Lkl::P64 != 3) goto u4Lko; else goto u4Lkp;
       u4Lko: // global
           if (_c4Lkl::P64 != 4) goto c4LjN; else goto u4Lkq;
       c4LjN: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Lkq: // global
           Sp = Sp + 8;
           call _c4Lka() args: 0, res: 0, upd: 0;
       u4Lkp: // global
           Sp = Sp + 8;
           call _c4Lk6() args: 0, res: 0, upd: 0;
     }
 },
 _c4LjY() //  [R1]
         { info_tbl: [(c4LjY,
                       label: block_c4LjY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LjY: // global
           if (R1 & 7 == 4) goto u4Lkr; else goto u4Lks;
       u4Lkr: // global
           Sp = Sp + 8;
           call _c4Lka() args: 0, res: 0, upd: 0;
       u4Lks: // global
           Sp = Sp + 8;
           call _c4Lk6() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lka() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lka: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lk6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lk6: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lkd() //  []
         { info_tbl: [(c4Lkd,
                       label: block_c4Lkd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lkd: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.920947018 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c>=_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c>=_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c>=_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c4LkO,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LkO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LkP; else goto c4LkQ;
       c4LkP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LkQ: // global
           I64[Sp - 16] = block_c4LkF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Lme; else goto c4LkG;
       u4Lme: // global
           call _c4LkF(R1) args: 0, res: 0, upd: 0;
       c4LkG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LkF() //  [R1]
         { info_tbl: [(c4LkF,
                       label: block_c4LkF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LkF: // global
           _s4L09::P64 = P64[Sp + 8];
           _c4LkN::P64 = R1 & 7;
           if (_c4LkN::P64 < 3) goto u4LlY; else goto u4LlZ;
       u4LlY: // global
           if (_c4LkN::P64 < 2) goto c4LkJ; else goto c4LkK;
       c4LkJ: // global
           I64[Sp + 8] = block_c4LkT_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lma; else goto c4LkV;
       u4Lma: // global
           call _c4LkT(R1) args: 0, res: 0, upd: 0;
       c4LkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LkK: // global
           I64[Sp + 8] = block_c4Llg_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lmb; else goto c4Lli;
       u4Lmb: // global
           call _c4Llg(R1) args: 0, res: 0, upd: 0;
       c4Lli: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4LlZ: // global
           if (_c4LkN::P64 < 4) goto c4LkL; else goto c4LkM;
       c4LkL: // global
           I64[Sp + 8] = block_c4Llz_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lmc; else goto c4LlB;
       u4Lmc: // global
           call _c4Llz(R1) args: 0, res: 0, upd: 0;
       c4LlB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LkM: // global
           I64[Sp + 8] = block_c4LlO_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lmd; else goto c4LlQ;
       u4Lmd: // global
           call _c4LlO() args: 0, res: 0, upd: 0;
       c4LlQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LkT() //  [R1]
         { info_tbl: [(c4LkT,
                       label: block_c4LkT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LkT: // global
           _c4LlX::P64 = R1 & 7;
           if (_c4LlX::P64 < 2) goto u4Lm2; else goto u4Lm0;
       u4Lm2: // global
           Sp = Sp + 8;
           call _c4LlH() args: 0, res: 0, upd: 0;
       u4Lm0: // global
           if (_c4LlX::P64 != 3) goto u4Lm4; else goto u4Lm4;
       u4Lm4: // global
           Sp = Sp + 8;
           call _c4LlL() args: 0, res: 0, upd: 0;
     }
 },
 _c4Llg() //  [R1]
         { info_tbl: [(c4Llg,
                       label: block_c4Llg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Llg: // global
           _c4LlW::P64 = R1 & 7;
           if (_c4LlW::P64 != 3) goto u4Lm1; else goto u4Lm5;
       u4Lm1: // global
           if (_c4LlW::P64 != 4) goto u4Lm7; else goto u4Lm6;
       u4Lm7: // global
           Sp = Sp + 8;
           call _c4LlH() args: 0, res: 0, upd: 0;
       u4Lm6: // global
           Sp = Sp + 8;
           goto u4Lmi;
       u4Lm5: // global
           Sp = Sp + 8;
           goto u4Lmi;
       u4Lmi: // global
           call _c4LlL() args: 0, res: 0, upd: 0;
     }
 },
 _c4Llz() //  [R1]
         { info_tbl: [(c4Llz,
                       label: block_c4Llz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Llz: // global
           if (R1 & 7 == 4) goto u4Lm8; else goto u4Lm9;
       u4Lm8: // global
           Sp = Sp + 8;
           call _c4LlL() args: 0, res: 0, upd: 0;
       u4Lm9: // global
           Sp = Sp + 8;
           call _c4LlH() args: 0, res: 0, upd: 0;
     }
 },
 _c4LlL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LlL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LlH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LlH: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LlO() //  []
         { info_tbl: [(c4LlO,
                       label: block_c4LlO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LlO: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.924075849 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c>_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c>_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c>_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c4Lmq,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lmq: // global
           _s4L0g::P64 = R3;
           R3 = R2;
           R2 = _s4L0g::P64;
           call GHC.IO.IOMode.$fOrdIOMode_$c<_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.925663933 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$cmin_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$cmin_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$cmin_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4LmG,
                       label: GHC.IO.IOMode.$fOrdIOMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LmG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LmH; else goto c4LmI;
       c4LmH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LmI: // global
           I64[Sp - 16] = block_c4Lmx_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LnB; else goto c4Lmy;
       u4LnB: // global
           call _c4Lmx(R1) args: 0, res: 0, upd: 0;
       c4Lmy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lmx() //  [R1]
         { info_tbl: [(c4Lmx,
                       label: block_c4Lmx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lmx: // global
           _s4L0h::P64 = P64[Sp + 8];
           _c4LmF::P64 = R1 & 7;
           if (_c4LmF::P64 < 3) goto u4Lnv; else goto u4Lnw;
       u4Lnv: // global
           if (_c4LmF::P64 < 2) goto c4LmB; else goto c4LmC;
       c4LmB: // global
           I64[Sp + 8] = block_c4LmL_info;
           R1 = _s4L0h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lny; else goto c4LmN;
       u4Lny: // global
           call _c4LmL() args: 0, res: 0, upd: 0;
       c4LmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LmC: // global
           I64[Sp + 8] = block_c4LmU_info;
           R1 = _s4L0h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lnz; else goto c4LmW;
       u4Lnz: // global
           call _c4LmU(R1) args: 0, res: 0, upd: 0;
       c4LmW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Lnw: // global
           if (_c4LmF::P64 < 4) goto c4LmD; else goto c4LmE;
       c4LmD: // global
           I64[Sp + 8] = block_c4Lnd_info;
           R1 = _s4L0h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LnA; else goto c4Lnf;
       u4LnA: // global
           call _c4Lnd(R1) args: 0, res: 0, upd: 0;
       c4Lnf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LmE: // global
           R1 = _s4L0h::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LmL() //  []
         { info_tbl: [(c4LmL,
                       label: block_c4LmL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LmL: // global
           R1 = GHC.IO.IOMode.ReadMode_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LmU() //  [R1]
         { info_tbl: [(c4LmU,
                       label: block_c4LmU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LmU: // global
           _c4Lnu::P64 = R1 & 7;
           if (_c4Lnu::P64 == 3) goto c4Lna; else goto u4Lnx;
       u4Lnx: // global
           if (_c4Lnu::P64 == 4) goto c4Lna; else goto c4Ln2;
       c4Lna: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ln2: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lnd() //  [R1]
         { info_tbl: [(c4Lnd,
                       label: block_c4Lnd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lnd: // global
           if (R1 & 7 == 4) goto c4Lnp; else goto c4Lnl;
       c4Lnp: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Lnl: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.927720985 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_closure" {
     GHC.IO.IOMode.$fOrdIOMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.IOMode.$fEqIOMode_closure+1;
         const GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c<_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c<=_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c>_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c>=_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$cmax_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.9298312 UTC

[section ""data" . GHC.IO.IOMode.$w$cunsafeIndex_closure" {
     GHC.IO.IOMode.$w$cunsafeIndex_closure:
         const GHC.IO.IOMode.$w$cunsafeIndex_info;
 },
 GHC.IO.IOMode.$w$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4LnP,
                       label: GHC.IO.IOMode.$w$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LnP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LnQ; else goto c4LnR;
       c4LnQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LnR: // global
           I64[Sp - 16] = block_c4LnG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LpS; else goto c4LnH;
       u4LpS: // global
           call _c4LnG(R1) args: 0, res: 0, upd: 0;
       c4LnH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LnG() //  [R1]
         { info_tbl: [(c4LnG,
                       label: block_c4LnG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LnG: // global
           _s4L0o::P64 = P64[Sp + 8];
           _c4LnO::P64 = R1 & 7;
           if (_c4LnO::P64 < 3) goto u4Lpq; else goto u4Lpr;
       u4Lpq: // global
           if (_c4LnO::P64 < 2) goto c4LnK; else goto c4LnL;
       c4LnK: // global
           I64[Sp + 8] = block_c4LnU_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LpO; else goto c4LnW;
       u4LpO: // global
           call _c4LnU(R1) args: 0, res: 0, upd: 0;
       c4LnW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LnL: // global
           I64[Sp + 8] = block_c4Loh_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LpP; else goto c4Loj;
       u4LpP: // global
           call _c4Loh(R1) args: 0, res: 0, upd: 0;
       c4Loj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Lpr: // global
           if (_c4LnO::P64 < 4) goto c4LnM; else goto c4LnN;
       c4LnM: // global
           I64[Sp + 8] = block_c4LoE_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LpQ; else goto c4LoG;
       u4LpQ: // global
           call _c4LoE(R1) args: 0, res: 0, upd: 0;
       c4LoG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LnN: // global
           I64[Sp + 8] = block_c4Lp1_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LpR; else goto c4Lp3;
       u4LpR: // global
           call _c4Lp1(R1) args: 0, res: 0, upd: 0;
       c4Lp3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LnU() //  [R1]
         { info_tbl: [(c4LnU,
                       label: block_c4LnU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LnU: // global
           _c4Lpp::P64 = R1 & 7;
           if (_c4Lpp::P64 < 3) goto u4Lps; else goto u4Lpt;
       u4Lps: // global
           if (_c4Lpp::P64 < 2) goto u4LpB; else goto u4LpA;
       u4LpB: // global
           Sp = Sp + 8;
           call _c4Lpl() args: 0, res: 0, upd: 0;
       u4LpA: // global
           Sp = Sp + 8;
           call _c4LoY() args: 0, res: 0, upd: 0;
       u4Lpt: // global
           if (_c4Lpp::P64 < 4) goto u4LpC; else goto c4Loe;
       u4LpC: // global
           Sp = Sp + 8;
           call _c4LoB() args: 0, res: 0, upd: 0;
       c4Loe: // global
           R1 = 3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Loh() //  [R1]
         { info_tbl: [(c4Loh,
                       label: block_c4Loh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Loh: // global
           _c4Lpo::P64 = R1 & 7;
           if (_c4Lpo::P64 < 3) goto u4Lpu; else goto u4Lpv;
       u4Lpu: // global
           if (_c4Lpo::P64 < 2) goto u4LpE; else goto u4LpD;
       u4LpE: // global
           Sp = Sp + 8;
           call _c4Lph() args: 0, res: 0, upd: 0;
       u4LpD: // global
           Sp = Sp + 8;
           call _c4Lpl() args: 0, res: 0, upd: 0;
       u4Lpv: // global
           if (_c4Lpo::P64 < 4) goto u4LpG; else goto u4LpF;
       u4LpG: // global
           Sp = Sp + 8;
           call _c4LoY() args: 0, res: 0, upd: 0;
       u4LpF: // global
           Sp = Sp + 8;
           call _c4LoB() args: 0, res: 0, upd: 0;
     }
 },
 _c4LoB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LoB: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LoE() //  [R1]
         { info_tbl: [(c4LoE,
                       label: block_c4LoE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LoE: // global
           _c4Lpn::P64 = R1 & 7;
           if (_c4Lpn::P64 < 3) goto u4Lpw; else goto u4Lpx;
       u4Lpw: // global
           if (_c4Lpn::P64 < 2) goto u4LpI; else goto u4LpH;
       u4LpI: // global
           Sp = Sp + 8;
           call _c4Lpd() args: 0, res: 0, upd: 0;
       u4LpH: // global
           Sp = Sp + 8;
           call _c4Lph() args: 0, res: 0, upd: 0;
       u4Lpx: // global
           if (_c4Lpn::P64 < 4) goto u4LpK; else goto u4LpJ;
       u4LpK: // global
           Sp = Sp + 8;
           call _c4Lpl() args: 0, res: 0, upd: 0;
       u4LpJ: // global
           Sp = Sp + 8;
           call _c4LoY() args: 0, res: 0, upd: 0;
     }
 },
 _c4LoY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LoY: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lp1() //  [R1]
         { info_tbl: [(c4Lp1,
                       label: block_c4Lp1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lp1: // global
           _c4Lpm::P64 = R1 & 7;
           if (_c4Lpm::P64 < 3) goto u4Lpy; else goto u4Lpz;
       u4Lpy: // global
           if (_c4Lpm::P64 < 2) goto c4Lp9; else goto u4LpL;
       c4Lp9: // global
           R1 = (-3);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4LpL: // global
           Sp = Sp + 8;
           call _c4Lpd() args: 0, res: 0, upd: 0;
       u4Lpz: // global
           if (_c4Lpm::P64 < 4) goto u4LpN; else goto u4LpM;
       u4LpN: // global
           Sp = Sp + 8;
           call _c4Lph() args: 0, res: 0, upd: 0;
       u4LpM: // global
           Sp = Sp + 8;
           call _c4Lpl() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lpd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lpd: // global
           R1 = (-2);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lph() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lph: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lpl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lpl: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.933533641 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4Lqe,
                       label: GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lqe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Lqm; else goto c4Lqn;
       c4Lqm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Lqn: // global
           I64[Sp - 16] = block_c4Lqb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Lqs; else goto c4Lqc;
       u4Lqs: // global
           call _c4Lqb(R1) args: 0, res: 0, upd: 0;
       c4Lqc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lqb() //  [R1]
         { info_tbl: [(c4Lqb,
                       label: block_c4Lqb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lqb: // global
           _s4L0v::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Lqh_info;
           R3 = _s4L0v::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$cunsafeIndex_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lqh() //  [R1]
         { info_tbl: [(c4Lqh,
                       label: block_c4Lqh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lqh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Lqr; else goto c4Lqq;
       c4Lqr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4Lqq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.936017837 UTC

[section ""data" . GHC.IO.IOMode.$w$cinRange_closure" {
     GHC.IO.IOMode.$w$cinRange_closure:
         const GHC.IO.IOMode.$w$cinRange_info;
 },
 GHC.IO.IOMode.$w$cinRange_entry() //  [R2, R3, R4]
         { info_tbl: [(c4LqI,
                       label: GHC.IO.IOMode.$w$cinRange_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LqI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4LqJ; else goto c4LqK;
       c4LqJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cinRange_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LqK: // global
           I64[Sp - 24] = block_c4Lqz_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Lsq; else goto c4LqA;
       u4Lsq: // global
           call _c4Lqz(R1) args: 0, res: 0, upd: 0;
       c4LqA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lqz() //  [R1]
         { info_tbl: [(c4Lqz,
                       label: block_c4Lqz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lqz: // global
           _s4L0B::P64 = P64[Sp + 8];
           _c4LqH::P64 = R1 & 7;
           if (_c4LqH::P64 < 3) goto u4Lsj; else goto u4Lsk;
       u4Lsj: // global
           if (_c4LqH::P64 < 2) goto c4LqD; else goto c4LqE;
       c4LqD: // global
           _s4L0E::I64 = 0;
           goto s4L0D;
       c4LqE: // global
           _s4L0E::I64 = 1;
           goto s4L0D;
       u4Lsk: // global
           if (_c4LqH::P64 < 4) goto c4LqF; else goto c4LqG;
       c4LqF: // global
           _s4L0E::I64 = 2;
           goto s4L0D;
       c4LqG: // global
           _s4L0E::I64 = 3;
           goto s4L0D;
       s4L0D: // global
           I64[Sp] = block_c4LqQ_info;
           R1 = _s4L0B::P64;
           I64[Sp + 8] = _s4L0E::I64;
           if (R1 & 7 != 0) goto u4Lsp; else goto c4LrA;
       u4Lsp: // global
           call _c4LqQ(R1) args: 0, res: 0, upd: 0;
       c4LrA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LqQ() //  [R1]
         { info_tbl: [(c4LqQ,
                       label: block_c4LqQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LqQ: // global
           _s4L0C::P64 = P64[Sp + 16];
           _c4Ls5::P64 = R1 & 7;
           if (_c4Ls5::P64 < 3) goto u4Lsl; else goto u4Lsm;
       u4Lsl: // global
           if (_c4Ls5::P64 < 2) goto c4LrG; else goto c4LrK;
       c4LrG: // global
           _s4L0G::I64 = 0;
           goto s4L0F;
       c4LrK: // global
           _s4L0G::I64 = 1;
           goto s4L0F;
       u4Lsm: // global
           if (_c4Ls5::P64 < 4) goto c4LrO; else goto c4LrS;
       c4LrO: // global
           _s4L0G::I64 = 2;
           goto s4L0F;
       c4LrS: // global
           _s4L0G::I64 = 3;
           goto s4L0F;
       s4L0F: // global
           I64[Sp] = block_c4LqV_info;
           R1 = _s4L0C::P64;
           I64[Sp + 16] = _s4L0G::I64;
           if (R1 & 7 != 0) goto u4Lsr; else goto c4LqX;
       u4Lsr: // global
           call _c4LqV(R1) args: 0, res: 0, upd: 0;
       c4LqX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LqV() //  [R1]
         { info_tbl: [(c4LqV,
                       label: block_c4LqV_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LqV: // global
           _s4L0E::I64 = I64[Sp + 8];
           _s4L0G::I64 = I64[Sp + 16];
           _c4Ls6::P64 = R1 & 7;
           if (_c4Ls6::P64 < 3) goto u4Lsn; else goto u4Lso;
       u4Lsn: // global
           if (_c4Ls6::P64 < 2) goto c4Lr8; else goto c4Lrh;
       c4Lr8: // global
           if (%MO_S_Lt_W64(0, _s4L0E::I64)) goto c4Lrx; else goto c4Lr6;
       c4Lr6: // global
           R1 = I64[(%MO_S_Le_W64(0,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Lrh: // global
           if (%MO_S_Lt_W64(1, _s4L0E::I64)) goto c4Lrx; else goto c4Lrg;
       c4Lrg: // global
           R1 = I64[(%MO_S_Le_W64(1,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Lso: // global
           if (_c4Ls6::P64 < 4) goto c4Lrq; else goto c4Lrz;
       c4Lrq: // global
           if (%MO_S_Lt_W64(2, _s4L0E::I64)) goto c4Lrx; else goto c4Lrp;
       c4Lrp: // global
           R1 = I64[(%MO_S_Le_W64(2,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Lrz: // global
           if (%MO_S_Lt_W64(3, _s4L0E::I64)) goto c4Lrx; else goto c4Lry;
       c4Lrx: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Lry: // global
           R1 = I64[(%MO_S_Le_W64(3,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.938882307 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cinRange_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cinRange_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cinRange_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4Lsz,
                       label: GHC.IO.IOMode.$fIxIOMode_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lsz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LsA; else goto c4LsB;
       c4LsA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LsB: // global
           I64[Sp - 16] = block_c4Lsw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LsF; else goto c4Lsx;
       u4LsF: // global
           call _c4Lsw(R1) args: 0, res: 0, upd: 0;
       c4Lsx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lsw() //  [R1]
         { info_tbl: [(c4Lsw,
                       label: block_c4Lsw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lsw: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.940011132 UTC

[section ""data" . lvl_r4KYL_closure" {
     lvl_r4KYL_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.940622636 UTC

[section ""data" . lvl1_r4KYM_closure" {
     lvl1_r4KYM_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.941200478 UTC

[section ""data" . lvl2_r4KYN_closure" {
     lvl2_r4KYN_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.941815675 UTC

[section ""data" . lvl3_r4KYO_closure" {
     lvl3_r4KYO_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.942857342 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_info;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4LsT,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LsT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4LsU; else goto c4LsV;
       c4LsU: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LsV: // global
           I64[Sp - 8] = block_c4LsK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Lta; else goto c4LsL;
       u4Lta: // global
           call _c4LsK(R1) args: 0, res: 0, upd: 0;
       c4LsL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LsK() //  [R1]
         { info_tbl: [(c4LsK,
                       label: block_c4LsK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LsK: // global
           _c4LsS::P64 = R1 & 7;
           if (_c4LsS::P64 < 3) goto u4Lt8; else goto u4Lt9;
       u4Lt8: // global
           if (_c4LsS::P64 < 2) goto c4LsO; else goto c4LsP;
       c4LsO: // global
           R1 = lvl_r4KYL_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LsP: // global
           R1 = lvl1_r4KYM_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Lt9: // global
           if (_c4LsS::P64 < 4) goto c4LsQ; else goto c4LsR;
       c4LsQ: // global
           R1 = lvl2_r4KYN_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LsR: // global
           R1 = lvl3_r4KYO_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.944731402 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go2_closure" {
     GHC.IO.IOMode.$fIxIOMode_go2_closure:
         const GHC.IO.IOMode.$fIxIOMode_go2_info;
 },
 sat_s4L13_entry() //  [R1]
         { info_tbl: [(c4Ltn,
                       label: sat_s4L13_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ltn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Lto; else goto c4Ltp;
       c4Lto: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ltp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L11::I64 = I64[R1 + 16];
           if (_s4L11::I64 != 0) goto c4Ltl; else goto c4Ltm;
       c4Ltl: // global
           R2 = _s4L11::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go2_entry(R2) args: 24, res: 0, upd: 24;
       c4Ltm: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L10_entry() //  [R1]
         { info_tbl: [(c4Ltw,
                       label: sat_s4L10_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ltw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ltx; else goto c4Lty;
       c4Ltx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Lty: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go2_entry() //  [R2]
         { info_tbl: [(c4LtA,
                       label: GHC.IO.IOMode.$fIxIOMode_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LtA: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4LtE; else goto c4LtD;
       c4LtE: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LtD: // global
           I64[Hp - 64] = sat_s4L13_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L10_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.946815101 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go1_closure" {
     GHC.IO.IOMode.$fIxIOMode_go1_closure:
         const GHC.IO.IOMode.$fIxIOMode_go1_info;
 },
 sat_s4L18_entry() //  [R1]
         { info_tbl: [(c4LtR,
                       label: sat_s4L18_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LtR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LtS; else goto c4LtT;
       c4LtS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LtT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L16::I64 = I64[R1 + 16];
           if (_s4L16::I64 != 1) goto c4LtP; else goto c4LtQ;
       c4LtP: // global
           R2 = _s4L16::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go1_entry(R2) args: 24, res: 0, upd: 24;
       c4LtQ: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L15_entry() //  [R1]
         { info_tbl: [(c4Lu0,
                       label: sat_s4L15_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lu0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Lu1; else goto c4Lu2;
       c4Lu1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Lu2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go1_entry() //  [R2]
         { info_tbl: [(c4Lu4,
                       label: GHC.IO.IOMode.$fIxIOMode_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lu4: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Lu8; else goto c4Lu7;
       c4Lu8: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Lu7: // global
           I64[Hp - 64] = sat_s4L18_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L15_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.948969386 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go_closure" {
     GHC.IO.IOMode.$fIxIOMode_go_closure:
         const GHC.IO.IOMode.$fIxIOMode_go_info;
 },
 sat_s4L1d_entry() //  [R1]
         { info_tbl: [(c4Lul,
                       label: sat_s4L1d_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lul: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Lum; else goto c4Lun;
       c4Lum: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Lun: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L1b::I64 = I64[R1 + 16];
           if (_s4L1b::I64 != 2) goto c4Luj; else goto c4Luk;
       c4Luj: // global
           R2 = _s4L1b::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go_entry(R2) args: 24, res: 0, upd: 24;
       c4Luk: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L1a_entry() //  [R1]
         { info_tbl: [(c4Luu,
                       label: sat_s4L1a_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Luu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Luv; else goto c4Luw;
       c4Luv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Luw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go_entry() //  [R2]
         { info_tbl: [(c4Luy,
                       label: GHC.IO.IOMode.$fIxIOMode_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Luy: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4LuC; else goto c4LuB;
       c4LuC: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LuB: // global
           I64[Hp - 64] = sat_s4L1d_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L1a_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.951036466 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go4_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go4_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go4_info;
 },
 sat_s4L1i_entry() //  [R1]
         { info_tbl: [(c4LuP,
                       label: sat_s4L1i_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LuP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LuQ; else goto c4LuR;
       c4LuQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LuR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L1g::I64 = I64[R1 + 16];
           if (_s4L1g::I64 != 3) goto c4LuN; else goto c4LuO;
       c4LuN: // global
           R2 = _s4L1g::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
       c4LuO: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L1f_entry() //  [R1]
         { info_tbl: [(c4LuY,
                       label: sat_s4L1f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LuY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LuZ; else goto c4Lv0;
       c4LuZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Lv0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go4_entry() //  [R2]
         { info_tbl: [(c4Lv2,
                       label: GHC.IO.IOMode.$fEnumIOMode_go4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lv2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Lv6; else goto c4Lv5;
       c4Lv6: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Lv5: // global
           I64[Hp - 64] = sat_s4L1i_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L1f_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.953512706 UTC

[section ""data" . GHC.IO.IOMode.$w$crange_closure" {
     GHC.IO.IOMode.$w$crange_closure:
         const GHC.IO.IOMode.$w$crange_info;
 },
 GHC.IO.IOMode.$w$crange_entry() //  [R2, R3]
         { info_tbl: [(c4Lvm,
                       label: GHC.IO.IOMode.$w$crange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lvm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Lvn; else goto c4Lvo;
       c4Lvn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$crange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Lvo: // global
           I64[Sp - 16] = block_c4Lvd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Lwp; else goto c4Lve;
       u4Lwp: // global
           call _c4Lvd(R1) args: 0, res: 0, upd: 0;
       c4Lve: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lvd() //  [R1]
         { info_tbl: [(c4Lvd,
                       label: block_c4Lvd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lvd: // global
           _s4L1k::P64 = P64[Sp + 8];
           _c4Lvl::P64 = R1 & 7;
           if (_c4Lvl::P64 < 3) goto u4Lwk; else goto u4Lwl;
       u4Lwk: // global
           if (_c4Lvl::P64 < 2) goto c4Lvh; else goto c4Lvi;
       c4Lvh: // global
           _s4L1m::I64 = 0;
           goto s4L1l;
       c4Lvi: // global
           _s4L1m::I64 = 1;
           goto s4L1l;
       u4Lwl: // global
           if (_c4Lvl::P64 < 4) goto c4Lvj; else goto c4Lvk;
       c4Lvj: // global
           _s4L1m::I64 = 2;
           goto s4L1l;
       c4Lvk: // global
           _s4L1m::I64 = 3;
           goto s4L1l;
       s4L1l: // global
           I64[Sp] = block_c4Lvs_info;
           R1 = _s4L1k::P64;
           I64[Sp + 8] = _s4L1m::I64;
           if (R1 & 7 != 0) goto u4Lwo; else goto c4Lvu;
       u4Lwo: // global
           call _c4Lvs(R1) args: 0, res: 0, upd: 0;
       c4Lvu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lvs() //  [R1]
         { info_tbl: [(c4Lvs,
                       label: block_c4Lvs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lvs: // global
           _s4L1m::I64 = I64[Sp + 8];
           _c4Lwj::P64 = R1 & 7;
           if (_c4Lwj::P64 < 3) goto u4Lwm; else goto u4Lwn;
       u4Lwm: // global
           if (_c4Lwj::P64 < 2) goto c4LvF; else goto c4LvO;
       c4LvF: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 0)) goto c4Lw5; else goto c4LvC;
       c4LvC: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go2_entry(R2) args: 8, res: 0, upd: 8;
       c4LvO: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 1)) goto c4Lw5; else goto c4LvM;
       c4LvM: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go1_entry(R2) args: 8, res: 0, upd: 8;
       u4Lwn: // global
           if (_c4Lwj::P64 < 4) goto c4LvX; else goto c4Lw6;
       c4LvX: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 2)) goto c4Lw5; else goto c4LvV;
       c4LvV: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go_entry(R2) args: 8, res: 0, upd: 8;
       c4Lw6: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 3)) goto c4Lw5; else goto c4Lw4;
       c4Lw5: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Lw4: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.955708631 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$crange_closure" {
     GHC.IO.IOMode.$fIxIOMode_$crange_closure:
         const GHC.IO.IOMode.$fIxIOMode_$crange_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$crange_entry() //  [R2]
         { info_tbl: [(c4Lwx,
                       label: GHC.IO.IOMode.$fIxIOMode_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lwx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Lwy; else goto c4Lwz;
       c4Lwy: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Lwz: // global
           I64[Sp - 8] = block_c4Lwu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4LwD; else goto c4Lwv;
       u4LwD: // global
           call _c4Lwu(R1) args: 0, res: 0, upd: 0;
       c4Lwv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lwu() //  [R1]
         { info_tbl: [(c4Lwu,
                       label: block_c4Lwu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lwu: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$crange_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.958636854 UTC

[section ""data" . GHC.IO.IOMode.$w$crangeSize_closure" {
     GHC.IO.IOMode.$w$crangeSize_closure:
         const GHC.IO.IOMode.$w$crangeSize_info;
 },
 GHC.IO.IOMode.$w$crangeSize_entry() //  [R2, R3]
         { info_tbl: [(c4LwO,
                       label: GHC.IO.IOMode.$w$crangeSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LwO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4LwP; else goto c4LwQ;
       c4LwP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$crangeSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LwQ: // global
           I64[Sp - 24] = block_c4LwI_info;
           R4 = R3;
           _s4L1y::P64 = R3;
           R3 = R3;
           _s4L1x::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4L1x::P64;
           P64[Sp - 8] = _s4L1y::P64;
           Sp = Sp - 24;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4LwI() //  [R1]
         { info_tbl: [(c4LwI,
                       label: block_c4LwI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LwI: // global
           if (R1 & 7 == 1) goto u4LyO; else goto c4LwM;
       u4LyO: // global
           Sp = Sp + 24;
           call _c4Lyu() args: 0, res: 0, upd: 0;
       c4LwM: // global
           _s4L1x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4LwW_info;
           R1 = _s4L1x::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lz3; else goto c4LwY;
       u4Lz3: // global
           call _c4LwW(R1) args: 0, res: 0, upd: 0;
       c4LwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LwW() //  [R1]
         { info_tbl: [(c4LwW,
                       label: block_c4LwW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LwW: // global
           _s4L1y::P64 = P64[Sp + 8];
           _c4Lyz::P64 = R1 & 7;
           if (_c4Lyz::P64 < 3) goto u4LyE; else goto u4LyF;
       u4LyE: // global
           if (_c4Lyz::P64 < 2) goto c4Lx5; else goto c4Lxt;
       c4Lx5: // global
           I64[Sp + 8] = block_c4Lx2_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lz5; else goto c4Lx6;
       u4Lz5: // global
           call _c4Lx2(R1) args: 0, res: 0, upd: 0;
       c4Lx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Lxt: // global
           I64[Sp + 8] = block_c4Lxr_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lz6; else goto c4Lxu;
       u4Lz6: // global
           call _c4Lxr(R1) args: 0, res: 0, upd: 0;
       c4Lxu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4LyF: // global
           if (_c4Lyz::P64 < 4) goto c4LxR; else goto c4Lyf;
       c4LxR: // global
           I64[Sp + 8] = block_c4LxP_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lz7; else goto c4LxS;
       u4Lz7: // global
           call _c4LxP(R1) args: 0, res: 0, upd: 0;
       c4LxS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Lyf: // global
           I64[Sp + 8] = block_c4Lyd_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Lz8; else goto c4Lyg;
       u4Lz8: // global
           call _c4Lyd(R1) args: 0, res: 0, upd: 0;
       c4Lyg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lx2() //  [R1]
         { info_tbl: [(c4Lx2,
                       label: block_c4Lx2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lx2: // global
           _c4LyD::P64 = R1 & 7;
           if (_c4LyD::P64 < 3) goto u4LyG; else goto u4LyH;
       u4LyG: // global
           if (_c4LyD::P64 < 2) goto u4LyQ; else goto u4LyP;
       u4LyQ: // global
           Sp = Sp + 8;
           call _c4Lyy() args: 0, res: 0, upd: 0;
       u4LyP: // global
           Sp = Sp + 8;
           call _c4Lya() args: 0, res: 0, upd: 0;
       u4LyH: // global
           if (_c4LyD::P64 < 4) goto u4LyR; else goto c4Lxo;
       u4LyR: // global
           Sp = Sp + 8;
           call _c4LxM() args: 0, res: 0, upd: 0;
       c4Lxo: // global
           R1 = 4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lxr() //  [R1]
         { info_tbl: [(c4Lxr,
                       label: block_c4Lxr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lxr: // global
           _c4LyC::P64 = R1 & 7;
           if (_c4LyC::P64 < 3) goto u4LyI; else goto u4LyJ;
       u4LyI: // global
           if (_c4LyC::P64 < 2) goto u4LyT; else goto u4LyS;
       u4LyT: // global
           Sp = Sp + 8;
           call _c4Lyu() args: 0, res: 0, upd: 0;
       u4LyS: // global
           Sp = Sp + 8;
           call _c4Lyy() args: 0, res: 0, upd: 0;
       u4LyJ: // global
           if (_c4LyC::P64 < 4) goto u4LyV; else goto u4LyU;
       u4LyV: // global
           Sp = Sp + 8;
           call _c4Lya() args: 0, res: 0, upd: 0;
       u4LyU: // global
           Sp = Sp + 8;
           call _c4LxM() args: 0, res: 0, upd: 0;
     }
 },
 _c4LxM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LxM: // global
           R1 = 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LxP() //  [R1]
         { info_tbl: [(c4LxP,
                       label: block_c4LxP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LxP: // global
           _c4LyB::P64 = R1 & 7;
           if (_c4LyB::P64 < 3) goto u4LyK; else goto u4LyL;
       u4LyK: // global
           if (_c4LyB::P64 < 2) goto u4LyX; else goto u4LyW;
       u4LyX: // global
           Sp = Sp + 8;
           call _c4Lyq() args: 0, res: 0, upd: 0;
       u4LyW: // global
           Sp = Sp + 8;
           call _c4Lyu() args: 0, res: 0, upd: 0;
       u4LyL: // global
           if (_c4LyB::P64 < 4) goto u4LyZ; else goto u4LyY;
       u4LyZ: // global
           Sp = Sp + 8;
           call _c4Lyy() args: 0, res: 0, upd: 0;
       u4LyY: // global
           Sp = Sp + 8;
           call _c4Lya() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lya() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lya: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lyd() //  [R1]
         { info_tbl: [(c4Lyd,
                       label: block_c4Lyd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lyd: // global
           _c4LyA::P64 = R1 & 7;
           if (_c4LyA::P64 < 3) goto u4LyM; else goto u4LyN;
       u4LyM: // global
           if (_c4LyA::P64 < 2) goto c4Lym; else goto u4Lz0;
       c4Lym: // global
           R1 = (-2);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Lz0: // global
           Sp = Sp + 8;
           call _c4Lyq() args: 0, res: 0, upd: 0;
       u4LyN: // global
           if (_c4LyA::P64 < 4) goto u4Lz2; else goto u4Lz1;
       u4Lz2: // global
           Sp = Sp + 8;
           call _c4Lyu() args: 0, res: 0, upd: 0;
       u4Lz1: // global
           Sp = Sp + 8;
           call _c4Lyy() args: 0, res: 0, upd: 0;
     }
 },
 _c4Lyq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lyq: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lyu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lyu: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Lyy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lyy: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.964408648 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure" {
     GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure:
         const GHC.IO.IOMode.$fIxIOMode_$crangeSize_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4Lzu,
                       label: GHC.IO.IOMode.$fIxIOMode_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lzu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4LzC; else goto c4LzD;
       c4LzC: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LzD: // global
           I64[Sp - 8] = block_c4Lzr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4LzI; else goto c4Lzs;
       u4LzI: // global
           call _c4Lzr(R1) args: 0, res: 0, upd: 0;
       c4Lzs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lzr() //  [R1]
         { info_tbl: [(c4Lzr,
                       label: block_c4Lzr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lzr: // global
           I64[Sp] = block_c4Lzx_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.IOMode.$w$crangeSize_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Lzx() //  [R1]
         { info_tbl: [(c4Lzx,
                       label: block_c4Lzx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Lzx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4LzH; else goto c4LzG;
       c4LzH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4LzG: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.967157161 UTC

[section ""data" . GHC.IO.IOMode.$w$cunsafeRangeSize_closure" {
     GHC.IO.IOMode.$w$cunsafeRangeSize_closure:
         const GHC.IO.IOMode.$w$cunsafeRangeSize_info;
 },
 GHC.IO.IOMode.$w$cunsafeRangeSize_entry() //  [R2, R3]
         { info_tbl: [(c4LzW,
                       label: GHC.IO.IOMode.$w$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LzW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LzX; else goto c4LzY;
       c4LzX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LzY: // global
           I64[Sp - 16] = block_c4LzN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LBZ; else goto c4LzO;
       u4LBZ: // global
           call _c4LzN(R1) args: 0, res: 0, upd: 0;
       c4LzO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LzN() //  [R1]
         { info_tbl: [(c4LzN,
                       label: block_c4LzN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LzN: // global
           _s4L1L::P64 = P64[Sp + 8];
           _c4LzV::P64 = R1 & 7;
           if (_c4LzV::P64 < 3) goto u4LBx; else goto u4LBy;
       u4LBx: // global
           if (_c4LzV::P64 < 2) goto c4LzR; else goto c4LzS;
       c4LzR: // global
           I64[Sp + 8] = block_c4LA1_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LBV; else goto c4LA3;
       u4LBV: // global
           call _c4LA1(R1) args: 0, res: 0, upd: 0;
       c4LA3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LzS: // global
           I64[Sp + 8] = block_c4LAo_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LBW; else goto c4LAq;
       u4LBW: // global
           call _c4LAo(R1) args: 0, res: 0, upd: 0;
       c4LAq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4LBy: // global
           if (_c4LzV::P64 < 4) goto c4LzT; else goto c4LzU;
       c4LzT: // global
           I64[Sp + 8] = block_c4LAL_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LBX; else goto c4LAN;
       u4LBX: // global
           call _c4LAL(R1) args: 0, res: 0, upd: 0;
       c4LAN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4LzU: // global
           I64[Sp + 8] = block_c4LB8_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4LBY; else goto c4LBa;
       u4LBY: // global
           call _c4LB8(R1) args: 0, res: 0, upd: 0;
       c4LBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LA1() //  [R1]
         { info_tbl: [(c4LA1,
                       label: block_c4LA1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LA1: // global
           _c4LBw::P64 = R1 & 7;
           if (_c4LBw::P64 < 3) goto u4LBz; else goto u4LBA;
       u4LBz: // global
           if (_c4LBw::P64 < 2) goto u4LBI; else goto u4LBH;
       u4LBI: // global
           Sp = Sp + 8;
           call _c4LBs() args: 0, res: 0, upd: 0;
       u4LBH: // global
           Sp = Sp + 8;
           call _c4LB5() args: 0, res: 0, upd: 0;
       u4LBA: // global
           if (_c4LBw::P64 < 4) goto u4LBJ; else goto c4LAl;
       u4LBJ: // global
           Sp = Sp + 8;
           call _c4LAI() args: 0, res: 0, upd: 0;
       c4LAl: // global
           R1 = 4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LAo() //  [R1]
         { info_tbl: [(c4LAo,
                       label: block_c4LAo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LAo: // global
           _c4LBv::P64 = R1 & 7;
           if (_c4LBv::P64 < 3) goto u4LBB; else goto u4LBC;
       u4LBB: // global
           if (_c4LBv::P64 < 2) goto u4LBL; else goto u4LBK;
       u4LBL: // global
           Sp = Sp + 8;
           call _c4LBo() args: 0, res: 0, upd: 0;
       u4LBK: // global
           Sp = Sp + 8;
           call _c4LBs() args: 0, res: 0, upd: 0;
       u4LBC: // global
           if (_c4LBv::P64 < 4) goto u4LBN; else goto u4LBM;
       u4LBN: // global
           Sp = Sp + 8;
           call _c4LB5() args: 0, res: 0, upd: 0;
       u4LBM: // global
           Sp = Sp + 8;
           call _c4LAI() args: 0, res: 0, upd: 0;
     }
 },
 _c4LAI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LAI: // global
           R1 = 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LAL() //  [R1]
         { info_tbl: [(c4LAL,
                       label: block_c4LAL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LAL: // global
           _c4LBu::P64 = R1 & 7;
           if (_c4LBu::P64 < 3) goto u4LBD; else goto u4LBE;
       u4LBD: // global
           if (_c4LBu::P64 < 2) goto u4LBP; else goto u4LBO;
       u4LBP: // global
           Sp = Sp + 8;
           call _c4LBk() args: 0, res: 0, upd: 0;
       u4LBO: // global
           Sp = Sp + 8;
           call _c4LBo() args: 0, res: 0, upd: 0;
       u4LBE: // global
           if (_c4LBu::P64 < 4) goto u4LBR; else goto u4LBQ;
       u4LBR: // global
           Sp = Sp + 8;
           call _c4LBs() args: 0, res: 0, upd: 0;
       u4LBQ: // global
           Sp = Sp + 8;
           call _c4LB5() args: 0, res: 0, upd: 0;
     }
 },
 _c4LB5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LB5: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LB8() //  [R1]
         { info_tbl: [(c4LB8,
                       label: block_c4LB8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LB8: // global
           _c4LBt::P64 = R1 & 7;
           if (_c4LBt::P64 < 3) goto u4LBF; else goto u4LBG;
       u4LBF: // global
           if (_c4LBt::P64 < 2) goto c4LBg; else goto u4LBS;
       c4LBg: // global
           R1 = (-2);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4LBS: // global
           Sp = Sp + 8;
           call _c4LBk() args: 0, res: 0, upd: 0;
       u4LBG: // global
           if (_c4LBt::P64 < 4) goto u4LBU; else goto u4LBT;
       u4LBU: // global
           Sp = Sp + 8;
           call _c4LBo() args: 0, res: 0, upd: 0;
       u4LBT: // global
           Sp = Sp + 8;
           call _c4LBs() args: 0, res: 0, upd: 0;
     }
 },
 _c4LBk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LBk: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LBo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LBo: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LBs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LBs: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.970820492 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4LCl,
                       label: GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LCl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4LCt; else goto c4LCu;
       c4LCt: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LCu: // global
           I64[Sp - 8] = block_c4LCi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4LCz; else goto c4LCj;
       u4LCz: // global
           call _c4LCi(R1) args: 0, res: 0, upd: 0;
       c4LCj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LCi() //  [R1]
         { info_tbl: [(c4LCi,
                       label: block_c4LCi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LCi: // global
           I64[Sp] = block_c4LCo_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.IOMode.$w$cunsafeRangeSize_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4LCo() //  [R1]
         { info_tbl: [(c4LCo,
                       label: block_c4LCo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LCo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4LCy; else goto c4LCx;
       c4LCy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4LCx: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.972595656 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cindex_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cindex_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cindex_info;
         const 0;
 },
 GHC.IO.IOMode.$fIxIOMode_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4LCH,
                       label: GHC.IO.IOMode.$fIxIOMode_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LCH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4LCI; else goto c4LCJ;
       c4LCI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LCJ: // global
           I64[Sp - 16] = block_c4LCE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LD7; else goto c4LCF;
       u4LD7: // global
           call _c4LCE(R1) args: 0, res: 0, upd: 0;
       c4LCF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LCE() //  [R1]
         { info_tbl: [(c4LCE,
                       label: block_c4LCE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LCE: // global
           I64[Sp - 8] = block_c4LCM_info;
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           _s4L1Z::P64 = P64[R1 + 7];
           R2 = _s4L1Z::P64;
           P64[Sp] = _s4L1Z::P64;
           Sp = Sp - 8;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4LCM() //  [R1]
         { info_tbl: [(c4LCM,
                       label: block_c4LCM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LCM: // global
           if (R1 & 7 == 1) goto c4LCT; else goto c4LD2;
       c4LCT: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4LD2: // global
           _s4L1X::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4LCW_info;
           R3 = _s4L1X::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.IOMode.$w$cunsafeIndex_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4LCW() //  [R1]
         { info_tbl: [(c4LCW,
                       label: block_c4LCW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LCW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4LD5; else goto c4LD4;
       c4LD5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4LD4: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.97446543 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_closure" {
     GHC.IO.IOMode.$fIxIOMode_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.IO.IOMode.$fOrdIOMode_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$crange_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$cindex_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$cinRange_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.975055397 UTC

[section ""cstring" . lvl4_r4KYP_bytes" {
     lvl4_r4KYP_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.975872805 UTC

[section ""data" . lvl5_r4KYQ_closure" {
     lvl5_r4KYQ_closure:
         const lvl5_r4KYQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r4KYQ_entry() //  [R1]
         { info_tbl: [(c4LDe,
                       label: lvl5_r4KYQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LDe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LDf; else goto c4LDg;
       c4LDf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LDg: // global
           (_c4LDb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LDb::I64 == 0) goto c4LDd; else goto c4LDc;
       c4LDd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LDc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LDb::I64;
           R2 = lvl4_r4KYP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.976797132 UTC

[section ""cstring" . GHC.IO.IOMode.$trModule4_bytes" {
     GHC.IO.IOMode.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.977577791 UTC

[section ""data" . lvl6_r4KYR_closure" {
     lvl6_r4KYR_closure:
         const lvl6_r4KYR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r4KYR_entry() //  [R1]
         { info_tbl: [(c4LDn,
                       label: lvl6_r4KYR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LDn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LDo; else goto c4LDp;
       c4LDo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LDp: // global
           (_c4LDk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LDk::I64 == 0) goto c4LDm; else goto c4LDl;
       c4LDm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LDl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LDk::I64;
           R2 = GHC.IO.IOMode.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.978469945 UTC

[section ""cstring" . GHC.IO.IOMode.$trModule2_bytes" {
     GHC.IO.IOMode.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,73,79,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.979174326 UTC

[section ""data" . lvl7_r4KYS_closure" {
     lvl7_r4KYS_closure:
         const lvl7_r4KYS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r4KYS_entry() //  [R1]
         { info_tbl: [(c4LDw,
                       label: lvl7_r4KYS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LDw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LDx; else goto c4LDy;
       c4LDx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LDy: // global
           (_c4LDt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LDt::I64 == 0) goto c4LDv; else goto c4LDu;
       c4LDv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LDu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LDt::I64;
           R2 = GHC.IO.IOMode.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.980084318 UTC

[section ""cstring" . lvl8_r4KYT_bytes" {
     lvl8_r4KYT_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,73,79,77,111,100,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.980872476 UTC

[section ""data" . lvl9_r4KYU_closure" {
     lvl9_r4KYU_closure:
         const lvl9_r4KYU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r4KYU_entry() //  [R1]
         { info_tbl: [(c4LDF,
                       label: lvl9_r4KYU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LDF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LDG; else goto c4LDH;
       c4LDG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LDH: // global
           (_c4LDC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LDC::I64 == 0) goto c4LDE; else goto c4LDD;
       c4LDE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LDD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LDC::I64;
           R2 = lvl8_r4KYT_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.981840944 UTC

[section ""data" . lvl10_r4KYV_closure" {
     lvl10_r4KYV_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.982387411 UTC

[section ""data" . lvl11_r4KYW_closure" {
     lvl11_r4KYW_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.982963123 UTC

[section ""data" . lvl12_r4KYX_closure" {
     lvl12_r4KYX_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl6_r4KYR_closure;
         const lvl7_r4KYS_closure;
         const lvl9_r4KYU_closure;
         const lvl10_r4KYV_closure+1;
         const lvl10_r4KYV_closure+1;
         const lvl10_r4KYV_closure+1;
         const lvl11_r4KYW_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.983560368 UTC

[section ""data" . lvl13_r4KYY_closure" {
     lvl13_r4KYY_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl5_r4KYQ_closure;
         const lvl12_r4KYX_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.984137134 UTC

[section ""cstring" . lvl14_r4KYZ_bytes" {
     lvl14_r4KYZ_bytes:
         I8[] [112,114,101,100,123,73,79,77,111,100,101,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.985067457 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode5_closure" {
     GHC.IO.IOMode.$fEnumIOMode5_closure:
         const GHC.IO.IOMode.$fEnumIOMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode5_entry() //  [R1]
         { info_tbl: [(c4LDQ,
                       label: GHC.IO.IOMode.$fEnumIOMode5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LDQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4LDR; else goto c4LDS;
       c4LDR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LDS: // global
           (_c4LDL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LDL::I64 == 0) goto c4LDN; else goto c4LDM;
       c4LDN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LDM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LDL::I64;
           I64[Sp - 24] = block_c4LDO_info;
           R2 = lvl14_r4KYZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4LDO() //  [R1]
         { info_tbl: [(c4LDO,
                       label: block_c4LDO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LDO: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.986622472 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cpred_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cpred_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cpred_entry() //  [R2]
         { info_tbl: [(c4LE9,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LE9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4LEa; else goto c4LEb;
       c4LEa: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LEb: // global
           I64[Sp - 8] = block_c4LE0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4LEq; else goto c4LE1;
       u4LEq: // global
           call _c4LE0(R1) args: 0, res: 0, upd: 0;
       c4LE1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LE0() //  [R1]
         { info_tbl: [(c4LE0,
                       label: block_c4LE0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LE0: // global
           _c4LE8::P64 = R1 & 7;
           if (_c4LE8::P64 < 3) goto u4LEo; else goto u4LEp;
       u4LEo: // global
           if (_c4LE8::P64 < 2) goto c4LE4; else goto c4LE5;
       c4LE4: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4LE5: // global
           R1 = GHC.IO.IOMode.ReadMode_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4LEp: // global
           if (_c4LE8::P64 < 4) goto c4LE6; else goto c4LE7;
       c4LE6: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LE7: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.987838782 UTC

[section ""cstring" . lvl15_r4KZ0_bytes" {
     lvl15_r4KZ0_bytes:
         I8[] [115,117,99,99,123,73,79,77,111,100,101,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.98867867 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode6_closure" {
     GHC.IO.IOMode.$fEnumIOMode6_closure:
         const GHC.IO.IOMode.$fEnumIOMode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode6_entry() //  [R1]
         { info_tbl: [(c4LEz,
                       label: GHC.IO.IOMode.$fEnumIOMode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LEz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4LEA; else goto c4LEB;
       c4LEA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LEB: // global
           (_c4LEu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LEu::I64 == 0) goto c4LEw; else goto c4LEv;
       c4LEw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LEv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LEu::I64;
           I64[Sp - 24] = block_c4LEx_info;
           R2 = lvl15_r4KZ0_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4LEx() //  [R1]
         { info_tbl: [(c4LEx,
                       label: block_c4LEx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LEx: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.990307905 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$csucc_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$csucc_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$csucc_entry() //  [R2]
         { info_tbl: [(c4LES,
                       label: GHC.IO.IOMode.$fEnumIOMode_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LES: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4LET; else goto c4LEU;
       c4LET: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LEU: // global
           I64[Sp - 8] = block_c4LEJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4LF9; else goto c4LEK;
       u4LF9: // global
           call _c4LEJ(R1) args: 0, res: 0, upd: 0;
       c4LEK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LEJ() //  [R1]
         { info_tbl: [(c4LEJ,
                       label: block_c4LEJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LEJ: // global
           _c4LER::P64 = R1 & 7;
           if (_c4LER::P64 < 3) goto u4LF7; else goto u4LF8;
       u4LF7: // global
           if (_c4LER::P64 < 2) goto c4LEN; else goto c4LEO;
       c4LEN: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LEO: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4LF8: // global
           if (_c4LER::P64 < 4) goto c4LEP; else goto c4LEQ;
       c4LEP: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LEQ: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.991543956 UTC

[section ""cstring" . lvl16_r4KZ1_bytes" {
     lvl16_r4KZ1_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.992112641 UTC

[section ""cstring" . lvl17_r4KZ2_bytes" {
     lvl17_r4KZ2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.992916381 UTC

[section ""data" . lvl18_r4KZ3_closure" {
     lvl18_r4KZ3_closure:
         const lvl18_r4KZ3_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_r4KZ3_entry() //  [R1]
         { info_tbl: [(c4LFg,
                       label: lvl18_r4KZ3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LFg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LFh; else goto c4LFi;
       c4LFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LFi: // global
           (_c4LFd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LFd::I64 == 0) goto c4LFf; else goto c4LFe;
       c4LFf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LFe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LFd::I64;
           R2 = lvl17_r4KZ2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.994215825 UTC

[section ""data" . lvl19_r4KZ4_closure" {
     lvl19_r4KZ4_closure:
         const lvl19_r4KZ4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_r4KZ4_entry() //  [R1]
         { info_tbl: [(c4LFs,
                       label: lvl19_r4KZ4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LFs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4LFt; else goto c4LFu;
       c4LFt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LFu: // global
           (_c4LFm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LFm::I64 == 0) goto c4LFo; else goto c4LFn;
       c4LFo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LFn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LFm::I64;
           I64[Sp - 24] = block_c4LFp_info;
           R4 = lvl18_r4KZ3_closure;
           R3 = 3;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4LFp() //  [R1, R2]
         { info_tbl: [(c4LFp,
                       label: block_c4LFp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LFp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LFx; else goto c4LFw;
       c4LFx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4LFw: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.995572296 UTC

[section ""data" . lvl20_r4KZ5_closure" {
     lvl20_r4KZ5_closure:
         const lvl20_r4KZ5_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_r4KZ5_entry() //  [R1]
         { info_tbl: [(c4LFE,
                       label: lvl20_r4KZ5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LFE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LFF; else goto c4LFG;
       c4LFF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LFG: // global
           (_c4LFB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LFB::I64 == 0) goto c4LFD; else goto c4LFC;
       c4LFD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LFC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LFB::I64;
           R3 = lvl19_r4KZ4_closure;
           R2 = lvl16_r4KZ1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.996519795 UTC

[section ""cstring" . lvl21_r4KZ6_bytes" {
     lvl21_r4KZ6_bytes:
         I8[] [116,111,69,110,117,109,123,73,79,77,111,100,101,125,58,32,116,97,103,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.997709721 UTC

[section ""data" . GHC.IO.IOMode.$wlvl_closure" {
     GHC.IO.IOMode.$wlvl_closure:
         const GHC.IO.IOMode.$wlvl_info;
         const 0;
 },
 sat_s4L2g_entry() //  [R1]
         { info_tbl: [(c4LFS,
                       label: sat_s4L2g_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LFS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4LFT; else goto c4LFU;
       c4LFT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LFU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4LFP_info;
           R4 = lvl20_r4KZ5_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4LFP() //  [R1, R2]
         { info_tbl: [(c4LFP,
                       label: block_c4LFP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LFP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LFX; else goto c4LFW;
       c4LFX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4LFW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$wlvl_entry() //  [R2]
         { info_tbl: [(c4LG0,
                       label: GHC.IO.IOMode.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LG0: // global
           _s4L2c::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4LG1; else goto c4LG2;
       c4LG2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LG4; else goto c4LG3;
       c4LG4: // global
           HpAlloc = 24;
           goto c4LG1;
       c4LG1: // global
           R2 = _s4L2c::I64;
           R1 = GHC.IO.IOMode.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LG3: // global
           I64[Hp - 16] = sat_s4L2g_info;
           I64[Hp] = _s4L2c::I64;
           I64[Sp - 8] = block_c4LFY_info;
           R3 = Hp - 16;
           R2 = lvl21_r4KZ6_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4LFY() //  [R1]
         { info_tbl: [(c4LFY,
                       label: block_c4LFY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LFY: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.99976465 UTC

[section ""data" . GHC.IO.IOMode.$w$ctoEnum_closure" {
     GHC.IO.IOMode.$w$ctoEnum_closure:
         const GHC.IO.IOMode.$w$ctoEnum_info;
         const 0;
 },
 GHC.IO.IOMode.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4LGh,
                       label: GHC.IO.IOMode.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LGh: // global
           _s4L2i::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c4LGp; else goto c4LGg;
       c4LGg: // global
           if (%MO_S_Gt_W64(_s4L2i::I64, 3)) goto c4LGp; else goto c4LGq;
       c4LGp: // global
           R2 = _s4L2i::I64;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4LGq: // global
           R1 = I64[(_s4L2i::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.000801102 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4LGy,
                       label: GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LGy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4LGz; else goto c4LGA;
       c4LGz: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LGA: // global
           I64[Sp - 8] = block_c4LGv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4LGE; else goto c4LGw;
       u4LGE: // global
           call _c4LGv(R1) args: 0, res: 0, upd: 0;
       c4LGw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LGv() //  [R1]
         { info_tbl: [(c4LGv,
                       label: block_c4LGv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LGv: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.002038114 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode4_closure" {
     GHC.IO.IOMode.$fEnumIOMode4_closure:
         const GHC.IO.IOMode.$fEnumIOMode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode4_entry() //  [R1]
         { info_tbl: [(c4LGL,
                       label: GHC.IO.IOMode.$fEnumIOMode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LGL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LGM; else goto c4LGN;
       c4LGM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LGN: // global
           (_c4LGI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LGI::I64 == 0) goto c4LGK; else goto c4LGJ;
       c4LGK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LGJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LGI::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.00314975 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode3_closure" {
     GHC.IO.IOMode.$fEnumIOMode3_closure:
         const GHC.IO.IOMode.$fEnumIOMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode3_entry() //  [R1]
         { info_tbl: [(c4LGU,
                       label: GHC.IO.IOMode.$fEnumIOMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LGU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LGV; else goto c4LGW;
       c4LGV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LGW: // global
           (_c4LGR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LGR::I64 == 0) goto c4LGT; else goto c4LGS;
       c4LGT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LGS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LGR::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.004203447 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode2_closure" {
     GHC.IO.IOMode.$fEnumIOMode2_closure:
         const GHC.IO.IOMode.$fEnumIOMode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode2_entry() //  [R1]
         { info_tbl: [(c4LH3,
                       label: GHC.IO.IOMode.$fEnumIOMode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LH3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LH4; else goto c4LH5;
       c4LH4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LH5: // global
           (_c4LH0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LH0::I64 == 0) goto c4LH2; else goto c4LH1;
       c4LH2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LH1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LH0::I64;
           R2 = 2;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.005892831 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode1_closure" {
     GHC.IO.IOMode.$fEnumIOMode1_closure:
         const GHC.IO.IOMode.$fEnumIOMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode1_entry() //  [R1]
         { info_tbl: [(c4LHc,
                       label: GHC.IO.IOMode.$fEnumIOMode1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LHc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LHd; else goto c4LHe;
       c4LHd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LHe: // global
           (_c4LH9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4LH9::I64 == 0) goto c4LHb; else goto c4LHa;
       c4LHb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4LHa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4LH9::I64;
           R2 = 3;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.007196921 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4LHs,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LHs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4LHt; else goto c4LHu;
       c4LHt: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LHu: // global
           I64[Sp - 8] = block_c4LHj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4LHJ; else goto c4LHk;
       u4LHJ: // global
           call _c4LHj(R1) args: 0, res: 0, upd: 0;
       c4LHk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LHj() //  [R1]
         { info_tbl: [(c4LHj,
                       label: block_c4LHj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LHj: // global
           _c4LHr::P64 = R1 & 7;
           if (_c4LHr::P64 < 3) goto u4LHH; else goto u4LHI;
       u4LHH: // global
           if (_c4LHr::P64 < 2) goto c4LHn; else goto c4LHo;
       c4LHn: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4LHo: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u4LHI: // global
           if (_c4LHr::P64 < 4) goto c4LHp; else goto c4LHq;
       c4LHp: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4LHq: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.017002234 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_info;
 },
 sat_s4L2H_entry() //  [R1]
         { info_tbl: [(c4LIv,
                       label: sat_s4L2H_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LIv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LIw; else goto c4LIx;
       c4LIw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LIx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L2C_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2F_entry() //  [R1]
         { info_tbl: [(c4LIC,
                       label: sat_s4L2F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LIC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LID; else goto c4LIE;
       c4LID: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LIE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2I_entry() //  [R1]
         { info_tbl: [(c4LIK,
                       label: sat_s4L2I_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LIK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LIL; else goto c4LIM;
       c4LIL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LIM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L2C_entry() //  [R1, R2]
         { info_tbl: [(c4LIQ,
                       label: go_dn_s4L2C_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LIQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4LIU; else goto c4LIT;
       c4LIU: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LIT: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4LIO; else goto c4LIP;
       c4LIO: // global
           _s4L2A::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L2H_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L2A::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L2F_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LIP: // global
           I64[Hp - 80] = sat_s4L2I_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4LIW::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4LIW::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L2J_entry() //  [R1]
         { info_tbl: [(c4LIX,
                       label: sat_s4L2J_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LIX: // global
           _s4L2J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4LIY; else goto c4LIZ;
       c4LIZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LJ1; else goto c4LJ0;
       c4LJ1: // global
           HpAlloc = 24;
           goto c4LIY;
       c4LIY: // global
           R1 = _s4L2J::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LJ0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L2J::P64;
           _s4L2v::I64 = I64[_s4L2J::P64 + 24];
           _s4L2A::I64 = _s4L2v::I64 - I64[_s4L2J::P64 + 16];
           I64[Hp - 16] = go_dn_s4L2C_info;
           I64[Hp - 8] = _s4L2A::I64;
           I64[Hp] = 3 - _s4L2A::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L2C_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2z_entry() //  [R1]
         { info_tbl: [(c4LJ6,
                       label: sat_s4L2z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LJ7; else goto c4LJ8;
       c4LJ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LJ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2L_entry() //  [R1]
         { info_tbl: [(c4LJh,
                       label: sat_s4L2L_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LJh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LJi; else goto c4LJj;
       c4LJi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LJj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2V_entry() //  [R1]
         { info_tbl: [(c4LJM,
                       label: sat_s4L2V_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LJM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LJN; else goto c4LJO;
       c4LJN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LJO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L2Q_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2T_entry() //  [R1]
         { info_tbl: [(c4LJT,
                       label: sat_s4L2T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LJT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LJU; else goto c4LJV;
       c4LJU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LJV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2W_entry() //  [R1]
         { info_tbl: [(c4LK1,
                       label: sat_s4L2W_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LK1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LK2; else goto c4LK3;
       c4LK2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LK3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L2Q_entry() //  [R1, R2]
         { info_tbl: [(c4LK7,
                       label: go_up_s4L2Q_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LK7: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4LKb; else goto c4LKa;
       c4LKb: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LKa: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4LK5; else goto c4LK6;
       c4LK5: // global
           _s4L2O::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L2V_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L2O::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L2T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LK6: // global
           I64[Hp - 80] = sat_s4L2W_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4LKd::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4LKd::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L2X_entry() //  [R1]
         { info_tbl: [(c4LKe,
                       label: sat_s4L2X_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LKe: // global
           _s4L2X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4LKf; else goto c4LKg;
       c4LKg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LKi; else goto c4LKh;
       c4LKi: // global
           HpAlloc = 24;
           goto c4LKf;
       c4LKf: // global
           R1 = _s4L2X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LKh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L2X::P64;
           _s4L2v::I64 = I64[_s4L2X::P64 + 24];
           _s4L2O::I64 = _s4L2v::I64 - I64[_s4L2X::P64 + 16];
           I64[Hp - 16] = go_up_s4L2Q_info;
           I64[Hp - 8] = _s4L2O::I64;
           I64[Hp] = 3 - _s4L2O::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L2Q_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2N_entry() //  [R1]
         { info_tbl: [(c4LKn,
                       label: sat_s4L2N_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LKo; else goto c4LKp;
       c4LKo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LKp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2Z_entry() //  [R1]
         { info_tbl: [(c4LKy,
                       label: sat_s4L2Z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LKy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LKz; else goto c4LKA;
       c4LKz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LKA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3a_entry() //  [R1]
         { info_tbl: [(c4LL6,
                       label: sat_s4L3a_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LL6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LL7; else goto c4LL8;
       c4LL7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LL8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L35_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L38_entry() //  [R1]
         { info_tbl: [(c4LLd,
                       label: sat_s4L38_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LLd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LLe; else goto c4LLf;
       c4LLe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LLf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3b_entry() //  [R1]
         { info_tbl: [(c4LLl,
                       label: sat_s4L3b_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LLl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LLm; else goto c4LLn;
       c4LLm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LLn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L35_entry() //  [R1, R2]
         { info_tbl: [(c4LLr,
                       label: go_dn_s4L35_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LLr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4LLv; else goto c4LLu;
       c4LLv: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LLu: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4LLp; else goto c4LLq;
       c4LLp: // global
           _s4L33::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L3a_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L33::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L38_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LLq: // global
           I64[Hp - 80] = sat_s4L3b_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4LLx::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4LLx::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L3c_entry() //  [R1]
         { info_tbl: [(c4LLy,
                       label: sat_s4L3c_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LLy: // global
           _s4L3c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4LLz; else goto c4LLA;
       c4LLA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LLC; else goto c4LLB;
       c4LLC: // global
           HpAlloc = 24;
           goto c4LLz;
       c4LLz: // global
           R1 = _s4L3c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LLB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L3c::P64;
           _s4L2v::I64 = I64[_s4L3c::P64 + 24];
           _s4L33::I64 = _s4L2v::I64 - I64[_s4L3c::P64 + 16];
           I64[Hp - 16] = go_dn_s4L35_info;
           I64[Hp - 8] = _s4L33::I64;
           I64[Hp] = 0 - _s4L33::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L35_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L32_entry() //  [R1]
         { info_tbl: [(c4LLH,
                       label: sat_s4L32_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LLH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LLI; else goto c4LLJ;
       c4LLI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LLJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3e_entry() //  [R1]
         { info_tbl: [(c4LLS,
                       label: sat_s4L3e_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LLS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LLT; else goto c4LLU;
       c4LLT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LLU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3o_entry() //  [R1]
         { info_tbl: [(c4LMn,
                       label: sat_s4L3o_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LMn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LMo; else goto c4LMp;
       c4LMo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LMp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L3j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3m_entry() //  [R1]
         { info_tbl: [(c4LMu,
                       label: sat_s4L3m_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LMu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LMv; else goto c4LMw;
       c4LMv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LMw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3p_entry() //  [R1]
         { info_tbl: [(c4LMC,
                       label: sat_s4L3p_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LMC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LMD; else goto c4LME;
       c4LMD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LME: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L3j_entry() //  [R1, R2]
         { info_tbl: [(c4LMI,
                       label: go_up_s4L3j_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LMI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4LMM; else goto c4LML;
       c4LMM: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LML: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4LMG; else goto c4LMH;
       c4LMG: // global
           _s4L3h::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L3o_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L3h::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3m_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LMH: // global
           I64[Hp - 80] = sat_s4L3p_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4LMO::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4LMO::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L3q_entry() //  [R1]
         { info_tbl: [(c4LMP,
                       label: sat_s4L3q_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LMP: // global
           _s4L3q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4LMQ; else goto c4LMR;
       c4LMR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LMT; else goto c4LMS;
       c4LMT: // global
           HpAlloc = 24;
           goto c4LMQ;
       c4LMQ: // global
           R1 = _s4L3q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LMS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L3q::P64;
           _s4L2v::I64 = I64[_s4L3q::P64 + 24];
           _s4L3h::I64 = _s4L2v::I64 - I64[_s4L3q::P64 + 16];
           I64[Hp - 16] = go_up_s4L3j_info;
           I64[Hp - 8] = _s4L3h::I64;
           I64[Hp] = 0 - _s4L3h::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L3j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3g_entry() //  [R1]
         { info_tbl: [(c4LMY,
                       label: sat_s4L3g_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LMY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LMZ; else goto c4LN0;
       c4LMZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LN0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3s_entry() //  [R1]
         { info_tbl: [(c4LN9,
                       label: sat_s4L3s_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LN9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LNa; else goto c4LNb;
       c4LNa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LNb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4LNl,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LNm; else goto c4LNn;
       c4LNm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LNn: // global
           I64[Sp - 16] = block_c4LNc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LOP; else goto c4LNd;
       u4LOP: // global
           call _c4LNc(R1) args: 0, res: 0, upd: 0;
       c4LNd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LNc() //  [R1]
         { info_tbl: [(c4LNc,
                       label: block_c4LNc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LNc: // global
           _s4L2r::P64 = P64[Sp + 8];
           _c4LNk::P64 = R1 & 7;
           if (_c4LNk::P64 < 3) goto u4LOE; else goto u4LOF;
       u4LOE: // global
           if (_c4LNk::P64 < 2) goto c4LNg; else goto c4LNh;
       c4LNg: // global
           _s4L2t::I64 = 0;
           goto s4L2s;
       c4LNh: // global
           _s4L2t::I64 = 1;
           goto s4L2s;
       u4LOF: // global
           if (_c4LNk::P64 < 4) goto c4LNi; else goto c4LNj;
       c4LNi: // global
           _s4L2t::I64 = 2;
           goto s4L2s;
       c4LNj: // global
           _s4L2t::I64 = 3;
           goto s4L2s;
       s4L2s: // global
           I64[Sp] = block_c4LNo_info;
           R1 = _s4L2r::P64;
           I64[Sp + 8] = _s4L2t::I64;
           if (R1 & 7 != 0) goto u4LOO; else goto c4LO8;
       u4LOO: // global
           call _c4LNo(R1) args: 0, res: 0, upd: 0;
       c4LO8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LNo() //  [R1]
         { info_tbl: [(c4LNo,
                       label: block_c4LNo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LNo: // global
           _c4LOD::P64 = R1 & 7;
           if (_c4LOD::P64 < 3) goto u4LOG; else goto u4LOH;
       u4LOG: // global
           if (_c4LOD::P64 < 2) goto c4LOe; else goto c4LOi;
       c4LOe: // global
           I64[Sp] = 0;
           goto u4LOT;
       c4LOi: // global
           I64[Sp] = 1;
           goto u4LOT;
       u4LOH: // global
           if (_c4LOD::P64 < 4) goto c4LOm; else goto c4LOq;
       c4LOm: // global
           I64[Sp] = 2;
           goto u4LOT;
       c4LOq: // global
           I64[Sp] = 3;
           goto u4LOT;
       u4LOT: // global
           call _c4LHW() args: 0, res: 0, upd: 0;
     }
 },
 _c4LHW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LHW: // global
           Hp = Hp + 80;
           _s4L2v::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c4LNs; else goto c4LNr;
       c4LNs: // global
           HpAlloc = 80;
           I64[Sp] = block_c4LHV_info;
           R1 = _s4L2v::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4LNr: // global
           _s4L2t::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_s4L2t::I64,
                            _s4L2v::I64)) goto c4LNN; else goto c4LO7;
       c4LNN: // global
           if (%MO_S_Lt_W64(_s4L2v::I64,
                            _s4L2t::I64)) goto c4LNC; else goto c4LNL;
       c4LNC: // global
           if (%MO_S_Le_W64(3, _s4L2v::I64)) goto c4LNv; else goto c4LNA;
       c4LNv: // global
           I64[Hp - 72] = sat_s4L2J_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L2z_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LNA: // global
           if (%MO_S_Gt_W64(3, _s4L2t::I64)) goto c4LO4; else goto c4LNy;
       c4LNy: // global
           I64[Hp - 72] = sat_s4L2L_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4LNw::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4LNw::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LNL: // global
           if (%MO_S_Ge_W64(3, _s4L2v::I64)) goto c4LNF; else goto c4LNK;
       c4LNF: // global
           I64[Hp - 72] = sat_s4L2X_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L2N_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LNK: // global
           if (%MO_S_Lt_W64(3, _s4L2t::I64)) goto c4LO4; else goto c4LNI;
       c4LNI: // global
           I64[Hp - 72] = sat_s4L2Z_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4LNG::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4LNG::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LO7: // global
           if (%MO_S_Lt_W64(_s4L2v::I64,
                            _s4L2t::I64)) goto c4LNX; else goto c4LO6;
       c4LNX: // global
           if (%MO_S_Le_W64(0, _s4L2v::I64)) goto c4LNQ; else goto c4LNV;
       c4LNQ: // global
           I64[Hp - 72] = sat_s4L3c_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L32_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LNV: // global
           if (%MO_S_Gt_W64(0, _s4L2t::I64)) goto c4LO4; else goto c4LNT;
       c4LNT: // global
           I64[Hp - 72] = sat_s4L3e_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4LNR::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4LNR::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LO6: // global
           if (%MO_S_Ge_W64(0, _s4L2v::I64)) goto c4LO0; else goto c4LO5;
       c4LO0: // global
           I64[Hp - 72] = sat_s4L3q_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L3g_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LO5: // global
           if (%MO_S_Lt_W64(0, _s4L2t::I64)) goto c4LO4; else goto c4LO3;
       c4LO4: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LO3: // global
           I64[Hp - 72] = sat_s4L3s_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4LO1::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4LO1::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4LHV() //  [R1]
         { info_tbl: [(c4LHV,
                       label: block_c4LHV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LHV: // global
           I64[Sp] = R1;
           call _c4LHW() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.029341411 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go3_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go3_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go3_info;
         const 0;
 },
 sat_s4L3B_entry() //  [R1]
         { info_tbl: [(c4LP6,
                       label: sat_s4L3B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LP6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LP7; else goto c4LP8;
       c4LP7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LP8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3z::I64 = I64[R1 + 16];
           if (_s4L3z::I64 != 0) goto c4LP4; else goto c4LP5;
       c4LP4: // global
           R2 = _s4L3z::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go3_entry(R2) args: 24, res: 0, upd: 24;
       c4LP5: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3y_entry() //  [R1]
         { info_tbl: [(c4LPk,
                       label: sat_s4L3y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LPk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LPl; else goto c4LPt;
       c4LPl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LPt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3v::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3v::I64, 0)) goto c4LPr; else goto c4LPj;
       c4LPj: // global
           if (%MO_S_Gt_W64(_s4L3v::I64, 3)) goto c4LPr; else goto c4LPs;
       c4LPr: // global
           R2 = _s4L3v::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LPs: // global
           R1 = I64[(_s4L3v::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go3_entry() //  [R2]
         { info_tbl: [(c4LPv,
                       label: GHC.IO.IOMode.$fEnumIOMode_go3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LPv: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4LPz; else goto c4LPy;
       c4LPz: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LPy: // global
           I64[Hp - 64] = sat_s4L3B_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3y_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.031608446 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go2_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go2_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go2_info;
         const 0;
 },
 sat_s4L3I_entry() //  [R1]
         { info_tbl: [(c4LPM,
                       label: sat_s4L3I_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LPM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LPN; else goto c4LPO;
       c4LPN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LPO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3G::I64 = I64[R1 + 16];
           if (_s4L3G::I64 != 1) goto c4LPK; else goto c4LPL;
       c4LPK: // global
           R2 = _s4L3G::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go2_entry(R2) args: 24, res: 0, upd: 24;
       c4LPL: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3F_entry() //  [R1]
         { info_tbl: [(c4LQ0,
                       label: sat_s4L3F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LQ0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LQ1; else goto c4LQ9;
       c4LQ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LQ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3C::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3C::I64, 0)) goto c4LQ7; else goto c4LPZ;
       c4LPZ: // global
           if (%MO_S_Gt_W64(_s4L3C::I64, 3)) goto c4LQ7; else goto c4LQ8;
       c4LQ7: // global
           R2 = _s4L3C::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LQ8: // global
           R1 = I64[(_s4L3C::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go2_entry() //  [R2]
         { info_tbl: [(c4LQb,
                       label: GHC.IO.IOMode.$fEnumIOMode_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LQb: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4LQf; else goto c4LQe;
       c4LQf: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LQe: // global
           I64[Hp - 64] = sat_s4L3I_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3F_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.033865174 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go1_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go1_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go1_info;
         const 0;
 },
 sat_s4L3P_entry() //  [R1]
         { info_tbl: [(c4LQs,
                       label: sat_s4L3P_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LQs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LQt; else goto c4LQu;
       c4LQt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LQu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3N::I64 = I64[R1 + 16];
           if (_s4L3N::I64 != 2) goto c4LQq; else goto c4LQr;
       c4LQq: // global
           R2 = _s4L3N::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go1_entry(R2) args: 24, res: 0, upd: 24;
       c4LQr: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3M_entry() //  [R1]
         { info_tbl: [(c4LQG,
                       label: sat_s4L3M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LQG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LQH; else goto c4LQP;
       c4LQH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LQP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3J::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3J::I64, 0)) goto c4LQN; else goto c4LQF;
       c4LQF: // global
           if (%MO_S_Gt_W64(_s4L3J::I64, 3)) goto c4LQN; else goto c4LQO;
       c4LQN: // global
           R2 = _s4L3J::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LQO: // global
           R1 = I64[(_s4L3J::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go1_entry() //  [R2]
         { info_tbl: [(c4LQR,
                       label: GHC.IO.IOMode.$fEnumIOMode_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LQR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4LQV; else goto c4LQU;
       c4LQV: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LQU: // global
           I64[Hp - 64] = sat_s4L3P_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3M_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.03604328 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go_info;
         const 0;
 },
 sat_s4L3W_entry() //  [R1]
         { info_tbl: [(c4LR8,
                       label: sat_s4L3W_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LR8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LR9; else goto c4LRa;
       c4LR9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LRa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3U::I64 = I64[R1 + 16];
           if (_s4L3U::I64 != 3) goto c4LR6; else goto c4LR7;
       c4LR6: // global
           R2 = _s4L3U::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go_entry(R2) args: 24, res: 0, upd: 24;
       c4LR7: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3T_entry() //  [R1]
         { info_tbl: [(c4LRm,
                       label: sat_s4L3T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LRm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LRn; else goto c4LRv;
       c4LRn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LRv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3Q::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3Q::I64, 0)) goto c4LRt; else goto c4LRl;
       c4LRl: // global
           if (%MO_S_Gt_W64(_s4L3Q::I64, 3)) goto c4LRt; else goto c4LRu;
       c4LRt: // global
           R2 = _s4L3Q::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LRu: // global
           R1 = I64[(_s4L3Q::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go_entry() //  [R2]
         { info_tbl: [(c4LRx,
                       label: GHC.IO.IOMode.$fEnumIOMode_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LRx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4LRB; else goto c4LRA;
       c4LRB: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LRA: // global
           I64[Hp - 64] = sat_s4L3W_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.038503275 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4LRR,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LRR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LRS; else goto c4LRT;
       c4LRS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4LRT: // global
           I64[Sp - 16] = block_c4LRI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4LSU; else goto c4LRJ;
       u4LSU: // global
           call _c4LRI(R1) args: 0, res: 0, upd: 0;
       c4LRJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LRI() //  [R1]
         { info_tbl: [(c4LRI,
                       label: block_c4LRI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LRI: // global
           _s4L3Y::P64 = P64[Sp + 8];
           _c4LRQ::P64 = R1 & 7;
           if (_c4LRQ::P64 < 3) goto u4LSP; else goto u4LSQ;
       u4LSP: // global
           if (_c4LRQ::P64 < 2) goto c4LRM; else goto c4LRN;
       c4LRM: // global
           _s4L40::I64 = 0;
           goto s4L3Z;
       c4LRN: // global
           _s4L40::I64 = 1;
           goto s4L3Z;
       u4LSQ: // global
           if (_c4LRQ::P64 < 4) goto c4LRO; else goto c4LRP;
       c4LRO: // global
           _s4L40::I64 = 2;
           goto s4L3Z;
       c4LRP: // global
           _s4L40::I64 = 3;
           goto s4L3Z;
       s4L3Z: // global
           I64[Sp] = block_c4LRX_info;
           R1 = _s4L3Y::P64;
           I64[Sp + 8] = _s4L40::I64;
           if (R1 & 7 != 0) goto u4LST; else goto c4LRZ;
       u4LST: // global
           call _c4LRX(R1) args: 0, res: 0, upd: 0;
       c4LRZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LRX() //  [R1]
         { info_tbl: [(c4LRX,
                       label: block_c4LRX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LRX: // global
           _s4L40::I64 = I64[Sp + 8];
           _c4LSO::P64 = R1 & 7;
           if (_c4LSO::P64 < 3) goto u4LSR; else goto u4LSS;
       u4LSR: // global
           if (_c4LSO::P64 < 2) goto c4LSa; else goto c4LSj;
       c4LSa: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 0)) goto c4LSA; else goto c4LS7;
       c4LS7: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go3_entry(R2) args: 8, res: 0, upd: 8;
       c4LSj: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 1)) goto c4LSA; else goto c4LSh;
       c4LSh: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go2_entry(R2) args: 8, res: 0, upd: 8;
       u4LSS: // global
           if (_c4LSO::P64 < 4) goto c4LSs; else goto c4LSB;
       c4LSs: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 2)) goto c4LSA; else goto c4LSq;
       c4LSq: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go1_entry(R2) args: 8, res: 0, upd: 8;
       c4LSB: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 3)) goto c4LSA; else goto c4LSz;
       c4LSA: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LSz: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.054704867 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_info;
         const 0;
 },
 sat_s4L4t_entry() //  [R1]
         { info_tbl: [(c4LTI,
                       label: sat_s4L4t_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LTI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LTJ; else goto c4LTK;
       c4LTJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LTK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L4m_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4r_entry() //  [R1]
         { info_tbl: [(c4LTU,
                       label: sat_s4L4r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LTU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LTV; else goto c4LU3;
       c4LTV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LU3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4n::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4n::I64, 0)) goto c4LU1; else goto c4LTT;
       c4LTT: // global
           if (%MO_S_Gt_W64(_s4L4n::I64, 3)) goto c4LU1; else goto c4LU2;
       c4LU1: // global
           R2 = _s4L4n::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LU2: // global
           R1 = I64[(_s4L4n::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4w_entry() //  [R1]
         { info_tbl: [(c4LUe,
                       label: sat_s4L4w_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LUe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LUf; else goto c4LUn;
       c4LUf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LUn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4n::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4n::I64, 0)) goto c4LUl; else goto c4LUd;
       c4LUd: // global
           if (%MO_S_Gt_W64(_s4L4n::I64, 3)) goto c4LUl; else goto c4LUm;
       c4LUl: // global
           R2 = _s4L4n::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LUm: // global
           R1 = I64[(_s4L4n::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L4m_entry() //  [R1, R2]
         { info_tbl: [(c4LUr,
                       label: go_dn_s4L4m_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LUr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4LUv; else goto c4LUu;
       c4LUv: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LUu: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4LUp; else goto c4LUq;
       c4LUp: // global
           _s4L4k::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L4t_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L4k::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L4r_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LUq: // global
           I64[Hp - 80] = sat_s4L4w_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4LUx::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4LUx::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L4x_entry() //  [R1]
         { info_tbl: [(c4LUy,
                       label: sat_s4L4x_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LUy: // global
           _s4L4x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4LUz; else goto c4LUA;
       c4LUA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LUC; else goto c4LUB;
       c4LUC: // global
           HpAlloc = 24;
           goto c4LUz;
       c4LUz: // global
           R1 = _s4L4x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LUB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L4x::P64;
           _s4L4d::I64 = I64[_s4L4x::P64 + 24];
           _s4L4k::I64 = _s4L4d::I64 - I64[_s4L4x::P64 + 16];
           I64[Hp - 16] = go_dn_s4L4m_info;
           I64[Hp - 8] = _s4L4k::I64;
           I64[Hp] = 0 - _s4L4k::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L4m_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4j_entry() //  [R1]
         { info_tbl: [(c4LUM,
                       label: sat_s4L4j_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LUM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LUN; else goto c4LUV;
       c4LUN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4LUT; else goto c4LUL;
       c4LUL: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4LUT; else goto c4LUU;
       c4LUT: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LUU: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4B_entry() //  [R1]
         { info_tbl: [(c4LV9,
                       label: sat_s4L4B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LV9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LVa; else goto c4LVi;
       c4LVa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LVi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4LVg; else goto c4LV8;
       c4LV8: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4LVg; else goto c4LVh;
       c4LVg: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LVh: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4P_entry() //  [R1]
         { info_tbl: [(c4LVL,
                       label: sat_s4L4P_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LVL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LVM; else goto c4LVN;
       c4LVM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LVN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L4I_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4N_entry() //  [R1]
         { info_tbl: [(c4LVX,
                       label: sat_s4L4N_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LVX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LVY; else goto c4LW6;
       c4LVY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LW6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4J::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4J::I64, 0)) goto c4LW4; else goto c4LVW;
       c4LVW: // global
           if (%MO_S_Gt_W64(_s4L4J::I64, 3)) goto c4LW4; else goto c4LW5;
       c4LW4: // global
           R2 = _s4L4J::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LW5: // global
           R1 = I64[(_s4L4J::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4S_entry() //  [R1]
         { info_tbl: [(c4LWh,
                       label: sat_s4L4S_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LWh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LWi; else goto c4LWq;
       c4LWi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LWq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4J::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4J::I64, 0)) goto c4LWo; else goto c4LWg;
       c4LWg: // global
           if (%MO_S_Gt_W64(_s4L4J::I64, 3)) goto c4LWo; else goto c4LWp;
       c4LWo: // global
           R2 = _s4L4J::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LWp: // global
           R1 = I64[(_s4L4J::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L4I_entry() //  [R1, R2]
         { info_tbl: [(c4LWu,
                       label: go_up_s4L4I_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LWu: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4LWy; else goto c4LWx;
       c4LWy: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LWx: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4LWs; else goto c4LWt;
       c4LWs: // global
           _s4L4G::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L4P_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L4G::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L4N_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LWt: // global
           I64[Hp - 80] = sat_s4L4S_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4LWA::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4LWA::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L4T_entry() //  [R1]
         { info_tbl: [(c4LWB,
                       label: sat_s4L4T_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LWB: // global
           _s4L4T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4LWC; else goto c4LWD;
       c4LWD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LWF; else goto c4LWE;
       c4LWF: // global
           HpAlloc = 24;
           goto c4LWC;
       c4LWC: // global
           R1 = _s4L4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LWE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L4T::P64;
           _s4L4d::I64 = I64[_s4L4T::P64 + 24];
           _s4L4G::I64 = _s4L4d::I64 - I64[_s4L4T::P64 + 16];
           I64[Hp - 16] = go_up_s4L4I_info;
           I64[Hp - 8] = _s4L4G::I64;
           I64[Hp] = 0 - _s4L4G::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L4I_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4F_entry() //  [R1]
         { info_tbl: [(c4LWP,
                       label: sat_s4L4F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LWP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LWQ; else goto c4LWY;
       c4LWQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LWY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4LWW; else goto c4LWO;
       c4LWO: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4LWW; else goto c4LWX;
       c4LWW: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LWX: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4X_entry() //  [R1]
         { info_tbl: [(c4LXc,
                       label: sat_s4L4X_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LXc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LXd; else goto c4LXl;
       c4LXd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LXl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4LXj; else goto c4LXb;
       c4LXb: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4LXj; else goto c4LXk;
       c4LXj: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LXk: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5c_entry() //  [R1]
         { info_tbl: [(c4LXS,
                       label: sat_s4L5c_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LXS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LXT; else goto c4LXU;
       c4LXT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LXU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L55_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5a_entry() //  [R1]
         { info_tbl: [(c4LY4,
                       label: sat_s4L5a_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LY4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LY5; else goto c4LYd;
       c4LY5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LYd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L56::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L56::I64, 0)) goto c4LYb; else goto c4LY3;
       c4LY3: // global
           if (%MO_S_Gt_W64(_s4L56::I64, 3)) goto c4LYb; else goto c4LYc;
       c4LYb: // global
           R2 = _s4L56::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LYc: // global
           R1 = I64[(_s4L56::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5f_entry() //  [R1]
         { info_tbl: [(c4LYo,
                       label: sat_s4L5f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LYo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LYp; else goto c4LYx;
       c4LYp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LYx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L56::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L56::I64, 0)) goto c4LYv; else goto c4LYn;
       c4LYn: // global
           if (%MO_S_Gt_W64(_s4L56::I64, 3)) goto c4LYv; else goto c4LYw;
       c4LYv: // global
           R2 = _s4L56::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LYw: // global
           R1 = I64[(_s4L56::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L55_entry() //  [R1, R2]
         { info_tbl: [(c4LYB,
                       label: go_dn_s4L55_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LYB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4LYF; else goto c4LYE;
       c4LYF: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4LYE: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4LYz; else goto c4LYA;
       c4LYz: // global
           _s4L53::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L5c_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L53::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L5a_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4LYA: // global
           I64[Hp - 80] = sat_s4L5f_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4LYH::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4LYH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L5g_entry() //  [R1]
         { info_tbl: [(c4LYI,
                       label: sat_s4L5g_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LYI: // global
           _s4L5g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4LYJ; else goto c4LYK;
       c4LYK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4LYM; else goto c4LYL;
       c4LYM: // global
           HpAlloc = 24;
           goto c4LYJ;
       c4LYJ: // global
           R1 = _s4L5g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LYL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L5g::P64;
           _s4L4d::I64 = I64[_s4L5g::P64 + 24];
           _s4L53::I64 = _s4L4d::I64 - I64[_s4L5g::P64 + 16];
           I64[Hp - 16] = go_dn_s4L55_info;
           I64[Hp - 8] = _s4L53::I64;
           I64[Hp] = 1 - _s4L53::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L55_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L52_entry() //  [R1]
         { info_tbl: [(c4LYW,
                       label: sat_s4L52_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LYW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LYX; else goto c4LZ5;
       c4LYX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LZ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4LZ3; else goto c4LYV;
       c4LYV: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4LZ3; else goto c4LZ4;
       c4LZ3: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LZ4: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5k_entry() //  [R1]
         { info_tbl: [(c4LZj,
                       label: sat_s4L5k_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LZk; else goto c4LZs;
       c4LZk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LZs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4LZq; else goto c4LZi;
       c4LZi: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4LZq; else goto c4LZr;
       c4LZq: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4LZr: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5y_entry() //  [R1]
         { info_tbl: [(c4LZV,
                       label: sat_s4L5y_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LZV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4LZW; else goto c4LZX;
       c4LZW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4LZX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L5r_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5w_entry() //  [R1]
         { info_tbl: [(c4M07,
                       label: sat_s4L5w_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M07: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M08; else goto c4M0g;
       c4M08: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M0g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5s::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5s::I64, 0)) goto c4M0e; else goto c4M06;
       c4M06: // global
           if (%MO_S_Gt_W64(_s4L5s::I64, 3)) goto c4M0e; else goto c4M0f;
       c4M0e: // global
           R2 = _s4L5s::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M0f: // global
           R1 = I64[(_s4L5s::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5B_entry() //  [R1]
         { info_tbl: [(c4M0r,
                       label: sat_s4L5B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M0r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M0s; else goto c4M0A;
       c4M0s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M0A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5s::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5s::I64, 0)) goto c4M0y; else goto c4M0q;
       c4M0q: // global
           if (%MO_S_Gt_W64(_s4L5s::I64, 3)) goto c4M0y; else goto c4M0z;
       c4M0y: // global
           R2 = _s4L5s::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M0z: // global
           R1 = I64[(_s4L5s::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L5r_entry() //  [R1, R2]
         { info_tbl: [(c4M0E,
                       label: go_up_s4L5r_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M0E: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4M0I; else goto c4M0H;
       c4M0I: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4M0H: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4M0C; else goto c4M0D;
       c4M0C: // global
           _s4L5p::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L5y_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L5p::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L5w_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4M0D: // global
           I64[Hp - 80] = sat_s4L5B_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4M0K::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4M0K::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L5C_entry() //  [R1]
         { info_tbl: [(c4M0L,
                       label: sat_s4L5C_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M0L: // global
           _s4L5C::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4M0M; else goto c4M0N;
       c4M0N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4M0P; else goto c4M0O;
       c4M0P: // global
           HpAlloc = 24;
           goto c4M0M;
       c4M0M: // global
           R1 = _s4L5C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M0O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L5C::P64;
           _s4L4d::I64 = I64[_s4L5C::P64 + 24];
           _s4L5p::I64 = _s4L4d::I64 - I64[_s4L5C::P64 + 16];
           I64[Hp - 16] = go_up_s4L5r_info;
           I64[Hp - 8] = _s4L5p::I64;
           I64[Hp] = 1 - _s4L5p::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L5r_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5o_entry() //  [R1]
         { info_tbl: [(c4M0Z,
                       label: sat_s4L5o_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M0Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M10; else goto c4M18;
       c4M10: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M18: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M16; else goto c4M0Y;
       c4M0Y: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M16; else goto c4M17;
       c4M16: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M17: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5G_entry() //  [R1]
         { info_tbl: [(c4M1m,
                       label: sat_s4L5G_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M1m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M1n; else goto c4M1v;
       c4M1n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M1v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M1t; else goto c4M1l;
       c4M1l: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M1t; else goto c4M1u;
       c4M1t: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M1u: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5V_entry() //  [R1]
         { info_tbl: [(c4M22,
                       label: sat_s4L5V_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M22: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M23; else goto c4M24;
       c4M23: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M24: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L5O_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5T_entry() //  [R1]
         { info_tbl: [(c4M2e,
                       label: sat_s4L5T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M2e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M2f; else goto c4M2n;
       c4M2f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M2n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5P::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5P::I64, 0)) goto c4M2l; else goto c4M2d;
       c4M2d: // global
           if (%MO_S_Gt_W64(_s4L5P::I64, 3)) goto c4M2l; else goto c4M2m;
       c4M2l: // global
           R2 = _s4L5P::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M2m: // global
           R1 = I64[(_s4L5P::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5Y_entry() //  [R1]
         { info_tbl: [(c4M2y,
                       label: sat_s4L5Y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M2y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M2z; else goto c4M2H;
       c4M2z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M2H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5P::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5P::I64, 0)) goto c4M2F; else goto c4M2x;
       c4M2x: // global
           if (%MO_S_Gt_W64(_s4L5P::I64, 3)) goto c4M2F; else goto c4M2G;
       c4M2F: // global
           R2 = _s4L5P::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M2G: // global
           R1 = I64[(_s4L5P::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L5O_entry() //  [R1, R2]
         { info_tbl: [(c4M2L,
                       label: go_dn_s4L5O_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M2L: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4M2P; else goto c4M2O;
       c4M2P: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4M2O: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4M2J; else goto c4M2K;
       c4M2J: // global
           _s4L5M::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L5V_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L5M::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L5T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4M2K: // global
           I64[Hp - 80] = sat_s4L5Y_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4M2R::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4M2R::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L5Z_entry() //  [R1]
         { info_tbl: [(c4M2S,
                       label: sat_s4L5Z_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M2S: // global
           _s4L5Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4M2T; else goto c4M2U;
       c4M2U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4M2W; else goto c4M2V;
       c4M2W: // global
           HpAlloc = 24;
           goto c4M2T;
       c4M2T: // global
           R1 = _s4L5Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M2V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L5Z::P64;
           _s4L4d::I64 = I64[_s4L5Z::P64 + 24];
           _s4L5M::I64 = _s4L4d::I64 - I64[_s4L5Z::P64 + 16];
           I64[Hp - 16] = go_dn_s4L5O_info;
           I64[Hp - 8] = _s4L5M::I64;
           I64[Hp] = 2 - _s4L5M::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L5O_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5L_entry() //  [R1]
         { info_tbl: [(c4M36,
                       label: sat_s4L5L_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M36: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M37; else goto c4M3f;
       c4M37: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M3f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M3d; else goto c4M35;
       c4M35: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M3d; else goto c4M3e;
       c4M3d: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M3e: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L63_entry() //  [R1]
         { info_tbl: [(c4M3t,
                       label: sat_s4L63_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M3t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M3u; else goto c4M3C;
       c4M3u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M3C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M3A; else goto c4M3s;
       c4M3s: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M3A; else goto c4M3B;
       c4M3A: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M3B: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6h_entry() //  [R1]
         { info_tbl: [(c4M45,
                       label: sat_s4L6h_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M45: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M46; else goto c4M47;
       c4M46: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M47: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L6a_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6f_entry() //  [R1]
         { info_tbl: [(c4M4h,
                       label: sat_s4L6f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M4h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M4i; else goto c4M4q;
       c4M4i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M4q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6b::I64, 0)) goto c4M4o; else goto c4M4g;
       c4M4g: // global
           if (%MO_S_Gt_W64(_s4L6b::I64, 3)) goto c4M4o; else goto c4M4p;
       c4M4o: // global
           R2 = _s4L6b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M4p: // global
           R1 = I64[(_s4L6b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6k_entry() //  [R1]
         { info_tbl: [(c4M4B,
                       label: sat_s4L6k_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M4B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M4C; else goto c4M4K;
       c4M4C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M4K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6b::I64, 0)) goto c4M4I; else goto c4M4A;
       c4M4A: // global
           if (%MO_S_Gt_W64(_s4L6b::I64, 3)) goto c4M4I; else goto c4M4J;
       c4M4I: // global
           R2 = _s4L6b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M4J: // global
           R1 = I64[(_s4L6b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L6a_entry() //  [R1, R2]
         { info_tbl: [(c4M4O,
                       label: go_up_s4L6a_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M4O: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4M4S; else goto c4M4R;
       c4M4S: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4M4R: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4M4M; else goto c4M4N;
       c4M4M: // global
           _s4L68::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L6h_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L68::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L6f_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4M4N: // global
           I64[Hp - 80] = sat_s4L6k_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4M4U::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4M4U::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L6l_entry() //  [R1]
         { info_tbl: [(c4M4V,
                       label: sat_s4L6l_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M4V: // global
           _s4L6l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4M4W; else goto c4M4X;
       c4M4X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4M4Z; else goto c4M4Y;
       c4M4Z: // global
           HpAlloc = 24;
           goto c4M4W;
       c4M4W: // global
           R1 = _s4L6l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M4Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L6l::P64;
           _s4L4d::I64 = I64[_s4L6l::P64 + 24];
           _s4L68::I64 = _s4L4d::I64 - I64[_s4L6l::P64 + 16];
           I64[Hp - 16] = go_up_s4L6a_info;
           I64[Hp - 8] = _s4L68::I64;
           I64[Hp] = 2 - _s4L68::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L6a_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L67_entry() //  [R1]
         { info_tbl: [(c4M59,
                       label: sat_s4L67_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M59: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M5a; else goto c4M5i;
       c4M5a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M5i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M5g; else goto c4M58;
       c4M58: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M5g; else goto c4M5h;
       c4M5g: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M5h: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6p_entry() //  [R1]
         { info_tbl: [(c4M5w,
                       label: sat_s4L6p_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M5w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M5x; else goto c4M5F;
       c4M5x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M5F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M5D; else goto c4M5v;
       c4M5v: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M5D; else goto c4M5E;
       c4M5D: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M5E: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6E_entry() //  [R1]
         { info_tbl: [(c4M6c,
                       label: sat_s4L6E_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M6c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M6d; else goto c4M6e;
       c4M6d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M6e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L6x_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6C_entry() //  [R1]
         { info_tbl: [(c4M6o,
                       label: sat_s4L6C_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M6o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M6p; else goto c4M6x;
       c4M6p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M6x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6y::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6y::I64, 0)) goto c4M6v; else goto c4M6n;
       c4M6n: // global
           if (%MO_S_Gt_W64(_s4L6y::I64, 3)) goto c4M6v; else goto c4M6w;
       c4M6v: // global
           R2 = _s4L6y::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M6w: // global
           R1 = I64[(_s4L6y::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6H_entry() //  [R1]
         { info_tbl: [(c4M6I,
                       label: sat_s4L6H_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M6I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M6J; else goto c4M6R;
       c4M6J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M6R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6y::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6y::I64, 0)) goto c4M6P; else goto c4M6H;
       c4M6H: // global
           if (%MO_S_Gt_W64(_s4L6y::I64, 3)) goto c4M6P; else goto c4M6Q;
       c4M6P: // global
           R2 = _s4L6y::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M6Q: // global
           R1 = I64[(_s4L6y::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L6x_entry() //  [R1, R2]
         { info_tbl: [(c4M6V,
                       label: go_dn_s4L6x_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M6V: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4M6Z; else goto c4M6Y;
       c4M6Z: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4M6Y: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4M6T; else goto c4M6U;
       c4M6T: // global
           _s4L6v::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L6E_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L6v::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L6C_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4M6U: // global
           I64[Hp - 80] = sat_s4L6H_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4M71::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4M71::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L6I_entry() //  [R1]
         { info_tbl: [(c4M72,
                       label: sat_s4L6I_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M72: // global
           _s4L6I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4M73; else goto c4M74;
       c4M74: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4M76; else goto c4M75;
       c4M76: // global
           HpAlloc = 24;
           goto c4M73;
       c4M73: // global
           R1 = _s4L6I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M75: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L6I::P64;
           _s4L4d::I64 = I64[_s4L6I::P64 + 24];
           _s4L6v::I64 = _s4L4d::I64 - I64[_s4L6I::P64 + 16];
           I64[Hp - 16] = go_dn_s4L6x_info;
           I64[Hp - 8] = _s4L6v::I64;
           I64[Hp] = 3 - _s4L6v::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L6x_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6u_entry() //  [R1]
         { info_tbl: [(c4M7g,
                       label: sat_s4L6u_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M7g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M7h; else goto c4M7p;
       c4M7h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M7p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M7n; else goto c4M7f;
       c4M7f: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M7n; else goto c4M7o;
       c4M7n: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M7o: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6M_entry() //  [R1]
         { info_tbl: [(c4M7D,
                       label: sat_s4L6M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M7E; else goto c4M7M;
       c4M7E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M7M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M7K; else goto c4M7C;
       c4M7C: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M7K; else goto c4M7L;
       c4M7K: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M7L: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L70_entry() //  [R1]
         { info_tbl: [(c4M8f,
                       label: sat_s4L70_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M8f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M8g; else goto c4M8h;
       c4M8g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M8h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L6T_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6Y_entry() //  [R1]
         { info_tbl: [(c4M8r,
                       label: sat_s4L6Y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M8r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M8s; else goto c4M8A;
       c4M8s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M8A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6U::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6U::I64, 0)) goto c4M8y; else goto c4M8q;
       c4M8q: // global
           if (%MO_S_Gt_W64(_s4L6U::I64, 3)) goto c4M8y; else goto c4M8z;
       c4M8y: // global
           R2 = _s4L6U::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M8z: // global
           R1 = I64[(_s4L6U::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L73_entry() //  [R1]
         { info_tbl: [(c4M8L,
                       label: sat_s4L73_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M8L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M8M; else goto c4M8U;
       c4M8M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M8U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6U::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6U::I64, 0)) goto c4M8S; else goto c4M8K;
       c4M8K: // global
           if (%MO_S_Gt_W64(_s4L6U::I64, 3)) goto c4M8S; else goto c4M8T;
       c4M8S: // global
           R2 = _s4L6U::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M8T: // global
           R1 = I64[(_s4L6U::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L6T_entry() //  [R1, R2]
         { info_tbl: [(c4M8Y,
                       label: go_up_s4L6T_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M8Y: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4M92; else goto c4M91;
       c4M92: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4M91: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4M8W; else goto c4M8X;
       c4M8W: // global
           _s4L6R::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L70_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L6R::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L6Y_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4M8X: // global
           I64[Hp - 80] = sat_s4L73_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4M94::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4M94::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L74_entry() //  [R1]
         { info_tbl: [(c4M95,
                       label: sat_s4L74_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M95: // global
           _s4L74::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4M96; else goto c4M97;
       c4M97: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4M99; else goto c4M98;
       c4M99: // global
           HpAlloc = 24;
           goto c4M96;
       c4M96: // global
           R1 = _s4L74::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M98: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L74::P64;
           _s4L4d::I64 = I64[_s4L74::P64 + 24];
           _s4L6R::I64 = _s4L4d::I64 - I64[_s4L74::P64 + 16];
           I64[Hp - 16] = go_up_s4L6T_info;
           I64[Hp - 8] = _s4L6R::I64;
           I64[Hp] = 3 - _s4L6R::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L6T_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6Q_entry() //  [R1]
         { info_tbl: [(c4M9j,
                       label: sat_s4L6Q_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M9j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M9k; else goto c4M9s;
       c4M9k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M9s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M9q; else goto c4M9i;
       c4M9i: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M9q; else goto c4M9r;
       c4M9q: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M9r: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L78_entry() //  [R1]
         { info_tbl: [(c4M9G,
                       label: sat_s4L78_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M9G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4M9H; else goto c4M9P;
       c4M9H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4M9P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4M9N; else goto c4M9F;
       c4M9F: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4M9N; else goto c4M9O;
       c4M9N: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4M9O: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c4M9Z,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M9Z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Ma0; else goto c4Ma1;
       c4Ma0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ma1: // global
           I64[Sp - 24] = block_c4M9Q_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Mce; else goto c4M9R;
       u4Mce: // global
           call _c4M9Q(R1) args: 0, res: 0, upd: 0;
       c4M9R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4M9Q() //  [R1]
         { info_tbl: [(c4M9Q,
                       label: block_c4M9Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4M9Q: // global
           _s4L48::P64 = P64[Sp + 8];
           _c4M9Y::P64 = R1 & 7;
           if (_c4M9Y::P64 < 3) goto u4Mc9; else goto u4Mca;
       u4Mc9: // global
           if (_c4M9Y::P64 < 2) goto c4M9U; else goto c4M9V;
       c4M9U: // global
           _s4L4b::I64 = 0;
           goto s4L4a;
       c4M9V: // global
           _s4L4b::I64 = 1;
           goto s4L4a;
       u4Mca: // global
           if (_c4M9Y::P64 < 4) goto c4M9W; else goto c4M9X;
       c4M9W: // global
           _s4L4b::I64 = 2;
           goto s4L4a;
       c4M9X: // global
           _s4L4b::I64 = 3;
           goto s4L4a;
       s4L4a: // global
           I64[Sp] = block_c4Ma2_info;
           R1 = _s4L48::P64;
           I64[Sp + 8] = _s4L4b::I64;
           if (R1 & 7 != 0) goto u4Mcd; else goto c4MbA;
       u4Mcd: // global
           call _c4Ma2(R1) args: 0, res: 0, upd: 0;
       c4MbA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ma2() //  [R1]
         { info_tbl: [(c4Ma2,
                       label: block_c4Ma2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ma2: // global
           _s4L49::P64 = P64[Sp + 16];
           _c4Mc5::P64 = R1 & 7;
           if (_c4Mc5::P64 < 3) goto u4Mcb; else goto u4Mcc;
       u4Mcb: // global
           if (_c4Mc5::P64 < 2) goto c4MbG; else goto c4MbK;
       c4MbG: // global
           _s4L4d::I64 = 0;
           goto s4L4c;
       c4MbK: // global
           _s4L4d::I64 = 1;
           goto s4L4c;
       u4Mcc: // global
           if (_c4Mc5::P64 < 4) goto c4MbO; else goto c4MbS;
       c4MbO: // global
           _s4L4d::I64 = 2;
           goto s4L4c;
       c4MbS: // global
           _s4L4d::I64 = 3;
           goto s4L4c;
       s4L4c: // global
           I64[Sp] = block_c4LT9_info;
           R1 = _s4L49::P64;
           I64[Sp + 16] = _s4L4d::I64;
           if (R1 & 7 != 0) goto u4Mcf; else goto c4LTa;
       u4Mcf: // global
           call _c4LT9(R1) args: 0, res: 0, upd: 0;
       c4LTa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4LT9() //  [R1]
         { info_tbl: [(c4LT9,
                       label: block_c4LT9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4LT9: // global
           _s4L4b::I64 = I64[Sp + 8];
           _s4L4d::I64 = I64[Sp + 16];
           _c4Mc6::P64 = R1 & 7;
           if (_c4Mc6::P64 < 3) goto u4Mc7; else goto u4Mc8;
       u4Mc7: // global
           if (_c4Mc6::P64 < 2) goto c4Ma6; else goto c4Mat;
       c4Ma6: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Mbg; else goto c4Ma8;
       c4Ma8: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4Maj; else goto c4Mas;
       c4Maj: // global
           if (%MO_S_Le_W64(0, _s4L4d::I64)) goto c4Mac; else goto c4Mah;
       c4Mac: // global
           I64[Hp - 72] = sat_s4L4x_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L4j_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mah: // global
           if (%MO_S_Gt_W64(0, _s4L4b::I64)) goto c4Mbx; else goto c4Maf;
       c4Maf: // global
           I64[Hp - 72] = sat_s4L4B_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Mad::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Mad::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mas: // global
           if (%MO_S_Ge_W64(0, _s4L4d::I64)) goto c4Mam; else goto c4Mar;
       c4Mam: // global
           I64[Hp - 72] = sat_s4L4T_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L4F_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mar: // global
           if (%MO_S_Lt_W64(0, _s4L4b::I64)) goto c4Mbx; else goto c4Map;
       c4Map: // global
           I64[Hp - 72] = sat_s4L4X_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Man::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Man::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mat: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Mbg; else goto c4Mav;
       c4Mav: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4MaG; else goto c4MaP;
       c4MaG: // global
           if (%MO_S_Le_W64(1, _s4L4d::I64)) goto c4Maz; else goto c4MaE;
       c4Maz: // global
           I64[Hp - 72] = sat_s4L5g_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L52_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MaE: // global
           if (%MO_S_Gt_W64(1, _s4L4b::I64)) goto c4Mbx; else goto c4MaC;
       c4MaC: // global
           I64[Hp - 72] = sat_s4L5k_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4MaA::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4MaA::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MaP: // global
           if (%MO_S_Ge_W64(1, _s4L4d::I64)) goto c4MaJ; else goto c4MaO;
       c4MaJ: // global
           I64[Hp - 72] = sat_s4L5C_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L5o_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MaO: // global
           if (%MO_S_Lt_W64(1, _s4L4b::I64)) goto c4Mbx; else goto c4MaM;
       c4MaM: // global
           I64[Hp - 72] = sat_s4L5G_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4MaK::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4MaK::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Mc8: // global
           if (_c4Mc6::P64 < 4) goto c4MaQ; else goto c4Mbd;
       c4MaQ: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Mbg; else goto c4MaS;
       c4MaS: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4Mb3; else goto c4Mbc;
       c4Mb3: // global
           if (%MO_S_Le_W64(2, _s4L4d::I64)) goto c4MaW; else goto c4Mb1;
       c4MaW: // global
           I64[Hp - 72] = sat_s4L5Z_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L5L_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mb1: // global
           if (%MO_S_Gt_W64(2, _s4L4b::I64)) goto c4Mbx; else goto c4MaZ;
       c4MaZ: // global
           I64[Hp - 72] = sat_s4L63_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4MaX::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4MaX::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mbc: // global
           if (%MO_S_Ge_W64(2, _s4L4d::I64)) goto c4Mb6; else goto c4Mbb;
       c4Mb6: // global
           I64[Hp - 72] = sat_s4L6l_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L67_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mbb: // global
           if (%MO_S_Lt_W64(2, _s4L4b::I64)) goto c4Mbx; else goto c4Mb9;
       c4Mb9: // global
           I64[Hp - 72] = sat_s4L6p_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Mb7::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Mb7::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mbd: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Mbg; else goto c4Mbf;
       c4Mbg: // global
           HpAlloc = 80;
           R1 = _s4L4e::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Mbf: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4Mbq; else goto c4Mbz;
       c4Mbq: // global
           if (%MO_S_Le_W64(3, _s4L4d::I64)) goto c4Mbj; else goto c4Mbo;
       c4Mbj: // global
           I64[Hp - 72] = sat_s4L6I_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L6u_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mbo: // global
           if (%MO_S_Gt_W64(3, _s4L4b::I64)) goto c4Mbx; else goto c4Mbm;
       c4Mbm: // global
           I64[Hp - 72] = sat_s4L6M_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Mbk::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Mbk::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mbz: // global
           if (%MO_S_Ge_W64(3, _s4L4d::I64)) goto c4Mbt; else goto c4Mby;
       c4Mbt: // global
           I64[Hp - 72] = sat_s4L74_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L6Q_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mby: // global
           if (%MO_S_Lt_W64(3, _s4L4b::I64)) goto c4Mbx; else goto c4Mbw;
       c4Mbx: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mbw: // global
           I64[Hp - 72] = sat_s4L78_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Mbu::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Mbu::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.083904914 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_closure" {
     GHC.IO.IOMode.$fEnumIOMode_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure+2;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure+2;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.08458675 UTC

[section ""data" . GHC.IO.IOMode.$trModule3_closure" {
     GHC.IO.IOMode.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.085157028 UTC

[section ""data" . GHC.IO.IOMode.$trModule1_closure" {
     GHC.IO.IOMode.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.085854292 UTC

[section ""data" . GHC.IO.IOMode.$trModule_closure" {
     GHC.IO.IOMode.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.IOMode.$trModule3_closure+1;
         const GHC.IO.IOMode.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.086455566 UTC

[section ""cstring" . GHC.IO.IOMode.$tcIOMode2_bytes" {
     GHC.IO.IOMode.$tcIOMode2_bytes:
         I8[] [73,79,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.087012622 UTC

[section ""data" . GHC.IO.IOMode.$tcIOMode1_closure" {
     GHC.IO.IOMode.$tcIOMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tcIOMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.087609429 UTC

[section ""data" . GHC.IO.IOMode.$tcIOMode_closure" {
     GHC.IO.IOMode.$tcIOMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tcIOMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9818555080744742578;
         const 14348064797489060312;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.088249458 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode1_closure" {
     GHC.IO.IOMode.$tc'AppendMode1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.IOMode.$tcIOMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.088841071 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'ReadMode2_bytes" {
     GHC.IO.IOMode.$tc'ReadMode2_bytes:
         I8[] [39,82,101,97,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.089556282 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadMode1_closure" {
     GHC.IO.IOMode.$tc'ReadMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'ReadMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.090146663 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadMode_closure" {
     GHC.IO.IOMode.$tc'ReadMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'ReadMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 17697021977009842408;
         const 16081808542294250782;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.090772509 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'WriteMode2_bytes" {
     GHC.IO.IOMode.$tc'WriteMode2_bytes:
         I8[] [39,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.091403982 UTC

[section ""data" . GHC.IO.IOMode.$tc'WriteMode1_closure" {
     GHC.IO.IOMode.$tc'WriteMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'WriteMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.091990719 UTC

[section ""data" . GHC.IO.IOMode.$tc'WriteMode_closure" {
     GHC.IO.IOMode.$tc'WriteMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'WriteMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 16610458722029011495;
         const 11554819901902375488;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.092642844 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'AppendMode3_bytes" {
     GHC.IO.IOMode.$tc'AppendMode3_bytes:
         I8[] [39,65,112,112,101,110,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.093207344 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode2_closure" {
     GHC.IO.IOMode.$tc'AppendMode2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'AppendMode3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.093849392 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode_closure" {
     GHC.IO.IOMode.$tc'AppendMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode2_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 3610623883618650464;
         const 11131639874085434472;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.09447327 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'ReadWriteMode2_bytes" {
     GHC.IO.IOMode.$tc'ReadWriteMode2_bytes:
         I8[] [39,82,101,97,100,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.095049973 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadWriteMode1_closure" {
     GHC.IO.IOMode.$tc'ReadWriteMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'ReadWriteMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.095644805 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadWriteMode_closure" {
     GHC.IO.IOMode.$tc'ReadWriteMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'ReadWriteMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 626157189396725199;
         const 9407417215311302278;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.096251908 UTC

[section ""data" . GHC.IO.IOMode.ReadMode_closure" {
     GHC.IO.IOMode.ReadMode_closure:
         const GHC.IO.IOMode.ReadMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.096844553 UTC

[section ""data" . GHC.IO.IOMode.WriteMode_closure" {
     GHC.IO.IOMode.WriteMode_closure:
         const GHC.IO.IOMode.WriteMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.097478231 UTC

[section ""data" . GHC.IO.IOMode.AppendMode_closure" {
     GHC.IO.IOMode.AppendMode_closure:
         const GHC.IO.IOMode.AppendMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.098056312 UTC

[section ""data" . GHC.IO.IOMode.ReadWriteMode_closure" {
     GHC.IO.IOMode.ReadWriteMode_closure:
         const GHC.IO.IOMode.ReadWriteMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.098644771 UTC

[section ""relreadonly" . GHC.IO.IOMode.IOMode_closure_tbl" {
     GHC.IO.IOMode.IOMode_closure_tbl:
         const GHC.IO.IOMode.ReadMode_closure+1;
         const GHC.IO.IOMode.WriteMode_closure+2;
         const GHC.IO.IOMode.AppendMode_closure+3;
         const GHC.IO.IOMode.ReadWriteMode_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.099402564 UTC

[GHC.IO.IOMode.ReadMode_con_entry() //  [R1]
         { info_tbl: [(c4Mcg,
                       label: GHC.IO.IOMode.ReadMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,82,101,97,100,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mcg: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.100217286 UTC

[GHC.IO.IOMode.WriteMode_con_entry() //  [R1]
         { info_tbl: [(c4Mch,
                       label: GHC.IO.IOMode.WriteMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,87,114,105,116,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mch: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.100982064 UTC

[GHC.IO.IOMode.AppendMode_con_entry() //  [R1]
         { info_tbl: [(c4Mci,
                       label: GHC.IO.IOMode.AppendMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,65,112,112,101,110,100,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mci: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.101829778 UTC

[GHC.IO.IOMode.ReadWriteMode_con_entry() //  [R1]
         { info_tbl: [(c4Mcj,
                       label: GHC.IO.IOMode.ReadWriteMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,82,101,97,100,87,114,105,116,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mcj: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.102525349 UTC

[section ""relreadonly" . S4L8g_srt" {
     S4L8g_srt:
         const GHC.IO.IOMode.$fReadIOMode8_closure;
         const GHC.IO.IOMode.$fReadIOMode12_closure;
         const GHC.IO.IOMode.$fReadIOMode16_closure;
         const GHC.IO.IOMode.$fReadIOMode20_closure;
         const GHC.IO.IOMode.$w$cshowsPrec_closure;
         const GHC.IO.IOMode.$fShowIOMode_$cshow_closure;
         const GHC.Read.choose2_closure;
         const GHC.IO.IOMode.$fReadIOMode_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.IOMode.$fReadIOMode2_closure;
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.IOMode.$fReadIOMode1_closure;
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
         const GHC.IO.IOMode.$fReadIOMode22_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.IO.IOMode.$fIxIOMode_$cindex_closure;
         const GHC.Err.error_closure;
         const lvl13_r4KYY_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_closure;
         const GHC.IO.IOMode.$fEnumIOMode5_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_closure;
         const GHC.IO.IOMode.$fEnumIOMode6_closure;
         const lvl18_r4KZ3_closure;
         const lvl19_r4KZ4_closure;
         const lvl20_r4KZ5_closure;
         const GHC.IO.IOMode.$wlvl_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure;
         const GHC.IO.IOMode.$w$ctoEnum_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure;
         const GHC.IO.IOMode.$fEnumIOMode1_closure;
         const GHC.IO.IOMode.$fEnumIOMode2_closure;
         const GHC.IO.IOMode.$fEnumIOMode3_closure;
         const GHC.IO.IOMode.$fEnumIOMode4_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go3_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go2_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go1_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.103354253 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:39.103893628 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode21_bytes" {
     GHC.IO.IOMode.$fReadIOMode21_bytes:
         I8[] [82,101,97,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.104792335 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode20_closure" {
     GHC.IO.IOMode.$fReadIOMode20_closure:
         const GHC.IO.IOMode.$fReadIOMode20_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode20_entry() //  [R1]
         { info_tbl: [(c4Mcq,
                       label: GHC.IO.IOMode.$fReadIOMode20_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mcq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mcr; else goto c4Mcs;
       c4Mcr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Mcs: // global
           (_c4Mcn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Mcn::I64 == 0) goto c4Mcp; else goto c4Mco;
       c4Mcp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Mco: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Mcn::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode21_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.105903288 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode17_bytes" {
     GHC.IO.IOMode.$fReadIOMode17_bytes:
         I8[] [87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.106681675 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode16_closure" {
     GHC.IO.IOMode.$fReadIOMode16_closure:
         const GHC.IO.IOMode.$fReadIOMode16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode16_entry() //  [R1]
         { info_tbl: [(c4Mcz,
                       label: GHC.IO.IOMode.$fReadIOMode16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mcz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4McA; else goto c4McB;
       c4McA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4McB: // global
           (_c4Mcw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Mcw::I64 == 0) goto c4Mcy; else goto c4Mcx;
       c4Mcy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Mcx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Mcw::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.10897033 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode13_bytes" {
     GHC.IO.IOMode.$fReadIOMode13_bytes:
         I8[] [65,112,112,101,110,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.109905053 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode12_closure" {
     GHC.IO.IOMode.$fReadIOMode12_closure:
         const GHC.IO.IOMode.$fReadIOMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode12_entry() //  [R1]
         { info_tbl: [(c4McI,
                       label: GHC.IO.IOMode.$fReadIOMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4McI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4McJ; else goto c4McK;
       c4McJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4McK: // global
           (_c4McF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4McF::I64 == 0) goto c4McH; else goto c4McG;
       c4McH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4McG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4McF::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.110838661 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode9_bytes" {
     GHC.IO.IOMode.$fReadIOMode9_bytes:
         I8[] [82,101,97,100,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.111564508 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode8_closure" {
     GHC.IO.IOMode.$fReadIOMode8_closure:
         const GHC.IO.IOMode.$fReadIOMode8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode8_entry() //  [R1]
         { info_tbl: [(c4McR,
                       label: GHC.IO.IOMode.$fReadIOMode8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4McR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4McS; else goto c4McT;
       c4McS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4McT: // global
           (_c4McO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4McO::I64 == 0) goto c4McQ; else goto c4McP;
       c4McQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4McP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4McO::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.112937072 UTC

[section ""data" . GHC.IO.IOMode.$w$cshowsPrec_closure" {
     GHC.IO.IOMode.$w$cshowsPrec_closure:
         const GHC.IO.IOMode.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.IOMode.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4Md7,
                       label: GHC.IO.IOMode.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Md7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Md8; else goto c4Md9;
       c4Md8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Md9: // global
           I64[Sp - 16] = block_c4McY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Mdo; else goto c4McZ;
       u4Mdo: // global
           call _c4McY(R1) args: 0, res: 0, upd: 0;
       c4McZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4McY() //  [R1]
         { info_tbl: [(c4McY,
                       label: block_c4McY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4McY: // global
           _s4KZ9::P64 = P64[Sp + 8];
           _c4Md6::P64 = R1 & 7;
           if (_c4Md6::P64 < 3) goto u4Mdm; else goto u4Mdn;
       u4Mdm: // global
           if (_c4Md6::P64 < 2) goto c4Md2; else goto c4Md3;
       c4Md2: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode20_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c4Md3: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode16_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4Mdn: // global
           if (_c4Md6::P64 < 4) goto c4Md4; else goto c4Md5;
       c4Md4: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode12_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c4Md5: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode8_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.114482018 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c4Mdt,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mdt: // global
           _s4KZc::P64 = R3;
           R3 = R4;
           R2 = _s4KZc::P64;
           call GHC.IO.IOMode.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.115556678 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshow_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshow_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshow_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshow_entry() //  [R2]
         { info_tbl: [(c4MdJ,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MdJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MdK; else goto c4MdL;
       c4MdK: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fShowIOMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MdL: // global
           I64[Sp - 8] = block_c4MdA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Me0; else goto c4MdB;
       u4Me0: // global
           call _c4MdA(R1) args: 0, res: 0, upd: 0;
       c4MdB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MdA() //  [R1]
         { info_tbl: [(c4MdA,
                       label: block_c4MdA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MdA: // global
           _c4MdI::P64 = R1 & 7;
           if (_c4MdI::P64 < 3) goto u4MdY; else goto u4MdZ;
       u4MdY: // global
           if (_c4MdI::P64 < 2) goto c4MdE; else goto c4MdF;
       c4MdE: // global
           R1 = GHC.IO.IOMode.$fReadIOMode20_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4MdF: // global
           R1 = GHC.IO.IOMode.$fReadIOMode16_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u4MdZ: // global
           if (_c4MdI::P64 < 4) goto c4MdG; else goto c4MdH;
       c4MdG: // global
           R1 = GHC.IO.IOMode.$fReadIOMode12_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4MdH: // global
           R1 = GHC.IO.IOMode.$fReadIOMode8_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.116896936 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshowList_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshowList_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshowList_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4Me5,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Me5: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.IOMode.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.117729127 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_closure" {
     GHC.IO.IOMode.$fShowIOMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure+3;
         const GHC.IO.IOMode.$fShowIOMode_$cshow_closure+1;
         const GHC.IO.IOMode.$fShowIOMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.118470424 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode19_closure" {
     GHC.IO.IOMode.$fReadIOMode19_closure:
         const GHC.IO.IOMode.$fReadIOMode19_info;
 },
 GHC.IO.IOMode.$fReadIOMode19_entry() //  [R3]
         { info_tbl: [(c4Mec,
                       label: GHC.IO.IOMode.$fReadIOMode19_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mec: // global
           R2 = GHC.IO.IOMode.ReadMode_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.119267914 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode18_closure" {
     GHC.IO.IOMode.$fReadIOMode18_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode20_closure;
         const GHC.IO.IOMode.$fReadIOMode19_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.11999297 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode15_closure" {
     GHC.IO.IOMode.$fReadIOMode15_closure:
         const GHC.IO.IOMode.$fReadIOMode15_info;
 },
 GHC.IO.IOMode.$fReadIOMode15_entry() //  [R3]
         { info_tbl: [(c4Mej,
                       label: GHC.IO.IOMode.$fReadIOMode15_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mej: // global
           R2 = GHC.IO.IOMode.WriteMode_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.120724082 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode14_closure" {
     GHC.IO.IOMode.$fReadIOMode14_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode16_closure;
         const GHC.IO.IOMode.$fReadIOMode15_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.121545407 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode11_closure" {
     GHC.IO.IOMode.$fReadIOMode11_closure:
         const GHC.IO.IOMode.$fReadIOMode11_info;
 },
 GHC.IO.IOMode.$fReadIOMode11_entry() //  [R3]
         { info_tbl: [(c4Meq,
                       label: GHC.IO.IOMode.$fReadIOMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Meq: // global
           R2 = GHC.IO.IOMode.AppendMode_closure+3;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.122262762 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode10_closure" {
     GHC.IO.IOMode.$fReadIOMode10_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode12_closure;
         const GHC.IO.IOMode.$fReadIOMode11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.122948875 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode7_closure" {
     GHC.IO.IOMode.$fReadIOMode7_closure:
         const GHC.IO.IOMode.$fReadIOMode7_info;
 },
 GHC.IO.IOMode.$fReadIOMode7_entry() //  [R3]
         { info_tbl: [(c4Mex,
                       label: GHC.IO.IOMode.$fReadIOMode7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mex: // global
           R2 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.123623627 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode6_closure" {
     GHC.IO.IOMode.$fReadIOMode6_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode8_closure;
         const GHC.IO.IOMode.$fReadIOMode7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.124213516 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode5_closure" {
     GHC.IO.IOMode.$fReadIOMode5_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.124797251 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode4_closure" {
     GHC.IO.IOMode.$fReadIOMode4_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode10_closure+1;
         const GHC.IO.IOMode.$fReadIOMode5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.12542066 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode3_closure" {
     GHC.IO.IOMode.$fReadIOMode3_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode14_closure+1;
         const GHC.IO.IOMode.$fReadIOMode4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.125986027 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_sps_closure" {
     GHC.IO.IOMode.$fReadIOMode_sps_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode18_closure+1;
         const GHC.IO.IOMode.$fReadIOMode3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.126810268 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode2_closure" {
     GHC.IO.IOMode.$fReadIOMode2_closure:
         const GHC.IO.IOMode.$fReadIOMode2_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode2_entry() //  [R2]
         { info_tbl: [(c4MeE,
                       label: GHC.IO.IOMode.$fReadIOMode2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MeE: // global
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.127738884 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode1_closure" {
     GHC.IO.IOMode.$fReadIOMode1_closure:
         const GHC.IO.IOMode.$fReadIOMode1_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode1_entry() //  [R2, R3]
         { info_tbl: [(c4MeL,
                       label: GHC.IO.IOMode.$fReadIOMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MeL: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.12886299 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_info;
         const 0;
 },
 sat_s4KZs_entry() //  [R1]
         { info_tbl: [(c4MeW,
                       label: sat_s4KZs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MeW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MeX; else goto c4MeY;
       c4MeX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MeY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.IOMode.$fReadIOMode2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fReadIOMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c4MeZ,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MeZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Mf3; else goto c4Mf2;
       c4Mf3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Mf2: // global
           I64[Hp - 16] = sat_s4KZs_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.130228529 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c4Mfa,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mfa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mfb; else goto c4Mfc;
       c4Mfb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Mfc: // global
           (_c4Mf7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Mf7::I64 == 0) goto c4Mf9; else goto c4Mf8;
       c4Mf9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Mf8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Mf7::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.131271073 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode22_closure" {
     GHC.IO.IOMode.$fReadIOMode22_closure:
         const GHC.IO.IOMode.$fReadIOMode22_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode22_entry() //  [R1]
         { info_tbl: [(c4Mfj,
                       label: GHC.IO.IOMode.$fReadIOMode22_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mfj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mfk; else goto c4Mfl;
       c4Mfk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Mfl: // global
           (_c4Mfg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Mfg::I64 == 0) goto c4Mfi; else goto c4Mfh;
       c4Mfi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Mfh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Mfg::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.132356867 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadList_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadList_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadList_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode_$creadList_entry() //  [R2]
         { info_tbl: [(c4Mfq,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mfq: // global
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode22_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.133098391 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_closure" {
     GHC.IO.IOMode.$fReadIOMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure+1;
         const GHC.IO.IOMode.$fReadIOMode_$creadList_closure+1;
         const GHC.IO.IOMode.$fReadIOMode1_closure+2;
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.134628433 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_$c==_closure" {
     GHC.IO.IOMode.$fEqIOMode_$c==_closure:
         const GHC.IO.IOMode.$fEqIOMode_$c==_info;
 },
 GHC.IO.IOMode.$fEqIOMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c4MfG,
                       label: GHC.IO.IOMode.$fEqIOMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MfG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MfH; else goto c4MfI;
       c4MfH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEqIOMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MfI: // global
           I64[Sp - 16] = block_c4Mfx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MgZ; else goto c4Mfy;
       u4MgZ: // global
           call _c4Mfx(R1) args: 0, res: 0, upd: 0;
       c4Mfy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mfx() //  [R1]
         { info_tbl: [(c4Mfx,
                       label: block_c4Mfx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mfx: // global
           _s4KZu::P64 = P64[Sp + 8];
           _c4MfF::P64 = R1 & 7;
           if (_c4MfF::P64 < 3) goto u4MgL; else goto u4MgM;
       u4MgL: // global
           if (_c4MfF::P64 < 2) goto c4MfB; else goto c4MfC;
       c4MfB: // global
           I64[Sp + 8] = block_c4MfL_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MgV; else goto c4MfN;
       u4MgV: // global
           call _c4MfL(R1) args: 0, res: 0, upd: 0;
       c4MfN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MfC: // global
           I64[Sp + 8] = block_c4Mg0_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MgW; else goto c4Mg2;
       u4MgW: // global
           call _c4Mg0(R1) args: 0, res: 0, upd: 0;
       c4Mg2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4MgM: // global
           if (_c4MfF::P64 < 4) goto c4MfD; else goto c4MfE;
       c4MfD: // global
           I64[Sp + 8] = block_c4Mgf_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MgX; else goto c4Mgh;
       u4MgX: // global
           call _c4Mgf(R1) args: 0, res: 0, upd: 0;
       c4Mgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MfE: // global
           I64[Sp + 8] = block_c4Mgu_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MgY; else goto c4Mgw;
       u4MgY: // global
           call _c4Mgu(R1) args: 0, res: 0, upd: 0;
       c4Mgw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MfL() //  [R1]
         { info_tbl: [(c4MfL,
                       label: block_c4MfL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MfL: // global
           if (R1 & 7 == 1) goto u4MgN; else goto u4MgO;
       u4MgN: // global
           Sp = Sp + 8;
           call _c4MgG() args: 0, res: 0, upd: 0;
       u4MgO: // global
           Sp = Sp + 8;
           call _c4MgC() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mg0() //  [R1]
         { info_tbl: [(c4Mg0,
                       label: block_c4Mg0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mg0: // global
           if (R1 & 7 == 2) goto u4MgP; else goto u4MgQ;
       u4MgP: // global
           Sp = Sp + 8;
           call _c4MgG() args: 0, res: 0, upd: 0;
       u4MgQ: // global
           Sp = Sp + 8;
           call _c4MgC() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mgf() //  [R1]
         { info_tbl: [(c4Mgf,
                       label: block_c4Mgf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mgf: // global
           if (R1 & 7 == 3) goto u4MgR; else goto u4MgS;
       u4MgR: // global
           Sp = Sp + 8;
           call _c4MgG() args: 0, res: 0, upd: 0;
       u4MgS: // global
           Sp = Sp + 8;
           call _c4MgC() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mgu() //  [R1]
         { info_tbl: [(c4Mgu,
                       label: block_c4Mgu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mgu: // global
           if (R1 & 7 == 4) goto u4MgT; else goto u4MgU;
       u4MgT: // global
           Sp = Sp + 8;
           call _c4MgG() args: 0, res: 0, upd: 0;
       u4MgU: // global
           Sp = Sp + 8;
           call _c4MgC() args: 0, res: 0, upd: 0;
     }
 },
 _c4MgG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MgG: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MgC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MgC: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.137726381 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_$c/=_closure" {
     GHC.IO.IOMode.$fEqIOMode_$c/=_closure:
         const GHC.IO.IOMode.$fEqIOMode_$c/=_info;
 },
 GHC.IO.IOMode.$fEqIOMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c4Mhl,
                       label: GHC.IO.IOMode.$fEqIOMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mhl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mhm; else goto c4Mhn;
       c4Mhm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEqIOMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Mhn: // global
           I64[Sp - 16] = block_c4Mhc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MiE; else goto c4Mhd;
       u4MiE: // global
           call _c4Mhc(R1) args: 0, res: 0, upd: 0;
       c4Mhd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mhc() //  [R1]
         { info_tbl: [(c4Mhc,
                       label: block_c4Mhc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mhc: // global
           _s4KZB::P64 = P64[Sp + 8];
           _c4Mhk::P64 = R1 & 7;
           if (_c4Mhk::P64 < 3) goto u4Miq; else goto u4Mir;
       u4Miq: // global
           if (_c4Mhk::P64 < 2) goto c4Mhg; else goto c4Mhh;
       c4Mhg: // global
           I64[Sp + 8] = block_c4Mhq_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MiA; else goto c4Mhs;
       u4MiA: // global
           call _c4Mhq(R1) args: 0, res: 0, upd: 0;
       c4Mhs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Mhh: // global
           I64[Sp + 8] = block_c4MhF_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MiB; else goto c4MhH;
       u4MiB: // global
           call _c4MhF(R1) args: 0, res: 0, upd: 0;
       c4MhH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Mir: // global
           if (_c4Mhk::P64 < 4) goto c4Mhi; else goto c4Mhj;
       c4Mhi: // global
           I64[Sp + 8] = block_c4MhU_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MiC; else goto c4MhW;
       u4MiC: // global
           call _c4MhU(R1) args: 0, res: 0, upd: 0;
       c4MhW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Mhj: // global
           I64[Sp + 8] = block_c4Mi9_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MiD; else goto c4Mib;
       u4MiD: // global
           call _c4Mi9(R1) args: 0, res: 0, upd: 0;
       c4Mib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mhq() //  [R1]
         { info_tbl: [(c4Mhq,
                       label: block_c4Mhq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mhq: // global
           if (R1 & 7 == 1) goto u4Mis; else goto u4Mit;
       u4Mis: // global
           Sp = Sp + 8;
           call _c4Mil() args: 0, res: 0, upd: 0;
       u4Mit: // global
           Sp = Sp + 8;
           call _c4Mih() args: 0, res: 0, upd: 0;
     }
 },
 _c4MhF() //  [R1]
         { info_tbl: [(c4MhF,
                       label: block_c4MhF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MhF: // global
           if (R1 & 7 == 2) goto u4Miu; else goto u4Miv;
       u4Miu: // global
           Sp = Sp + 8;
           call _c4Mil() args: 0, res: 0, upd: 0;
       u4Miv: // global
           Sp = Sp + 8;
           call _c4Mih() args: 0, res: 0, upd: 0;
     }
 },
 _c4MhU() //  [R1]
         { info_tbl: [(c4MhU,
                       label: block_c4MhU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MhU: // global
           if (R1 & 7 == 3) goto u4Miw; else goto u4Mix;
       u4Miw: // global
           Sp = Sp + 8;
           call _c4Mil() args: 0, res: 0, upd: 0;
       u4Mix: // global
           Sp = Sp + 8;
           call _c4Mih() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mi9() //  [R1]
         { info_tbl: [(c4Mi9,
                       label: block_c4Mi9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mi9: // global
           if (R1 & 7 == 4) goto u4Miy; else goto u4Miz;
       u4Miy: // global
           Sp = Sp + 8;
           call _c4Mil() args: 0, res: 0, upd: 0;
       u4Miz: // global
           Sp = Sp + 8;
           call _c4Mih() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mil() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mil: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mih() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mih: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.139973817 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_closure" {
     GHC.IO.IOMode.$fEqIOMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.IOMode.$fEqIOMode_$c==_closure+2;
         const GHC.IO.IOMode.$fEqIOMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.141742511 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$ccompare_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4Mj0,
                       label: GHC.IO.IOMode.$fOrdIOMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mj0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mj1; else goto c4Mj2;
       c4Mj1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Mj2: // global
           I64[Sp - 16] = block_c4MiR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MkL; else goto c4MiS;
       u4MkL: // global
           call _c4MiR(R1) args: 0, res: 0, upd: 0;
       c4MiS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MiR() //  [R1]
         { info_tbl: [(c4MiR,
                       label: block_c4MiR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MiR: // global
           _s4KZI::P64 = P64[Sp + 8];
           _c4MiZ::P64 = R1 & 7;
           if (_c4MiZ::P64 < 3) goto u4Mkp; else goto u4Mkq;
       u4Mkp: // global
           if (_c4MiZ::P64 < 2) goto c4MiV; else goto c4MiW;
       c4MiV: // global
           I64[Sp + 8] = block_c4Mj5_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MkH; else goto c4Mj7;
       u4MkH: // global
           call _c4Mj5(R1) args: 0, res: 0, upd: 0;
       c4Mj7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MiW: // global
           I64[Sp + 8] = block_c4Mjs_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MkI; else goto c4Mju;
       u4MkI: // global
           call _c4Mjs(R1) args: 0, res: 0, upd: 0;
       c4Mju: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Mkq: // global
           if (_c4MiZ::P64 < 4) goto c4MiX; else goto c4MiY;
       c4MiX: // global
           I64[Sp + 8] = block_c4MjP_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MkJ; else goto c4MjR;
       u4MkJ: // global
           call _c4MjP(R1) args: 0, res: 0, upd: 0;
       c4MjR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MiY: // global
           I64[Sp + 8] = block_c4Mk8_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MkK; else goto c4Mka;
       u4MkK: // global
           call _c4Mk8(R1) args: 0, res: 0, upd: 0;
       c4Mka: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mj5() //  [R1]
         { info_tbl: [(c4Mj5,
                       label: block_c4Mj5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mj5: // global
           _c4Mko::P64 = R1 & 7;
           if (_c4Mko::P64 < 2) goto u4Mkv; else goto u4Mkr;
       u4Mkv: // global
           Sp = Sp + 8;
           call _c4Mkk() args: 0, res: 0, upd: 0;
       u4Mkr: // global
           if (_c4Mko::P64 != 3) goto u4Mkx; else goto u4Mkx;
       u4Mkx: // global
           Sp = Sp + 8;
           call _c4Mk5() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mjs() //  [R1]
         { info_tbl: [(c4Mjs,
                       label: block_c4Mjs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mjs: // global
           _c4Mkn::P64 = R1 & 7;
           if (_c4Mkn::P64 < 3) goto u4Mks; else goto u4Mkt;
       u4Mks: // global
           if (_c4Mkn::P64 < 2) goto u4Mkz; else goto u4Mky;
       u4Mkz: // global
           Sp = Sp + 8;
           call _c4Mkg() args: 0, res: 0, upd: 0;
       u4Mky: // global
           Sp = Sp + 8;
           call _c4Mkk() args: 0, res: 0, upd: 0;
       u4Mkt: // global
           if (_c4Mkn::P64 < 4) goto u4MkB; else goto u4MkB;
       u4MkB: // global
           Sp = Sp + 8;
           call _c4Mk5() args: 0, res: 0, upd: 0;
     }
 },
 _c4MjP() //  [R1]
         { info_tbl: [(c4MjP,
                       label: block_c4MjP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MjP: // global
           _c4Mkm::P64 = R1 & 7;
           if (_c4Mkm::P64 != 3) goto u4Mku; else goto u4MkC;
       u4Mku: // global
           if (_c4Mkm::P64 != 4) goto u4MkE; else goto u4MkD;
       u4MkE: // global
           Sp = Sp + 8;
           call _c4Mkg() args: 0, res: 0, upd: 0;
       u4MkD: // global
           Sp = Sp + 8;
           call _c4Mk5() args: 0, res: 0, upd: 0;
       u4MkC: // global
           Sp = Sp + 8;
           call _c4Mkk() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mk5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mk5: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mk8() //  [R1]
         { info_tbl: [(c4Mk8,
                       label: block_c4Mk8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mk8: // global
           if (R1 & 7 == 4) goto u4MkF; else goto u4MkG;
       u4MkF: // global
           Sp = Sp + 8;
           call _c4Mkk() args: 0, res: 0, upd: 0;
       u4MkG: // global
           Sp = Sp + 8;
           call _c4Mkg() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mkk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mkk: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mkg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mkg: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.145328105 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c<_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c<_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c<_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c4Ml9,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ml9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mla; else goto c4Mlb;
       c4Mla: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Mlb: // global
           I64[Sp - 16] = block_c4Ml0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Mmz; else goto c4Ml1;
       u4Mmz: // global
           call _c4Ml0(R1) args: 0, res: 0, upd: 0;
       c4Ml1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ml0() //  [R1]
         { info_tbl: [(c4Ml0,
                       label: block_c4Ml0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ml0: // global
           _s4KZP::P64 = P64[Sp + 8];
           _c4Ml8::P64 = R1 & 7;
           if (_c4Ml8::P64 < 3) goto u4Mmj; else goto u4Mmk;
       u4Mmj: // global
           if (_c4Ml8::P64 < 2) goto c4Ml4; else goto c4Ml5;
       c4Ml4: // global
           I64[Sp + 8] = block_c4Mle_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Mmv; else goto c4Mlg;
       u4Mmv: // global
           call _c4Mle(R1) args: 0, res: 0, upd: 0;
       c4Mlg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Ml5: // global
           I64[Sp + 8] = block_c4MlB_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Mmw; else goto c4MlD;
       u4Mmw: // global
           call _c4MlB(R1) args: 0, res: 0, upd: 0;
       c4MlD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Mmk: // global
           if (_c4Ml8::P64 < 4) goto c4Ml6; else goto c4Ml7;
       c4Ml6: // global
           I64[Sp + 8] = block_c4MlU_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Mmx; else goto c4MlW;
       u4Mmx: // global
           call _c4MlU(R1) args: 0, res: 0, upd: 0;
       c4MlW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Ml7: // global
           I64[Sp + 8] = block_c4Mm9_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Mmy; else goto c4Mmb;
       u4Mmy: // global
           call _c4Mm9() args: 0, res: 0, upd: 0;
       c4Mmb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mle() //  [R1]
         { info_tbl: [(c4Mle,
                       label: block_c4Mle_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mle: // global
           _c4Mmi::P64 = R1 & 7;
           if (_c4Mmi::P64 < 2) goto u4Mmn; else goto u4Mml;
       u4Mmn: // global
           Sp = Sp + 8;
           call _c4Mm2() args: 0, res: 0, upd: 0;
       u4Mml: // global
           if (_c4Mmi::P64 != 3) goto u4Mmp; else goto u4Mmp;
       u4Mmp: // global
           Sp = Sp + 8;
           call _c4Mm6() args: 0, res: 0, upd: 0;
     }
 },
 _c4MlB() //  [R1]
         { info_tbl: [(c4MlB,
                       label: block_c4MlB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MlB: // global
           _c4Mmh::P64 = R1 & 7;
           if (_c4Mmh::P64 != 3) goto u4Mmm; else goto u4Mmq;
       u4Mmm: // global
           if (_c4Mmh::P64 != 4) goto u4Mms; else goto u4Mmr;
       u4Mms: // global
           Sp = Sp + 8;
           call _c4Mm2() args: 0, res: 0, upd: 0;
       u4Mmr: // global
           Sp = Sp + 8;
           goto u4MmD;
       u4Mmq: // global
           Sp = Sp + 8;
           goto u4MmD;
       u4MmD: // global
           call _c4Mm6() args: 0, res: 0, upd: 0;
     }
 },
 _c4MlU() //  [R1]
         { info_tbl: [(c4MlU,
                       label: block_c4MlU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MlU: // global
           if (R1 & 7 == 4) goto u4Mmt; else goto u4Mmu;
       u4Mmt: // global
           Sp = Sp + 8;
           call _c4Mm6() args: 0, res: 0, upd: 0;
       u4Mmu: // global
           Sp = Sp + 8;
           call _c4Mm2() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mm6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mm6: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mm2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mm2: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mm9() //  []
         { info_tbl: [(c4Mm9,
                       label: block_c4Mm9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mm9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.148622322 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c<=_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c<=_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c<=_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c4MmU,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MmU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MmV; else goto c4MmW;
       c4MmV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MmW: // global
           I64[Sp - 16] = block_c4MmL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Mok; else goto c4MmM;
       u4Mok: // global
           call _c4MmL(R1) args: 0, res: 0, upd: 0;
       c4MmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MmL() //  [R1]
         { info_tbl: [(c4MmL,
                       label: block_c4MmL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MmL: // global
           _s4KZV::P64 = P64[Sp + 8];
           _c4MmT::P64 = R1 & 7;
           if (_c4MmT::P64 < 3) goto u4Mo4; else goto u4Mo5;
       u4Mo4: // global
           if (_c4MmT::P64 < 2) goto c4MmP; else goto c4MmQ;
       c4MmP: // global
           I64[Sp + 8] = block_c4MmZ_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Mog; else goto c4Mn1;
       u4Mog: // global
           call _c4MmZ(R1) args: 0, res: 0, upd: 0;
       c4Mn1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MmQ: // global
           I64[Sp + 8] = block_c4Mnm_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Moh; else goto c4Mno;
       u4Moh: // global
           call _c4Mnm(R1) args: 0, res: 0, upd: 0;
       c4Mno: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Mo5: // global
           if (_c4MmT::P64 < 4) goto c4MmR; else goto c4MmS;
       c4MmR: // global
           I64[Sp + 8] = block_c4MnF_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Moi; else goto c4MnH;
       u4Moi: // global
           call _c4MnF(R1) args: 0, res: 0, upd: 0;
       c4MnH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MmS: // global
           I64[Sp + 8] = block_c4MnU_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Moj; else goto c4MnW;
       u4Moj: // global
           call _c4MnU() args: 0, res: 0, upd: 0;
       c4MnW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MmZ() //  [R1]
         { info_tbl: [(c4MmZ,
                       label: block_c4MmZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MmZ: // global
           _c4Mo3::P64 = R1 & 7;
           if (_c4Mo3::P64 < 2) goto u4Mo8; else goto u4Mo6;
       u4Mo8: // global
           Sp = Sp + 8;
           call _c4MnN() args: 0, res: 0, upd: 0;
       u4Mo6: // global
           if (_c4Mo3::P64 != 3) goto u4Moa; else goto u4Moa;
       u4Moa: // global
           Sp = Sp + 8;
           call _c4MnR() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mnm() //  [R1]
         { info_tbl: [(c4Mnm,
                       label: block_c4Mnm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mnm: // global
           _c4Mo2::P64 = R1 & 7;
           if (_c4Mo2::P64 != 3) goto u4Mo7; else goto u4Mob;
       u4Mo7: // global
           if (_c4Mo2::P64 != 4) goto u4Mod; else goto u4Moc;
       u4Mod: // global
           Sp = Sp + 8;
           call _c4MnN() args: 0, res: 0, upd: 0;
       u4Moc: // global
           Sp = Sp + 8;
           goto u4Moo;
       u4Mob: // global
           Sp = Sp + 8;
           goto u4Moo;
       u4Moo: // global
           call _c4MnR() args: 0, res: 0, upd: 0;
     }
 },
 _c4MnF() //  [R1]
         { info_tbl: [(c4MnF,
                       label: block_c4MnF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MnF: // global
           if (R1 & 7 == 4) goto u4Moe; else goto u4Mof;
       u4Moe: // global
           Sp = Sp + 8;
           call _c4MnR() args: 0, res: 0, upd: 0;
       u4Mof: // global
           Sp = Sp + 8;
           call _c4MnN() args: 0, res: 0, upd: 0;
     }
 },
 _c4MnR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MnR: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MnN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MnN: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MnU() //  []
         { info_tbl: [(c4MnU,
                       label: block_c4MnU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MnU: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.152475838 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$cmax_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$cmax_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$cmax_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4MoF,
                       label: GHC.IO.IOMode.$fOrdIOMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MoF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MoG; else goto c4MoH;
       c4MoG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MoH: // global
           I64[Sp - 16] = block_c4Mow_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MpE; else goto c4Mox;
       u4MpE: // global
           call _c4Mow(R1) args: 0, res: 0, upd: 0;
       c4Mox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mow() //  [R1]
         { info_tbl: [(c4Mow,
                       label: block_c4Mow_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mow: // global
           _s4L02::P64 = P64[Sp + 8];
           _c4MoE::P64 = R1 & 7;
           if (_c4MoE::P64 < 3) goto u4Mpu; else goto u4Mpv;
       u4Mpu: // global
           if (_c4MoE::P64 < 2) goto c4MoA; else goto c4MoB;
       c4MoA: // global
           R1 = _s4L02::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4MoB: // global
           I64[Sp + 8] = block_c4MoN_info;
           R1 = _s4L02::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MpB; else goto c4MoP;
       u4MpB: // global
           call _c4MoN(R1) args: 0, res: 0, upd: 0;
       c4MoP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Mpv: // global
           if (_c4MoE::P64 < 4) goto c4MoC; else goto c4MoD;
       c4MoC: // global
           I64[Sp + 8] = block_c4Mp6_info;
           R1 = _s4L02::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MpC; else goto c4Mp8;
       u4MpC: // global
           call _c4Mp6(R1) args: 0, res: 0, upd: 0;
       c4Mp8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MoD: // global
           I64[Sp + 8] = block_c4Mpl_info;
           R1 = _s4L02::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MpD; else goto c4Mpn;
       u4MpD: // global
           call _c4Mpl() args: 0, res: 0, upd: 0;
       c4Mpn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MoN() //  [R1]
         { info_tbl: [(c4MoN,
                       label: block_c4MoN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MoN: // global
           _c4Mpt::P64 = R1 & 7;
           if (_c4Mpt::P64 != 3) goto u4Mpw; else goto u4Mpx;
       u4Mpw: // global
           if (_c4Mpt::P64 != 4) goto c4MoV; else goto u4Mpy;
       c4MoV: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Mpy: // global
           Sp = Sp + 8;
           call _c4Mpi() args: 0, res: 0, upd: 0;
       u4Mpx: // global
           Sp = Sp + 8;
           call _c4Mpe() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mp6() //  [R1]
         { info_tbl: [(c4Mp6,
                       label: block_c4Mp6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mp6: // global
           if (R1 & 7 == 4) goto u4Mpz; else goto u4MpA;
       u4Mpz: // global
           Sp = Sp + 8;
           call _c4Mpi() args: 0, res: 0, upd: 0;
       u4MpA: // global
           Sp = Sp + 8;
           call _c4Mpe() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mpi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mpi: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mpe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mpe: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mpl() //  []
         { info_tbl: [(c4Mpl,
                       label: block_c4Mpl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mpl: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.159902388 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c>=_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c>=_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c>=_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c4MpW,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MpW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MpX; else goto c4MpY;
       c4MpX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MpY: // global
           I64[Sp - 16] = block_c4MpN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Mrm; else goto c4MpO;
       u4Mrm: // global
           call _c4MpN(R1) args: 0, res: 0, upd: 0;
       c4MpO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MpN() //  [R1]
         { info_tbl: [(c4MpN,
                       label: block_c4MpN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MpN: // global
           _s4L09::P64 = P64[Sp + 8];
           _c4MpV::P64 = R1 & 7;
           if (_c4MpV::P64 < 3) goto u4Mr6; else goto u4Mr7;
       u4Mr6: // global
           if (_c4MpV::P64 < 2) goto c4MpR; else goto c4MpS;
       c4MpR: // global
           I64[Sp + 8] = block_c4Mq1_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Mri; else goto c4Mq3;
       u4Mri: // global
           call _c4Mq1(R1) args: 0, res: 0, upd: 0;
       c4Mq3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MpS: // global
           I64[Sp + 8] = block_c4Mqo_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Mrj; else goto c4Mqq;
       u4Mrj: // global
           call _c4Mqo(R1) args: 0, res: 0, upd: 0;
       c4Mqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Mr7: // global
           if (_c4MpV::P64 < 4) goto c4MpT; else goto c4MpU;
       c4MpT: // global
           I64[Sp + 8] = block_c4MqH_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Mrk; else goto c4MqJ;
       u4Mrk: // global
           call _c4MqH(R1) args: 0, res: 0, upd: 0;
       c4MqJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MpU: // global
           I64[Sp + 8] = block_c4MqW_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Mrl; else goto c4MqY;
       u4Mrl: // global
           call _c4MqW() args: 0, res: 0, upd: 0;
       c4MqY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mq1() //  [R1]
         { info_tbl: [(c4Mq1,
                       label: block_c4Mq1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mq1: // global
           _c4Mr5::P64 = R1 & 7;
           if (_c4Mr5::P64 < 2) goto u4Mra; else goto u4Mr8;
       u4Mra: // global
           Sp = Sp + 8;
           call _c4MqP() args: 0, res: 0, upd: 0;
       u4Mr8: // global
           if (_c4Mr5::P64 != 3) goto u4Mrc; else goto u4Mrc;
       u4Mrc: // global
           Sp = Sp + 8;
           call _c4MqT() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mqo() //  [R1]
         { info_tbl: [(c4Mqo,
                       label: block_c4Mqo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mqo: // global
           _c4Mr4::P64 = R1 & 7;
           if (_c4Mr4::P64 != 3) goto u4Mr9; else goto u4Mrd;
       u4Mr9: // global
           if (_c4Mr4::P64 != 4) goto u4Mrf; else goto u4Mre;
       u4Mrf: // global
           Sp = Sp + 8;
           call _c4MqP() args: 0, res: 0, upd: 0;
       u4Mre: // global
           Sp = Sp + 8;
           goto u4Mrq;
       u4Mrd: // global
           Sp = Sp + 8;
           goto u4Mrq;
       u4Mrq: // global
           call _c4MqT() args: 0, res: 0, upd: 0;
     }
 },
 _c4MqH() //  [R1]
         { info_tbl: [(c4MqH,
                       label: block_c4MqH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MqH: // global
           if (R1 & 7 == 4) goto u4Mrg; else goto u4Mrh;
       u4Mrg: // global
           Sp = Sp + 8;
           call _c4MqT() args: 0, res: 0, upd: 0;
       u4Mrh: // global
           Sp = Sp + 8;
           call _c4MqP() args: 0, res: 0, upd: 0;
     }
 },
 _c4MqT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MqT: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MqP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MqP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MqW() //  []
         { info_tbl: [(c4MqW,
                       label: block_c4MqW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MqW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.164111164 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c>_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c>_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c>_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c4Mry,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mry: // global
           _s4L0g::P64 = R3;
           R3 = R2;
           R2 = _s4L0g::P64;
           call GHC.IO.IOMode.$fOrdIOMode_$c<_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.166414388 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$cmin_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$cmin_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$cmin_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4MrO,
                       label: GHC.IO.IOMode.$fOrdIOMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MrO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MrP; else goto c4MrQ;
       c4MrP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MrQ: // global
           I64[Sp - 16] = block_c4MrF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MsJ; else goto c4MrG;
       u4MsJ: // global
           call _c4MrF(R1) args: 0, res: 0, upd: 0;
       c4MrG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MrF() //  [R1]
         { info_tbl: [(c4MrF,
                       label: block_c4MrF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MrF: // global
           _s4L0h::P64 = P64[Sp + 8];
           _c4MrN::P64 = R1 & 7;
           if (_c4MrN::P64 < 3) goto u4MsD; else goto u4MsE;
       u4MsD: // global
           if (_c4MrN::P64 < 2) goto c4MrJ; else goto c4MrK;
       c4MrJ: // global
           I64[Sp + 8] = block_c4MrT_info;
           R1 = _s4L0h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MsG; else goto c4MrV;
       u4MsG: // global
           call _c4MrT() args: 0, res: 0, upd: 0;
       c4MrV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MrK: // global
           I64[Sp + 8] = block_c4Ms2_info;
           R1 = _s4L0h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MsH; else goto c4Ms4;
       u4MsH: // global
           call _c4Ms2(R1) args: 0, res: 0, upd: 0;
       c4Ms4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4MsE: // global
           if (_c4MrN::P64 < 4) goto c4MrL; else goto c4MrM;
       c4MrL: // global
           I64[Sp + 8] = block_c4Msl_info;
           R1 = _s4L0h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MsI; else goto c4Msn;
       u4MsI: // global
           call _c4Msl(R1) args: 0, res: 0, upd: 0;
       c4Msn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MrM: // global
           R1 = _s4L0h::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MrT() //  []
         { info_tbl: [(c4MrT,
                       label: block_c4MrT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MrT: // global
           R1 = GHC.IO.IOMode.ReadMode_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Ms2() //  [R1]
         { info_tbl: [(c4Ms2,
                       label: block_c4Ms2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ms2: // global
           _c4MsC::P64 = R1 & 7;
           if (_c4MsC::P64 == 3) goto c4Msi; else goto u4MsF;
       u4MsF: // global
           if (_c4MsC::P64 == 4) goto c4Msi; else goto c4Msa;
       c4Msi: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Msa: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Msl() //  [R1]
         { info_tbl: [(c4Msl,
                       label: block_c4Msl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Msl: // global
           if (R1 & 7 == 4) goto c4Msx; else goto c4Mst;
       c4Msx: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mst: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.169713939 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_closure" {
     GHC.IO.IOMode.$fOrdIOMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.IOMode.$fEqIOMode_closure+1;
         const GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c<_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c<=_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c>_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c>=_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$cmax_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.172833512 UTC

[section ""data" . GHC.IO.IOMode.$w$cunsafeIndex_closure" {
     GHC.IO.IOMode.$w$cunsafeIndex_closure:
         const GHC.IO.IOMode.$w$cunsafeIndex_info;
 },
 GHC.IO.IOMode.$w$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4MsX,
                       label: GHC.IO.IOMode.$w$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MsX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MsY; else goto c4MsZ;
       c4MsY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MsZ: // global
           I64[Sp - 16] = block_c4MsO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Mv0; else goto c4MsP;
       u4Mv0: // global
           call _c4MsO(R1) args: 0, res: 0, upd: 0;
       c4MsP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MsO() //  [R1]
         { info_tbl: [(c4MsO,
                       label: block_c4MsO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MsO: // global
           _s4L0o::P64 = P64[Sp + 8];
           _c4MsW::P64 = R1 & 7;
           if (_c4MsW::P64 < 3) goto u4Muy; else goto u4Muz;
       u4Muy: // global
           if (_c4MsW::P64 < 2) goto c4MsS; else goto c4MsT;
       c4MsS: // global
           I64[Sp + 8] = block_c4Mt2_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MuW; else goto c4Mt4;
       u4MuW: // global
           call _c4Mt2(R1) args: 0, res: 0, upd: 0;
       c4Mt4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MsT: // global
           I64[Sp + 8] = block_c4Mtp_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MuX; else goto c4Mtr;
       u4MuX: // global
           call _c4Mtp(R1) args: 0, res: 0, upd: 0;
       c4Mtr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Muz: // global
           if (_c4MsW::P64 < 4) goto c4MsU; else goto c4MsV;
       c4MsU: // global
           I64[Sp + 8] = block_c4MtM_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MuY; else goto c4MtO;
       u4MuY: // global
           call _c4MtM(R1) args: 0, res: 0, upd: 0;
       c4MtO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MsV: // global
           I64[Sp + 8] = block_c4Mu9_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MuZ; else goto c4Mub;
       u4MuZ: // global
           call _c4Mu9(R1) args: 0, res: 0, upd: 0;
       c4Mub: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mt2() //  [R1]
         { info_tbl: [(c4Mt2,
                       label: block_c4Mt2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mt2: // global
           _c4Mux::P64 = R1 & 7;
           if (_c4Mux::P64 < 3) goto u4MuA; else goto u4MuB;
       u4MuA: // global
           if (_c4Mux::P64 < 2) goto u4MuJ; else goto u4MuI;
       u4MuJ: // global
           Sp = Sp + 8;
           call _c4Mut() args: 0, res: 0, upd: 0;
       u4MuI: // global
           Sp = Sp + 8;
           call _c4Mu6() args: 0, res: 0, upd: 0;
       u4MuB: // global
           if (_c4Mux::P64 < 4) goto u4MuK; else goto c4Mtm;
       u4MuK: // global
           Sp = Sp + 8;
           call _c4MtJ() args: 0, res: 0, upd: 0;
       c4Mtm: // global
           R1 = 3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mtp() //  [R1]
         { info_tbl: [(c4Mtp,
                       label: block_c4Mtp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mtp: // global
           _c4Muw::P64 = R1 & 7;
           if (_c4Muw::P64 < 3) goto u4MuC; else goto u4MuD;
       u4MuC: // global
           if (_c4Muw::P64 < 2) goto u4MuM; else goto u4MuL;
       u4MuM: // global
           Sp = Sp + 8;
           call _c4Mup() args: 0, res: 0, upd: 0;
       u4MuL: // global
           Sp = Sp + 8;
           call _c4Mut() args: 0, res: 0, upd: 0;
       u4MuD: // global
           if (_c4Muw::P64 < 4) goto u4MuO; else goto u4MuN;
       u4MuO: // global
           Sp = Sp + 8;
           call _c4Mu6() args: 0, res: 0, upd: 0;
       u4MuN: // global
           Sp = Sp + 8;
           call _c4MtJ() args: 0, res: 0, upd: 0;
     }
 },
 _c4MtJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MtJ: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MtM() //  [R1]
         { info_tbl: [(c4MtM,
                       label: block_c4MtM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MtM: // global
           _c4Muv::P64 = R1 & 7;
           if (_c4Muv::P64 < 3) goto u4MuE; else goto u4MuF;
       u4MuE: // global
           if (_c4Muv::P64 < 2) goto u4MuQ; else goto u4MuP;
       u4MuQ: // global
           Sp = Sp + 8;
           call _c4Mul() args: 0, res: 0, upd: 0;
       u4MuP: // global
           Sp = Sp + 8;
           call _c4Mup() args: 0, res: 0, upd: 0;
       u4MuF: // global
           if (_c4Muv::P64 < 4) goto u4MuS; else goto u4MuR;
       u4MuS: // global
           Sp = Sp + 8;
           call _c4Mut() args: 0, res: 0, upd: 0;
       u4MuR: // global
           Sp = Sp + 8;
           call _c4Mu6() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mu6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mu6: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mu9() //  [R1]
         { info_tbl: [(c4Mu9,
                       label: block_c4Mu9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mu9: // global
           _c4Muu::P64 = R1 & 7;
           if (_c4Muu::P64 < 3) goto u4MuG; else goto u4MuH;
       u4MuG: // global
           if (_c4Muu::P64 < 2) goto c4Muh; else goto u4MuT;
       c4Muh: // global
           R1 = (-3);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4MuT: // global
           Sp = Sp + 8;
           call _c4Mul() args: 0, res: 0, upd: 0;
       u4MuH: // global
           if (_c4Muu::P64 < 4) goto u4MuV; else goto u4MuU;
       u4MuV: // global
           Sp = Sp + 8;
           call _c4Mup() args: 0, res: 0, upd: 0;
       u4MuU: // global
           Sp = Sp + 8;
           call _c4Mut() args: 0, res: 0, upd: 0;
     }
 },
 _c4Mul() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mul: // global
           R1 = (-2);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mup() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mup: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Mut() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mut: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.178584266 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4Mvm,
                       label: GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mvm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mvu; else goto c4Mvv;
       c4Mvu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Mvv: // global
           I64[Sp - 16] = block_c4Mvj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MvA; else goto c4Mvk;
       u4MvA: // global
           call _c4Mvj(R1) args: 0, res: 0, upd: 0;
       c4Mvk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mvj() //  [R1]
         { info_tbl: [(c4Mvj,
                       label: block_c4Mvj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mvj: // global
           _s4L0v::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Mvp_info;
           R3 = _s4L0v::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$cunsafeIndex_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mvp() //  [R1]
         { info_tbl: [(c4Mvp,
                       label: block_c4Mvp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mvp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Mvz; else goto c4Mvy;
       c4Mvz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4Mvy: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.182701183 UTC

[section ""data" . GHC.IO.IOMode.$w$cinRange_closure" {
     GHC.IO.IOMode.$w$cinRange_closure:
         const GHC.IO.IOMode.$w$cinRange_info;
 },
 GHC.IO.IOMode.$w$cinRange_entry() //  [R2, R3, R4]
         { info_tbl: [(c4MvQ,
                       label: GHC.IO.IOMode.$w$cinRange_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MvQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4MvR; else goto c4MvS;
       c4MvR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cinRange_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MvS: // global
           I64[Sp - 24] = block_c4MvH_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Mxy; else goto c4MvI;
       u4Mxy: // global
           call _c4MvH(R1) args: 0, res: 0, upd: 0;
       c4MvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MvH() //  [R1]
         { info_tbl: [(c4MvH,
                       label: block_c4MvH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MvH: // global
           _s4L0B::P64 = P64[Sp + 8];
           _c4MvP::P64 = R1 & 7;
           if (_c4MvP::P64 < 3) goto u4Mxr; else goto u4Mxs;
       u4Mxr: // global
           if (_c4MvP::P64 < 2) goto c4MvL; else goto c4MvM;
       c4MvL: // global
           _s4L0E::I64 = 0;
           goto s4L0D;
       c4MvM: // global
           _s4L0E::I64 = 1;
           goto s4L0D;
       u4Mxs: // global
           if (_c4MvP::P64 < 4) goto c4MvN; else goto c4MvO;
       c4MvN: // global
           _s4L0E::I64 = 2;
           goto s4L0D;
       c4MvO: // global
           _s4L0E::I64 = 3;
           goto s4L0D;
       s4L0D: // global
           I64[Sp] = block_c4MvY_info;
           R1 = _s4L0B::P64;
           I64[Sp + 8] = _s4L0E::I64;
           if (R1 & 7 != 0) goto u4Mxx; else goto c4MwI;
       u4Mxx: // global
           call _c4MvY(R1) args: 0, res: 0, upd: 0;
       c4MwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MvY() //  [R1]
         { info_tbl: [(c4MvY,
                       label: block_c4MvY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MvY: // global
           _s4L0C::P64 = P64[Sp + 16];
           _c4Mxd::P64 = R1 & 7;
           if (_c4Mxd::P64 < 3) goto u4Mxt; else goto u4Mxu;
       u4Mxt: // global
           if (_c4Mxd::P64 < 2) goto c4MwO; else goto c4MwS;
       c4MwO: // global
           _s4L0G::I64 = 0;
           goto s4L0F;
       c4MwS: // global
           _s4L0G::I64 = 1;
           goto s4L0F;
       u4Mxu: // global
           if (_c4Mxd::P64 < 4) goto c4MwW; else goto c4Mx0;
       c4MwW: // global
           _s4L0G::I64 = 2;
           goto s4L0F;
       c4Mx0: // global
           _s4L0G::I64 = 3;
           goto s4L0F;
       s4L0F: // global
           I64[Sp] = block_c4Mw3_info;
           R1 = _s4L0C::P64;
           I64[Sp + 16] = _s4L0G::I64;
           if (R1 & 7 != 0) goto u4Mxz; else goto c4Mw5;
       u4Mxz: // global
           call _c4Mw3(R1) args: 0, res: 0, upd: 0;
       c4Mw5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Mw3() //  [R1]
         { info_tbl: [(c4Mw3,
                       label: block_c4Mw3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mw3: // global
           _s4L0E::I64 = I64[Sp + 8];
           _s4L0G::I64 = I64[Sp + 16];
           _c4Mxe::P64 = R1 & 7;
           if (_c4Mxe::P64 < 3) goto u4Mxv; else goto u4Mxw;
       u4Mxv: // global
           if (_c4Mxe::P64 < 2) goto c4Mwg; else goto c4Mwp;
       c4Mwg: // global
           if (%MO_S_Lt_W64(0, _s4L0E::I64)) goto c4MwF; else goto c4Mwe;
       c4Mwe: // global
           R1 = I64[(%MO_S_Le_W64(0,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Mwp: // global
           if (%MO_S_Lt_W64(1, _s4L0E::I64)) goto c4MwF; else goto c4Mwo;
       c4Mwo: // global
           R1 = I64[(%MO_S_Le_W64(1,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Mxw: // global
           if (_c4Mxe::P64 < 4) goto c4Mwy; else goto c4MwH;
       c4Mwy: // global
           if (%MO_S_Lt_W64(2, _s4L0E::I64)) goto c4MwF; else goto c4Mwx;
       c4Mwx: // global
           R1 = I64[(%MO_S_Le_W64(2,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MwH: // global
           if (%MO_S_Lt_W64(3, _s4L0E::I64)) goto c4MwF; else goto c4MwG;
       c4MwF: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MwG: // global
           R1 = I64[(%MO_S_Le_W64(3,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.187123764 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cinRange_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cinRange_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cinRange_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4MxH,
                       label: GHC.IO.IOMode.$fIxIOMode_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MxH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MxI; else goto c4MxJ;
       c4MxI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MxJ: // global
           I64[Sp - 16] = block_c4MxE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MxN; else goto c4MxF;
       u4MxN: // global
           call _c4MxE(R1) args: 0, res: 0, upd: 0;
       c4MxF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MxE() //  [R1]
         { info_tbl: [(c4MxE,
                       label: block_c4MxE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MxE: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.188737786 UTC

[section ""data" . lvl_r4KYL_closure" {
     lvl_r4KYL_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.19175076 UTC

[section ""data" . lvl1_r4KYM_closure" {
     lvl1_r4KYM_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.19256492 UTC

[section ""data" . lvl2_r4KYN_closure" {
     lvl2_r4KYN_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.1934496 UTC

[section ""data" . lvl3_r4KYO_closure" {
     lvl3_r4KYO_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.194829404 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_info;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4My1,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4My1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4My2; else goto c4My3;
       c4My2: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4My3: // global
           I64[Sp - 8] = block_c4MxS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Myi; else goto c4MxT;
       u4Myi: // global
           call _c4MxS(R1) args: 0, res: 0, upd: 0;
       c4MxT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MxS() //  [R1]
         { info_tbl: [(c4MxS,
                       label: block_c4MxS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MxS: // global
           _c4My0::P64 = R1 & 7;
           if (_c4My0::P64 < 3) goto u4Myg; else goto u4Myh;
       u4Myg: // global
           if (_c4My0::P64 < 2) goto c4MxW; else goto c4MxX;
       c4MxW: // global
           R1 = lvl_r4KYL_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MxX: // global
           R1 = lvl1_r4KYM_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Myh: // global
           if (_c4My0::P64 < 4) goto c4MxY; else goto c4MxZ;
       c4MxY: // global
           R1 = lvl2_r4KYN_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MxZ: // global
           R1 = lvl3_r4KYO_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.19754381 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go2_closure" {
     GHC.IO.IOMode.$fIxIOMode_go2_closure:
         const GHC.IO.IOMode.$fIxIOMode_go2_info;
 },
 sat_s4L13_entry() //  [R1]
         { info_tbl: [(c4Myv,
                       label: sat_s4L13_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Myv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Myw; else goto c4Myx;
       c4Myw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Myx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L11::I64 = I64[R1 + 16];
           if (_s4L11::I64 != 0) goto c4Myt; else goto c4Myu;
       c4Myt: // global
           R2 = _s4L11::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go2_entry(R2) args: 24, res: 0, upd: 24;
       c4Myu: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L10_entry() //  [R1]
         { info_tbl: [(c4MyE,
                       label: sat_s4L10_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MyE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MyF; else goto c4MyG;
       c4MyF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MyG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go2_entry() //  [R2]
         { info_tbl: [(c4MyI,
                       label: GHC.IO.IOMode.$fIxIOMode_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MyI: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4MyM; else goto c4MyL;
       c4MyM: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MyL: // global
           I64[Hp - 64] = sat_s4L13_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L10_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.200528712 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go1_closure" {
     GHC.IO.IOMode.$fIxIOMode_go1_closure:
         const GHC.IO.IOMode.$fIxIOMode_go1_info;
 },
 sat_s4L18_entry() //  [R1]
         { info_tbl: [(c4MyZ,
                       label: sat_s4L18_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MyZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mz0; else goto c4Mz1;
       c4Mz0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Mz1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L16::I64 = I64[R1 + 16];
           if (_s4L16::I64 != 1) goto c4MyX; else goto c4MyY;
       c4MyX: // global
           R2 = _s4L16::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go1_entry(R2) args: 24, res: 0, upd: 24;
       c4MyY: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L15_entry() //  [R1]
         { info_tbl: [(c4Mz8,
                       label: sat_s4L15_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mz8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mz9; else goto c4Mza;
       c4Mz9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Mza: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go1_entry() //  [R2]
         { info_tbl: [(c4Mzc,
                       label: GHC.IO.IOMode.$fIxIOMode_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mzc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Mzg; else goto c4Mzf;
       c4Mzg: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Mzf: // global
           I64[Hp - 64] = sat_s4L18_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L15_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.203510669 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go_closure" {
     GHC.IO.IOMode.$fIxIOMode_go_closure:
         const GHC.IO.IOMode.$fIxIOMode_go_info;
 },
 sat_s4L1d_entry() //  [R1]
         { info_tbl: [(c4Mzt,
                       label: sat_s4L1d_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Mzt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Mzu; else goto c4Mzv;
       c4Mzu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Mzv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L1b::I64 = I64[R1 + 16];
           if (_s4L1b::I64 != 2) goto c4Mzr; else goto c4Mzs;
       c4Mzr: // global
           R2 = _s4L1b::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go_entry(R2) args: 24, res: 0, upd: 24;
       c4Mzs: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L1a_entry() //  [R1]
         { info_tbl: [(c4MzC,
                       label: sat_s4L1a_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MzC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MzD; else goto c4MzE;
       c4MzD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MzE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go_entry() //  [R2]
         { info_tbl: [(c4MzG,
                       label: GHC.IO.IOMode.$fIxIOMode_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MzG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4MzK; else goto c4MzJ;
       c4MzK: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MzJ: // global
           I64[Hp - 64] = sat_s4L1d_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L1a_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.206499465 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go4_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go4_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go4_info;
 },
 sat_s4L1i_entry() //  [R1]
         { info_tbl: [(c4MzX,
                       label: sat_s4L1i_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MzX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MzY; else goto c4MzZ;
       c4MzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MzZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L1g::I64 = I64[R1 + 16];
           if (_s4L1g::I64 != 3) goto c4MzV; else goto c4MzW;
       c4MzV: // global
           R2 = _s4L1g::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
       c4MzW: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L1f_entry() //  [R1]
         { info_tbl: [(c4MA6,
                       label: sat_s4L1f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MA6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MA7; else goto c4MA8;
       c4MA7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MA8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go4_entry() //  [R2]
         { info_tbl: [(c4MAa,
                       label: GHC.IO.IOMode.$fEnumIOMode_go4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MAa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4MAe; else goto c4MAd;
       c4MAe: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MAd: // global
           I64[Hp - 64] = sat_s4L1i_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L1f_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.210120926 UTC

[section ""data" . GHC.IO.IOMode.$w$crange_closure" {
     GHC.IO.IOMode.$w$crange_closure:
         const GHC.IO.IOMode.$w$crange_info;
 },
 GHC.IO.IOMode.$w$crange_entry() //  [R2, R3]
         { info_tbl: [(c4MAu,
                       label: GHC.IO.IOMode.$w$crange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MAu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MAv; else goto c4MAw;
       c4MAv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$crange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MAw: // global
           I64[Sp - 16] = block_c4MAl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MBx; else goto c4MAm;
       u4MBx: // global
           call _c4MAl(R1) args: 0, res: 0, upd: 0;
       c4MAm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MAl() //  [R1]
         { info_tbl: [(c4MAl,
                       label: block_c4MAl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MAl: // global
           _s4L1k::P64 = P64[Sp + 8];
           _c4MAt::P64 = R1 & 7;
           if (_c4MAt::P64 < 3) goto u4MBs; else goto u4MBt;
       u4MBs: // global
           if (_c4MAt::P64 < 2) goto c4MAp; else goto c4MAq;
       c4MAp: // global
           _s4L1m::I64 = 0;
           goto s4L1l;
       c4MAq: // global
           _s4L1m::I64 = 1;
           goto s4L1l;
       u4MBt: // global
           if (_c4MAt::P64 < 4) goto c4MAr; else goto c4MAs;
       c4MAr: // global
           _s4L1m::I64 = 2;
           goto s4L1l;
       c4MAs: // global
           _s4L1m::I64 = 3;
           goto s4L1l;
       s4L1l: // global
           I64[Sp] = block_c4MAA_info;
           R1 = _s4L1k::P64;
           I64[Sp + 8] = _s4L1m::I64;
           if (R1 & 7 != 0) goto u4MBw; else goto c4MAC;
       u4MBw: // global
           call _c4MAA(R1) args: 0, res: 0, upd: 0;
       c4MAC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MAA() //  [R1]
         { info_tbl: [(c4MAA,
                       label: block_c4MAA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MAA: // global
           _s4L1m::I64 = I64[Sp + 8];
           _c4MBr::P64 = R1 & 7;
           if (_c4MBr::P64 < 3) goto u4MBu; else goto u4MBv;
       u4MBu: // global
           if (_c4MBr::P64 < 2) goto c4MAN; else goto c4MAW;
       c4MAN: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 0)) goto c4MBd; else goto c4MAK;
       c4MAK: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go2_entry(R2) args: 8, res: 0, upd: 8;
       c4MAW: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 1)) goto c4MBd; else goto c4MAU;
       c4MAU: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go1_entry(R2) args: 8, res: 0, upd: 8;
       u4MBv: // global
           if (_c4MBr::P64 < 4) goto c4MB5; else goto c4MBe;
       c4MB5: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 2)) goto c4MBd; else goto c4MB3;
       c4MB3: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go_entry(R2) args: 8, res: 0, upd: 8;
       c4MBe: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 3)) goto c4MBd; else goto c4MBc;
       c4MBd: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MBc: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.212629189 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$crange_closure" {
     GHC.IO.IOMode.$fIxIOMode_$crange_closure:
         const GHC.IO.IOMode.$fIxIOMode_$crange_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$crange_entry() //  [R2]
         { info_tbl: [(c4MBF,
                       label: GHC.IO.IOMode.$fIxIOMode_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MBF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MBG; else goto c4MBH;
       c4MBG: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MBH: // global
           I64[Sp - 8] = block_c4MBC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4MBL; else goto c4MBD;
       u4MBL: // global
           call _c4MBC(R1) args: 0, res: 0, upd: 0;
       c4MBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MBC() //  [R1]
         { info_tbl: [(c4MBC,
                       label: block_c4MBC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MBC: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$crange_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.215261018 UTC

[section ""data" . GHC.IO.IOMode.$w$crangeSize_closure" {
     GHC.IO.IOMode.$w$crangeSize_closure:
         const GHC.IO.IOMode.$w$crangeSize_info;
 },
 GHC.IO.IOMode.$w$crangeSize_entry() //  [R2, R3]
         { info_tbl: [(c4MBW,
                       label: GHC.IO.IOMode.$w$crangeSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MBW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4MBX; else goto c4MBY;
       c4MBX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$crangeSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MBY: // global
           I64[Sp - 24] = block_c4MBQ_info;
           R4 = R3;
           _s4L1y::P64 = R3;
           R3 = R3;
           _s4L1x::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4L1x::P64;
           P64[Sp - 8] = _s4L1y::P64;
           Sp = Sp - 24;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4MBQ() //  [R1]
         { info_tbl: [(c4MBQ,
                       label: block_c4MBQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MBQ: // global
           if (R1 & 7 == 1) goto u4MDW; else goto c4MBU;
       u4MDW: // global
           Sp = Sp + 24;
           call _c4MDC() args: 0, res: 0, upd: 0;
       c4MBU: // global
           _s4L1x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4MC4_info;
           R1 = _s4L1x::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MEb; else goto c4MC6;
       u4MEb: // global
           call _c4MC4(R1) args: 0, res: 0, upd: 0;
       c4MC6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MC4() //  [R1]
         { info_tbl: [(c4MC4,
                       label: block_c4MC4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MC4: // global
           _s4L1y::P64 = P64[Sp + 8];
           _c4MDH::P64 = R1 & 7;
           if (_c4MDH::P64 < 3) goto u4MDM; else goto u4MDN;
       u4MDM: // global
           if (_c4MDH::P64 < 2) goto c4MCd; else goto c4MCB;
       c4MCd: // global
           I64[Sp + 8] = block_c4MCa_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MEd; else goto c4MCe;
       u4MEd: // global
           call _c4MCa(R1) args: 0, res: 0, upd: 0;
       c4MCe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MCB: // global
           I64[Sp + 8] = block_c4MCz_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MEe; else goto c4MCC;
       u4MEe: // global
           call _c4MCz(R1) args: 0, res: 0, upd: 0;
       c4MCC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4MDN: // global
           if (_c4MDH::P64 < 4) goto c4MCZ; else goto c4MDn;
       c4MCZ: // global
           I64[Sp + 8] = block_c4MCX_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MEf; else goto c4MD0;
       u4MEf: // global
           call _c4MCX(R1) args: 0, res: 0, upd: 0;
       c4MD0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MDn: // global
           I64[Sp + 8] = block_c4MDl_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MEg; else goto c4MDo;
       u4MEg: // global
           call _c4MDl(R1) args: 0, res: 0, upd: 0;
       c4MDo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MCa() //  [R1]
         { info_tbl: [(c4MCa,
                       label: block_c4MCa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MCa: // global
           _c4MDL::P64 = R1 & 7;
           if (_c4MDL::P64 < 3) goto u4MDO; else goto u4MDP;
       u4MDO: // global
           if (_c4MDL::P64 < 2) goto u4MDY; else goto u4MDX;
       u4MDY: // global
           Sp = Sp + 8;
           call _c4MDG() args: 0, res: 0, upd: 0;
       u4MDX: // global
           Sp = Sp + 8;
           call _c4MDi() args: 0, res: 0, upd: 0;
       u4MDP: // global
           if (_c4MDL::P64 < 4) goto u4MDZ; else goto c4MCw;
       u4MDZ: // global
           Sp = Sp + 8;
           call _c4MCU() args: 0, res: 0, upd: 0;
       c4MCw: // global
           R1 = 4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MCz() //  [R1]
         { info_tbl: [(c4MCz,
                       label: block_c4MCz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MCz: // global
           _c4MDK::P64 = R1 & 7;
           if (_c4MDK::P64 < 3) goto u4MDQ; else goto u4MDR;
       u4MDQ: // global
           if (_c4MDK::P64 < 2) goto u4ME1; else goto u4ME0;
       u4ME1: // global
           Sp = Sp + 8;
           call _c4MDC() args: 0, res: 0, upd: 0;
       u4ME0: // global
           Sp = Sp + 8;
           call _c4MDG() args: 0, res: 0, upd: 0;
       u4MDR: // global
           if (_c4MDK::P64 < 4) goto u4ME3; else goto u4ME2;
       u4ME3: // global
           Sp = Sp + 8;
           call _c4MDi() args: 0, res: 0, upd: 0;
       u4ME2: // global
           Sp = Sp + 8;
           call _c4MCU() args: 0, res: 0, upd: 0;
     }
 },
 _c4MCU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MCU: // global
           R1 = 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MCX() //  [R1]
         { info_tbl: [(c4MCX,
                       label: block_c4MCX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MCX: // global
           _c4MDJ::P64 = R1 & 7;
           if (_c4MDJ::P64 < 3) goto u4MDS; else goto u4MDT;
       u4MDS: // global
           if (_c4MDJ::P64 < 2) goto u4ME5; else goto u4ME4;
       u4ME5: // global
           Sp = Sp + 8;
           call _c4MDy() args: 0, res: 0, upd: 0;
       u4ME4: // global
           Sp = Sp + 8;
           call _c4MDC() args: 0, res: 0, upd: 0;
       u4MDT: // global
           if (_c4MDJ::P64 < 4) goto u4ME7; else goto u4ME6;
       u4ME7: // global
           Sp = Sp + 8;
           call _c4MDG() args: 0, res: 0, upd: 0;
       u4ME6: // global
           Sp = Sp + 8;
           call _c4MDi() args: 0, res: 0, upd: 0;
     }
 },
 _c4MDi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MDi: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MDl() //  [R1]
         { info_tbl: [(c4MDl,
                       label: block_c4MDl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MDl: // global
           _c4MDI::P64 = R1 & 7;
           if (_c4MDI::P64 < 3) goto u4MDU; else goto u4MDV;
       u4MDU: // global
           if (_c4MDI::P64 < 2) goto c4MDu; else goto u4ME8;
       c4MDu: // global
           R1 = (-2);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4ME8: // global
           Sp = Sp + 8;
           call _c4MDy() args: 0, res: 0, upd: 0;
       u4MDV: // global
           if (_c4MDI::P64 < 4) goto u4MEa; else goto u4ME9;
       u4MEa: // global
           Sp = Sp + 8;
           call _c4MDC() args: 0, res: 0, upd: 0;
       u4ME9: // global
           Sp = Sp + 8;
           call _c4MDG() args: 0, res: 0, upd: 0;
     }
 },
 _c4MDy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MDy: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MDC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MDC: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MDG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MDG: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.219294682 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure" {
     GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure:
         const GHC.IO.IOMode.$fIxIOMode_$crangeSize_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4MEC,
                       label: GHC.IO.IOMode.$fIxIOMode_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MEC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MEK; else goto c4MEL;
       c4MEK: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MEL: // global
           I64[Sp - 8] = block_c4MEz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4MEQ; else goto c4MEA;
       u4MEQ: // global
           call _c4MEz(R1) args: 0, res: 0, upd: 0;
       c4MEA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MEz() //  [R1]
         { info_tbl: [(c4MEz,
                       label: block_c4MEz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MEz: // global
           I64[Sp] = block_c4MEF_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.IOMode.$w$crangeSize_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4MEF() //  [R1]
         { info_tbl: [(c4MEF,
                       label: block_c4MEF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MEF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4MEP; else goto c4MEO;
       c4MEP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4MEO: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.222186876 UTC

[section ""data" . GHC.IO.IOMode.$w$cunsafeRangeSize_closure" {
     GHC.IO.IOMode.$w$cunsafeRangeSize_closure:
         const GHC.IO.IOMode.$w$cunsafeRangeSize_info;
 },
 GHC.IO.IOMode.$w$cunsafeRangeSize_entry() //  [R2, R3]
         { info_tbl: [(c4MF4,
                       label: GHC.IO.IOMode.$w$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MF4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MF5; else goto c4MF6;
       c4MF5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MF6: // global
           I64[Sp - 16] = block_c4MEV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MH7; else goto c4MEW;
       u4MH7: // global
           call _c4MEV(R1) args: 0, res: 0, upd: 0;
       c4MEW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MEV() //  [R1]
         { info_tbl: [(c4MEV,
                       label: block_c4MEV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MEV: // global
           _s4L1L::P64 = P64[Sp + 8];
           _c4MF3::P64 = R1 & 7;
           if (_c4MF3::P64 < 3) goto u4MGF; else goto u4MGG;
       u4MGF: // global
           if (_c4MF3::P64 < 2) goto c4MEZ; else goto c4MF0;
       c4MEZ: // global
           I64[Sp + 8] = block_c4MF9_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MH3; else goto c4MFb;
       u4MH3: // global
           call _c4MF9(R1) args: 0, res: 0, upd: 0;
       c4MFb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MF0: // global
           I64[Sp + 8] = block_c4MFw_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MH4; else goto c4MFy;
       u4MH4: // global
           call _c4MFw(R1) args: 0, res: 0, upd: 0;
       c4MFy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4MGG: // global
           if (_c4MF3::P64 < 4) goto c4MF1; else goto c4MF2;
       c4MF1: // global
           I64[Sp + 8] = block_c4MFT_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MH5; else goto c4MFV;
       u4MH5: // global
           call _c4MFT(R1) args: 0, res: 0, upd: 0;
       c4MFV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4MF2: // global
           I64[Sp + 8] = block_c4MGg_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4MH6; else goto c4MGi;
       u4MH6: // global
           call _c4MGg(R1) args: 0, res: 0, upd: 0;
       c4MGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MF9() //  [R1]
         { info_tbl: [(c4MF9,
                       label: block_c4MF9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MF9: // global
           _c4MGE::P64 = R1 & 7;
           if (_c4MGE::P64 < 3) goto u4MGH; else goto u4MGI;
       u4MGH: // global
           if (_c4MGE::P64 < 2) goto u4MGQ; else goto u4MGP;
       u4MGQ: // global
           Sp = Sp + 8;
           call _c4MGA() args: 0, res: 0, upd: 0;
       u4MGP: // global
           Sp = Sp + 8;
           call _c4MGd() args: 0, res: 0, upd: 0;
       u4MGI: // global
           if (_c4MGE::P64 < 4) goto u4MGR; else goto c4MFt;
       u4MGR: // global
           Sp = Sp + 8;
           call _c4MFQ() args: 0, res: 0, upd: 0;
       c4MFt: // global
           R1 = 4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MFw() //  [R1]
         { info_tbl: [(c4MFw,
                       label: block_c4MFw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MFw: // global
           _c4MGD::P64 = R1 & 7;
           if (_c4MGD::P64 < 3) goto u4MGJ; else goto u4MGK;
       u4MGJ: // global
           if (_c4MGD::P64 < 2) goto u4MGT; else goto u4MGS;
       u4MGT: // global
           Sp = Sp + 8;
           call _c4MGw() args: 0, res: 0, upd: 0;
       u4MGS: // global
           Sp = Sp + 8;
           call _c4MGA() args: 0, res: 0, upd: 0;
       u4MGK: // global
           if (_c4MGD::P64 < 4) goto u4MGV; else goto u4MGU;
       u4MGV: // global
           Sp = Sp + 8;
           call _c4MGd() args: 0, res: 0, upd: 0;
       u4MGU: // global
           Sp = Sp + 8;
           call _c4MFQ() args: 0, res: 0, upd: 0;
     }
 },
 _c4MFQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MFQ: // global
           R1 = 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MFT() //  [R1]
         { info_tbl: [(c4MFT,
                       label: block_c4MFT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MFT: // global
           _c4MGC::P64 = R1 & 7;
           if (_c4MGC::P64 < 3) goto u4MGL; else goto u4MGM;
       u4MGL: // global
           if (_c4MGC::P64 < 2) goto u4MGX; else goto u4MGW;
       u4MGX: // global
           Sp = Sp + 8;
           call _c4MGs() args: 0, res: 0, upd: 0;
       u4MGW: // global
           Sp = Sp + 8;
           call _c4MGw() args: 0, res: 0, upd: 0;
       u4MGM: // global
           if (_c4MGC::P64 < 4) goto u4MGZ; else goto u4MGY;
       u4MGZ: // global
           Sp = Sp + 8;
           call _c4MGA() args: 0, res: 0, upd: 0;
       u4MGY: // global
           Sp = Sp + 8;
           call _c4MGd() args: 0, res: 0, upd: 0;
     }
 },
 _c4MGd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MGd: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MGg() //  [R1]
         { info_tbl: [(c4MGg,
                       label: block_c4MGg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MGg: // global
           _c4MGB::P64 = R1 & 7;
           if (_c4MGB::P64 < 3) goto u4MGN; else goto u4MGO;
       u4MGN: // global
           if (_c4MGB::P64 < 2) goto c4MGo; else goto u4MH0;
       c4MGo: // global
           R1 = (-2);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4MH0: // global
           Sp = Sp + 8;
           call _c4MGs() args: 0, res: 0, upd: 0;
       u4MGO: // global
           if (_c4MGB::P64 < 4) goto u4MH2; else goto u4MH1;
       u4MH2: // global
           Sp = Sp + 8;
           call _c4MGw() args: 0, res: 0, upd: 0;
       u4MH1: // global
           Sp = Sp + 8;
           call _c4MGA() args: 0, res: 0, upd: 0;
     }
 },
 _c4MGs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MGs: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MGw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MGw: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MGA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MGA: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.227828642 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4MHt,
                       label: GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MHt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MHB; else goto c4MHC;
       c4MHB: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MHC: // global
           I64[Sp - 8] = block_c4MHq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4MHH; else goto c4MHr;
       u4MHH: // global
           call _c4MHq(R1) args: 0, res: 0, upd: 0;
       c4MHr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MHq() //  [R1]
         { info_tbl: [(c4MHq,
                       label: block_c4MHq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MHq: // global
           I64[Sp] = block_c4MHw_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.IOMode.$w$cunsafeRangeSize_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4MHw() //  [R1]
         { info_tbl: [(c4MHw,
                       label: block_c4MHw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MHw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4MHG; else goto c4MHF;
       c4MHG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4MHF: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.229715319 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cindex_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cindex_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cindex_info;
         const 0;
 },
 GHC.IO.IOMode.$fIxIOMode_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4MHP,
                       label: GHC.IO.IOMode.$fIxIOMode_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MHP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4MHQ; else goto c4MHR;
       c4MHQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MHR: // global
           I64[Sp - 16] = block_c4MHM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MIf; else goto c4MHN;
       u4MIf: // global
           call _c4MHM(R1) args: 0, res: 0, upd: 0;
       c4MHN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MHM() //  [R1]
         { info_tbl: [(c4MHM,
                       label: block_c4MHM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MHM: // global
           I64[Sp - 8] = block_c4MHU_info;
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           _s4L1Z::P64 = P64[R1 + 7];
           R2 = _s4L1Z::P64;
           P64[Sp] = _s4L1Z::P64;
           Sp = Sp - 8;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4MHU() //  [R1]
         { info_tbl: [(c4MHU,
                       label: block_c4MHU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MHU: // global
           if (R1 & 7 == 1) goto c4MI1; else goto c4MIa;
       c4MI1: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4MIa: // global
           _s4L1X::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4MI4_info;
           R3 = _s4L1X::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.IOMode.$w$cunsafeIndex_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4MI4() //  [R1]
         { info_tbl: [(c4MI4,
                       label: block_c4MI4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MI4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4MId; else goto c4MIc;
       c4MId: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4MIc: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.231325575 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_closure" {
     GHC.IO.IOMode.$fIxIOMode_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.IO.IOMode.$fOrdIOMode_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$crange_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$cindex_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$cinRange_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.231927779 UTC

[section ""cstring" . lvl4_r4KYP_bytes" {
     lvl4_r4KYP_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.232753289 UTC

[section ""data" . lvl5_r4KYQ_closure" {
     lvl5_r4KYQ_closure:
         const lvl5_r4KYQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r4KYQ_entry() //  [R1]
         { info_tbl: [(c4MIm,
                       label: lvl5_r4KYQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MIm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MIn; else goto c4MIo;
       c4MIn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MIo: // global
           (_c4MIj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MIj::I64 == 0) goto c4MIl; else goto c4MIk;
       c4MIl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MIk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MIj::I64;
           R2 = lvl4_r4KYP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.233753993 UTC

[section ""cstring" . GHC.IO.IOMode.$trModule4_bytes" {
     GHC.IO.IOMode.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.234543482 UTC

[section ""data" . lvl6_r4KYR_closure" {
     lvl6_r4KYR_closure:
         const lvl6_r4KYR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r4KYR_entry() //  [R1]
         { info_tbl: [(c4MIv,
                       label: lvl6_r4KYR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MIv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MIw; else goto c4MIx;
       c4MIw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MIx: // global
           (_c4MIs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MIs::I64 == 0) goto c4MIu; else goto c4MIt;
       c4MIu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MIt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MIs::I64;
           R2 = GHC.IO.IOMode.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.235433089 UTC

[section ""cstring" . GHC.IO.IOMode.$trModule2_bytes" {
     GHC.IO.IOMode.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,73,79,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.236164866 UTC

[section ""data" . lvl7_r4KYS_closure" {
     lvl7_r4KYS_closure:
         const lvl7_r4KYS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r4KYS_entry() //  [R1]
         { info_tbl: [(c4MIE,
                       label: lvl7_r4KYS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MIE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MIF; else goto c4MIG;
       c4MIF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MIG: // global
           (_c4MIB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MIB::I64 == 0) goto c4MID; else goto c4MIC;
       c4MID: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MIC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MIB::I64;
           R2 = GHC.IO.IOMode.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.23707488 UTC

[section ""cstring" . lvl8_r4KYT_bytes" {
     lvl8_r4KYT_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,73,79,77,111,100,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.237882599 UTC

[section ""data" . lvl9_r4KYU_closure" {
     lvl9_r4KYU_closure:
         const lvl9_r4KYU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r4KYU_entry() //  [R1]
         { info_tbl: [(c4MIN,
                       label: lvl9_r4KYU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MIN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MIO; else goto c4MIP;
       c4MIO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MIP: // global
           (_c4MIK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MIK::I64 == 0) goto c4MIM; else goto c4MIL;
       c4MIM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MIL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MIK::I64;
           R2 = lvl8_r4KYT_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.238782114 UTC

[section ""data" . lvl10_r4KYV_closure" {
     lvl10_r4KYV_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.239379985 UTC

[section ""data" . lvl11_r4KYW_closure" {
     lvl11_r4KYW_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.239937375 UTC

[section ""data" . lvl12_r4KYX_closure" {
     lvl12_r4KYX_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl6_r4KYR_closure;
         const lvl7_r4KYS_closure;
         const lvl9_r4KYU_closure;
         const lvl10_r4KYV_closure+1;
         const lvl10_r4KYV_closure+1;
         const lvl10_r4KYV_closure+1;
         const lvl11_r4KYW_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.240560958 UTC

[section ""data" . lvl13_r4KYY_closure" {
     lvl13_r4KYY_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl5_r4KYQ_closure;
         const lvl12_r4KYX_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.241104609 UTC

[section ""cstring" . lvl14_r4KYZ_bytes" {
     lvl14_r4KYZ_bytes:
         I8[] [112,114,101,100,123,73,79,77,111,100,101,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.242191902 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode5_closure" {
     GHC.IO.IOMode.$fEnumIOMode5_closure:
         const GHC.IO.IOMode.$fEnumIOMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode5_entry() //  [R1]
         { info_tbl: [(c4MIY,
                       label: GHC.IO.IOMode.$fEnumIOMode5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MIY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4MIZ; else goto c4MJ0;
       c4MIZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MJ0: // global
           (_c4MIT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MIT::I64 == 0) goto c4MIV; else goto c4MIU;
       c4MIV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MIU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MIT::I64;
           I64[Sp - 24] = block_c4MIW_info;
           R2 = lvl14_r4KYZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4MIW() //  [R1]
         { info_tbl: [(c4MIW,
                       label: block_c4MIW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MIW: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.243737324 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cpred_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cpred_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cpred_entry() //  [R2]
         { info_tbl: [(c4MJh,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MJh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MJi; else goto c4MJj;
       c4MJi: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MJj: // global
           I64[Sp - 8] = block_c4MJ8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4MJy; else goto c4MJ9;
       u4MJy: // global
           call _c4MJ8(R1) args: 0, res: 0, upd: 0;
       c4MJ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MJ8() //  [R1]
         { info_tbl: [(c4MJ8,
                       label: block_c4MJ8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MJ8: // global
           _c4MJg::P64 = R1 & 7;
           if (_c4MJg::P64 < 3) goto u4MJw; else goto u4MJx;
       u4MJw: // global
           if (_c4MJg::P64 < 2) goto c4MJc; else goto c4MJd;
       c4MJc: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4MJd: // global
           R1 = GHC.IO.IOMode.ReadMode_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4MJx: // global
           if (_c4MJg::P64 < 4) goto c4MJe; else goto c4MJf;
       c4MJe: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MJf: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.244965225 UTC

[section ""cstring" . lvl15_r4KZ0_bytes" {
     lvl15_r4KZ0_bytes:
         I8[] [115,117,99,99,123,73,79,77,111,100,101,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.245817791 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode6_closure" {
     GHC.IO.IOMode.$fEnumIOMode6_closure:
         const GHC.IO.IOMode.$fEnumIOMode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode6_entry() //  [R1]
         { info_tbl: [(c4MJH,
                       label: GHC.IO.IOMode.$fEnumIOMode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MJH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4MJI; else goto c4MJJ;
       c4MJI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MJJ: // global
           (_c4MJC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MJC::I64 == 0) goto c4MJE; else goto c4MJD;
       c4MJE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MJD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MJC::I64;
           I64[Sp - 24] = block_c4MJF_info;
           R2 = lvl15_r4KZ0_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4MJF() //  [R1]
         { info_tbl: [(c4MJF,
                       label: block_c4MJF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MJF: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.247278789 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$csucc_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$csucc_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$csucc_entry() //  [R2]
         { info_tbl: [(c4MK0,
                       label: GHC.IO.IOMode.$fEnumIOMode_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MK0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MK1; else goto c4MK2;
       c4MK1: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MK2: // global
           I64[Sp - 8] = block_c4MJR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4MKh; else goto c4MJS;
       u4MKh: // global
           call _c4MJR(R1) args: 0, res: 0, upd: 0;
       c4MJS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MJR() //  [R1]
         { info_tbl: [(c4MJR,
                       label: block_c4MJR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MJR: // global
           _c4MJZ::P64 = R1 & 7;
           if (_c4MJZ::P64 < 3) goto u4MKf; else goto u4MKg;
       u4MKf: // global
           if (_c4MJZ::P64 < 2) goto c4MJV; else goto c4MJW;
       c4MJV: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MJW: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4MKg: // global
           if (_c4MJZ::P64 < 4) goto c4MJX; else goto c4MJY;
       c4MJX: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MJY: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.248576218 UTC

[section ""cstring" . lvl16_r4KZ1_bytes" {
     lvl16_r4KZ1_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.249131605 UTC

[section ""cstring" . lvl17_r4KZ2_bytes" {
     lvl17_r4KZ2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.24996301 UTC

[section ""data" . lvl18_r4KZ3_closure" {
     lvl18_r4KZ3_closure:
         const lvl18_r4KZ3_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_r4KZ3_entry() //  [R1]
         { info_tbl: [(c4MKo,
                       label: lvl18_r4KZ3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MKo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MKp; else goto c4MKq;
       c4MKp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MKq: // global
           (_c4MKl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MKl::I64 == 0) goto c4MKn; else goto c4MKm;
       c4MKn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MKm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MKl::I64;
           R2 = lvl17_r4KZ2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.251189089 UTC

[section ""data" . lvl19_r4KZ4_closure" {
     lvl19_r4KZ4_closure:
         const lvl19_r4KZ4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_r4KZ4_entry() //  [R1]
         { info_tbl: [(c4MKA,
                       label: lvl19_r4KZ4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MKA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4MKB; else goto c4MKC;
       c4MKB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MKC: // global
           (_c4MKu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MKu::I64 == 0) goto c4MKw; else goto c4MKv;
       c4MKw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MKv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MKu::I64;
           I64[Sp - 24] = block_c4MKx_info;
           R4 = lvl18_r4KZ3_closure;
           R3 = 3;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4MKx() //  [R1, R2]
         { info_tbl: [(c4MKx,
                       label: block_c4MKx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MKx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4MKF; else goto c4MKE;
       c4MKF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4MKE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.25258448 UTC

[section ""data" . lvl20_r4KZ5_closure" {
     lvl20_r4KZ5_closure:
         const lvl20_r4KZ5_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_r4KZ5_entry() //  [R1]
         { info_tbl: [(c4MKM,
                       label: lvl20_r4KZ5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MKM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MKN; else goto c4MKO;
       c4MKN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MKO: // global
           (_c4MKJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MKJ::I64 == 0) goto c4MKL; else goto c4MKK;
       c4MKL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MKK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MKJ::I64;
           R3 = lvl19_r4KZ4_closure;
           R2 = lvl16_r4KZ1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.253514972 UTC

[section ""cstring" . lvl21_r4KZ6_bytes" {
     lvl21_r4KZ6_bytes:
         I8[] [116,111,69,110,117,109,123,73,79,77,111,100,101,125,58,32,116,97,103,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.254574086 UTC

[section ""data" . GHC.IO.IOMode.$wlvl_closure" {
     GHC.IO.IOMode.$wlvl_closure:
         const GHC.IO.IOMode.$wlvl_info;
         const 0;
 },
 sat_s4L2g_entry() //  [R1]
         { info_tbl: [(c4ML0,
                       label: sat_s4L2g_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ML0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ML1; else goto c4ML2;
       c4ML1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ML2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4MKX_info;
           R4 = lvl20_r4KZ5_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4MKX() //  [R1, R2]
         { info_tbl: [(c4MKX,
                       label: block_c4MKX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MKX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ML5; else goto c4ML4;
       c4ML5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4ML4: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$wlvl_entry() //  [R2]
         { info_tbl: [(c4ML8,
                       label: GHC.IO.IOMode.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ML8: // global
           _s4L2c::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4ML9; else goto c4MLa;
       c4MLa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4MLc; else goto c4MLb;
       c4MLc: // global
           HpAlloc = 24;
           goto c4ML9;
       c4ML9: // global
           R2 = _s4L2c::I64;
           R1 = GHC.IO.IOMode.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MLb: // global
           I64[Hp - 16] = sat_s4L2g_info;
           I64[Hp] = _s4L2c::I64;
           I64[Sp - 8] = block_c4ML6_info;
           R3 = Hp - 16;
           R2 = lvl21_r4KZ6_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ML6() //  [R1]
         { info_tbl: [(c4ML6,
                       label: block_c4ML6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ML6: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.256437098 UTC

[section ""data" . GHC.IO.IOMode.$w$ctoEnum_closure" {
     GHC.IO.IOMode.$w$ctoEnum_closure:
         const GHC.IO.IOMode.$w$ctoEnum_info;
         const 0;
 },
 GHC.IO.IOMode.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4MLp,
                       label: GHC.IO.IOMode.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MLp: // global
           _s4L2i::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c4MLx; else goto c4MLo;
       c4MLo: // global
           if (%MO_S_Gt_W64(_s4L2i::I64, 3)) goto c4MLx; else goto c4MLy;
       c4MLx: // global
           R2 = _s4L2i::I64;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4MLy: // global
           R1 = I64[(_s4L2i::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.257607586 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4MLG,
                       label: GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MLG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MLH; else goto c4MLI;
       c4MLH: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MLI: // global
           I64[Sp - 8] = block_c4MLD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4MLM; else goto c4MLE;
       u4MLM: // global
           call _c4MLD(R1) args: 0, res: 0, upd: 0;
       c4MLE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MLD() //  [R1]
         { info_tbl: [(c4MLD,
                       label: block_c4MLD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MLD: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.258791012 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode4_closure" {
     GHC.IO.IOMode.$fEnumIOMode4_closure:
         const GHC.IO.IOMode.$fEnumIOMode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode4_entry() //  [R1]
         { info_tbl: [(c4MLT,
                       label: GHC.IO.IOMode.$fEnumIOMode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MLT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MLU; else goto c4MLV;
       c4MLU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MLV: // global
           (_c4MLQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MLQ::I64 == 0) goto c4MLS; else goto c4MLR;
       c4MLS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MLR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MLQ::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.259917536 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode3_closure" {
     GHC.IO.IOMode.$fEnumIOMode3_closure:
         const GHC.IO.IOMode.$fEnumIOMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode3_entry() //  [R1]
         { info_tbl: [(c4MM2,
                       label: GHC.IO.IOMode.$fEnumIOMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MM2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MM3; else goto c4MM4;
       c4MM3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MM4: // global
           (_c4MLZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MLZ::I64 == 0) goto c4MM1; else goto c4MM0;
       c4MM1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MM0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MLZ::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.260978157 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode2_closure" {
     GHC.IO.IOMode.$fEnumIOMode2_closure:
         const GHC.IO.IOMode.$fEnumIOMode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode2_entry() //  [R1]
         { info_tbl: [(c4MMb,
                       label: GHC.IO.IOMode.$fEnumIOMode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MMb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MMc; else goto c4MMd;
       c4MMc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MMd: // global
           (_c4MM8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MM8::I64 == 0) goto c4MMa; else goto c4MM9;
       c4MMa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MM9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MM8::I64;
           R2 = 2;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.262121273 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode1_closure" {
     GHC.IO.IOMode.$fEnumIOMode1_closure:
         const GHC.IO.IOMode.$fEnumIOMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode1_entry() //  [R1]
         { info_tbl: [(c4MMk,
                       label: GHC.IO.IOMode.$fEnumIOMode1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MMk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MMl; else goto c4MMm;
       c4MMl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MMm: // global
           (_c4MMh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4MMh::I64 == 0) goto c4MMj; else goto c4MMi;
       c4MMj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4MMi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4MMh::I64;
           R2 = 3;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.263400117 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4MMA,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MMA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4MMB; else goto c4MMC;
       c4MMB: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MMC: // global
           I64[Sp - 8] = block_c4MMr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4MMR; else goto c4MMs;
       u4MMR: // global
           call _c4MMr(R1) args: 0, res: 0, upd: 0;
       c4MMs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MMr() //  [R1]
         { info_tbl: [(c4MMr,
                       label: block_c4MMr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MMr: // global
           _c4MMz::P64 = R1 & 7;
           if (_c4MMz::P64 < 3) goto u4MMP; else goto u4MMQ;
       u4MMP: // global
           if (_c4MMz::P64 < 2) goto c4MMv; else goto c4MMw;
       c4MMv: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4MMw: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u4MMQ: // global
           if (_c4MMz::P64 < 4) goto c4MMx; else goto c4MMy;
       c4MMx: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4MMy: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.270625677 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_info;
 },
 sat_s4L2H_entry() //  [R1]
         { info_tbl: [(c4MND,
                       label: sat_s4L2H_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MND: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MNE; else goto c4MNF;
       c4MNE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MNF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L2C_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2F_entry() //  [R1]
         { info_tbl: [(c4MNK,
                       label: sat_s4L2F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MNK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MNL; else goto c4MNM;
       c4MNL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MNM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2I_entry() //  [R1]
         { info_tbl: [(c4MNS,
                       label: sat_s4L2I_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MNS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MNT; else goto c4MNU;
       c4MNT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MNU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L2C_entry() //  [R1, R2]
         { info_tbl: [(c4MNY,
                       label: go_dn_s4L2C_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MNY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4MO2; else goto c4MO1;
       c4MO2: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MO1: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4MNW; else goto c4MNX;
       c4MNW: // global
           _s4L2A::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L2H_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L2A::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L2F_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MNX: // global
           I64[Hp - 80] = sat_s4L2I_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4MO4::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4MO4::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L2J_entry() //  [R1]
         { info_tbl: [(c4MO5,
                       label: sat_s4L2J_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MO5: // global
           _s4L2J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4MO6; else goto c4MO7;
       c4MO7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4MO9; else goto c4MO8;
       c4MO9: // global
           HpAlloc = 24;
           goto c4MO6;
       c4MO6: // global
           R1 = _s4L2J::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MO8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L2J::P64;
           _s4L2v::I64 = I64[_s4L2J::P64 + 24];
           _s4L2A::I64 = _s4L2v::I64 - I64[_s4L2J::P64 + 16];
           I64[Hp - 16] = go_dn_s4L2C_info;
           I64[Hp - 8] = _s4L2A::I64;
           I64[Hp] = 3 - _s4L2A::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L2C_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2z_entry() //  [R1]
         { info_tbl: [(c4MOe,
                       label: sat_s4L2z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MOe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MOf; else goto c4MOg;
       c4MOf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MOg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2L_entry() //  [R1]
         { info_tbl: [(c4MOp,
                       label: sat_s4L2L_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MOp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MOq; else goto c4MOr;
       c4MOq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MOr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2V_entry() //  [R1]
         { info_tbl: [(c4MOU,
                       label: sat_s4L2V_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MOU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MOV; else goto c4MOW;
       c4MOV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MOW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L2Q_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2T_entry() //  [R1]
         { info_tbl: [(c4MP1,
                       label: sat_s4L2T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MP1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MP2; else goto c4MP3;
       c4MP2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MP3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2W_entry() //  [R1]
         { info_tbl: [(c4MP9,
                       label: sat_s4L2W_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MP9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MPa; else goto c4MPb;
       c4MPa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MPb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L2Q_entry() //  [R1, R2]
         { info_tbl: [(c4MPf,
                       label: go_up_s4L2Q_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MPf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4MPj; else goto c4MPi;
       c4MPj: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MPi: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4MPd; else goto c4MPe;
       c4MPd: // global
           _s4L2O::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L2V_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L2O::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L2T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MPe: // global
           I64[Hp - 80] = sat_s4L2W_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4MPl::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4MPl::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L2X_entry() //  [R1]
         { info_tbl: [(c4MPm,
                       label: sat_s4L2X_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MPm: // global
           _s4L2X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4MPn; else goto c4MPo;
       c4MPo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4MPq; else goto c4MPp;
       c4MPq: // global
           HpAlloc = 24;
           goto c4MPn;
       c4MPn: // global
           R1 = _s4L2X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MPp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L2X::P64;
           _s4L2v::I64 = I64[_s4L2X::P64 + 24];
           _s4L2O::I64 = _s4L2v::I64 - I64[_s4L2X::P64 + 16];
           I64[Hp - 16] = go_up_s4L2Q_info;
           I64[Hp - 8] = _s4L2O::I64;
           I64[Hp] = 3 - _s4L2O::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L2Q_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2N_entry() //  [R1]
         { info_tbl: [(c4MPv,
                       label: sat_s4L2N_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MPv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MPw; else goto c4MPx;
       c4MPw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MPx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2Z_entry() //  [R1]
         { info_tbl: [(c4MPG,
                       label: sat_s4L2Z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MPG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MPH; else goto c4MPI;
       c4MPH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MPI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3a_entry() //  [R1]
         { info_tbl: [(c4MQe,
                       label: sat_s4L3a_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MQe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MQf; else goto c4MQg;
       c4MQf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MQg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L35_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L38_entry() //  [R1]
         { info_tbl: [(c4MQl,
                       label: sat_s4L38_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MQl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MQm; else goto c4MQn;
       c4MQm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MQn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3b_entry() //  [R1]
         { info_tbl: [(c4MQt,
                       label: sat_s4L3b_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MQt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MQu; else goto c4MQv;
       c4MQu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MQv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L35_entry() //  [R1, R2]
         { info_tbl: [(c4MQz,
                       label: go_dn_s4L35_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MQz: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4MQD; else goto c4MQC;
       c4MQD: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MQC: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4MQx; else goto c4MQy;
       c4MQx: // global
           _s4L33::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L3a_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L33::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L38_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MQy: // global
           I64[Hp - 80] = sat_s4L3b_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4MQF::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4MQF::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L3c_entry() //  [R1]
         { info_tbl: [(c4MQG,
                       label: sat_s4L3c_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MQG: // global
           _s4L3c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4MQH; else goto c4MQI;
       c4MQI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4MQK; else goto c4MQJ;
       c4MQK: // global
           HpAlloc = 24;
           goto c4MQH;
       c4MQH: // global
           R1 = _s4L3c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MQJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L3c::P64;
           _s4L2v::I64 = I64[_s4L3c::P64 + 24];
           _s4L33::I64 = _s4L2v::I64 - I64[_s4L3c::P64 + 16];
           I64[Hp - 16] = go_dn_s4L35_info;
           I64[Hp - 8] = _s4L33::I64;
           I64[Hp] = 0 - _s4L33::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L35_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L32_entry() //  [R1]
         { info_tbl: [(c4MQP,
                       label: sat_s4L32_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MQP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MQQ; else goto c4MQR;
       c4MQQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MQR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3e_entry() //  [R1]
         { info_tbl: [(c4MR0,
                       label: sat_s4L3e_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MR0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MR1; else goto c4MR2;
       c4MR1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MR2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3o_entry() //  [R1]
         { info_tbl: [(c4MRv,
                       label: sat_s4L3o_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MRv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MRw; else goto c4MRx;
       c4MRw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MRx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L3j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3m_entry() //  [R1]
         { info_tbl: [(c4MRC,
                       label: sat_s4L3m_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MRC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MRD; else goto c4MRE;
       c4MRD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MRE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3p_entry() //  [R1]
         { info_tbl: [(c4MRK,
                       label: sat_s4L3p_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MRK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MRL; else goto c4MRM;
       c4MRL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MRM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L3j_entry() //  [R1, R2]
         { info_tbl: [(c4MRQ,
                       label: go_up_s4L3j_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MRQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4MRU; else goto c4MRT;
       c4MRU: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MRT: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4MRO; else goto c4MRP;
       c4MRO: // global
           _s4L3h::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L3o_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L3h::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3m_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MRP: // global
           I64[Hp - 80] = sat_s4L3p_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4MRW::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4MRW::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L3q_entry() //  [R1]
         { info_tbl: [(c4MRX,
                       label: sat_s4L3q_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MRX: // global
           _s4L3q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4MRY; else goto c4MRZ;
       c4MRZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4MS1; else goto c4MS0;
       c4MS1: // global
           HpAlloc = 24;
           goto c4MRY;
       c4MRY: // global
           R1 = _s4L3q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MS0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L3q::P64;
           _s4L2v::I64 = I64[_s4L3q::P64 + 24];
           _s4L3h::I64 = _s4L2v::I64 - I64[_s4L3q::P64 + 16];
           I64[Hp - 16] = go_up_s4L3j_info;
           I64[Hp - 8] = _s4L3h::I64;
           I64[Hp] = 0 - _s4L3h::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L3j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3g_entry() //  [R1]
         { info_tbl: [(c4MS6,
                       label: sat_s4L3g_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MS6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MS7; else goto c4MS8;
       c4MS7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MS8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3s_entry() //  [R1]
         { info_tbl: [(c4MSh,
                       label: sat_s4L3s_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MSh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MSi; else goto c4MSj;
       c4MSi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MSj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4MSt,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MSt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MSu; else goto c4MSv;
       c4MSu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MSv: // global
           I64[Sp - 16] = block_c4MSk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MTX; else goto c4MSl;
       u4MTX: // global
           call _c4MSk(R1) args: 0, res: 0, upd: 0;
       c4MSl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MSk() //  [R1]
         { info_tbl: [(c4MSk,
                       label: block_c4MSk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MSk: // global
           _s4L2r::P64 = P64[Sp + 8];
           _c4MSs::P64 = R1 & 7;
           if (_c4MSs::P64 < 3) goto u4MTM; else goto u4MTN;
       u4MTM: // global
           if (_c4MSs::P64 < 2) goto c4MSo; else goto c4MSp;
       c4MSo: // global
           _s4L2t::I64 = 0;
           goto s4L2s;
       c4MSp: // global
           _s4L2t::I64 = 1;
           goto s4L2s;
       u4MTN: // global
           if (_c4MSs::P64 < 4) goto c4MSq; else goto c4MSr;
       c4MSq: // global
           _s4L2t::I64 = 2;
           goto s4L2s;
       c4MSr: // global
           _s4L2t::I64 = 3;
           goto s4L2s;
       s4L2s: // global
           I64[Sp] = block_c4MSw_info;
           R1 = _s4L2r::P64;
           I64[Sp + 8] = _s4L2t::I64;
           if (R1 & 7 != 0) goto u4MTW; else goto c4MTg;
       u4MTW: // global
           call _c4MSw(R1) args: 0, res: 0, upd: 0;
       c4MTg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MSw() //  [R1]
         { info_tbl: [(c4MSw,
                       label: block_c4MSw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MSw: // global
           _c4MTL::P64 = R1 & 7;
           if (_c4MTL::P64 < 3) goto u4MTO; else goto u4MTP;
       u4MTO: // global
           if (_c4MTL::P64 < 2) goto c4MTm; else goto c4MTq;
       c4MTm: // global
           I64[Sp] = 0;
           goto u4MU1;
       c4MTq: // global
           I64[Sp] = 1;
           goto u4MU1;
       u4MTP: // global
           if (_c4MTL::P64 < 4) goto c4MTu; else goto c4MTy;
       c4MTu: // global
           I64[Sp] = 2;
           goto u4MU1;
       c4MTy: // global
           I64[Sp] = 3;
           goto u4MU1;
       u4MU1: // global
           call _c4MN4() args: 0, res: 0, upd: 0;
     }
 },
 _c4MN4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MN4: // global
           Hp = Hp + 80;
           _s4L2v::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c4MSA; else goto c4MSz;
       c4MSA: // global
           HpAlloc = 80;
           I64[Sp] = block_c4MN3_info;
           R1 = _s4L2v::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4MSz: // global
           _s4L2t::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_s4L2t::I64,
                            _s4L2v::I64)) goto c4MSV; else goto c4MTf;
       c4MSV: // global
           if (%MO_S_Lt_W64(_s4L2v::I64,
                            _s4L2t::I64)) goto c4MSK; else goto c4MST;
       c4MSK: // global
           if (%MO_S_Le_W64(3, _s4L2v::I64)) goto c4MSD; else goto c4MSI;
       c4MSD: // global
           I64[Hp - 72] = sat_s4L2J_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L2z_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MSI: // global
           if (%MO_S_Gt_W64(3, _s4L2t::I64)) goto c4MTc; else goto c4MSG;
       c4MSG: // global
           I64[Hp - 72] = sat_s4L2L_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4MSE::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4MSE::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MST: // global
           if (%MO_S_Ge_W64(3, _s4L2v::I64)) goto c4MSN; else goto c4MSS;
       c4MSN: // global
           I64[Hp - 72] = sat_s4L2X_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L2N_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MSS: // global
           if (%MO_S_Lt_W64(3, _s4L2t::I64)) goto c4MTc; else goto c4MSQ;
       c4MSQ: // global
           I64[Hp - 72] = sat_s4L2Z_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4MSO::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4MSO::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MTf: // global
           if (%MO_S_Lt_W64(_s4L2v::I64,
                            _s4L2t::I64)) goto c4MT5; else goto c4MTe;
       c4MT5: // global
           if (%MO_S_Le_W64(0, _s4L2v::I64)) goto c4MSY; else goto c4MT3;
       c4MSY: // global
           I64[Hp - 72] = sat_s4L3c_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L32_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MT3: // global
           if (%MO_S_Gt_W64(0, _s4L2t::I64)) goto c4MTc; else goto c4MT1;
       c4MT1: // global
           I64[Hp - 72] = sat_s4L3e_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4MSZ::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4MSZ::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MTe: // global
           if (%MO_S_Ge_W64(0, _s4L2v::I64)) goto c4MT8; else goto c4MTd;
       c4MT8: // global
           I64[Hp - 72] = sat_s4L3q_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L3g_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MTd: // global
           if (%MO_S_Lt_W64(0, _s4L2t::I64)) goto c4MTc; else goto c4MTb;
       c4MTc: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MTb: // global
           I64[Hp - 72] = sat_s4L3s_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4MT9::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4MT9::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4MN3() //  [R1]
         { info_tbl: [(c4MN3,
                       label: block_c4MN3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MN3: // global
           I64[Sp] = R1;
           call _c4MN4() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.286440052 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go3_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go3_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go3_info;
         const 0;
 },
 sat_s4L3B_entry() //  [R1]
         { info_tbl: [(c4MUe,
                       label: sat_s4L3B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MUe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MUf; else goto c4MUg;
       c4MUf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MUg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3z::I64 = I64[R1 + 16];
           if (_s4L3z::I64 != 0) goto c4MUc; else goto c4MUd;
       c4MUc: // global
           R2 = _s4L3z::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go3_entry(R2) args: 24, res: 0, upd: 24;
       c4MUd: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3y_entry() //  [R1]
         { info_tbl: [(c4MUs,
                       label: sat_s4L3y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MUs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MUt; else goto c4MUB;
       c4MUt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MUB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3v::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3v::I64, 0)) goto c4MUz; else goto c4MUr;
       c4MUr: // global
           if (%MO_S_Gt_W64(_s4L3v::I64, 3)) goto c4MUz; else goto c4MUA;
       c4MUz: // global
           R2 = _s4L3v::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4MUA: // global
           R1 = I64[(_s4L3v::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go3_entry() //  [R2]
         { info_tbl: [(c4MUD,
                       label: GHC.IO.IOMode.$fEnumIOMode_go3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MUD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4MUH; else goto c4MUG;
       c4MUH: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MUG: // global
           I64[Hp - 64] = sat_s4L3B_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3y_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.2887533 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go2_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go2_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go2_info;
         const 0;
 },
 sat_s4L3I_entry() //  [R1]
         { info_tbl: [(c4MUU,
                       label: sat_s4L3I_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MUU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MUV; else goto c4MUW;
       c4MUV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MUW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3G::I64 = I64[R1 + 16];
           if (_s4L3G::I64 != 1) goto c4MUS; else goto c4MUT;
       c4MUS: // global
           R2 = _s4L3G::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go2_entry(R2) args: 24, res: 0, upd: 24;
       c4MUT: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3F_entry() //  [R1]
         { info_tbl: [(c4MV8,
                       label: sat_s4L3F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MV8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MV9; else goto c4MVh;
       c4MV9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MVh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3C::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3C::I64, 0)) goto c4MVf; else goto c4MV7;
       c4MV7: // global
           if (%MO_S_Gt_W64(_s4L3C::I64, 3)) goto c4MVf; else goto c4MVg;
       c4MVf: // global
           R2 = _s4L3C::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4MVg: // global
           R1 = I64[(_s4L3C::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go2_entry() //  [R2]
         { info_tbl: [(c4MVj,
                       label: GHC.IO.IOMode.$fEnumIOMode_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MVj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4MVn; else goto c4MVm;
       c4MVn: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MVm: // global
           I64[Hp - 64] = sat_s4L3I_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3F_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.291021551 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go1_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go1_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go1_info;
         const 0;
 },
 sat_s4L3P_entry() //  [R1]
         { info_tbl: [(c4MVA,
                       label: sat_s4L3P_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MVA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MVB; else goto c4MVC;
       c4MVB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MVC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3N::I64 = I64[R1 + 16];
           if (_s4L3N::I64 != 2) goto c4MVy; else goto c4MVz;
       c4MVy: // global
           R2 = _s4L3N::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go1_entry(R2) args: 24, res: 0, upd: 24;
       c4MVz: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3M_entry() //  [R1]
         { info_tbl: [(c4MVO,
                       label: sat_s4L3M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MVO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MVP; else goto c4MVX;
       c4MVP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MVX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3J::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3J::I64, 0)) goto c4MVV; else goto c4MVN;
       c4MVN: // global
           if (%MO_S_Gt_W64(_s4L3J::I64, 3)) goto c4MVV; else goto c4MVW;
       c4MVV: // global
           R2 = _s4L3J::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4MVW: // global
           R1 = I64[(_s4L3J::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go1_entry() //  [R2]
         { info_tbl: [(c4MVZ,
                       label: GHC.IO.IOMode.$fEnumIOMode_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MVZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4MW3; else goto c4MW2;
       c4MW3: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MW2: // global
           I64[Hp - 64] = sat_s4L3P_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3M_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.293353482 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go_info;
         const 0;
 },
 sat_s4L3W_entry() //  [R1]
         { info_tbl: [(c4MWg,
                       label: sat_s4L3W_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MWg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MWh; else goto c4MWi;
       c4MWh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MWi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3U::I64 = I64[R1 + 16];
           if (_s4L3U::I64 != 3) goto c4MWe; else goto c4MWf;
       c4MWe: // global
           R2 = _s4L3U::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go_entry(R2) args: 24, res: 0, upd: 24;
       c4MWf: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3T_entry() //  [R1]
         { info_tbl: [(c4MWu,
                       label: sat_s4L3T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MWu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MWv; else goto c4MWD;
       c4MWv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MWD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3Q::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3Q::I64, 0)) goto c4MWB; else goto c4MWt;
       c4MWt: // global
           if (%MO_S_Gt_W64(_s4L3Q::I64, 3)) goto c4MWB; else goto c4MWC;
       c4MWB: // global
           R2 = _s4L3Q::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4MWC: // global
           R1 = I64[(_s4L3Q::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go_entry() //  [R2]
         { info_tbl: [(c4MWF,
                       label: GHC.IO.IOMode.$fEnumIOMode_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MWF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4MWJ; else goto c4MWI;
       c4MWJ: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MWI: // global
           I64[Hp - 64] = sat_s4L3W_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.295743866 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4MWZ,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MWZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MX0; else goto c4MX1;
       c4MX0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4MX1: // global
           I64[Sp - 16] = block_c4MWQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4MY2; else goto c4MWR;
       u4MY2: // global
           call _c4MWQ(R1) args: 0, res: 0, upd: 0;
       c4MWR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MWQ() //  [R1]
         { info_tbl: [(c4MWQ,
                       label: block_c4MWQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MWQ: // global
           _s4L3Y::P64 = P64[Sp + 8];
           _c4MWY::P64 = R1 & 7;
           if (_c4MWY::P64 < 3) goto u4MXX; else goto u4MXY;
       u4MXX: // global
           if (_c4MWY::P64 < 2) goto c4MWU; else goto c4MWV;
       c4MWU: // global
           _s4L40::I64 = 0;
           goto s4L3Z;
       c4MWV: // global
           _s4L40::I64 = 1;
           goto s4L3Z;
       u4MXY: // global
           if (_c4MWY::P64 < 4) goto c4MWW; else goto c4MWX;
       c4MWW: // global
           _s4L40::I64 = 2;
           goto s4L3Z;
       c4MWX: // global
           _s4L40::I64 = 3;
           goto s4L3Z;
       s4L3Z: // global
           I64[Sp] = block_c4MX5_info;
           R1 = _s4L3Y::P64;
           I64[Sp + 8] = _s4L40::I64;
           if (R1 & 7 != 0) goto u4MY1; else goto c4MX7;
       u4MY1: // global
           call _c4MX5(R1) args: 0, res: 0, upd: 0;
       c4MX7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MX5() //  [R1]
         { info_tbl: [(c4MX5,
                       label: block_c4MX5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MX5: // global
           _s4L40::I64 = I64[Sp + 8];
           _c4MXW::P64 = R1 & 7;
           if (_c4MXW::P64 < 3) goto u4MXZ; else goto u4MY0;
       u4MXZ: // global
           if (_c4MXW::P64 < 2) goto c4MXi; else goto c4MXr;
       c4MXi: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 0)) goto c4MXI; else goto c4MXf;
       c4MXf: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go3_entry(R2) args: 8, res: 0, upd: 8;
       c4MXr: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 1)) goto c4MXI; else goto c4MXp;
       c4MXp: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go2_entry(R2) args: 8, res: 0, upd: 8;
       u4MY0: // global
           if (_c4MXW::P64 < 4) goto c4MXA; else goto c4MXJ;
       c4MXA: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 2)) goto c4MXI; else goto c4MXy;
       c4MXy: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go1_entry(R2) args: 8, res: 0, upd: 8;
       c4MXJ: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 3)) goto c4MXI; else goto c4MXH;
       c4MXI: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MXH: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.313551617 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_info;
         const 0;
 },
 sat_s4L4t_entry() //  [R1]
         { info_tbl: [(c4MYQ,
                       label: sat_s4L4t_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MYQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MYR; else goto c4MYS;
       c4MYR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MYS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L4m_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4r_entry() //  [R1]
         { info_tbl: [(c4MZ2,
                       label: sat_s4L4r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MZ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MZ3; else goto c4MZb;
       c4MZ3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MZb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4n::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4n::I64, 0)) goto c4MZ9; else goto c4MZ1;
       c4MZ1: // global
           if (%MO_S_Gt_W64(_s4L4n::I64, 3)) goto c4MZ9; else goto c4MZa;
       c4MZ9: // global
           R2 = _s4L4n::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4MZa: // global
           R1 = I64[(_s4L4n::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4w_entry() //  [R1]
         { info_tbl: [(c4MZm,
                       label: sat_s4L4w_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MZm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MZn; else goto c4MZv;
       c4MZn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MZv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4n::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4n::I64, 0)) goto c4MZt; else goto c4MZl;
       c4MZl: // global
           if (%MO_S_Gt_W64(_s4L4n::I64, 3)) goto c4MZt; else goto c4MZu;
       c4MZt: // global
           R2 = _s4L4n::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4MZu: // global
           R1 = I64[(_s4L4n::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L4m_entry() //  [R1, R2]
         { info_tbl: [(c4MZz,
                       label: go_dn_s4L4m_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MZz: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4MZD; else goto c4MZC;
       c4MZD: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4MZC: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4MZx; else goto c4MZy;
       c4MZx: // global
           _s4L4k::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L4t_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L4k::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L4r_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4MZy: // global
           I64[Hp - 80] = sat_s4L4w_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4MZF::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4MZF::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L4x_entry() //  [R1]
         { info_tbl: [(c4MZG,
                       label: sat_s4L4x_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MZG: // global
           _s4L4x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4MZH; else goto c4MZI;
       c4MZI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4MZK; else goto c4MZJ;
       c4MZK: // global
           HpAlloc = 24;
           goto c4MZH;
       c4MZH: // global
           R1 = _s4L4x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4MZJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L4x::P64;
           _s4L4d::I64 = I64[_s4L4x::P64 + 24];
           _s4L4k::I64 = _s4L4d::I64 - I64[_s4L4x::P64 + 16];
           I64[Hp - 16] = go_dn_s4L4m_info;
           I64[Hp - 8] = _s4L4k::I64;
           I64[Hp] = 0 - _s4L4k::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L4m_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4j_entry() //  [R1]
         { info_tbl: [(c4MZU,
                       label: sat_s4L4j_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MZU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4MZV; else goto c4N03;
       c4MZV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N03: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N01; else goto c4MZT;
       c4MZT: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N01; else goto c4N02;
       c4N01: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N02: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4B_entry() //  [R1]
         { info_tbl: [(c4N0h,
                       label: sat_s4L4B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N0h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N0i; else goto c4N0q;
       c4N0i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N0q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N0o; else goto c4N0g;
       c4N0g: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N0o; else goto c4N0p;
       c4N0o: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N0p: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4P_entry() //  [R1]
         { info_tbl: [(c4N0T,
                       label: sat_s4L4P_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N0T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N0U; else goto c4N0V;
       c4N0U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N0V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L4I_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4N_entry() //  [R1]
         { info_tbl: [(c4N15,
                       label: sat_s4L4N_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N15: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N16; else goto c4N1e;
       c4N16: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N1e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4J::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4J::I64, 0)) goto c4N1c; else goto c4N14;
       c4N14: // global
           if (%MO_S_Gt_W64(_s4L4J::I64, 3)) goto c4N1c; else goto c4N1d;
       c4N1c: // global
           R2 = _s4L4J::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N1d: // global
           R1 = I64[(_s4L4J::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4S_entry() //  [R1]
         { info_tbl: [(c4N1p,
                       label: sat_s4L4S_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N1p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N1q; else goto c4N1y;
       c4N1q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N1y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4J::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4J::I64, 0)) goto c4N1w; else goto c4N1o;
       c4N1o: // global
           if (%MO_S_Gt_W64(_s4L4J::I64, 3)) goto c4N1w; else goto c4N1x;
       c4N1w: // global
           R2 = _s4L4J::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N1x: // global
           R1 = I64[(_s4L4J::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L4I_entry() //  [R1, R2]
         { info_tbl: [(c4N1C,
                       label: go_up_s4L4I_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N1C: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4N1G; else goto c4N1F;
       c4N1G: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4N1F: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4N1A; else goto c4N1B;
       c4N1A: // global
           _s4L4G::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L4P_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L4G::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L4N_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4N1B: // global
           I64[Hp - 80] = sat_s4L4S_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4N1I::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4N1I::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L4T_entry() //  [R1]
         { info_tbl: [(c4N1J,
                       label: sat_s4L4T_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N1J: // global
           _s4L4T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4N1K; else goto c4N1L;
       c4N1L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4N1N; else goto c4N1M;
       c4N1N: // global
           HpAlloc = 24;
           goto c4N1K;
       c4N1K: // global
           R1 = _s4L4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N1M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L4T::P64;
           _s4L4d::I64 = I64[_s4L4T::P64 + 24];
           _s4L4G::I64 = _s4L4d::I64 - I64[_s4L4T::P64 + 16];
           I64[Hp - 16] = go_up_s4L4I_info;
           I64[Hp - 8] = _s4L4G::I64;
           I64[Hp] = 0 - _s4L4G::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L4I_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4F_entry() //  [R1]
         { info_tbl: [(c4N1X,
                       label: sat_s4L4F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N1X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N1Y; else goto c4N26;
       c4N1Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N26: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N24; else goto c4N1W;
       c4N1W: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N24; else goto c4N25;
       c4N24: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N25: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4X_entry() //  [R1]
         { info_tbl: [(c4N2k,
                       label: sat_s4L4X_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N2k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N2l; else goto c4N2t;
       c4N2l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N2t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N2r; else goto c4N2j;
       c4N2j: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N2r; else goto c4N2s;
       c4N2r: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N2s: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5c_entry() //  [R1]
         { info_tbl: [(c4N30,
                       label: sat_s4L5c_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N30: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N31; else goto c4N32;
       c4N31: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N32: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L55_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5a_entry() //  [R1]
         { info_tbl: [(c4N3c,
                       label: sat_s4L5a_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N3c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N3d; else goto c4N3l;
       c4N3d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N3l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L56::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L56::I64, 0)) goto c4N3j; else goto c4N3b;
       c4N3b: // global
           if (%MO_S_Gt_W64(_s4L56::I64, 3)) goto c4N3j; else goto c4N3k;
       c4N3j: // global
           R2 = _s4L56::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N3k: // global
           R1 = I64[(_s4L56::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5f_entry() //  [R1]
         { info_tbl: [(c4N3w,
                       label: sat_s4L5f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N3w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N3x; else goto c4N3F;
       c4N3x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N3F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L56::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L56::I64, 0)) goto c4N3D; else goto c4N3v;
       c4N3v: // global
           if (%MO_S_Gt_W64(_s4L56::I64, 3)) goto c4N3D; else goto c4N3E;
       c4N3D: // global
           R2 = _s4L56::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N3E: // global
           R1 = I64[(_s4L56::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L55_entry() //  [R1, R2]
         { info_tbl: [(c4N3J,
                       label: go_dn_s4L55_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N3J: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4N3N; else goto c4N3M;
       c4N3N: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4N3M: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4N3H; else goto c4N3I;
       c4N3H: // global
           _s4L53::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L5c_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L53::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L5a_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4N3I: // global
           I64[Hp - 80] = sat_s4L5f_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4N3P::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4N3P::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L5g_entry() //  [R1]
         { info_tbl: [(c4N3Q,
                       label: sat_s4L5g_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N3Q: // global
           _s4L5g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4N3R; else goto c4N3S;
       c4N3S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4N3U; else goto c4N3T;
       c4N3U: // global
           HpAlloc = 24;
           goto c4N3R;
       c4N3R: // global
           R1 = _s4L5g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N3T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L5g::P64;
           _s4L4d::I64 = I64[_s4L5g::P64 + 24];
           _s4L53::I64 = _s4L4d::I64 - I64[_s4L5g::P64 + 16];
           I64[Hp - 16] = go_dn_s4L55_info;
           I64[Hp - 8] = _s4L53::I64;
           I64[Hp] = 1 - _s4L53::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L55_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L52_entry() //  [R1]
         { info_tbl: [(c4N44,
                       label: sat_s4L52_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N44: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N45; else goto c4N4d;
       c4N45: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N4d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N4b; else goto c4N43;
       c4N43: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N4b; else goto c4N4c;
       c4N4b: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N4c: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5k_entry() //  [R1]
         { info_tbl: [(c4N4r,
                       label: sat_s4L5k_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N4r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N4s; else goto c4N4A;
       c4N4s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N4A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N4y; else goto c4N4q;
       c4N4q: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N4y; else goto c4N4z;
       c4N4y: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N4z: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5y_entry() //  [R1]
         { info_tbl: [(c4N53,
                       label: sat_s4L5y_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N53: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N54; else goto c4N55;
       c4N54: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N55: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L5r_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5w_entry() //  [R1]
         { info_tbl: [(c4N5f,
                       label: sat_s4L5w_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N5f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N5g; else goto c4N5o;
       c4N5g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N5o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5s::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5s::I64, 0)) goto c4N5m; else goto c4N5e;
       c4N5e: // global
           if (%MO_S_Gt_W64(_s4L5s::I64, 3)) goto c4N5m; else goto c4N5n;
       c4N5m: // global
           R2 = _s4L5s::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N5n: // global
           R1 = I64[(_s4L5s::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5B_entry() //  [R1]
         { info_tbl: [(c4N5z,
                       label: sat_s4L5B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N5A; else goto c4N5I;
       c4N5A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N5I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5s::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5s::I64, 0)) goto c4N5G; else goto c4N5y;
       c4N5y: // global
           if (%MO_S_Gt_W64(_s4L5s::I64, 3)) goto c4N5G; else goto c4N5H;
       c4N5G: // global
           R2 = _s4L5s::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N5H: // global
           R1 = I64[(_s4L5s::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L5r_entry() //  [R1, R2]
         { info_tbl: [(c4N5M,
                       label: go_up_s4L5r_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N5M: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4N5Q; else goto c4N5P;
       c4N5Q: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4N5P: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4N5K; else goto c4N5L;
       c4N5K: // global
           _s4L5p::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L5y_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L5p::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L5w_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4N5L: // global
           I64[Hp - 80] = sat_s4L5B_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4N5S::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4N5S::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L5C_entry() //  [R1]
         { info_tbl: [(c4N5T,
                       label: sat_s4L5C_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N5T: // global
           _s4L5C::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4N5U; else goto c4N5V;
       c4N5V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4N5X; else goto c4N5W;
       c4N5X: // global
           HpAlloc = 24;
           goto c4N5U;
       c4N5U: // global
           R1 = _s4L5C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N5W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L5C::P64;
           _s4L4d::I64 = I64[_s4L5C::P64 + 24];
           _s4L5p::I64 = _s4L4d::I64 - I64[_s4L5C::P64 + 16];
           I64[Hp - 16] = go_up_s4L5r_info;
           I64[Hp - 8] = _s4L5p::I64;
           I64[Hp] = 1 - _s4L5p::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L5r_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5o_entry() //  [R1]
         { info_tbl: [(c4N67,
                       label: sat_s4L5o_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N67: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N68; else goto c4N6g;
       c4N68: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N6g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N6e; else goto c4N66;
       c4N66: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N6e; else goto c4N6f;
       c4N6e: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N6f: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5G_entry() //  [R1]
         { info_tbl: [(c4N6u,
                       label: sat_s4L5G_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N6u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N6v; else goto c4N6D;
       c4N6v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N6D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N6B; else goto c4N6t;
       c4N6t: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N6B; else goto c4N6C;
       c4N6B: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N6C: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5V_entry() //  [R1]
         { info_tbl: [(c4N7a,
                       label: sat_s4L5V_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N7a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N7b; else goto c4N7c;
       c4N7b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N7c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L5O_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5T_entry() //  [R1]
         { info_tbl: [(c4N7m,
                       label: sat_s4L5T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N7m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N7n; else goto c4N7v;
       c4N7n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N7v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5P::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5P::I64, 0)) goto c4N7t; else goto c4N7l;
       c4N7l: // global
           if (%MO_S_Gt_W64(_s4L5P::I64, 3)) goto c4N7t; else goto c4N7u;
       c4N7t: // global
           R2 = _s4L5P::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N7u: // global
           R1 = I64[(_s4L5P::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5Y_entry() //  [R1]
         { info_tbl: [(c4N7G,
                       label: sat_s4L5Y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N7G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N7H; else goto c4N7P;
       c4N7H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N7P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5P::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5P::I64, 0)) goto c4N7N; else goto c4N7F;
       c4N7F: // global
           if (%MO_S_Gt_W64(_s4L5P::I64, 3)) goto c4N7N; else goto c4N7O;
       c4N7N: // global
           R2 = _s4L5P::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N7O: // global
           R1 = I64[(_s4L5P::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L5O_entry() //  [R1, R2]
         { info_tbl: [(c4N7T,
                       label: go_dn_s4L5O_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N7T: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4N7X; else goto c4N7W;
       c4N7X: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4N7W: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4N7R; else goto c4N7S;
       c4N7R: // global
           _s4L5M::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L5V_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L5M::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L5T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4N7S: // global
           I64[Hp - 80] = sat_s4L5Y_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4N7Z::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4N7Z::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L5Z_entry() //  [R1]
         { info_tbl: [(c4N80,
                       label: sat_s4L5Z_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N80: // global
           _s4L5Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4N81; else goto c4N82;
       c4N82: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4N84; else goto c4N83;
       c4N84: // global
           HpAlloc = 24;
           goto c4N81;
       c4N81: // global
           R1 = _s4L5Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N83: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L5Z::P64;
           _s4L4d::I64 = I64[_s4L5Z::P64 + 24];
           _s4L5M::I64 = _s4L4d::I64 - I64[_s4L5Z::P64 + 16];
           I64[Hp - 16] = go_dn_s4L5O_info;
           I64[Hp - 8] = _s4L5M::I64;
           I64[Hp] = 2 - _s4L5M::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L5O_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5L_entry() //  [R1]
         { info_tbl: [(c4N8e,
                       label: sat_s4L5L_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N8e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N8f; else goto c4N8n;
       c4N8f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N8n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N8l; else goto c4N8d;
       c4N8d: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N8l; else goto c4N8m;
       c4N8l: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N8m: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L63_entry() //  [R1]
         { info_tbl: [(c4N8B,
                       label: sat_s4L63_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N8B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N8C; else goto c4N8K;
       c4N8C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N8K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4N8I; else goto c4N8A;
       c4N8A: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4N8I; else goto c4N8J;
       c4N8I: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N8J: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6h_entry() //  [R1]
         { info_tbl: [(c4N9d,
                       label: sat_s4L6h_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N9d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N9e; else goto c4N9f;
       c4N9e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N9f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L6a_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6f_entry() //  [R1]
         { info_tbl: [(c4N9p,
                       label: sat_s4L6f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N9p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N9q; else goto c4N9y;
       c4N9q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N9y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6b::I64, 0)) goto c4N9w; else goto c4N9o;
       c4N9o: // global
           if (%MO_S_Gt_W64(_s4L6b::I64, 3)) goto c4N9w; else goto c4N9x;
       c4N9w: // global
           R2 = _s4L6b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N9x: // global
           R1 = I64[(_s4L6b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6k_entry() //  [R1]
         { info_tbl: [(c4N9J,
                       label: sat_s4L6k_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N9J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4N9K; else goto c4N9S;
       c4N9K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4N9S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6b::I64, 0)) goto c4N9Q; else goto c4N9I;
       c4N9I: // global
           if (%MO_S_Gt_W64(_s4L6b::I64, 3)) goto c4N9Q; else goto c4N9R;
       c4N9Q: // global
           R2 = _s4L6b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4N9R: // global
           R1 = I64[(_s4L6b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L6a_entry() //  [R1, R2]
         { info_tbl: [(c4N9W,
                       label: go_up_s4L6a_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4N9W: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Na0; else goto c4N9Z;
       c4Na0: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4N9Z: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4N9U; else goto c4N9V;
       c4N9U: // global
           _s4L68::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L6h_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L68::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L6f_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4N9V: // global
           I64[Hp - 80] = sat_s4L6k_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Na2::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Na2::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L6l_entry() //  [R1]
         { info_tbl: [(c4Na3,
                       label: sat_s4L6l_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Na3: // global
           _s4L6l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Na4; else goto c4Na5;
       c4Na5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Na7; else goto c4Na6;
       c4Na7: // global
           HpAlloc = 24;
           goto c4Na4;
       c4Na4: // global
           R1 = _s4L6l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Na6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L6l::P64;
           _s4L4d::I64 = I64[_s4L6l::P64 + 24];
           _s4L68::I64 = _s4L4d::I64 - I64[_s4L6l::P64 + 16];
           I64[Hp - 16] = go_up_s4L6a_info;
           I64[Hp - 8] = _s4L68::I64;
           I64[Hp] = 2 - _s4L68::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L6a_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L67_entry() //  [R1]
         { info_tbl: [(c4Nah,
                       label: sat_s4L67_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nah: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nai; else goto c4Naq;
       c4Nai: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Naq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Nao; else goto c4Nag;
       c4Nag: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Nao; else goto c4Nap;
       c4Nao: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Nap: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6p_entry() //  [R1]
         { info_tbl: [(c4NaE,
                       label: sat_s4L6p_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NaE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NaF; else goto c4NaN;
       c4NaF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NaN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4NaL; else goto c4NaD;
       c4NaD: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4NaL; else goto c4NaM;
       c4NaL: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4NaM: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6E_entry() //  [R1]
         { info_tbl: [(c4Nbk,
                       label: sat_s4L6E_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nbk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nbl; else goto c4Nbm;
       c4Nbl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Nbm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L6x_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6C_entry() //  [R1]
         { info_tbl: [(c4Nbw,
                       label: sat_s4L6C_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nbw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nbx; else goto c4NbF;
       c4Nbx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NbF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6y::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6y::I64, 0)) goto c4NbD; else goto c4Nbv;
       c4Nbv: // global
           if (%MO_S_Gt_W64(_s4L6y::I64, 3)) goto c4NbD; else goto c4NbE;
       c4NbD: // global
           R2 = _s4L6y::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4NbE: // global
           R1 = I64[(_s4L6y::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6H_entry() //  [R1]
         { info_tbl: [(c4NbQ,
                       label: sat_s4L6H_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NbQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NbR; else goto c4NbZ;
       c4NbR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NbZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6y::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6y::I64, 0)) goto c4NbX; else goto c4NbP;
       c4NbP: // global
           if (%MO_S_Gt_W64(_s4L6y::I64, 3)) goto c4NbX; else goto c4NbY;
       c4NbX: // global
           R2 = _s4L6y::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4NbY: // global
           R1 = I64[(_s4L6y::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L6x_entry() //  [R1, R2]
         { info_tbl: [(c4Nc3,
                       label: go_dn_s4L6x_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nc3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Nc7; else goto c4Nc6;
       c4Nc7: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Nc6: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4Nc1; else goto c4Nc2;
       c4Nc1: // global
           _s4L6v::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L6E_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L6v::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L6C_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Nc2: // global
           I64[Hp - 80] = sat_s4L6H_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Nc9::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Nc9::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L6I_entry() //  [R1]
         { info_tbl: [(c4Nca,
                       label: sat_s4L6I_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nca: // global
           _s4L6I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ncb; else goto c4Ncc;
       c4Ncc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Nce; else goto c4Ncd;
       c4Nce: // global
           HpAlloc = 24;
           goto c4Ncb;
       c4Ncb: // global
           R1 = _s4L6I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ncd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L6I::P64;
           _s4L4d::I64 = I64[_s4L6I::P64 + 24];
           _s4L6v::I64 = _s4L4d::I64 - I64[_s4L6I::P64 + 16];
           I64[Hp - 16] = go_dn_s4L6x_info;
           I64[Hp - 8] = _s4L6v::I64;
           I64[Hp] = 3 - _s4L6v::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L6x_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6u_entry() //  [R1]
         { info_tbl: [(c4Nco,
                       label: sat_s4L6u_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nco: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ncp; else goto c4Ncx;
       c4Ncp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ncx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Ncv; else goto c4Ncn;
       c4Ncn: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Ncv; else goto c4Ncw;
       c4Ncv: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Ncw: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6M_entry() //  [R1]
         { info_tbl: [(c4NcL,
                       label: sat_s4L6M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NcL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NcM; else goto c4NcU;
       c4NcM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NcU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4NcS; else goto c4NcK;
       c4NcK: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4NcS; else goto c4NcT;
       c4NcS: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4NcT: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L70_entry() //  [R1]
         { info_tbl: [(c4Ndn,
                       label: sat_s4L70_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ndn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ndo; else goto c4Ndp;
       c4Ndo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ndp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L6T_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6Y_entry() //  [R1]
         { info_tbl: [(c4Ndz,
                       label: sat_s4L6Y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ndz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NdA; else goto c4NdI;
       c4NdA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NdI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6U::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6U::I64, 0)) goto c4NdG; else goto c4Ndy;
       c4Ndy: // global
           if (%MO_S_Gt_W64(_s4L6U::I64, 3)) goto c4NdG; else goto c4NdH;
       c4NdG: // global
           R2 = _s4L6U::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4NdH: // global
           R1 = I64[(_s4L6U::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L73_entry() //  [R1]
         { info_tbl: [(c4NdT,
                       label: sat_s4L73_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NdT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NdU; else goto c4Ne2;
       c4NdU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ne2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6U::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6U::I64, 0)) goto c4Ne0; else goto c4NdS;
       c4NdS: // global
           if (%MO_S_Gt_W64(_s4L6U::I64, 3)) goto c4Ne0; else goto c4Ne1;
       c4Ne0: // global
           R2 = _s4L6U::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Ne1: // global
           R1 = I64[(_s4L6U::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L6T_entry() //  [R1, R2]
         { info_tbl: [(c4Ne6,
                       label: go_up_s4L6T_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ne6: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Nea; else goto c4Ne9;
       c4Nea: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Ne9: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4Ne4; else goto c4Ne5;
       c4Ne4: // global
           _s4L6R::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L70_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L6R::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L6Y_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ne5: // global
           I64[Hp - 80] = sat_s4L73_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Nec::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Nec::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L74_entry() //  [R1]
         { info_tbl: [(c4Ned,
                       label: sat_s4L74_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ned: // global
           _s4L74::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nee; else goto c4Nef;
       c4Nef: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Neh; else goto c4Neg;
       c4Neh: // global
           HpAlloc = 24;
           goto c4Nee;
       c4Nee: // global
           R1 = _s4L74::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Neg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L74::P64;
           _s4L4d::I64 = I64[_s4L74::P64 + 24];
           _s4L6R::I64 = _s4L4d::I64 - I64[_s4L74::P64 + 16];
           I64[Hp - 16] = go_up_s4L6T_info;
           I64[Hp - 8] = _s4L6R::I64;
           I64[Hp] = 3 - _s4L6R::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L6T_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6Q_entry() //  [R1]
         { info_tbl: [(c4Ner,
                       label: sat_s4L6Q_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ner: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nes; else goto c4NeA;
       c4Nes: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NeA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Ney; else goto c4Neq;
       c4Neq: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Ney; else goto c4Nez;
       c4Ney: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Nez: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L78_entry() //  [R1]
         { info_tbl: [(c4NeO,
                       label: sat_s4L78_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NeO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NeP; else goto c4NeX;
       c4NeP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NeX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4NeV; else goto c4NeN;
       c4NeN: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4NeV; else goto c4NeW;
       c4NeV: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4NeW: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c4Nf7,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nf7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Nf8; else goto c4Nf9;
       c4Nf8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Nf9: // global
           I64[Sp - 24] = block_c4NeY_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Nhm; else goto c4NeZ;
       u4Nhm: // global
           call _c4NeY(R1) args: 0, res: 0, upd: 0;
       c4NeZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NeY() //  [R1]
         { info_tbl: [(c4NeY,
                       label: block_c4NeY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NeY: // global
           _s4L48::P64 = P64[Sp + 8];
           _c4Nf6::P64 = R1 & 7;
           if (_c4Nf6::P64 < 3) goto u4Nhh; else goto u4Nhi;
       u4Nhh: // global
           if (_c4Nf6::P64 < 2) goto c4Nf2; else goto c4Nf3;
       c4Nf2: // global
           _s4L4b::I64 = 0;
           goto s4L4a;
       c4Nf3: // global
           _s4L4b::I64 = 1;
           goto s4L4a;
       u4Nhi: // global
           if (_c4Nf6::P64 < 4) goto c4Nf4; else goto c4Nf5;
       c4Nf4: // global
           _s4L4b::I64 = 2;
           goto s4L4a;
       c4Nf5: // global
           _s4L4b::I64 = 3;
           goto s4L4a;
       s4L4a: // global
           I64[Sp] = block_c4Nfa_info;
           R1 = _s4L48::P64;
           I64[Sp + 8] = _s4L4b::I64;
           if (R1 & 7 != 0) goto u4Nhl; else goto c4NgI;
       u4Nhl: // global
           call _c4Nfa(R1) args: 0, res: 0, upd: 0;
       c4NgI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Nfa() //  [R1]
         { info_tbl: [(c4Nfa,
                       label: block_c4Nfa_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nfa: // global
           _s4L49::P64 = P64[Sp + 16];
           _c4Nhd::P64 = R1 & 7;
           if (_c4Nhd::P64 < 3) goto u4Nhj; else goto u4Nhk;
       u4Nhj: // global
           if (_c4Nhd::P64 < 2) goto c4NgO; else goto c4NgS;
       c4NgO: // global
           _s4L4d::I64 = 0;
           goto s4L4c;
       c4NgS: // global
           _s4L4d::I64 = 1;
           goto s4L4c;
       u4Nhk: // global
           if (_c4Nhd::P64 < 4) goto c4NgW; else goto c4Nh0;
       c4NgW: // global
           _s4L4d::I64 = 2;
           goto s4L4c;
       c4Nh0: // global
           _s4L4d::I64 = 3;
           goto s4L4c;
       s4L4c: // global
           I64[Sp] = block_c4MYh_info;
           R1 = _s4L49::P64;
           I64[Sp + 16] = _s4L4d::I64;
           if (R1 & 7 != 0) goto u4Nhn; else goto c4MYi;
       u4Nhn: // global
           call _c4MYh(R1) args: 0, res: 0, upd: 0;
       c4MYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4MYh() //  [R1]
         { info_tbl: [(c4MYh,
                       label: block_c4MYh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4MYh: // global
           _s4L4b::I64 = I64[Sp + 8];
           _s4L4d::I64 = I64[Sp + 16];
           _c4Nhe::P64 = R1 & 7;
           if (_c4Nhe::P64 < 3) goto u4Nhf; else goto u4Nhg;
       u4Nhf: // global
           if (_c4Nhe::P64 < 2) goto c4Nfe; else goto c4NfB;
       c4Nfe: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Ngo; else goto c4Nfg;
       c4Nfg: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4Nfr; else goto c4NfA;
       c4Nfr: // global
           if (%MO_S_Le_W64(0, _s4L4d::I64)) goto c4Nfk; else goto c4Nfp;
       c4Nfk: // global
           I64[Hp - 72] = sat_s4L4x_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L4j_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Nfp: // global
           if (%MO_S_Gt_W64(0, _s4L4b::I64)) goto c4NgF; else goto c4Nfn;
       c4Nfn: // global
           I64[Hp - 72] = sat_s4L4B_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Nfl::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Nfl::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NfA: // global
           if (%MO_S_Ge_W64(0, _s4L4d::I64)) goto c4Nfu; else goto c4Nfz;
       c4Nfu: // global
           I64[Hp - 72] = sat_s4L4T_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L4F_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Nfz: // global
           if (%MO_S_Lt_W64(0, _s4L4b::I64)) goto c4NgF; else goto c4Nfx;
       c4Nfx: // global
           I64[Hp - 72] = sat_s4L4X_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Nfv::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Nfv::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NfB: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Ngo; else goto c4NfD;
       c4NfD: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4NfO; else goto c4NfX;
       c4NfO: // global
           if (%MO_S_Le_W64(1, _s4L4d::I64)) goto c4NfH; else goto c4NfM;
       c4NfH: // global
           I64[Hp - 72] = sat_s4L5g_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L52_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NfM: // global
           if (%MO_S_Gt_W64(1, _s4L4b::I64)) goto c4NgF; else goto c4NfK;
       c4NfK: // global
           I64[Hp - 72] = sat_s4L5k_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4NfI::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4NfI::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NfX: // global
           if (%MO_S_Ge_W64(1, _s4L4d::I64)) goto c4NfR; else goto c4NfW;
       c4NfR: // global
           I64[Hp - 72] = sat_s4L5C_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L5o_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NfW: // global
           if (%MO_S_Lt_W64(1, _s4L4b::I64)) goto c4NgF; else goto c4NfU;
       c4NfU: // global
           I64[Hp - 72] = sat_s4L5G_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4NfS::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4NfS::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Nhg: // global
           if (_c4Nhe::P64 < 4) goto c4NfY; else goto c4Ngl;
       c4NfY: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Ngo; else goto c4Ng0;
       c4Ng0: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4Ngb; else goto c4Ngk;
       c4Ngb: // global
           if (%MO_S_Le_W64(2, _s4L4d::I64)) goto c4Ng4; else goto c4Ng9;
       c4Ng4: // global
           I64[Hp - 72] = sat_s4L5Z_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L5L_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ng9: // global
           if (%MO_S_Gt_W64(2, _s4L4b::I64)) goto c4NgF; else goto c4Ng7;
       c4Ng7: // global
           I64[Hp - 72] = sat_s4L63_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Ng5::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Ng5::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ngk: // global
           if (%MO_S_Ge_W64(2, _s4L4d::I64)) goto c4Nge; else goto c4Ngj;
       c4Nge: // global
           I64[Hp - 72] = sat_s4L6l_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L67_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ngj: // global
           if (%MO_S_Lt_W64(2, _s4L4b::I64)) goto c4NgF; else goto c4Ngh;
       c4Ngh: // global
           I64[Hp - 72] = sat_s4L6p_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Ngf::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Ngf::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ngl: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4Ngo; else goto c4Ngn;
       c4Ngo: // global
           HpAlloc = 80;
           R1 = _s4L4e::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Ngn: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4Ngy; else goto c4NgH;
       c4Ngy: // global
           if (%MO_S_Le_W64(3, _s4L4d::I64)) goto c4Ngr; else goto c4Ngw;
       c4Ngr: // global
           I64[Hp - 72] = sat_s4L6I_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L6u_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ngw: // global
           if (%MO_S_Gt_W64(3, _s4L4b::I64)) goto c4NgF; else goto c4Ngu;
       c4Ngu: // global
           I64[Hp - 72] = sat_s4L6M_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Ngs::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Ngs::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NgH: // global
           if (%MO_S_Ge_W64(3, _s4L4d::I64)) goto c4NgB; else goto c4NgG;
       c4NgB: // global
           I64[Hp - 72] = sat_s4L74_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L6Q_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NgG: // global
           if (%MO_S_Lt_W64(3, _s4L4b::I64)) goto c4NgF; else goto c4NgE;
       c4NgF: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NgE: // global
           I64[Hp - 72] = sat_s4L78_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4NgC::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4NgC::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.343720528 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_closure" {
     GHC.IO.IOMode.$fEnumIOMode_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure+2;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure+2;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.344686997 UTC

[section ""data" . GHC.IO.IOMode.$trModule3_closure" {
     GHC.IO.IOMode.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.345627163 UTC

[section ""data" . GHC.IO.IOMode.$trModule1_closure" {
     GHC.IO.IOMode.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.346528803 UTC

[section ""data" . GHC.IO.IOMode.$trModule_closure" {
     GHC.IO.IOMode.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.IOMode.$trModule3_closure+1;
         const GHC.IO.IOMode.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.34729793 UTC

[section ""cstring" . GHC.IO.IOMode.$tcIOMode2_bytes" {
     GHC.IO.IOMode.$tcIOMode2_bytes:
         I8[] [73,79,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.347880828 UTC

[section ""data" . GHC.IO.IOMode.$tcIOMode1_closure" {
     GHC.IO.IOMode.$tcIOMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tcIOMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.348506812 UTC

[section ""data" . GHC.IO.IOMode.$tcIOMode_closure" {
     GHC.IO.IOMode.$tcIOMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tcIOMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9818555080744742578;
         const 14348064797489060312;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.349137072 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode1_closure" {
     GHC.IO.IOMode.$tc'AppendMode1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.IOMode.$tcIOMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.349786356 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'ReadMode2_bytes" {
     GHC.IO.IOMode.$tc'ReadMode2_bytes:
         I8[] [39,82,101,97,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.350358852 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadMode1_closure" {
     GHC.IO.IOMode.$tc'ReadMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'ReadMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.350935195 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadMode_closure" {
     GHC.IO.IOMode.$tc'ReadMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'ReadMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 17697021977009842408;
         const 16081808542294250782;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.351571269 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'WriteMode2_bytes" {
     GHC.IO.IOMode.$tc'WriteMode2_bytes:
         I8[] [39,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.352113077 UTC

[section ""data" . GHC.IO.IOMode.$tc'WriteMode1_closure" {
     GHC.IO.IOMode.$tc'WriteMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'WriteMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.352690663 UTC

[section ""data" . GHC.IO.IOMode.$tc'WriteMode_closure" {
     GHC.IO.IOMode.$tc'WriteMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'WriteMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 16610458722029011495;
         const 11554819901902375488;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.353414643 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'AppendMode3_bytes" {
     GHC.IO.IOMode.$tc'AppendMode3_bytes:
         I8[] [39,65,112,112,101,110,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.354078704 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode2_closure" {
     GHC.IO.IOMode.$tc'AppendMode2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'AppendMode3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.35467027 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode_closure" {
     GHC.IO.IOMode.$tc'AppendMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode2_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 3610623883618650464;
         const 11131639874085434472;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.35534679 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'ReadWriteMode2_bytes" {
     GHC.IO.IOMode.$tc'ReadWriteMode2_bytes:
         I8[] [39,82,101,97,100,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.355907173 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadWriteMode1_closure" {
     GHC.IO.IOMode.$tc'ReadWriteMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'ReadWriteMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.356516196 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadWriteMode_closure" {
     GHC.IO.IOMode.$tc'ReadWriteMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'ReadWriteMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 626157189396725199;
         const 9407417215311302278;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.357142368 UTC

[section ""data" . GHC.IO.IOMode.ReadMode_closure" {
     GHC.IO.IOMode.ReadMode_closure:
         const GHC.IO.IOMode.ReadMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.357746693 UTC

[section ""data" . GHC.IO.IOMode.WriteMode_closure" {
     GHC.IO.IOMode.WriteMode_closure:
         const GHC.IO.IOMode.WriteMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.358337554 UTC

[section ""data" . GHC.IO.IOMode.AppendMode_closure" {
     GHC.IO.IOMode.AppendMode_closure:
         const GHC.IO.IOMode.AppendMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.358895492 UTC

[section ""data" . GHC.IO.IOMode.ReadWriteMode_closure" {
     GHC.IO.IOMode.ReadWriteMode_closure:
         const GHC.IO.IOMode.ReadWriteMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.359451862 UTC

[section ""relreadonly" . GHC.IO.IOMode.IOMode_closure_tbl" {
     GHC.IO.IOMode.IOMode_closure_tbl:
         const GHC.IO.IOMode.ReadMode_closure+1;
         const GHC.IO.IOMode.WriteMode_closure+2;
         const GHC.IO.IOMode.AppendMode_closure+3;
         const GHC.IO.IOMode.ReadWriteMode_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.360157792 UTC

[GHC.IO.IOMode.ReadMode_con_entry() //  [R1]
         { info_tbl: [(c4Nho,
                       label: GHC.IO.IOMode.ReadMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,82,101,97,100,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nho: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.360928866 UTC

[GHC.IO.IOMode.WriteMode_con_entry() //  [R1]
         { info_tbl: [(c4Nhq,
                       label: GHC.IO.IOMode.WriteMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,87,114,105,116,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nhq: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.361762288 UTC

[GHC.IO.IOMode.AppendMode_con_entry() //  [R1]
         { info_tbl: [(c4Nhs,
                       label: GHC.IO.IOMode.AppendMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,65,112,112,101,110,100,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nhs: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.362499023 UTC

[GHC.IO.IOMode.ReadWriteMode_con_entry() //  [R1]
         { info_tbl: [(c4Nhu,
                       label: GHC.IO.IOMode.ReadWriteMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,82,101,97,100,87,114,105,116,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nhu: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.363212319 UTC

[section ""relreadonly" . S4L8g_srt" {
     S4L8g_srt:
         const GHC.IO.IOMode.$fReadIOMode8_closure;
         const GHC.IO.IOMode.$fReadIOMode12_closure;
         const GHC.IO.IOMode.$fReadIOMode16_closure;
         const GHC.IO.IOMode.$fReadIOMode20_closure;
         const GHC.IO.IOMode.$w$cshowsPrec_closure;
         const GHC.IO.IOMode.$fShowIOMode_$cshow_closure;
         const GHC.Read.choose2_closure;
         const GHC.IO.IOMode.$fReadIOMode_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.IOMode.$fReadIOMode2_closure;
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.IOMode.$fReadIOMode1_closure;
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
         const GHC.IO.IOMode.$fReadIOMode22_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.IO.IOMode.$fIxIOMode_$cindex_closure;
         const GHC.Err.error_closure;
         const lvl13_r4KYY_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_closure;
         const GHC.IO.IOMode.$fEnumIOMode5_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_closure;
         const GHC.IO.IOMode.$fEnumIOMode6_closure;
         const lvl18_r4KZ3_closure;
         const lvl19_r4KZ4_closure;
         const lvl20_r4KZ5_closure;
         const GHC.IO.IOMode.$wlvl_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure;
         const GHC.IO.IOMode.$w$ctoEnum_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure;
         const GHC.IO.IOMode.$fEnumIOMode1_closure;
         const GHC.IO.IOMode.$fEnumIOMode2_closure;
         const GHC.IO.IOMode.$fEnumIOMode3_closure;
         const GHC.IO.IOMode.$fEnumIOMode4_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go3_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go2_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go1_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.364257315 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:39.365493014 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode21_bytes" {
     GHC.IO.IOMode.$fReadIOMode21_bytes:
         I8[] [82,101,97,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.367697463 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode20_closure" {
     GHC.IO.IOMode.$fReadIOMode20_closure:
         const GHC.IO.IOMode.$fReadIOMode20_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode20_entry() //  [R1]
         { info_tbl: [(c4NhD,
                       label: GHC.IO.IOMode.$fReadIOMode20_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NhD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NhE; else goto c4NhF;
       c4NhE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NhF: // global
           (_c4NhA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4NhA::I64 == 0) goto c4NhC; else goto c4NhB;
       c4NhC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4NhB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4NhA::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode21_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.373596092 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode17_bytes" {
     GHC.IO.IOMode.$fReadIOMode17_bytes:
         I8[] [87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.375890869 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode16_closure" {
     GHC.IO.IOMode.$fReadIOMode16_closure:
         const GHC.IO.IOMode.$fReadIOMode16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode16_entry() //  [R1]
         { info_tbl: [(c4NhU,
                       label: GHC.IO.IOMode.$fReadIOMode16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NhU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NhV; else goto c4NhW;
       c4NhV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NhW: // global
           (_c4NhR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4NhR::I64 == 0) goto c4NhT; else goto c4NhS;
       c4NhT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4NhS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4NhR::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.382189839 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode13_bytes" {
     GHC.IO.IOMode.$fReadIOMode13_bytes:
         I8[] [65,112,112,101,110,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.385152148 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode12_closure" {
     GHC.IO.IOMode.$fReadIOMode12_closure:
         const GHC.IO.IOMode.$fReadIOMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode12_entry() //  [R1]
         { info_tbl: [(c4Nib,
                       label: GHC.IO.IOMode.$fReadIOMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nib: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nic; else goto c4Nid;
       c4Nic: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Nid: // global
           (_c4Ni8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Ni8::I64 == 0) goto c4Nia; else goto c4Ni9;
       c4Nia: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Ni9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Ni8::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.391316349 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode9_bytes" {
     GHC.IO.IOMode.$fReadIOMode9_bytes:
         I8[] [82,101,97,100,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.393574436 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode8_closure" {
     GHC.IO.IOMode.$fReadIOMode8_closure:
         const GHC.IO.IOMode.$fReadIOMode8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode8_entry() //  [R1]
         { info_tbl: [(c4Nis,
                       label: GHC.IO.IOMode.$fReadIOMode8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nis: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nit; else goto c4Niu;
       c4Nit: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Niu: // global
           (_c4Nip::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Nip::I64 == 0) goto c4Nir; else goto c4Niq;
       c4Nir: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Niq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Nip::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.398864575 UTC

[section ""data" . GHC.IO.IOMode.$w$cshowsPrec_closure" {
     GHC.IO.IOMode.$w$cshowsPrec_closure:
         const GHC.IO.IOMode.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.IOMode.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4NiP,
                       label: GHC.IO.IOMode.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NiP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NiQ; else goto c4NiR;
       c4NiQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NiR: // global
           I64[Sp - 16] = block_c4NiG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Nj6; else goto c4NiH;
       u4Nj6: // global
           call _c4NiG(R1) args: 0, res: 0, upd: 0;
       c4NiH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NiG() //  [R1]
         { info_tbl: [(c4NiG,
                       label: block_c4NiG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NiG: // global
           _s4KZ9::P64 = P64[Sp + 8];
           _c4NiO::P64 = R1 & 7;
           if (_c4NiO::P64 < 3) goto u4Nj4; else goto u4Nj5;
       u4Nj4: // global
           if (_c4NiO::P64 < 2) goto c4NiK; else goto c4NiL;
       c4NiK: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode20_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c4NiL: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode16_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4Nj5: // global
           if (_c4NiO::P64 < 4) goto c4NiM; else goto c4NiN;
       c4NiM: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode12_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c4NiN: // global
           R3 = _s4KZ9::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode8_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.40614728 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c4Njl,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Njl: // global
           _s4KZc::P64 = R3;
           R3 = R4;
           R2 = _s4KZc::P64;
           call GHC.IO.IOMode.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.410335968 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshow_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshow_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshow_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshow_entry() //  [R2]
         { info_tbl: [(c4NjF,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NjF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4NjG; else goto c4NjH;
       c4NjG: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fShowIOMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NjH: // global
           I64[Sp - 8] = block_c4Njw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4NjW; else goto c4Njx;
       u4NjW: // global
           call _c4Njw(R1) args: 0, res: 0, upd: 0;
       c4Njx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Njw() //  [R1]
         { info_tbl: [(c4Njw,
                       label: block_c4Njw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Njw: // global
           _c4NjE::P64 = R1 & 7;
           if (_c4NjE::P64 < 3) goto u4NjU; else goto u4NjV;
       u4NjU: // global
           if (_c4NjE::P64 < 2) goto c4NjA; else goto c4NjB;
       c4NjA: // global
           R1 = GHC.IO.IOMode.$fReadIOMode20_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4NjB: // global
           R1 = GHC.IO.IOMode.$fReadIOMode16_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u4NjV: // global
           if (_c4NjE::P64 < 4) goto c4NjC; else goto c4NjD;
       c4NjC: // global
           R1 = GHC.IO.IOMode.$fReadIOMode12_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4NjD: // global
           R1 = GHC.IO.IOMode.$fReadIOMode8_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.417655707 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshowList_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshowList_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshowList_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4Nkf,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nkf: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.IOMode.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.421319519 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_closure" {
     GHC.IO.IOMode.$fShowIOMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure+3;
         const GHC.IO.IOMode.$fShowIOMode_$cshow_closure+1;
         const GHC.IO.IOMode.$fShowIOMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.423421159 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode19_closure" {
     GHC.IO.IOMode.$fReadIOMode19_closure:
         const GHC.IO.IOMode.$fReadIOMode19_info;
 },
 GHC.IO.IOMode.$fReadIOMode19_entry() //  [R3]
         { info_tbl: [(c4Nkr,
                       label: GHC.IO.IOMode.$fReadIOMode19_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nkr: // global
           R2 = GHC.IO.IOMode.ReadMode_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.427228637 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode18_closure" {
     GHC.IO.IOMode.$fReadIOMode18_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode20_closure;
         const GHC.IO.IOMode.$fReadIOMode19_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.429188504 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode15_closure" {
     GHC.IO.IOMode.$fReadIOMode15_closure:
         const GHC.IO.IOMode.$fReadIOMode15_info;
 },
 GHC.IO.IOMode.$fReadIOMode15_entry() //  [R3]
         { info_tbl: [(c4NkD,
                       label: GHC.IO.IOMode.$fReadIOMode15_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NkD: // global
           R2 = GHC.IO.IOMode.WriteMode_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.432650407 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode14_closure" {
     GHC.IO.IOMode.$fReadIOMode14_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode16_closure;
         const GHC.IO.IOMode.$fReadIOMode15_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.434708786 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode11_closure" {
     GHC.IO.IOMode.$fReadIOMode11_closure:
         const GHC.IO.IOMode.$fReadIOMode11_info;
 },
 GHC.IO.IOMode.$fReadIOMode11_entry() //  [R3]
         { info_tbl: [(c4NkP,
                       label: GHC.IO.IOMode.$fReadIOMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NkP: // global
           R2 = GHC.IO.IOMode.AppendMode_closure+3;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.438066985 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode10_closure" {
     GHC.IO.IOMode.$fReadIOMode10_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode12_closure;
         const GHC.IO.IOMode.$fReadIOMode11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.440042599 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode7_closure" {
     GHC.IO.IOMode.$fReadIOMode7_closure:
         const GHC.IO.IOMode.$fReadIOMode7_info;
 },
 GHC.IO.IOMode.$fReadIOMode7_entry() //  [R3]
         { info_tbl: [(c4Nl1,
                       label: GHC.IO.IOMode.$fReadIOMode7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nl1: // global
           R2 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.443854615 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode6_closure" {
     GHC.IO.IOMode.$fReadIOMode6_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode8_closure;
         const GHC.IO.IOMode.$fReadIOMode7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.445971581 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode5_closure" {
     GHC.IO.IOMode.$fReadIOMode5_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.449617317 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode4_closure" {
     GHC.IO.IOMode.$fReadIOMode4_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode10_closure+1;
         const GHC.IO.IOMode.$fReadIOMode5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.452296317 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode3_closure" {
     GHC.IO.IOMode.$fReadIOMode3_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode14_closure+1;
         const GHC.IO.IOMode.$fReadIOMode4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.454809163 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_sps_closure" {
     GHC.IO.IOMode.$fReadIOMode_sps_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode18_closure+1;
         const GHC.IO.IOMode.$fReadIOMode3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.456899755 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode2_closure" {
     GHC.IO.IOMode.$fReadIOMode2_closure:
         const GHC.IO.IOMode.$fReadIOMode2_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode2_entry() //  [R2]
         { info_tbl: [(c4Nlh,
                       label: GHC.IO.IOMode.$fReadIOMode2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nlh: // global
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.461014933 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode1_closure" {
     GHC.IO.IOMode.$fReadIOMode1_closure:
         const GHC.IO.IOMode.$fReadIOMode1_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode1_entry() //  [R2, R3]
         { info_tbl: [(c4Nls,
                       label: GHC.IO.IOMode.$fReadIOMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nls: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.464809482 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_info;
         const 0;
 },
 sat_s4KZs_entry() //  [R1]
         { info_tbl: [(c4NlH,
                       label: sat_s4KZs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NlH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NlI; else goto c4NlJ;
       c4NlI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NlJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.IOMode.$fReadIOMode2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fReadIOMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c4NlK,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NlK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4NlO; else goto c4NlN;
       c4NlO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NlN: // global
           I64[Hp - 16] = sat_s4KZs_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.470752748 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c4Nm3,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nm3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nm4; else goto c4Nm5;
       c4Nm4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Nm5: // global
           (_c4Nm0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Nm0::I64 == 0) goto c4Nm2; else goto c4Nm1;
       c4Nm2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Nm1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Nm0::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.47567844 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode22_closure" {
     GHC.IO.IOMode.$fReadIOMode22_closure:
         const GHC.IO.IOMode.$fReadIOMode22_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode22_entry() //  [R1]
         { info_tbl: [(c4Nmj,
                       label: GHC.IO.IOMode.$fReadIOMode22_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nmj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nmk; else goto c4Nml;
       c4Nmk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Nml: // global
           (_c4Nmg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Nmg::I64 == 0) goto c4Nmi; else goto c4Nmh;
       c4Nmi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Nmh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Nmg::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.480120405 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadList_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadList_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadList_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode_$creadList_entry() //  [R2]
         { info_tbl: [(c4Nmx,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nmx: // global
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode22_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.484131617 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_closure" {
     GHC.IO.IOMode.$fReadIOMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure+1;
         const GHC.IO.IOMode.$fReadIOMode_$creadList_closure+1;
         const GHC.IO.IOMode.$fReadIOMode1_closure+2;
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.486935973 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_$c==_closure" {
     GHC.IO.IOMode.$fEqIOMode_$c==_closure:
         const GHC.IO.IOMode.$fEqIOMode_$c==_info;
 },
 GHC.IO.IOMode.$fEqIOMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c4NmS,
                       label: GHC.IO.IOMode.$fEqIOMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NmS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NmT; else goto c4NmU;
       c4NmT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEqIOMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NmU: // global
           I64[Sp - 16] = block_c4NmJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Nob; else goto c4NmK;
       u4Nob: // global
           call _c4NmJ(R1) args: 0, res: 0, upd: 0;
       c4NmK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NmJ() //  [R1]
         { info_tbl: [(c4NmJ,
                       label: block_c4NmJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NmJ: // global
           _s4KZu::P64 = P64[Sp + 8];
           _c4NmR::P64 = R1 & 7;
           if (_c4NmR::P64 < 3) goto u4NnX; else goto u4NnY;
       u4NnX: // global
           if (_c4NmR::P64 < 2) goto c4NmN; else goto c4NmO;
       c4NmN: // global
           I64[Sp + 8] = block_c4NmX_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4No7; else goto c4NmZ;
       u4No7: // global
           call _c4NmX(R1) args: 0, res: 0, upd: 0;
       c4NmZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NmO: // global
           I64[Sp + 8] = block_c4Nnc_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4No8; else goto c4Nne;
       u4No8: // global
           call _c4Nnc(R1) args: 0, res: 0, upd: 0;
       c4Nne: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4NnY: // global
           if (_c4NmR::P64 < 4) goto c4NmP; else goto c4NmQ;
       c4NmP: // global
           I64[Sp + 8] = block_c4Nnr_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4No9; else goto c4Nnt;
       u4No9: // global
           call _c4Nnr(R1) args: 0, res: 0, upd: 0;
       c4Nnt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NmQ: // global
           I64[Sp + 8] = block_c4NnG_info;
           R1 = _s4KZu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Noa; else goto c4NnI;
       u4Noa: // global
           call _c4NnG(R1) args: 0, res: 0, upd: 0;
       c4NnI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NmX() //  [R1]
         { info_tbl: [(c4NmX,
                       label: block_c4NmX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NmX: // global
           if (R1 & 7 == 1) goto u4NnZ; else goto u4No0;
       u4NnZ: // global
           Sp = Sp + 8;
           call _c4NnS() args: 0, res: 0, upd: 0;
       u4No0: // global
           Sp = Sp + 8;
           call _c4NnO() args: 0, res: 0, upd: 0;
     }
 },
 _c4Nnc() //  [R1]
         { info_tbl: [(c4Nnc,
                       label: block_c4Nnc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nnc: // global
           if (R1 & 7 == 2) goto u4No1; else goto u4No2;
       u4No1: // global
           Sp = Sp + 8;
           call _c4NnS() args: 0, res: 0, upd: 0;
       u4No2: // global
           Sp = Sp + 8;
           call _c4NnO() args: 0, res: 0, upd: 0;
     }
 },
 _c4Nnr() //  [R1]
         { info_tbl: [(c4Nnr,
                       label: block_c4Nnr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nnr: // global
           if (R1 & 7 == 3) goto u4No3; else goto u4No4;
       u4No3: // global
           Sp = Sp + 8;
           call _c4NnS() args: 0, res: 0, upd: 0;
       u4No4: // global
           Sp = Sp + 8;
           call _c4NnO() args: 0, res: 0, upd: 0;
     }
 },
 _c4NnG() //  [R1]
         { info_tbl: [(c4NnG,
                       label: block_c4NnG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NnG: // global
           if (R1 & 7 == 4) goto u4No5; else goto u4No6;
       u4No5: // global
           Sp = Sp + 8;
           call _c4NnS() args: 0, res: 0, upd: 0;
       u4No6: // global
           Sp = Sp + 8;
           call _c4NnO() args: 0, res: 0, upd: 0;
     }
 },
 _c4NnS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NnS: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NnO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NnO: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.5025977 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_$c/=_closure" {
     GHC.IO.IOMode.$fEqIOMode_$c/=_closure:
         const GHC.IO.IOMode.$fEqIOMode_$c/=_info;
 },
 GHC.IO.IOMode.$fEqIOMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c4Npb,
                       label: GHC.IO.IOMode.$fEqIOMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Npb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Npc; else goto c4Npd;
       c4Npc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEqIOMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Npd: // global
           I64[Sp - 16] = block_c4Np2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Nqu; else goto c4Np3;
       u4Nqu: // global
           call _c4Np2(R1) args: 0, res: 0, upd: 0;
       c4Np3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Np2() //  [R1]
         { info_tbl: [(c4Np2,
                       label: block_c4Np2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Np2: // global
           _s4KZB::P64 = P64[Sp + 8];
           _c4Npa::P64 = R1 & 7;
           if (_c4Npa::P64 < 3) goto u4Nqg; else goto u4Nqh;
       u4Nqg: // global
           if (_c4Npa::P64 < 2) goto c4Np6; else goto c4Np7;
       c4Np6: // global
           I64[Sp + 8] = block_c4Npg_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Nqq; else goto c4Npi;
       u4Nqq: // global
           call _c4Npg(R1) args: 0, res: 0, upd: 0;
       c4Npi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Np7: // global
           I64[Sp + 8] = block_c4Npv_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Nqr; else goto c4Npx;
       u4Nqr: // global
           call _c4Npv(R1) args: 0, res: 0, upd: 0;
       c4Npx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Nqh: // global
           if (_c4Npa::P64 < 4) goto c4Np8; else goto c4Np9;
       c4Np8: // global
           I64[Sp + 8] = block_c4NpK_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Nqs; else goto c4NpM;
       u4Nqs: // global
           call _c4NpK(R1) args: 0, res: 0, upd: 0;
       c4NpM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Np9: // global
           I64[Sp + 8] = block_c4NpZ_info;
           R1 = _s4KZB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Nqt; else goto c4Nq1;
       u4Nqt: // global
           call _c4NpZ(R1) args: 0, res: 0, upd: 0;
       c4Nq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Npg() //  [R1]
         { info_tbl: [(c4Npg,
                       label: block_c4Npg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Npg: // global
           if (R1 & 7 == 1) goto u4Nqi; else goto u4Nqj;
       u4Nqi: // global
           Sp = Sp + 8;
           call _c4Nqb() args: 0, res: 0, upd: 0;
       u4Nqj: // global
           Sp = Sp + 8;
           call _c4Nq7() args: 0, res: 0, upd: 0;
     }
 },
 _c4Npv() //  [R1]
         { info_tbl: [(c4Npv,
                       label: block_c4Npv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Npv: // global
           if (R1 & 7 == 2) goto u4Nqk; else goto u4Nql;
       u4Nqk: // global
           Sp = Sp + 8;
           call _c4Nqb() args: 0, res: 0, upd: 0;
       u4Nql: // global
           Sp = Sp + 8;
           call _c4Nq7() args: 0, res: 0, upd: 0;
     }
 },
 _c4NpK() //  [R1]
         { info_tbl: [(c4NpK,
                       label: block_c4NpK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NpK: // global
           if (R1 & 7 == 3) goto u4Nqm; else goto u4Nqn;
       u4Nqm: // global
           Sp = Sp + 8;
           call _c4Nqb() args: 0, res: 0, upd: 0;
       u4Nqn: // global
           Sp = Sp + 8;
           call _c4Nq7() args: 0, res: 0, upd: 0;
     }
 },
 _c4NpZ() //  [R1]
         { info_tbl: [(c4NpZ,
                       label: block_c4NpZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NpZ: // global
           if (R1 & 7 == 4) goto u4Nqo; else goto u4Nqp;
       u4Nqo: // global
           Sp = Sp + 8;
           call _c4Nqb() args: 0, res: 0, upd: 0;
       u4Nqp: // global
           Sp = Sp + 8;
           call _c4Nq7() args: 0, res: 0, upd: 0;
     }
 },
 _c4Nqb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nqb: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Nq7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nq7: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.517195884 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_closure" {
     GHC.IO.IOMode.$fEqIOMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.IOMode.$fEqIOMode_$c==_closure+2;
         const GHC.IO.IOMode.$fEqIOMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.520530159 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$ccompare_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4Nrv,
                       label: GHC.IO.IOMode.$fOrdIOMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nrv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nrw; else goto c4Nrx;
       c4Nrw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Nrx: // global
           I64[Sp - 16] = block_c4Nrm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ntg; else goto c4Nrn;
       u4Ntg: // global
           call _c4Nrm(R1) args: 0, res: 0, upd: 0;
       c4Nrn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Nrm() //  [R1]
         { info_tbl: [(c4Nrm,
                       label: block_c4Nrm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nrm: // global
           _s4KZI::P64 = P64[Sp + 8];
           _c4Nru::P64 = R1 & 7;
           if (_c4Nru::P64 < 3) goto u4NsU; else goto u4NsV;
       u4NsU: // global
           if (_c4Nru::P64 < 2) goto c4Nrq; else goto c4Nrr;
       c4Nrq: // global
           I64[Sp + 8] = block_c4NrA_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ntc; else goto c4NrC;
       u4Ntc: // global
           call _c4NrA(R1) args: 0, res: 0, upd: 0;
       c4NrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Nrr: // global
           I64[Sp + 8] = block_c4NrX_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ntd; else goto c4NrZ;
       u4Ntd: // global
           call _c4NrX(R1) args: 0, res: 0, upd: 0;
       c4NrZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4NsV: // global
           if (_c4Nru::P64 < 4) goto c4Nrs; else goto c4Nrt;
       c4Nrs: // global
           I64[Sp + 8] = block_c4Nsk_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Nte; else goto c4Nsm;
       u4Nte: // global
           call _c4Nsk(R1) args: 0, res: 0, upd: 0;
       c4Nsm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Nrt: // global
           I64[Sp + 8] = block_c4NsD_info;
           R1 = _s4KZI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ntf; else goto c4NsF;
       u4Ntf: // global
           call _c4NsD(R1) args: 0, res: 0, upd: 0;
       c4NsF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NrA() //  [R1]
         { info_tbl: [(c4NrA,
                       label: block_c4NrA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NrA: // global
           _c4NsT::P64 = R1 & 7;
           if (_c4NsT::P64 < 2) goto u4Nt0; else goto u4NsW;
       u4Nt0: // global
           Sp = Sp + 8;
           call _c4NsP() args: 0, res: 0, upd: 0;
       u4NsW: // global
           if (_c4NsT::P64 != 3) goto u4Nt2; else goto u4Nt2;
       u4Nt2: // global
           Sp = Sp + 8;
           call _c4NsA() args: 0, res: 0, upd: 0;
     }
 },
 _c4NrX() //  [R1]
         { info_tbl: [(c4NrX,
                       label: block_c4NrX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NrX: // global
           _c4NsS::P64 = R1 & 7;
           if (_c4NsS::P64 < 3) goto u4NsX; else goto u4NsY;
       u4NsX: // global
           if (_c4NsS::P64 < 2) goto u4Nt4; else goto u4Nt3;
       u4Nt4: // global
           Sp = Sp + 8;
           call _c4NsL() args: 0, res: 0, upd: 0;
       u4Nt3: // global
           Sp = Sp + 8;
           call _c4NsP() args: 0, res: 0, upd: 0;
       u4NsY: // global
           if (_c4NsS::P64 < 4) goto u4Nt6; else goto u4Nt6;
       u4Nt6: // global
           Sp = Sp + 8;
           call _c4NsA() args: 0, res: 0, upd: 0;
     }
 },
 _c4Nsk() //  [R1]
         { info_tbl: [(c4Nsk,
                       label: block_c4Nsk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nsk: // global
           _c4NsR::P64 = R1 & 7;
           if (_c4NsR::P64 != 3) goto u4NsZ; else goto u4Nt7;
       u4NsZ: // global
           if (_c4NsR::P64 != 4) goto u4Nt9; else goto u4Nt8;
       u4Nt9: // global
           Sp = Sp + 8;
           call _c4NsL() args: 0, res: 0, upd: 0;
       u4Nt8: // global
           Sp = Sp + 8;
           call _c4NsA() args: 0, res: 0, upd: 0;
       u4Nt7: // global
           Sp = Sp + 8;
           call _c4NsP() args: 0, res: 0, upd: 0;
     }
 },
 _c4NsA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NsA: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NsD() //  [R1]
         { info_tbl: [(c4NsD,
                       label: block_c4NsD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NsD: // global
           if (R1 & 7 == 4) goto u4Nta; else goto u4Ntb;
       u4Nta: // global
           Sp = Sp + 8;
           call _c4NsP() args: 0, res: 0, upd: 0;
       u4Ntb: // global
           Sp = Sp + 8;
           call _c4NsL() args: 0, res: 0, upd: 0;
     }
 },
 _c4NsP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NsP: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NsL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NsL: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.539223252 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c<_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c<_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c<_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c4Nui,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nui: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nuj; else goto c4Nuk;
       c4Nuj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Nuk: // global
           I64[Sp - 16] = block_c4Nu9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NvI; else goto c4Nua;
       u4NvI: // global
           call _c4Nu9(R1) args: 0, res: 0, upd: 0;
       c4Nua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Nu9() //  [R1]
         { info_tbl: [(c4Nu9,
                       label: block_c4Nu9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nu9: // global
           _s4KZP::P64 = P64[Sp + 8];
           _c4Nuh::P64 = R1 & 7;
           if (_c4Nuh::P64 < 3) goto u4Nvs; else goto u4Nvt;
       u4Nvs: // global
           if (_c4Nuh::P64 < 2) goto c4Nud; else goto c4Nue;
       c4Nud: // global
           I64[Sp + 8] = block_c4Nun_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NvE; else goto c4Nup;
       u4NvE: // global
           call _c4Nun(R1) args: 0, res: 0, upd: 0;
       c4Nup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Nue: // global
           I64[Sp + 8] = block_c4NuK_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NvF; else goto c4NuM;
       u4NvF: // global
           call _c4NuK(R1) args: 0, res: 0, upd: 0;
       c4NuM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Nvt: // global
           if (_c4Nuh::P64 < 4) goto c4Nuf; else goto c4Nug;
       c4Nuf: // global
           I64[Sp + 8] = block_c4Nv3_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NvG; else goto c4Nv5;
       u4NvG: // global
           call _c4Nv3(R1) args: 0, res: 0, upd: 0;
       c4Nv5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Nug: // global
           I64[Sp + 8] = block_c4Nvi_info;
           R1 = _s4KZP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NvH; else goto c4Nvk;
       u4NvH: // global
           call _c4Nvi() args: 0, res: 0, upd: 0;
       c4Nvk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Nun() //  [R1]
         { info_tbl: [(c4Nun,
                       label: block_c4Nun_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nun: // global
           _c4Nvr::P64 = R1 & 7;
           if (_c4Nvr::P64 < 2) goto u4Nvw; else goto u4Nvu;
       u4Nvw: // global
           Sp = Sp + 8;
           call _c4Nvb() args: 0, res: 0, upd: 0;
       u4Nvu: // global
           if (_c4Nvr::P64 != 3) goto u4Nvy; else goto u4Nvy;
       u4Nvy: // global
           Sp = Sp + 8;
           call _c4Nvf() args: 0, res: 0, upd: 0;
     }
 },
 _c4NuK() //  [R1]
         { info_tbl: [(c4NuK,
                       label: block_c4NuK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NuK: // global
           _c4Nvq::P64 = R1 & 7;
           if (_c4Nvq::P64 != 3) goto u4Nvv; else goto u4Nvz;
       u4Nvv: // global
           if (_c4Nvq::P64 != 4) goto u4NvB; else goto u4NvA;
       u4NvB: // global
           Sp = Sp + 8;
           call _c4Nvb() args: 0, res: 0, upd: 0;
       u4NvA: // global
           Sp = Sp + 8;
           goto u4NvM;
       u4Nvz: // global
           Sp = Sp + 8;
           goto u4NvM;
       u4NvM: // global
           call _c4Nvf() args: 0, res: 0, upd: 0;
     }
 },
 _c4Nv3() //  [R1]
         { info_tbl: [(c4Nv3,
                       label: block_c4Nv3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nv3: // global
           if (R1 & 7 == 4) goto u4NvC; else goto u4NvD;
       u4NvC: // global
           Sp = Sp + 8;
           call _c4Nvf() args: 0, res: 0, upd: 0;
       u4NvD: // global
           Sp = Sp + 8;
           call _c4Nvb() args: 0, res: 0, upd: 0;
     }
 },
 _c4Nvf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nvf: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Nvb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nvb: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Nvi() //  []
         { info_tbl: [(c4Nvi,
                       label: block_c4Nvi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nvi: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.558339676 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c<=_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c<=_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c<=_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c4NwE,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NwE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NwF; else goto c4NwG;
       c4NwF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NwG: // global
           I64[Sp - 16] = block_c4Nwv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ny4; else goto c4Nww;
       u4Ny4: // global
           call _c4Nwv(R1) args: 0, res: 0, upd: 0;
       c4Nww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Nwv() //  [R1]
         { info_tbl: [(c4Nwv,
                       label: block_c4Nwv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nwv: // global
           _s4KZV::P64 = P64[Sp + 8];
           _c4NwD::P64 = R1 & 7;
           if (_c4NwD::P64 < 3) goto u4NxO; else goto u4NxP;
       u4NxO: // global
           if (_c4NwD::P64 < 2) goto c4Nwz; else goto c4NwA;
       c4Nwz: // global
           I64[Sp + 8] = block_c4NwJ_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ny0; else goto c4NwL;
       u4Ny0: // global
           call _c4NwJ(R1) args: 0, res: 0, upd: 0;
       c4NwL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NwA: // global
           I64[Sp + 8] = block_c4Nx6_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ny1; else goto c4Nx8;
       u4Ny1: // global
           call _c4Nx6(R1) args: 0, res: 0, upd: 0;
       c4Nx8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4NxP: // global
           if (_c4NwD::P64 < 4) goto c4NwB; else goto c4NwC;
       c4NwB: // global
           I64[Sp + 8] = block_c4Nxp_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ny2; else goto c4Nxr;
       u4Ny2: // global
           call _c4Nxp(R1) args: 0, res: 0, upd: 0;
       c4Nxr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NwC: // global
           I64[Sp + 8] = block_c4NxE_info;
           R1 = _s4KZV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ny3; else goto c4NxG;
       u4Ny3: // global
           call _c4NxE() args: 0, res: 0, upd: 0;
       c4NxG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NwJ() //  [R1]
         { info_tbl: [(c4NwJ,
                       label: block_c4NwJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NwJ: // global
           _c4NxN::P64 = R1 & 7;
           if (_c4NxN::P64 < 2) goto u4NxS; else goto u4NxQ;
       u4NxS: // global
           Sp = Sp + 8;
           call _c4Nxx() args: 0, res: 0, upd: 0;
       u4NxQ: // global
           if (_c4NxN::P64 != 3) goto u4NxU; else goto u4NxU;
       u4NxU: // global
           Sp = Sp + 8;
           call _c4NxB() args: 0, res: 0, upd: 0;
     }
 },
 _c4Nx6() //  [R1]
         { info_tbl: [(c4Nx6,
                       label: block_c4Nx6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nx6: // global
           _c4NxM::P64 = R1 & 7;
           if (_c4NxM::P64 != 3) goto u4NxR; else goto u4NxV;
       u4NxR: // global
           if (_c4NxM::P64 != 4) goto u4NxX; else goto u4NxW;
       u4NxX: // global
           Sp = Sp + 8;
           call _c4Nxx() args: 0, res: 0, upd: 0;
       u4NxW: // global
           Sp = Sp + 8;
           goto u4Ny8;
       u4NxV: // global
           Sp = Sp + 8;
           goto u4Ny8;
       u4Ny8: // global
           call _c4NxB() args: 0, res: 0, upd: 0;
     }
 },
 _c4Nxp() //  [R1]
         { info_tbl: [(c4Nxp,
                       label: block_c4Nxp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nxp: // global
           if (R1 & 7 == 4) goto u4NxY; else goto u4NxZ;
       u4NxY: // global
           Sp = Sp + 8;
           call _c4NxB() args: 0, res: 0, upd: 0;
       u4NxZ: // global
           Sp = Sp + 8;
           call _c4Nxx() args: 0, res: 0, upd: 0;
     }
 },
 _c4NxB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NxB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Nxx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nxx: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NxE() //  []
         { info_tbl: [(c4NxE,
                       label: block_c4NxE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NxE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.575973 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$cmax_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$cmax_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$cmax_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4Nz0,
                       label: GHC.IO.IOMode.$fOrdIOMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nz0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Nz1; else goto c4Nz2;
       c4Nz1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Nz2: // global
           I64[Sp - 16] = block_c4NyR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NzZ; else goto c4NyS;
       u4NzZ: // global
           call _c4NyR(R1) args: 0, res: 0, upd: 0;
       c4NyS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NyR() //  [R1]
         { info_tbl: [(c4NyR,
                       label: block_c4NyR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NyR: // global
           _s4L02::P64 = P64[Sp + 8];
           _c4NyZ::P64 = R1 & 7;
           if (_c4NyZ::P64 < 3) goto u4NzP; else goto u4NzQ;
       u4NzP: // global
           if (_c4NyZ::P64 < 2) goto c4NyV; else goto c4NyW;
       c4NyV: // global
           R1 = _s4L02::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4NyW: // global
           I64[Sp + 8] = block_c4Nz8_info;
           R1 = _s4L02::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NzW; else goto c4Nza;
       u4NzW: // global
           call _c4Nz8(R1) args: 0, res: 0, upd: 0;
       c4Nza: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4NzQ: // global
           if (_c4NyZ::P64 < 4) goto c4NyX; else goto c4NyY;
       c4NyX: // global
           I64[Sp + 8] = block_c4Nzr_info;
           R1 = _s4L02::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NzX; else goto c4Nzt;
       u4NzX: // global
           call _c4Nzr(R1) args: 0, res: 0, upd: 0;
       c4Nzt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NyY: // global
           I64[Sp + 8] = block_c4NzG_info;
           R1 = _s4L02::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NzY; else goto c4NzI;
       u4NzY: // global
           call _c4NzG() args: 0, res: 0, upd: 0;
       c4NzI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Nz8() //  [R1]
         { info_tbl: [(c4Nz8,
                       label: block_c4Nz8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nz8: // global
           _c4NzO::P64 = R1 & 7;
           if (_c4NzO::P64 != 3) goto u4NzR; else goto u4NzS;
       u4NzR: // global
           if (_c4NzO::P64 != 4) goto c4Nzg; else goto u4NzT;
       c4Nzg: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4NzT: // global
           Sp = Sp + 8;
           call _c4NzD() args: 0, res: 0, upd: 0;
       u4NzS: // global
           Sp = Sp + 8;
           call _c4Nzz() args: 0, res: 0, upd: 0;
     }
 },
 _c4Nzr() //  [R1]
         { info_tbl: [(c4Nzr,
                       label: block_c4Nzr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nzr: // global
           if (R1 & 7 == 4) goto u4NzU; else goto u4NzV;
       u4NzU: // global
           Sp = Sp + 8;
           call _c4NzD() args: 0, res: 0, upd: 0;
       u4NzV: // global
           Sp = Sp + 8;
           call _c4Nzz() args: 0, res: 0, upd: 0;
     }
 },
 _c4NzD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NzD: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Nzz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Nzz: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NzG() //  []
         { info_tbl: [(c4NzG,
                       label: block_c4NzG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NzG: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.590914427 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c>=_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c>=_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c>=_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c4NAQ,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NAQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NAR; else goto c4NAS;
       c4NAR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NAS: // global
           I64[Sp - 16] = block_c4NAH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NCg; else goto c4NAI;
       u4NCg: // global
           call _c4NAH(R1) args: 0, res: 0, upd: 0;
       c4NAI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NAH() //  [R1]
         { info_tbl: [(c4NAH,
                       label: block_c4NAH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NAH: // global
           _s4L09::P64 = P64[Sp + 8];
           _c4NAP::P64 = R1 & 7;
           if (_c4NAP::P64 < 3) goto u4NC0; else goto u4NC1;
       u4NC0: // global
           if (_c4NAP::P64 < 2) goto c4NAL; else goto c4NAM;
       c4NAL: // global
           I64[Sp + 8] = block_c4NAV_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NCc; else goto c4NAX;
       u4NCc: // global
           call _c4NAV(R1) args: 0, res: 0, upd: 0;
       c4NAX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NAM: // global
           I64[Sp + 8] = block_c4NBi_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NCd; else goto c4NBk;
       u4NCd: // global
           call _c4NBi(R1) args: 0, res: 0, upd: 0;
       c4NBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4NC1: // global
           if (_c4NAP::P64 < 4) goto c4NAN; else goto c4NAO;
       c4NAN: // global
           I64[Sp + 8] = block_c4NBB_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NCe; else goto c4NBD;
       u4NCe: // global
           call _c4NBB(R1) args: 0, res: 0, upd: 0;
       c4NBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NAO: // global
           I64[Sp + 8] = block_c4NBQ_info;
           R1 = _s4L09::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NCf; else goto c4NBS;
       u4NCf: // global
           call _c4NBQ() args: 0, res: 0, upd: 0;
       c4NBS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NAV() //  [R1]
         { info_tbl: [(c4NAV,
                       label: block_c4NAV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NAV: // global
           _c4NBZ::P64 = R1 & 7;
           if (_c4NBZ::P64 < 2) goto u4NC4; else goto u4NC2;
       u4NC4: // global
           Sp = Sp + 8;
           call _c4NBJ() args: 0, res: 0, upd: 0;
       u4NC2: // global
           if (_c4NBZ::P64 != 3) goto u4NC6; else goto u4NC6;
       u4NC6: // global
           Sp = Sp + 8;
           call _c4NBN() args: 0, res: 0, upd: 0;
     }
 },
 _c4NBi() //  [R1]
         { info_tbl: [(c4NBi,
                       label: block_c4NBi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NBi: // global
           _c4NBY::P64 = R1 & 7;
           if (_c4NBY::P64 != 3) goto u4NC3; else goto u4NC7;
       u4NC3: // global
           if (_c4NBY::P64 != 4) goto u4NC9; else goto u4NC8;
       u4NC9: // global
           Sp = Sp + 8;
           call _c4NBJ() args: 0, res: 0, upd: 0;
       u4NC8: // global
           Sp = Sp + 8;
           goto u4NCk;
       u4NC7: // global
           Sp = Sp + 8;
           goto u4NCk;
       u4NCk: // global
           call _c4NBN() args: 0, res: 0, upd: 0;
     }
 },
 _c4NBB() //  [R1]
         { info_tbl: [(c4NBB,
                       label: block_c4NBB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NBB: // global
           if (R1 & 7 == 4) goto u4NCa; else goto u4NCb;
       u4NCa: // global
           Sp = Sp + 8;
           call _c4NBN() args: 0, res: 0, upd: 0;
       u4NCb: // global
           Sp = Sp + 8;
           call _c4NBJ() args: 0, res: 0, upd: 0;
     }
 },
 _c4NBN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NBN: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NBJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NBJ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NBQ() //  []
         { info_tbl: [(c4NBQ,
                       label: block_c4NBQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NBQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.606632836 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c>_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c>_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c>_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c4ND3,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ND3: // global
           _s4L0g::P64 = R3;
           R3 = R2;
           R2 = _s4L0g::P64;
           call GHC.IO.IOMode.$fOrdIOMode_$c<_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.611918779 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$cmin_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$cmin_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$cmin_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4NDn,
                       label: GHC.IO.IOMode.$fOrdIOMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NDn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NDo; else goto c4NDp;
       c4NDo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NDp: // global
           I64[Sp - 16] = block_c4NDe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NEi; else goto c4NDf;
       u4NEi: // global
           call _c4NDe(R1) args: 0, res: 0, upd: 0;
       c4NDf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NDe() //  [R1]
         { info_tbl: [(c4NDe,
                       label: block_c4NDe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NDe: // global
           _s4L0h::P64 = P64[Sp + 8];
           _c4NDm::P64 = R1 & 7;
           if (_c4NDm::P64 < 3) goto u4NEc; else goto u4NEd;
       u4NEc: // global
           if (_c4NDm::P64 < 2) goto c4NDi; else goto c4NDj;
       c4NDi: // global
           I64[Sp + 8] = block_c4NDs_info;
           R1 = _s4L0h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NEf; else goto c4NDu;
       u4NEf: // global
           call _c4NDs() args: 0, res: 0, upd: 0;
       c4NDu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NDj: // global
           I64[Sp + 8] = block_c4NDB_info;
           R1 = _s4L0h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NEg; else goto c4NDD;
       u4NEg: // global
           call _c4NDB(R1) args: 0, res: 0, upd: 0;
       c4NDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4NEd: // global
           if (_c4NDm::P64 < 4) goto c4NDk; else goto c4NDl;
       c4NDk: // global
           I64[Sp + 8] = block_c4NDU_info;
           R1 = _s4L0h::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NEh; else goto c4NDW;
       u4NEh: // global
           call _c4NDU(R1) args: 0, res: 0, upd: 0;
       c4NDW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NDl: // global
           R1 = _s4L0h::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NDs() //  []
         { info_tbl: [(c4NDs,
                       label: block_c4NDs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NDs: // global
           R1 = GHC.IO.IOMode.ReadMode_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NDB() //  [R1]
         { info_tbl: [(c4NDB,
                       label: block_c4NDB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NDB: // global
           _c4NEb::P64 = R1 & 7;
           if (_c4NEb::P64 == 3) goto c4NDR; else goto u4NEe;
       u4NEe: // global
           if (_c4NEb::P64 == 4) goto c4NDR; else goto c4NDJ;
       c4NDR: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NDJ: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NDU() //  [R1]
         { info_tbl: [(c4NDU,
                       label: block_c4NDU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NDU: // global
           if (R1 & 7 == 4) goto c4NE6; else goto c4NE2;
       c4NE6: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NE2: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.624140359 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_closure" {
     GHC.IO.IOMode.$fOrdIOMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.IOMode.$fEqIOMode_closure+1;
         const GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c<_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c<=_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c>_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c>=_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$cmax_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.62741038 UTC

[section ""data" . GHC.IO.IOMode.$w$cunsafeIndex_closure" {
     GHC.IO.IOMode.$w$cunsafeIndex_closure:
         const GHC.IO.IOMode.$w$cunsafeIndex_info;
 },
 GHC.IO.IOMode.$w$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4NF5,
                       label: GHC.IO.IOMode.$w$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NF5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NF6; else goto c4NF7;
       c4NF6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NF7: // global
           I64[Sp - 16] = block_c4NEW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NH8; else goto c4NEX;
       u4NH8: // global
           call _c4NEW(R1) args: 0, res: 0, upd: 0;
       c4NEX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NEW() //  [R1]
         { info_tbl: [(c4NEW,
                       label: block_c4NEW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NEW: // global
           _s4L0o::P64 = P64[Sp + 8];
           _c4NF4::P64 = R1 & 7;
           if (_c4NF4::P64 < 3) goto u4NGG; else goto u4NGH;
       u4NGG: // global
           if (_c4NF4::P64 < 2) goto c4NF0; else goto c4NF1;
       c4NF0: // global
           I64[Sp + 8] = block_c4NFa_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NH4; else goto c4NFc;
       u4NH4: // global
           call _c4NFa(R1) args: 0, res: 0, upd: 0;
       c4NFc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NF1: // global
           I64[Sp + 8] = block_c4NFx_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NH5; else goto c4NFz;
       u4NH5: // global
           call _c4NFx(R1) args: 0, res: 0, upd: 0;
       c4NFz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4NGH: // global
           if (_c4NF4::P64 < 4) goto c4NF2; else goto c4NF3;
       c4NF2: // global
           I64[Sp + 8] = block_c4NFU_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NH6; else goto c4NFW;
       u4NH6: // global
           call _c4NFU(R1) args: 0, res: 0, upd: 0;
       c4NFW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NF3: // global
           I64[Sp + 8] = block_c4NGh_info;
           R1 = _s4L0o::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NH7; else goto c4NGj;
       u4NH7: // global
           call _c4NGh(R1) args: 0, res: 0, upd: 0;
       c4NGj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NFa() //  [R1]
         { info_tbl: [(c4NFa,
                       label: block_c4NFa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NFa: // global
           _c4NGF::P64 = R1 & 7;
           if (_c4NGF::P64 < 3) goto u4NGI; else goto u4NGJ;
       u4NGI: // global
           if (_c4NGF::P64 < 2) goto u4NGR; else goto u4NGQ;
       u4NGR: // global
           Sp = Sp + 8;
           call _c4NGB() args: 0, res: 0, upd: 0;
       u4NGQ: // global
           Sp = Sp + 8;
           call _c4NGe() args: 0, res: 0, upd: 0;
       u4NGJ: // global
           if (_c4NGF::P64 < 4) goto u4NGS; else goto c4NFu;
       u4NGS: // global
           Sp = Sp + 8;
           call _c4NFR() args: 0, res: 0, upd: 0;
       c4NFu: // global
           R1 = 3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NFx() //  [R1]
         { info_tbl: [(c4NFx,
                       label: block_c4NFx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NFx: // global
           _c4NGE::P64 = R1 & 7;
           if (_c4NGE::P64 < 3) goto u4NGK; else goto u4NGL;
       u4NGK: // global
           if (_c4NGE::P64 < 2) goto u4NGU; else goto u4NGT;
       u4NGU: // global
           Sp = Sp + 8;
           call _c4NGx() args: 0, res: 0, upd: 0;
       u4NGT: // global
           Sp = Sp + 8;
           call _c4NGB() args: 0, res: 0, upd: 0;
       u4NGL: // global
           if (_c4NGE::P64 < 4) goto u4NGW; else goto u4NGV;
       u4NGW: // global
           Sp = Sp + 8;
           call _c4NGe() args: 0, res: 0, upd: 0;
       u4NGV: // global
           Sp = Sp + 8;
           call _c4NFR() args: 0, res: 0, upd: 0;
     }
 },
 _c4NFR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NFR: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NFU() //  [R1]
         { info_tbl: [(c4NFU,
                       label: block_c4NFU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NFU: // global
           _c4NGD::P64 = R1 & 7;
           if (_c4NGD::P64 < 3) goto u4NGM; else goto u4NGN;
       u4NGM: // global
           if (_c4NGD::P64 < 2) goto u4NGY; else goto u4NGX;
       u4NGY: // global
           Sp = Sp + 8;
           call _c4NGt() args: 0, res: 0, upd: 0;
       u4NGX: // global
           Sp = Sp + 8;
           call _c4NGx() args: 0, res: 0, upd: 0;
       u4NGN: // global
           if (_c4NGD::P64 < 4) goto u4NH0; else goto u4NGZ;
       u4NH0: // global
           Sp = Sp + 8;
           call _c4NGB() args: 0, res: 0, upd: 0;
       u4NGZ: // global
           Sp = Sp + 8;
           call _c4NGe() args: 0, res: 0, upd: 0;
     }
 },
 _c4NGe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NGe: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NGh() //  [R1]
         { info_tbl: [(c4NGh,
                       label: block_c4NGh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NGh: // global
           _c4NGC::P64 = R1 & 7;
           if (_c4NGC::P64 < 3) goto u4NGO; else goto u4NGP;
       u4NGO: // global
           if (_c4NGC::P64 < 2) goto c4NGp; else goto u4NH1;
       c4NGp: // global
           R1 = (-3);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4NH1: // global
           Sp = Sp + 8;
           call _c4NGt() args: 0, res: 0, upd: 0;
       u4NGP: // global
           if (_c4NGC::P64 < 4) goto u4NH3; else goto u4NH2;
       u4NH3: // global
           Sp = Sp + 8;
           call _c4NGx() args: 0, res: 0, upd: 0;
       u4NH2: // global
           Sp = Sp + 8;
           call _c4NGB() args: 0, res: 0, upd: 0;
     }
 },
 _c4NGt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NGt: // global
           R1 = (-2);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NGx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NGx: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NGB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NGB: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.64742503 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4NIf,
                       label: GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NIf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NIn; else goto c4NIo;
       c4NIn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NIo: // global
           I64[Sp - 16] = block_c4NIc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NIt; else goto c4NId;
       u4NIt: // global
           call _c4NIc(R1) args: 0, res: 0, upd: 0;
       c4NId: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NIc() //  [R1]
         { info_tbl: [(c4NIc,
                       label: block_c4NIc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NIc: // global
           _s4L0v::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4NIi_info;
           R3 = _s4L0v::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$cunsafeIndex_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4NIi() //  [R1]
         { info_tbl: [(c4NIi,
                       label: block_c4NIi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NIi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4NIs; else goto c4NIr;
       c4NIs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4NIr: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.659481848 UTC

[section ""data" . GHC.IO.IOMode.$w$cinRange_closure" {
     GHC.IO.IOMode.$w$cinRange_closure:
         const GHC.IO.IOMode.$w$cinRange_info;
 },
 GHC.IO.IOMode.$w$cinRange_entry() //  [R2, R3, R4]
         { info_tbl: [(c4NIW,
                       label: GHC.IO.IOMode.$w$cinRange_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NIW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4NIX; else goto c4NIY;
       c4NIX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cinRange_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NIY: // global
           I64[Sp - 24] = block_c4NIN_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4NKE; else goto c4NIO;
       u4NKE: // global
           call _c4NIN(R1) args: 0, res: 0, upd: 0;
       c4NIO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NIN() //  [R1]
         { info_tbl: [(c4NIN,
                       label: block_c4NIN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NIN: // global
           _s4L0B::P64 = P64[Sp + 8];
           _c4NIV::P64 = R1 & 7;
           if (_c4NIV::P64 < 3) goto u4NKx; else goto u4NKy;
       u4NKx: // global
           if (_c4NIV::P64 < 2) goto c4NIR; else goto c4NIS;
       c4NIR: // global
           _s4L0E::I64 = 0;
           goto s4L0D;
       c4NIS: // global
           _s4L0E::I64 = 1;
           goto s4L0D;
       u4NKy: // global
           if (_c4NIV::P64 < 4) goto c4NIT; else goto c4NIU;
       c4NIT: // global
           _s4L0E::I64 = 2;
           goto s4L0D;
       c4NIU: // global
           _s4L0E::I64 = 3;
           goto s4L0D;
       s4L0D: // global
           I64[Sp] = block_c4NJ4_info;
           R1 = _s4L0B::P64;
           I64[Sp + 8] = _s4L0E::I64;
           if (R1 & 7 != 0) goto u4NKD; else goto c4NJO;
       u4NKD: // global
           call _c4NJ4(R1) args: 0, res: 0, upd: 0;
       c4NJO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NJ4() //  [R1]
         { info_tbl: [(c4NJ4,
                       label: block_c4NJ4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NJ4: // global
           _s4L0C::P64 = P64[Sp + 16];
           _c4NKj::P64 = R1 & 7;
           if (_c4NKj::P64 < 3) goto u4NKz; else goto u4NKA;
       u4NKz: // global
           if (_c4NKj::P64 < 2) goto c4NJU; else goto c4NJY;
       c4NJU: // global
           _s4L0G::I64 = 0;
           goto s4L0F;
       c4NJY: // global
           _s4L0G::I64 = 1;
           goto s4L0F;
       u4NKA: // global
           if (_c4NKj::P64 < 4) goto c4NK2; else goto c4NK6;
       c4NK2: // global
           _s4L0G::I64 = 2;
           goto s4L0F;
       c4NK6: // global
           _s4L0G::I64 = 3;
           goto s4L0F;
       s4L0F: // global
           I64[Sp] = block_c4NJ9_info;
           R1 = _s4L0C::P64;
           I64[Sp + 16] = _s4L0G::I64;
           if (R1 & 7 != 0) goto u4NKF; else goto c4NJb;
       u4NKF: // global
           call _c4NJ9(R1) args: 0, res: 0, upd: 0;
       c4NJb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NJ9() //  [R1]
         { info_tbl: [(c4NJ9,
                       label: block_c4NJ9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NJ9: // global
           _s4L0E::I64 = I64[Sp + 8];
           _s4L0G::I64 = I64[Sp + 16];
           _c4NKk::P64 = R1 & 7;
           if (_c4NKk::P64 < 3) goto u4NKB; else goto u4NKC;
       u4NKB: // global
           if (_c4NKk::P64 < 2) goto c4NJm; else goto c4NJv;
       c4NJm: // global
           if (%MO_S_Lt_W64(0, _s4L0E::I64)) goto c4NJL; else goto c4NJk;
       c4NJk: // global
           R1 = I64[(%MO_S_Le_W64(0,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NJv: // global
           if (%MO_S_Lt_W64(1, _s4L0E::I64)) goto c4NJL; else goto c4NJu;
       c4NJu: // global
           R1 = I64[(%MO_S_Le_W64(1,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4NKC: // global
           if (_c4NKk::P64 < 4) goto c4NJE; else goto c4NJN;
       c4NJE: // global
           if (%MO_S_Lt_W64(2, _s4L0E::I64)) goto c4NJL; else goto c4NJD;
       c4NJD: // global
           R1 = I64[(%MO_S_Le_W64(2,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NJN: // global
           if (%MO_S_Lt_W64(3, _s4L0E::I64)) goto c4NJL; else goto c4NJM;
       c4NJL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NJM: // global
           R1 = I64[(%MO_S_Le_W64(3,
                                  _s4L0G::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.67629361 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cinRange_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cinRange_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cinRange_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4NLk,
                       label: GHC.IO.IOMode.$fIxIOMode_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NLk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NLl; else goto c4NLm;
       c4NLl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NLm: // global
           I64[Sp - 16] = block_c4NLh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NLq; else goto c4NLi;
       u4NLq: // global
           call _c4NLh(R1) args: 0, res: 0, upd: 0;
       c4NLi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NLh() //  [R1]
         { info_tbl: [(c4NLh,
                       label: block_c4NLh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NLh: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.682060929 UTC

[section ""data" . lvl_r4KYL_closure" {
     lvl_r4KYL_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.683817608 UTC

[section ""data" . lvl1_r4KYM_closure" {
     lvl1_r4KYM_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.685575356 UTC

[section ""data" . lvl2_r4KYN_closure" {
     lvl2_r4KYN_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.68724487 UTC

[section ""data" . lvl3_r4KYO_closure" {
     lvl3_r4KYO_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.689581325 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_info;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4NLR,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NLR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4NLS; else goto c4NLT;
       c4NLS: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NLT: // global
           I64[Sp - 8] = block_c4NLI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4NM8; else goto c4NLJ;
       u4NM8: // global
           call _c4NLI(R1) args: 0, res: 0, upd: 0;
       c4NLJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NLI() //  [R1]
         { info_tbl: [(c4NLI,
                       label: block_c4NLI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NLI: // global
           _c4NLQ::P64 = R1 & 7;
           if (_c4NLQ::P64 < 3) goto u4NM6; else goto u4NM7;
       u4NM6: // global
           if (_c4NLQ::P64 < 2) goto c4NLM; else goto c4NLN;
       c4NLM: // global
           R1 = lvl_r4KYL_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NLN: // global
           R1 = lvl1_r4KYM_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4NM7: // global
           if (_c4NLQ::P64 < 4) goto c4NLO; else goto c4NLP;
       c4NLO: // global
           R1 = lvl2_r4KYN_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NLP: // global
           R1 = lvl3_r4KYO_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.696698249 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go2_closure" {
     GHC.IO.IOMode.$fIxIOMode_go2_closure:
         const GHC.IO.IOMode.$fIxIOMode_go2_info;
 },
 sat_s4L13_entry() //  [R1]
         { info_tbl: [(c4NMz,
                       label: sat_s4L13_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NMz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NMA; else goto c4NMB;
       c4NMA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NMB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L11::I64 = I64[R1 + 16];
           if (_s4L11::I64 != 0) goto c4NMx; else goto c4NMy;
       c4NMx: // global
           R2 = _s4L11::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go2_entry(R2) args: 24, res: 0, upd: 24;
       c4NMy: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L10_entry() //  [R1]
         { info_tbl: [(c4NMI,
                       label: sat_s4L10_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NMI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NMJ; else goto c4NMK;
       c4NMJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NMK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go2_entry() //  [R2]
         { info_tbl: [(c4NMM,
                       label: GHC.IO.IOMode.$fIxIOMode_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NMM: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4NMQ; else goto c4NMP;
       c4NMQ: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NMP: // global
           I64[Hp - 64] = sat_s4L13_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L10_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.706462987 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go1_closure" {
     GHC.IO.IOMode.$fIxIOMode_go1_closure:
         const GHC.IO.IOMode.$fIxIOMode_go1_info;
 },
 sat_s4L18_entry() //  [R1]
         { info_tbl: [(c4NNl,
                       label: sat_s4L18_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NNm; else goto c4NNn;
       c4NNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NNn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L16::I64 = I64[R1 + 16];
           if (_s4L16::I64 != 1) goto c4NNj; else goto c4NNk;
       c4NNj: // global
           R2 = _s4L16::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go1_entry(R2) args: 24, res: 0, upd: 24;
       c4NNk: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L15_entry() //  [R1]
         { info_tbl: [(c4NNu,
                       label: sat_s4L15_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NNu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NNv; else goto c4NNw;
       c4NNv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NNw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go1_entry() //  [R2]
         { info_tbl: [(c4NNy,
                       label: GHC.IO.IOMode.$fIxIOMode_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NNy: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4NNC; else goto c4NNB;
       c4NNC: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NNB: // global
           I64[Hp - 64] = sat_s4L18_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L15_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.71528632 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go_closure" {
     GHC.IO.IOMode.$fIxIOMode_go_closure:
         const GHC.IO.IOMode.$fIxIOMode_go_info;
 },
 sat_s4L1d_entry() //  [R1]
         { info_tbl: [(c4NO7,
                       label: sat_s4L1d_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NO7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NO8; else goto c4NO9;
       c4NO8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NO9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L1b::I64 = I64[R1 + 16];
           if (_s4L1b::I64 != 2) goto c4NO5; else goto c4NO6;
       c4NO5: // global
           R2 = _s4L1b::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go_entry(R2) args: 24, res: 0, upd: 24;
       c4NO6: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L1a_entry() //  [R1]
         { info_tbl: [(c4NOg,
                       label: sat_s4L1a_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NOg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NOh; else goto c4NOi;
       c4NOh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NOi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go_entry() //  [R2]
         { info_tbl: [(c4NOk,
                       label: GHC.IO.IOMode.$fIxIOMode_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NOk: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4NOo; else goto c4NOn;
       c4NOo: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NOn: // global
           I64[Hp - 64] = sat_s4L1d_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L1a_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.724113555 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go4_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go4_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go4_info;
 },
 sat_s4L1i_entry() //  [R1]
         { info_tbl: [(c4NOT,
                       label: sat_s4L1i_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NOT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NOU; else goto c4NOV;
       c4NOU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NOV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L1g::I64 = I64[R1 + 16];
           if (_s4L1g::I64 != 3) goto c4NOR; else goto c4NOS;
       c4NOR: // global
           R2 = _s4L1g::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
       c4NOS: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L1f_entry() //  [R1]
         { info_tbl: [(c4NP2,
                       label: sat_s4L1f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NP2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NP3; else goto c4NP4;
       c4NP3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4NP4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go4_entry() //  [R2]
         { info_tbl: [(c4NP6,
                       label: GHC.IO.IOMode.$fEnumIOMode_go4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NP6: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4NPa; else goto c4NP9;
       c4NPa: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NP9: // global
           I64[Hp - 64] = sat_s4L1i_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L1f_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.73391294 UTC

[section ""data" . GHC.IO.IOMode.$w$crange_closure" {
     GHC.IO.IOMode.$w$crange_closure:
         const GHC.IO.IOMode.$w$crange_info;
 },
 GHC.IO.IOMode.$w$crange_entry() //  [R2, R3]
         { info_tbl: [(c4NPI,
                       label: GHC.IO.IOMode.$w$crange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NPI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NPJ; else goto c4NPK;
       c4NPJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$crange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NPK: // global
           I64[Sp - 16] = block_c4NPz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NQL; else goto c4NPA;
       u4NQL: // global
           call _c4NPz(R1) args: 0, res: 0, upd: 0;
       c4NPA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NPz() //  [R1]
         { info_tbl: [(c4NPz,
                       label: block_c4NPz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NPz: // global
           _s4L1k::P64 = P64[Sp + 8];
           _c4NPH::P64 = R1 & 7;
           if (_c4NPH::P64 < 3) goto u4NQG; else goto u4NQH;
       u4NQG: // global
           if (_c4NPH::P64 < 2) goto c4NPD; else goto c4NPE;
       c4NPD: // global
           _s4L1m::I64 = 0;
           goto s4L1l;
       c4NPE: // global
           _s4L1m::I64 = 1;
           goto s4L1l;
       u4NQH: // global
           if (_c4NPH::P64 < 4) goto c4NPF; else goto c4NPG;
       c4NPF: // global
           _s4L1m::I64 = 2;
           goto s4L1l;
       c4NPG: // global
           _s4L1m::I64 = 3;
           goto s4L1l;
       s4L1l: // global
           I64[Sp] = block_c4NPO_info;
           R1 = _s4L1k::P64;
           I64[Sp + 8] = _s4L1m::I64;
           if (R1 & 7 != 0) goto u4NQK; else goto c4NPQ;
       u4NQK: // global
           call _c4NPO(R1) args: 0, res: 0, upd: 0;
       c4NPQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NPO() //  [R1]
         { info_tbl: [(c4NPO,
                       label: block_c4NPO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NPO: // global
           _s4L1m::I64 = I64[Sp + 8];
           _c4NQF::P64 = R1 & 7;
           if (_c4NQF::P64 < 3) goto u4NQI; else goto u4NQJ;
       u4NQI: // global
           if (_c4NQF::P64 < 2) goto c4NQ1; else goto c4NQa;
       c4NQ1: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 0)) goto c4NQr; else goto c4NPY;
       c4NPY: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go2_entry(R2) args: 8, res: 0, upd: 8;
       c4NQa: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 1)) goto c4NQr; else goto c4NQ8;
       c4NQ8: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go1_entry(R2) args: 8, res: 0, upd: 8;
       u4NQJ: // global
           if (_c4NQF::P64 < 4) goto c4NQj; else goto c4NQs;
       c4NQj: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 2)) goto c4NQr; else goto c4NQh;
       c4NQh: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go_entry(R2) args: 8, res: 0, upd: 8;
       c4NQs: // global
           if (%MO_S_Gt_W64(_s4L1m::I64, 3)) goto c4NQr; else goto c4NQq;
       c4NQr: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4NQq: // global
           R2 = _s4L1m::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.745076542 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$crange_closure" {
     GHC.IO.IOMode.$fIxIOMode_$crange_closure:
         const GHC.IO.IOMode.$fIxIOMode_$crange_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$crange_entry() //  [R2]
         { info_tbl: [(c4NR9,
                       label: GHC.IO.IOMode.$fIxIOMode_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NR9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4NRa; else goto c4NRb;
       c4NRa: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NRb: // global
           I64[Sp - 8] = block_c4NR6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4NRf; else goto c4NR7;
       u4NRf: // global
           call _c4NR6(R1) args: 0, res: 0, upd: 0;
       c4NR7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NR6() //  [R1]
         { info_tbl: [(c4NR6,
                       label: block_c4NR6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NR6: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$crange_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.752004294 UTC

[section ""data" . GHC.IO.IOMode.$w$crangeSize_closure" {
     GHC.IO.IOMode.$w$crangeSize_closure:
         const GHC.IO.IOMode.$w$crangeSize_info;
 },
 GHC.IO.IOMode.$w$crangeSize_entry() //  [R2, R3]
         { info_tbl: [(c4NRz,
                       label: GHC.IO.IOMode.$w$crangeSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NRz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4NRA; else goto c4NRB;
       c4NRA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$crangeSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NRB: // global
           I64[Sp - 24] = block_c4NRt_info;
           R4 = R3;
           _s4L1y::P64 = R3;
           R3 = R3;
           _s4L1x::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4L1x::P64;
           P64[Sp - 8] = _s4L1y::P64;
           Sp = Sp - 24;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4NRt() //  [R1]
         { info_tbl: [(c4NRt,
                       label: block_c4NRt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NRt: // global
           if (R1 & 7 == 1) goto u4NTz; else goto c4NRx;
       u4NTz: // global
           Sp = Sp + 24;
           call _c4NTf() args: 0, res: 0, upd: 0;
       c4NRx: // global
           _s4L1x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4NRH_info;
           R1 = _s4L1x::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NTO; else goto c4NRJ;
       u4NTO: // global
           call _c4NRH(R1) args: 0, res: 0, upd: 0;
       c4NRJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NRH() //  [R1]
         { info_tbl: [(c4NRH,
                       label: block_c4NRH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NRH: // global
           _s4L1y::P64 = P64[Sp + 8];
           _c4NTk::P64 = R1 & 7;
           if (_c4NTk::P64 < 3) goto u4NTp; else goto u4NTq;
       u4NTp: // global
           if (_c4NTk::P64 < 2) goto c4NRQ; else goto c4NSe;
       c4NRQ: // global
           I64[Sp + 8] = block_c4NRN_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NTQ; else goto c4NRR;
       u4NTQ: // global
           call _c4NRN(R1) args: 0, res: 0, upd: 0;
       c4NRR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NSe: // global
           I64[Sp + 8] = block_c4NSc_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NTR; else goto c4NSf;
       u4NTR: // global
           call _c4NSc(R1) args: 0, res: 0, upd: 0;
       c4NSf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4NTq: // global
           if (_c4NTk::P64 < 4) goto c4NSC; else goto c4NT0;
       c4NSC: // global
           I64[Sp + 8] = block_c4NSA_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NTS; else goto c4NSD;
       u4NTS: // global
           call _c4NSA(R1) args: 0, res: 0, upd: 0;
       c4NSD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NT0: // global
           I64[Sp + 8] = block_c4NSY_info;
           R1 = _s4L1y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NTT; else goto c4NT1;
       u4NTT: // global
           call _c4NSY(R1) args: 0, res: 0, upd: 0;
       c4NT1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NRN() //  [R1]
         { info_tbl: [(c4NRN,
                       label: block_c4NRN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NRN: // global
           _c4NTo::P64 = R1 & 7;
           if (_c4NTo::P64 < 3) goto u4NTr; else goto u4NTs;
       u4NTr: // global
           if (_c4NTo::P64 < 2) goto u4NTB; else goto u4NTA;
       u4NTB: // global
           Sp = Sp + 8;
           call _c4NTj() args: 0, res: 0, upd: 0;
       u4NTA: // global
           Sp = Sp + 8;
           call _c4NSV() args: 0, res: 0, upd: 0;
       u4NTs: // global
           if (_c4NTo::P64 < 4) goto u4NTC; else goto c4NS9;
       u4NTC: // global
           Sp = Sp + 8;
           call _c4NSx() args: 0, res: 0, upd: 0;
       c4NS9: // global
           R1 = 4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NSc() //  [R1]
         { info_tbl: [(c4NSc,
                       label: block_c4NSc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NSc: // global
           _c4NTn::P64 = R1 & 7;
           if (_c4NTn::P64 < 3) goto u4NTt; else goto u4NTu;
       u4NTt: // global
           if (_c4NTn::P64 < 2) goto u4NTE; else goto u4NTD;
       u4NTE: // global
           Sp = Sp + 8;
           call _c4NTf() args: 0, res: 0, upd: 0;
       u4NTD: // global
           Sp = Sp + 8;
           call _c4NTj() args: 0, res: 0, upd: 0;
       u4NTu: // global
           if (_c4NTn::P64 < 4) goto u4NTG; else goto u4NTF;
       u4NTG: // global
           Sp = Sp + 8;
           call _c4NSV() args: 0, res: 0, upd: 0;
       u4NTF: // global
           Sp = Sp + 8;
           call _c4NSx() args: 0, res: 0, upd: 0;
     }
 },
 _c4NSx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NSx: // global
           R1 = 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NSA() //  [R1]
         { info_tbl: [(c4NSA,
                       label: block_c4NSA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NSA: // global
           _c4NTm::P64 = R1 & 7;
           if (_c4NTm::P64 < 3) goto u4NTv; else goto u4NTw;
       u4NTv: // global
           if (_c4NTm::P64 < 2) goto u4NTI; else goto u4NTH;
       u4NTI: // global
           Sp = Sp + 8;
           call _c4NTb() args: 0, res: 0, upd: 0;
       u4NTH: // global
           Sp = Sp + 8;
           call _c4NTf() args: 0, res: 0, upd: 0;
       u4NTw: // global
           if (_c4NTm::P64 < 4) goto u4NTK; else goto u4NTJ;
       u4NTK: // global
           Sp = Sp + 8;
           call _c4NTj() args: 0, res: 0, upd: 0;
       u4NTJ: // global
           Sp = Sp + 8;
           call _c4NSV() args: 0, res: 0, upd: 0;
     }
 },
 _c4NSV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NSV: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NSY() //  [R1]
         { info_tbl: [(c4NSY,
                       label: block_c4NSY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NSY: // global
           _c4NTl::P64 = R1 & 7;
           if (_c4NTl::P64 < 3) goto u4NTx; else goto u4NTy;
       u4NTx: // global
           if (_c4NTl::P64 < 2) goto c4NT7; else goto u4NTL;
       c4NT7: // global
           R1 = (-2);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4NTL: // global
           Sp = Sp + 8;
           call _c4NTb() args: 0, res: 0, upd: 0;
       u4NTy: // global
           if (_c4NTl::P64 < 4) goto u4NTN; else goto u4NTM;
       u4NTN: // global
           Sp = Sp + 8;
           call _c4NTf() args: 0, res: 0, upd: 0;
       u4NTM: // global
           Sp = Sp + 8;
           call _c4NTj() args: 0, res: 0, upd: 0;
     }
 },
 _c4NTb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NTb: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NTf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NTf: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NTj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NTj: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.774261246 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure" {
     GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure:
         const GHC.IO.IOMode.$fIxIOMode_$crangeSize_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4NV5,
                       label: GHC.IO.IOMode.$fIxIOMode_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NV5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4NVd; else goto c4NVe;
       c4NVd: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NVe: // global
           I64[Sp - 8] = block_c4NV2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4NVj; else goto c4NV3;
       u4NVj: // global
           call _c4NV2(R1) args: 0, res: 0, upd: 0;
       c4NV3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NV2() //  [R1]
         { info_tbl: [(c4NV2,
                       label: block_c4NV2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NV2: // global
           I64[Sp] = block_c4NV8_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.IOMode.$w$crangeSize_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4NV8() //  [R1]
         { info_tbl: [(c4NV8,
                       label: block_c4NV8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NV8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4NVi; else goto c4NVh;
       c4NVi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4NVh: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.783112539 UTC

[section ""data" . GHC.IO.IOMode.$w$cunsafeRangeSize_closure" {
     GHC.IO.IOMode.$w$cunsafeRangeSize_closure:
         const GHC.IO.IOMode.$w$cunsafeRangeSize_info;
 },
 GHC.IO.IOMode.$w$cunsafeRangeSize_entry() //  [R2, R3]
         { info_tbl: [(c4NVK,
                       label: GHC.IO.IOMode.$w$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NVK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4NVL; else goto c4NVM;
       c4NVL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NVM: // global
           I64[Sp - 16] = block_c4NVB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NXN; else goto c4NVC;
       u4NXN: // global
           call _c4NVB(R1) args: 0, res: 0, upd: 0;
       c4NVC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NVB() //  [R1]
         { info_tbl: [(c4NVB,
                       label: block_c4NVB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NVB: // global
           _s4L1L::P64 = P64[Sp + 8];
           _c4NVJ::P64 = R1 & 7;
           if (_c4NVJ::P64 < 3) goto u4NXl; else goto u4NXm;
       u4NXl: // global
           if (_c4NVJ::P64 < 2) goto c4NVF; else goto c4NVG;
       c4NVF: // global
           I64[Sp + 8] = block_c4NVP_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NXJ; else goto c4NVR;
       u4NXJ: // global
           call _c4NVP(R1) args: 0, res: 0, upd: 0;
       c4NVR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NVG: // global
           I64[Sp + 8] = block_c4NWc_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NXK; else goto c4NWe;
       u4NXK: // global
           call _c4NWc(R1) args: 0, res: 0, upd: 0;
       c4NWe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4NXm: // global
           if (_c4NVJ::P64 < 4) goto c4NVH; else goto c4NVI;
       c4NVH: // global
           I64[Sp + 8] = block_c4NWz_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NXL; else goto c4NWB;
       u4NXL: // global
           call _c4NWz(R1) args: 0, res: 0, upd: 0;
       c4NWB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4NVI: // global
           I64[Sp + 8] = block_c4NWW_info;
           R1 = _s4L1L::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4NXM; else goto c4NWY;
       u4NXM: // global
           call _c4NWW(R1) args: 0, res: 0, upd: 0;
       c4NWY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NVP() //  [R1]
         { info_tbl: [(c4NVP,
                       label: block_c4NVP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NVP: // global
           _c4NXk::P64 = R1 & 7;
           if (_c4NXk::P64 < 3) goto u4NXn; else goto u4NXo;
       u4NXn: // global
           if (_c4NXk::P64 < 2) goto u4NXw; else goto u4NXv;
       u4NXw: // global
           Sp = Sp + 8;
           call _c4NXg() args: 0, res: 0, upd: 0;
       u4NXv: // global
           Sp = Sp + 8;
           call _c4NWT() args: 0, res: 0, upd: 0;
       u4NXo: // global
           if (_c4NXk::P64 < 4) goto u4NXx; else goto c4NW9;
       u4NXx: // global
           Sp = Sp + 8;
           call _c4NWw() args: 0, res: 0, upd: 0;
       c4NW9: // global
           R1 = 4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NWc() //  [R1]
         { info_tbl: [(c4NWc,
                       label: block_c4NWc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NWc: // global
           _c4NXj::P64 = R1 & 7;
           if (_c4NXj::P64 < 3) goto u4NXp; else goto u4NXq;
       u4NXp: // global
           if (_c4NXj::P64 < 2) goto u4NXz; else goto u4NXy;
       u4NXz: // global
           Sp = Sp + 8;
           call _c4NXc() args: 0, res: 0, upd: 0;
       u4NXy: // global
           Sp = Sp + 8;
           call _c4NXg() args: 0, res: 0, upd: 0;
       u4NXq: // global
           if (_c4NXj::P64 < 4) goto u4NXB; else goto u4NXA;
       u4NXB: // global
           Sp = Sp + 8;
           call _c4NWT() args: 0, res: 0, upd: 0;
       u4NXA: // global
           Sp = Sp + 8;
           call _c4NWw() args: 0, res: 0, upd: 0;
     }
 },
 _c4NWw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NWw: // global
           R1 = 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NWz() //  [R1]
         { info_tbl: [(c4NWz,
                       label: block_c4NWz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NWz: // global
           _c4NXi::P64 = R1 & 7;
           if (_c4NXi::P64 < 3) goto u4NXr; else goto u4NXs;
       u4NXr: // global
           if (_c4NXi::P64 < 2) goto u4NXD; else goto u4NXC;
       u4NXD: // global
           Sp = Sp + 8;
           call _c4NX8() args: 0, res: 0, upd: 0;
       u4NXC: // global
           Sp = Sp + 8;
           call _c4NXc() args: 0, res: 0, upd: 0;
       u4NXs: // global
           if (_c4NXi::P64 < 4) goto u4NXF; else goto u4NXE;
       u4NXF: // global
           Sp = Sp + 8;
           call _c4NXg() args: 0, res: 0, upd: 0;
       u4NXE: // global
           Sp = Sp + 8;
           call _c4NWT() args: 0, res: 0, upd: 0;
     }
 },
 _c4NWT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NWT: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NWW() //  [R1]
         { info_tbl: [(c4NWW,
                       label: block_c4NWW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NWW: // global
           _c4NXh::P64 = R1 & 7;
           if (_c4NXh::P64 < 3) goto u4NXt; else goto u4NXu;
       u4NXt: // global
           if (_c4NXh::P64 < 2) goto c4NX4; else goto u4NXG;
       c4NX4: // global
           R1 = (-2);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4NXG: // global
           Sp = Sp + 8;
           call _c4NX8() args: 0, res: 0, upd: 0;
       u4NXu: // global
           if (_c4NXh::P64 < 4) goto u4NXI; else goto u4NXH;
       u4NXI: // global
           Sp = Sp + 8;
           call _c4NXc() args: 0, res: 0, upd: 0;
       u4NXH: // global
           Sp = Sp + 8;
           call _c4NXg() args: 0, res: 0, upd: 0;
     }
 },
 _c4NX8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NX8: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NXc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NXc: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4NXg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NXg: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.803801594 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4NYU,
                       label: GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NYU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4NZ2; else goto c4NZ3;
       c4NZ2: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4NZ3: // global
           I64[Sp - 8] = block_c4NYR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4NZ8; else goto c4NYS;
       u4NZ8: // global
           call _c4NYR(R1) args: 0, res: 0, upd: 0;
       c4NYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NYR() //  [R1]
         { info_tbl: [(c4NYR,
                       label: block_c4NYR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NYR: // global
           I64[Sp] = block_c4NYX_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.IOMode.$w$cunsafeRangeSize_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4NYX() //  [R1]
         { info_tbl: [(c4NYX,
                       label: block_c4NYX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NYX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4NZ7; else goto c4NZ6;
       c4NZ7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4NZ6: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.812063643 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cindex_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cindex_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cindex_info;
         const 0;
 },
 GHC.IO.IOMode.$fIxIOMode_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4NZt,
                       label: GHC.IO.IOMode.$fIxIOMode_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NZt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4NZu; else goto c4NZv;
       c4NZu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4NZv: // global
           I64[Sp - 16] = block_c4NZq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4NZT; else goto c4NZr;
       u4NZT: // global
           call _c4NZq(R1) args: 0, res: 0, upd: 0;
       c4NZr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4NZq() //  [R1]
         { info_tbl: [(c4NZq,
                       label: block_c4NZq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NZq: // global
           I64[Sp - 8] = block_c4NZy_info;
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           _s4L1Z::P64 = P64[R1 + 7];
           R2 = _s4L1Z::P64;
           P64[Sp] = _s4L1Z::P64;
           Sp = Sp - 8;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4NZy() //  [R1]
         { info_tbl: [(c4NZy,
                       label: block_c4NZy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NZy: // global
           if (R1 & 7 == 1) goto c4NZF; else goto c4NZO;
       c4NZF: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4NZO: // global
           _s4L1X::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4NZI_info;
           R3 = _s4L1X::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.IOMode.$w$cunsafeIndex_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4NZI() //  [R1]
         { info_tbl: [(c4NZI,
                       label: block_c4NZI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4NZI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4NZR; else goto c4NZQ;
       c4NZR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4NZQ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.822124713 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_closure" {
     GHC.IO.IOMode.$fIxIOMode_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.IO.IOMode.$fOrdIOMode_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$crange_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$cindex_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$cinRange_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.824641696 UTC

[section ""cstring" . lvl4_r4KYP_bytes" {
     lvl4_r4KYP_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.826853556 UTC

[section ""data" . lvl5_r4KYQ_closure" {
     lvl5_r4KYQ_closure:
         const lvl5_r4KYQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r4KYQ_entry() //  [R1]
         { info_tbl: [(c4O0l,
                       label: lvl5_r4KYQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O0l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O0m; else goto c4O0n;
       c4O0m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O0n: // global
           (_c4O0i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O0i::I64 == 0) goto c4O0k; else goto c4O0j;
       c4O0k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O0j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O0i::I64;
           R2 = lvl4_r4KYP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.830925238 UTC

[section ""cstring" . GHC.IO.IOMode.$trModule4_bytes" {
     GHC.IO.IOMode.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.832898088 UTC

[section ""data" . lvl6_r4KYR_closure" {
     lvl6_r4KYR_closure:
         const lvl6_r4KYR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r4KYR_entry() //  [R1]
         { info_tbl: [(c4O0C,
                       label: lvl6_r4KYR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O0C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O0D; else goto c4O0E;
       c4O0D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O0E: // global
           (_c4O0z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O0z::I64 == 0) goto c4O0B; else goto c4O0A;
       c4O0B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O0A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O0z::I64;
           R2 = GHC.IO.IOMode.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.836911992 UTC

[section ""cstring" . GHC.IO.IOMode.$trModule2_bytes" {
     GHC.IO.IOMode.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,73,79,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.83927918 UTC

[section ""data" . lvl7_r4KYS_closure" {
     lvl7_r4KYS_closure:
         const lvl7_r4KYS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r4KYS_entry() //  [R1]
         { info_tbl: [(c4O0T,
                       label: lvl7_r4KYS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O0T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O0U; else goto c4O0V;
       c4O0U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O0V: // global
           (_c4O0Q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O0Q::I64 == 0) goto c4O0S; else goto c4O0R;
       c4O0S: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O0R: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O0Q::I64;
           R2 = GHC.IO.IOMode.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.843353597 UTC

[section ""cstring" . lvl8_r4KYT_bytes" {
     lvl8_r4KYT_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,73,79,77,111,100,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.845517031 UTC

[section ""data" . lvl9_r4KYU_closure" {
     lvl9_r4KYU_closure:
         const lvl9_r4KYU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r4KYU_entry() //  [R1]
         { info_tbl: [(c4O1a,
                       label: lvl9_r4KYU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O1a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O1b; else goto c4O1c;
       c4O1b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O1c: // global
           (_c4O17::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O17::I64 == 0) goto c4O19; else goto c4O18;
       c4O19: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O18: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O17::I64;
           R2 = lvl8_r4KYT_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.849601673 UTC

[section ""data" . lvl10_r4KYV_closure" {
     lvl10_r4KYV_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.851357938 UTC

[section ""data" . lvl11_r4KYW_closure" {
     lvl11_r4KYW_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.854005854 UTC

[section ""data" . lvl12_r4KYX_closure" {
     lvl12_r4KYX_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl6_r4KYR_closure;
         const lvl7_r4KYS_closure;
         const lvl9_r4KYU_closure;
         const lvl10_r4KYV_closure+1;
         const lvl10_r4KYV_closure+1;
         const lvl10_r4KYV_closure+1;
         const lvl11_r4KYW_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.855958551 UTC

[section ""data" . lvl13_r4KYY_closure" {
     lvl13_r4KYY_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl5_r4KYQ_closure;
         const lvl12_r4KYX_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.858421983 UTC

[section ""cstring" . lvl14_r4KYZ_bytes" {
     lvl14_r4KYZ_bytes:
         I8[] [112,114,101,100,123,73,79,77,111,100,101,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.860516089 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode5_closure" {
     GHC.IO.IOMode.$fEnumIOMode5_closure:
         const GHC.IO.IOMode.$fEnumIOMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode5_entry() //  [R1]
         { info_tbl: [(c4O1x,
                       label: GHC.IO.IOMode.$fEnumIOMode5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O1x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4O1y; else goto c4O1z;
       c4O1y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O1z: // global
           (_c4O1s::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O1s::I64 == 0) goto c4O1u; else goto c4O1t;
       c4O1u: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O1t: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O1s::I64;
           I64[Sp - 24] = block_c4O1v_info;
           R2 = lvl14_r4KYZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4O1v() //  [R1]
         { info_tbl: [(c4O1v,
                       label: block_c4O1v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O1v: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.866818954 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cpred_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cpred_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cpred_entry() //  [R2]
         { info_tbl: [(c4O20,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O20: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4O21; else goto c4O22;
       c4O21: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4O22: // global
           I64[Sp - 8] = block_c4O1R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4O2h; else goto c4O1S;
       u4O2h: // global
           call _c4O1R(R1) args: 0, res: 0, upd: 0;
       c4O1S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4O1R() //  [R1]
         { info_tbl: [(c4O1R,
                       label: block_c4O1R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O1R: // global
           _c4O1Z::P64 = R1 & 7;
           if (_c4O1Z::P64 < 3) goto u4O2f; else goto u4O2g;
       u4O2f: // global
           if (_c4O1Z::P64 < 2) goto c4O1V; else goto c4O1W;
       c4O1V: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4O1W: // global
           R1 = GHC.IO.IOMode.ReadMode_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4O2g: // global
           if (_c4O1Z::P64 < 4) goto c4O1X; else goto c4O1Y;
       c4O1X: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4O1Y: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.873003073 UTC

[section ""cstring" . lvl15_r4KZ0_bytes" {
     lvl15_r4KZ0_bytes:
         I8[] [115,117,99,99,123,73,79,77,111,100,101,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.875150782 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode6_closure" {
     GHC.IO.IOMode.$fEnumIOMode6_closure:
         const GHC.IO.IOMode.$fEnumIOMode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode6_entry() //  [R1]
         { info_tbl: [(c4O2F,
                       label: GHC.IO.IOMode.$fEnumIOMode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O2F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4O2G; else goto c4O2H;
       c4O2G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O2H: // global
           (_c4O2A::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O2A::I64 == 0) goto c4O2C; else goto c4O2B;
       c4O2C: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O2B: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O2A::I64;
           I64[Sp - 24] = block_c4O2D_info;
           R2 = lvl15_r4KZ0_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4O2D() //  [R1]
         { info_tbl: [(c4O2D,
                       label: block_c4O2D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O2D: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.881766288 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$csucc_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$csucc_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$csucc_entry() //  [R2]
         { info_tbl: [(c4O38,
                       label: GHC.IO.IOMode.$fEnumIOMode_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O38: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4O39; else goto c4O3a;
       c4O39: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4O3a: // global
           I64[Sp - 8] = block_c4O2Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4O3p; else goto c4O30;
       u4O3p: // global
           call _c4O2Z(R1) args: 0, res: 0, upd: 0;
       c4O30: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4O2Z() //  [R1]
         { info_tbl: [(c4O2Z,
                       label: block_c4O2Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O2Z: // global
           _c4O37::P64 = R1 & 7;
           if (_c4O37::P64 < 3) goto u4O3n; else goto u4O3o;
       u4O3n: // global
           if (_c4O37::P64 < 2) goto c4O33; else goto c4O34;
       c4O33: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4O34: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4O3o: // global
           if (_c4O37::P64 < 4) goto c4O35; else goto c4O36;
       c4O35: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4O36: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.88796748 UTC

[section ""cstring" . lvl16_r4KZ1_bytes" {
     lvl16_r4KZ1_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.89016778 UTC

[section ""cstring" . lvl17_r4KZ2_bytes" {
     lvl17_r4KZ2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.892136407 UTC

[section ""data" . lvl18_r4KZ3_closure" {
     lvl18_r4KZ3_closure:
         const lvl18_r4KZ3_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_r4KZ3_entry() //  [R1]
         { info_tbl: [(c4O3M,
                       label: lvl18_r4KZ3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O3M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O3N; else goto c4O3O;
       c4O3N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O3O: // global
           (_c4O3J::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O3J::I64 == 0) goto c4O3L; else goto c4O3K;
       c4O3L: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O3K: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O3J::I64;
           R2 = lvl17_r4KZ2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.897327301 UTC

[section ""data" . lvl19_r4KZ4_closure" {
     lvl19_r4KZ4_closure:
         const lvl19_r4KZ4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_r4KZ4_entry() //  [R1]
         { info_tbl: [(c4O45,
                       label: lvl19_r4KZ4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O45: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4O46; else goto c4O47;
       c4O46: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O47: // global
           (_c4O3Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O3Z::I64 == 0) goto c4O41; else goto c4O40;
       c4O41: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O40: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O3Z::I64;
           I64[Sp - 24] = block_c4O42_info;
           R4 = lvl18_r4KZ3_closure;
           R3 = 3;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4O42() //  [R1, R2]
         { info_tbl: [(c4O42,
                       label: block_c4O42_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O42: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4O4a; else goto c4O49;
       c4O4a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4O49: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.90340838 UTC

[section ""data" . lvl20_r4KZ5_closure" {
     lvl20_r4KZ5_closure:
         const lvl20_r4KZ5_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_r4KZ5_entry() //  [R1]
         { info_tbl: [(c4O4s,
                       label: lvl20_r4KZ5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O4s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O4t; else goto c4O4u;
       c4O4t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O4u: // global
           (_c4O4p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O4p::I64 == 0) goto c4O4r; else goto c4O4q;
       c4O4r: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O4q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O4p::I64;
           R3 = lvl19_r4KZ4_closure;
           R2 = lvl16_r4KZ1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.907764372 UTC

[section ""cstring" . lvl21_r4KZ6_bytes" {
     lvl21_r4KZ6_bytes:
         I8[] [116,111,69,110,117,109,123,73,79,77,111,100,101,125,58,32,116,97,103,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.910154686 UTC

[section ""data" . GHC.IO.IOMode.$wlvl_closure" {
     GHC.IO.IOMode.$wlvl_closure:
         const GHC.IO.IOMode.$wlvl_info;
         const 0;
 },
 sat_s4L2g_entry() //  [R1]
         { info_tbl: [(c4O4O,
                       label: sat_s4L2g_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O4O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4O4P; else goto c4O4Q;
       c4O4P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O4Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4O4L_info;
           R4 = lvl20_r4KZ5_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4O4L() //  [R1, R2]
         { info_tbl: [(c4O4L,
                       label: block_c4O4L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O4L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4O4T; else goto c4O4S;
       c4O4T: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4O4S: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$wlvl_entry() //  [R2]
         { info_tbl: [(c4O4W,
                       label: GHC.IO.IOMode.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O4W: // global
           _s4L2c::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4O4X; else goto c4O4Y;
       c4O4Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4O50; else goto c4O4Z;
       c4O50: // global
           HpAlloc = 24;
           goto c4O4X;
       c4O4X: // global
           R2 = _s4L2c::I64;
           R1 = GHC.IO.IOMode.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4O4Z: // global
           I64[Hp - 16] = sat_s4L2g_info;
           I64[Hp] = _s4L2c::I64;
           I64[Sp - 8] = block_c4O4U_info;
           R3 = Hp - 16;
           R2 = lvl21_r4KZ6_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4O4U() //  [R1]
         { info_tbl: [(c4O4U,
                       label: block_c4O4U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O4U: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.91996094 UTC

[section ""data" . GHC.IO.IOMode.$w$ctoEnum_closure" {
     GHC.IO.IOMode.$w$ctoEnum_closure:
         const GHC.IO.IOMode.$w$ctoEnum_info;
         const 0;
 },
 GHC.IO.IOMode.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4O5t,
                       label: GHC.IO.IOMode.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O5t: // global
           _s4L2i::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c4O5B; else goto c4O5s;
       c4O5s: // global
           if (%MO_S_Gt_W64(_s4L2i::I64, 3)) goto c4O5B; else goto c4O5C;
       c4O5B: // global
           R2 = _s4L2i::I64;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4O5C: // global
           R1 = I64[(_s4L2i::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.924427073 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4O5Q,
                       label: GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O5Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4O5R; else goto c4O5S;
       c4O5R: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4O5S: // global
           I64[Sp - 8] = block_c4O5N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4O5W; else goto c4O5O;
       u4O5W: // global
           call _c4O5N(R1) args: 0, res: 0, upd: 0;
       c4O5O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4O5N() //  [R1]
         { info_tbl: [(c4O5N,
                       label: block_c4O5N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O5N: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.930203619 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode4_closure" {
     GHC.IO.IOMode.$fEnumIOMode4_closure:
         const GHC.IO.IOMode.$fEnumIOMode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode4_entry() //  [R1]
         { info_tbl: [(c4O6c,
                       label: GHC.IO.IOMode.$fEnumIOMode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O6c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O6d; else goto c4O6e;
       c4O6d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O6e: // global
           (_c4O69::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O69::I64 == 0) goto c4O6b; else goto c4O6a;
       c4O6b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O6a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O69::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.93517607 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode3_closure" {
     GHC.IO.IOMode.$fEnumIOMode3_closure:
         const GHC.IO.IOMode.$fEnumIOMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode3_entry() //  [R1]
         { info_tbl: [(c4O6s,
                       label: GHC.IO.IOMode.$fEnumIOMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O6s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O6t; else goto c4O6u;
       c4O6t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O6u: // global
           (_c4O6p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O6p::I64 == 0) goto c4O6r; else goto c4O6q;
       c4O6r: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O6q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O6p::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.940104257 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode2_closure" {
     GHC.IO.IOMode.$fEnumIOMode2_closure:
         const GHC.IO.IOMode.$fEnumIOMode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode2_entry() //  [R1]
         { info_tbl: [(c4O6I,
                       label: GHC.IO.IOMode.$fEnumIOMode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O6I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O6J; else goto c4O6K;
       c4O6J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O6K: // global
           (_c4O6F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O6F::I64 == 0) goto c4O6H; else goto c4O6G;
       c4O6H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O6G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O6F::I64;
           R2 = 2;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.944349982 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode1_closure" {
     GHC.IO.IOMode.$fEnumIOMode1_closure:
         const GHC.IO.IOMode.$fEnumIOMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode1_entry() //  [R1]
         { info_tbl: [(c4O6Y,
                       label: GHC.IO.IOMode.$fEnumIOMode1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O6Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O6Z; else goto c4O70;
       c4O6Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O70: // global
           (_c4O6V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4O6V::I64 == 0) goto c4O6X; else goto c4O6W;
       c4O6X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4O6W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4O6V::I64;
           R2 = 3;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.948723988 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4O7l,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O7l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4O7m; else goto c4O7n;
       c4O7m: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4O7n: // global
           I64[Sp - 8] = block_c4O7c_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4O7C; else goto c4O7d;
       u4O7C: // global
           call _c4O7c(R1) args: 0, res: 0, upd: 0;
       c4O7d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4O7c() //  [R1]
         { info_tbl: [(c4O7c,
                       label: block_c4O7c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O7c: // global
           _c4O7k::P64 = R1 & 7;
           if (_c4O7k::P64 < 3) goto u4O7A; else goto u4O7B;
       u4O7A: // global
           if (_c4O7k::P64 < 2) goto c4O7g; else goto c4O7h;
       c4O7g: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4O7h: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u4O7B: // global
           if (_c4O7k::P64 < 4) goto c4O7i; else goto c4O7j;
       c4O7i: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4O7j: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:39.961074942 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_info;
 },
 sat_s4L2H_entry() //  [R1]
         { info_tbl: [(c4O8C,
                       label: sat_s4L2H_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O8C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O8D; else goto c4O8E;
       c4O8D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O8E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L2C_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2F_entry() //  [R1]
         { info_tbl: [(c4O8J,
                       label: sat_s4L2F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O8J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O8K; else goto c4O8L;
       c4O8K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O8L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2I_entry() //  [R1]
         { info_tbl: [(c4O8R,
                       label: sat_s4L2I_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O8R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O8S; else goto c4O8T;
       c4O8S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O8T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L2C_entry() //  [R1, R2]
         { info_tbl: [(c4O8X,
                       label: go_dn_s4L2C_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O8X: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4O91; else goto c4O90;
       c4O91: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4O90: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4O8V; else goto c4O8W;
       c4O8V: // global
           _s4L2A::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L2H_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L2A::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L2F_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4O8W: // global
           I64[Hp - 80] = sat_s4L2I_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4O93::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4O93::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L2J_entry() //  [R1]
         { info_tbl: [(c4O94,
                       label: sat_s4L2J_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O94: // global
           _s4L2J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4O95; else goto c4O96;
       c4O96: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4O98; else goto c4O97;
       c4O98: // global
           HpAlloc = 24;
           goto c4O95;
       c4O95: // global
           R1 = _s4L2J::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O97: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L2J::P64;
           _s4L2v::I64 = I64[_s4L2J::P64 + 24];
           _s4L2A::I64 = _s4L2v::I64 - I64[_s4L2J::P64 + 16];
           I64[Hp - 16] = go_dn_s4L2C_info;
           I64[Hp - 8] = _s4L2A::I64;
           I64[Hp] = 3 - _s4L2A::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L2C_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2z_entry() //  [R1]
         { info_tbl: [(c4O9d,
                       label: sat_s4L2z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O9d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O9e; else goto c4O9f;
       c4O9e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O9f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2L_entry() //  [R1]
         { info_tbl: [(c4O9o,
                       label: sat_s4L2L_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O9o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O9p; else goto c4O9q;
       c4O9p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O9q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2V_entry() //  [R1]
         { info_tbl: [(c4O9T,
                       label: sat_s4L2V_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O9T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4O9U; else goto c4O9V;
       c4O9U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4O9V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L2Q_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2T_entry() //  [R1]
         { info_tbl: [(c4Oa0,
                       label: sat_s4L2T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oa0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oa1; else goto c4Oa2;
       c4Oa1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oa2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2W_entry() //  [R1]
         { info_tbl: [(c4Oa8,
                       label: sat_s4L2W_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oa8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oa9; else goto c4Oaa;
       c4Oa9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oaa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L2Q_entry() //  [R1, R2]
         { info_tbl: [(c4Oae,
                       label: go_up_s4L2Q_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oae: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Oai; else goto c4Oah;
       c4Oai: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Oah: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4Oac; else goto c4Oad;
       c4Oac: // global
           _s4L2O::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L2V_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L2O::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L2T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Oad: // global
           I64[Hp - 80] = sat_s4L2W_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Oak::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Oak::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L2X_entry() //  [R1]
         { info_tbl: [(c4Oal,
                       label: sat_s4L2X_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oal: // global
           _s4L2X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oam; else goto c4Oan;
       c4Oan: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Oap; else goto c4Oao;
       c4Oap: // global
           HpAlloc = 24;
           goto c4Oam;
       c4Oam: // global
           R1 = _s4L2X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oao: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L2X::P64;
           _s4L2v::I64 = I64[_s4L2X::P64 + 24];
           _s4L2O::I64 = _s4L2v::I64 - I64[_s4L2X::P64 + 16];
           I64[Hp - 16] = go_up_s4L2Q_info;
           I64[Hp - 8] = _s4L2O::I64;
           I64[Hp] = 3 - _s4L2O::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L2Q_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2N_entry() //  [R1]
         { info_tbl: [(c4Oau,
                       label: sat_s4L2N_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oau: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oav; else goto c4Oaw;
       c4Oav: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oaw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L2Z_entry() //  [R1]
         { info_tbl: [(c4OaF,
                       label: sat_s4L2Z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OaF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OaG; else goto c4OaH;
       c4OaG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OaH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3a_entry() //  [R1]
         { info_tbl: [(c4Obd,
                       label: sat_s4L3a_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Obd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Obe; else goto c4Obf;
       c4Obe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Obf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L35_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L38_entry() //  [R1]
         { info_tbl: [(c4Obk,
                       label: sat_s4L38_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Obk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Obl; else goto c4Obm;
       c4Obl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Obm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3b_entry() //  [R1]
         { info_tbl: [(c4Obs,
                       label: sat_s4L3b_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Obs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Obt; else goto c4Obu;
       c4Obt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Obu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L35_entry() //  [R1, R2]
         { info_tbl: [(c4Oby,
                       label: go_dn_s4L35_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oby: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4ObC; else goto c4ObB;
       c4ObC: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ObB: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4Obw; else goto c4Obx;
       c4Obw: // global
           _s4L33::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L3a_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L33::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L38_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Obx: // global
           I64[Hp - 80] = sat_s4L3b_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4ObE::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4ObE::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L3c_entry() //  [R1]
         { info_tbl: [(c4ObF,
                       label: sat_s4L3c_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ObF: // global
           _s4L3c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ObG; else goto c4ObH;
       c4ObH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ObJ; else goto c4ObI;
       c4ObJ: // global
           HpAlloc = 24;
           goto c4ObG;
       c4ObG: // global
           R1 = _s4L3c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ObI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L3c::P64;
           _s4L2v::I64 = I64[_s4L3c::P64 + 24];
           _s4L33::I64 = _s4L2v::I64 - I64[_s4L3c::P64 + 16];
           I64[Hp - 16] = go_dn_s4L35_info;
           I64[Hp - 8] = _s4L33::I64;
           I64[Hp] = 0 - _s4L33::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L35_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L32_entry() //  [R1]
         { info_tbl: [(c4ObO,
                       label: sat_s4L32_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ObO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ObP; else goto c4ObQ;
       c4ObP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ObQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3e_entry() //  [R1]
         { info_tbl: [(c4ObZ,
                       label: sat_s4L3e_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ObZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oc0; else goto c4Oc1;
       c4Oc0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oc1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3o_entry() //  [R1]
         { info_tbl: [(c4Ocu,
                       label: sat_s4L3o_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ocu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ocv; else goto c4Ocw;
       c4Ocv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ocw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L3j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3m_entry() //  [R1]
         { info_tbl: [(c4OcB,
                       label: sat_s4L3m_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OcB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OcC; else goto c4OcD;
       c4OcC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OcD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3p_entry() //  [R1]
         { info_tbl: [(c4OcJ,
                       label: sat_s4L3p_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OcJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OcK; else goto c4OcL;
       c4OcK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OcL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L3j_entry() //  [R1, R2]
         { info_tbl: [(c4OcP,
                       label: go_up_s4L3j_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OcP: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4OcT; else goto c4OcS;
       c4OcT: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OcS: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4OcN; else goto c4OcO;
       c4OcN: // global
           _s4L3h::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L3o_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L3h::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3m_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OcO: // global
           I64[Hp - 80] = sat_s4L3p_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4OcV::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4OcV::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L3q_entry() //  [R1]
         { info_tbl: [(c4OcW,
                       label: sat_s4L3q_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OcW: // global
           _s4L3q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4OcX; else goto c4OcY;
       c4OcY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Od0; else goto c4OcZ;
       c4Od0: // global
           HpAlloc = 24;
           goto c4OcX;
       c4OcX: // global
           R1 = _s4L3q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OcZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L3q::P64;
           _s4L2v::I64 = I64[_s4L3q::P64 + 24];
           _s4L3h::I64 = _s4L2v::I64 - I64[_s4L3q::P64 + 16];
           I64[Hp - 16] = go_up_s4L3j_info;
           I64[Hp - 8] = _s4L3h::I64;
           I64[Hp] = 0 - _s4L3h::I64;
           R2 = _s4L2v::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L3j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3g_entry() //  [R1]
         { info_tbl: [(c4Od5,
                       label: sat_s4L3g_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Od5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Od6; else goto c4Od7;
       c4Od6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Od7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3s_entry() //  [R1]
         { info_tbl: [(c4Odg,
                       label: sat_s4L3s_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Odg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Odh; else goto c4Odi;
       c4Odh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Odi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4Ods,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ods: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Odt; else goto c4Odu;
       c4Odt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Odu: // global
           I64[Sp - 16] = block_c4Odj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4OeW; else goto c4Odk;
       u4OeW: // global
           call _c4Odj(R1) args: 0, res: 0, upd: 0;
       c4Odk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Odj() //  [R1]
         { info_tbl: [(c4Odj,
                       label: block_c4Odj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Odj: // global
           _s4L2r::P64 = P64[Sp + 8];
           _c4Odr::P64 = R1 & 7;
           if (_c4Odr::P64 < 3) goto u4OeL; else goto u4OeM;
       u4OeL: // global
           if (_c4Odr::P64 < 2) goto c4Odn; else goto c4Odo;
       c4Odn: // global
           _s4L2t::I64 = 0;
           goto s4L2s;
       c4Odo: // global
           _s4L2t::I64 = 1;
           goto s4L2s;
       u4OeM: // global
           if (_c4Odr::P64 < 4) goto c4Odp; else goto c4Odq;
       c4Odp: // global
           _s4L2t::I64 = 2;
           goto s4L2s;
       c4Odq: // global
           _s4L2t::I64 = 3;
           goto s4L2s;
       s4L2s: // global
           I64[Sp] = block_c4Odv_info;
           R1 = _s4L2r::P64;
           I64[Sp + 8] = _s4L2t::I64;
           if (R1 & 7 != 0) goto u4OeV; else goto c4Oef;
       u4OeV: // global
           call _c4Odv(R1) args: 0, res: 0, upd: 0;
       c4Oef: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Odv() //  [R1]
         { info_tbl: [(c4Odv,
                       label: block_c4Odv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Odv: // global
           _c4OeK::P64 = R1 & 7;
           if (_c4OeK::P64 < 3) goto u4OeN; else goto u4OeO;
       u4OeN: // global
           if (_c4OeK::P64 < 2) goto c4Oel; else goto c4Oep;
       c4Oel: // global
           I64[Sp] = 0;
           goto u4Of0;
       c4Oep: // global
           I64[Sp] = 1;
           goto u4Of0;
       u4OeO: // global
           if (_c4OeK::P64 < 4) goto c4Oet; else goto c4Oex;
       c4Oet: // global
           I64[Sp] = 2;
           goto u4Of0;
       c4Oex: // global
           I64[Sp] = 3;
           goto u4Of0;
       u4Of0: // global
           call _c4O83() args: 0, res: 0, upd: 0;
     }
 },
 _c4O83() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O83: // global
           Hp = Hp + 80;
           _s4L2v::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c4Odz; else goto c4Ody;
       c4Odz: // global
           HpAlloc = 80;
           I64[Sp] = block_c4O82_info;
           R1 = _s4L2v::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4Ody: // global
           _s4L2t::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_s4L2t::I64,
                            _s4L2v::I64)) goto c4OdU; else goto c4Oee;
       c4OdU: // global
           if (%MO_S_Lt_W64(_s4L2v::I64,
                            _s4L2t::I64)) goto c4OdJ; else goto c4OdS;
       c4OdJ: // global
           if (%MO_S_Le_W64(3, _s4L2v::I64)) goto c4OdC; else goto c4OdH;
       c4OdC: // global
           I64[Hp - 72] = sat_s4L2J_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L2z_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OdH: // global
           if (%MO_S_Gt_W64(3, _s4L2t::I64)) goto c4Oeb; else goto c4OdF;
       c4OdF: // global
           I64[Hp - 72] = sat_s4L2L_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OdD::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OdD::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OdS: // global
           if (%MO_S_Ge_W64(3, _s4L2v::I64)) goto c4OdM; else goto c4OdR;
       c4OdM: // global
           I64[Hp - 72] = sat_s4L2X_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L2N_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OdR: // global
           if (%MO_S_Lt_W64(3, _s4L2t::I64)) goto c4Oeb; else goto c4OdP;
       c4OdP: // global
           I64[Hp - 72] = sat_s4L2Z_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OdN::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OdN::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Oee: // global
           if (%MO_S_Lt_W64(_s4L2v::I64,
                            _s4L2t::I64)) goto c4Oe4; else goto c4Oed;
       c4Oe4: // global
           if (%MO_S_Le_W64(0, _s4L2v::I64)) goto c4OdX; else goto c4Oe2;
       c4OdX: // global
           I64[Hp - 72] = sat_s4L3c_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L32_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Oe2: // global
           if (%MO_S_Gt_W64(0, _s4L2t::I64)) goto c4Oeb; else goto c4Oe0;
       c4Oe0: // global
           I64[Hp - 72] = sat_s4L3e_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OdY::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OdY::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Oed: // global
           if (%MO_S_Ge_W64(0, _s4L2v::I64)) goto c4Oe7; else goto c4Oec;
       c4Oe7: // global
           I64[Hp - 72] = sat_s4L3q_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = _s4L2v::I64;
           I64[Hp - 40] = sat_s4L3g_info;
           I64[Hp - 24] = _s4L2t::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Oec: // global
           if (%MO_S_Lt_W64(0, _s4L2t::I64)) goto c4Oeb; else goto c4Oea;
       c4Oeb: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Oea: // global
           I64[Hp - 72] = sat_s4L3s_info;
           I64[Hp - 56] = _s4L2t::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Oe8::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Oe8::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4O82() //  [R1]
         { info_tbl: [(c4O82,
                       label: block_c4O82_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4O82: // global
           I64[Sp] = R1;
           call _c4O83() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.04101712 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go3_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go3_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go3_info;
         const 0;
 },
 sat_s4L3B_entry() //  [R1]
         { info_tbl: [(c4OiM,
                       label: sat_s4L3B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OiM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OiN; else goto c4OiO;
       c4OiN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OiO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3z::I64 = I64[R1 + 16];
           if (_s4L3z::I64 != 0) goto c4OiK; else goto c4OiL;
       c4OiK: // global
           R2 = _s4L3z::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go3_entry(R2) args: 24, res: 0, upd: 24;
       c4OiL: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3y_entry() //  [R1]
         { info_tbl: [(c4Oj0,
                       label: sat_s4L3y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oj0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oj1; else goto c4Oj9;
       c4Oj1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oj9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3v::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3v::I64, 0)) goto c4Oj7; else goto c4OiZ;
       c4OiZ: // global
           if (%MO_S_Gt_W64(_s4L3v::I64, 3)) goto c4Oj7; else goto c4Oj8;
       c4Oj7: // global
           R2 = _s4L3v::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Oj8: // global
           R1 = I64[(_s4L3v::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go3_entry() //  [R2]
         { info_tbl: [(c4Ojb,
                       label: GHC.IO.IOMode.$fEnumIOMode_go3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ojb: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Ojf; else goto c4Oje;
       c4Ojf: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Oje: // global
           I64[Hp - 64] = sat_s4L3B_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3y_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.056368953 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go2_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go2_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go2_info;
         const 0;
 },
 sat_s4L3I_entry() //  [R1]
         { info_tbl: [(c4OjK,
                       label: sat_s4L3I_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OjK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OjL; else goto c4OjM;
       c4OjL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OjM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3G::I64 = I64[R1 + 16];
           if (_s4L3G::I64 != 1) goto c4OjI; else goto c4OjJ;
       c4OjI: // global
           R2 = _s4L3G::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go2_entry(R2) args: 24, res: 0, upd: 24;
       c4OjJ: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3F_entry() //  [R1]
         { info_tbl: [(c4OjY,
                       label: sat_s4L3F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OjY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OjZ; else goto c4Ok7;
       c4OjZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ok7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3C::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3C::I64, 0)) goto c4Ok5; else goto c4OjX;
       c4OjX: // global
           if (%MO_S_Gt_W64(_s4L3C::I64, 3)) goto c4Ok5; else goto c4Ok6;
       c4Ok5: // global
           R2 = _s4L3C::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Ok6: // global
           R1 = I64[(_s4L3C::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go2_entry() //  [R2]
         { info_tbl: [(c4Ok9,
                       label: GHC.IO.IOMode.$fEnumIOMode_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ok9: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Okd; else goto c4Okc;
       c4Okd: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Okc: // global
           I64[Hp - 64] = sat_s4L3I_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3F_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.068012268 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go1_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go1_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go1_info;
         const 0;
 },
 sat_s4L3P_entry() //  [R1]
         { info_tbl: [(c4OkI,
                       label: sat_s4L3P_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OkI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OkJ; else goto c4OkK;
       c4OkJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OkK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3N::I64 = I64[R1 + 16];
           if (_s4L3N::I64 != 2) goto c4OkG; else goto c4OkH;
       c4OkG: // global
           R2 = _s4L3N::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go1_entry(R2) args: 24, res: 0, upd: 24;
       c4OkH: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3M_entry() //  [R1]
         { info_tbl: [(c4OkW,
                       label: sat_s4L3M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OkW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OkX; else goto c4Ol5;
       c4OkX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ol5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3J::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3J::I64, 0)) goto c4Ol3; else goto c4OkV;
       c4OkV: // global
           if (%MO_S_Gt_W64(_s4L3J::I64, 3)) goto c4Ol3; else goto c4Ol4;
       c4Ol3: // global
           R2 = _s4L3J::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Ol4: // global
           R1 = I64[(_s4L3J::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go1_entry() //  [R2]
         { info_tbl: [(c4Ol7,
                       label: GHC.IO.IOMode.$fEnumIOMode_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ol7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Olb; else goto c4Ola;
       c4Olb: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Ola: // global
           I64[Hp - 64] = sat_s4L3P_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3M_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.083935399 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go_info;
         const 0;
 },
 sat_s4L3W_entry() //  [R1]
         { info_tbl: [(c4OlG,
                       label: sat_s4L3W_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OlG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OlH; else goto c4OlI;
       c4OlH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OlI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3U::I64 = I64[R1 + 16];
           if (_s4L3U::I64 != 3) goto c4OlE; else goto c4OlF;
       c4OlE: // global
           R2 = _s4L3U::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go_entry(R2) args: 24, res: 0, upd: 24;
       c4OlF: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L3T_entry() //  [R1]
         { info_tbl: [(c4OlU,
                       label: sat_s4L3T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OlU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OlV; else goto c4Om3;
       c4OlV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Om3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L3Q::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L3Q::I64, 0)) goto c4Om1; else goto c4OlT;
       c4OlT: // global
           if (%MO_S_Gt_W64(_s4L3Q::I64, 3)) goto c4Om1; else goto c4Om2;
       c4Om1: // global
           R2 = _s4L3Q::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Om2: // global
           R1 = I64[(_s4L3Q::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go_entry() //  [R2]
         { info_tbl: [(c4Om5,
                       label: GHC.IO.IOMode.$fEnumIOMode_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Om5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Om9; else goto c4Om8;
       c4Om9: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Om8: // global
           I64[Hp - 64] = sat_s4L3W_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L3T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.100777045 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4OmH,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OmH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OmI; else goto c4OmJ;
       c4OmI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4OmJ: // global
           I64[Sp - 16] = block_c4Omy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4OnK; else goto c4Omz;
       u4OnK: // global
           call _c4Omy(R1) args: 0, res: 0, upd: 0;
       c4Omz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Omy() //  [R1]
         { info_tbl: [(c4Omy,
                       label: block_c4Omy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Omy: // global
           _s4L3Y::P64 = P64[Sp + 8];
           _c4OmG::P64 = R1 & 7;
           if (_c4OmG::P64 < 3) goto u4OnF; else goto u4OnG;
       u4OnF: // global
           if (_c4OmG::P64 < 2) goto c4OmC; else goto c4OmD;
       c4OmC: // global
           _s4L40::I64 = 0;
           goto s4L3Z;
       c4OmD: // global
           _s4L40::I64 = 1;
           goto s4L3Z;
       u4OnG: // global
           if (_c4OmG::P64 < 4) goto c4OmE; else goto c4OmF;
       c4OmE: // global
           _s4L40::I64 = 2;
           goto s4L3Z;
       c4OmF: // global
           _s4L40::I64 = 3;
           goto s4L3Z;
       s4L3Z: // global
           I64[Sp] = block_c4OmN_info;
           R1 = _s4L3Y::P64;
           I64[Sp + 8] = _s4L40::I64;
           if (R1 & 7 != 0) goto u4OnJ; else goto c4OmP;
       u4OnJ: // global
           call _c4OmN(R1) args: 0, res: 0, upd: 0;
       c4OmP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4OmN() //  [R1]
         { info_tbl: [(c4OmN,
                       label: block_c4OmN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OmN: // global
           _s4L40::I64 = I64[Sp + 8];
           _c4OnE::P64 = R1 & 7;
           if (_c4OnE::P64 < 3) goto u4OnH; else goto u4OnI;
       u4OnH: // global
           if (_c4OnE::P64 < 2) goto c4On0; else goto c4On9;
       c4On0: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 0)) goto c4Onq; else goto c4OmX;
       c4OmX: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go3_entry(R2) args: 8, res: 0, upd: 8;
       c4On9: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 1)) goto c4Onq; else goto c4On7;
       c4On7: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go2_entry(R2) args: 8, res: 0, upd: 8;
       u4OnI: // global
           if (_c4OnE::P64 < 4) goto c4Oni; else goto c4Onr;
       c4Oni: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 2)) goto c4Onq; else goto c4Ong;
       c4Ong: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go1_entry(R2) args: 8, res: 0, upd: 8;
       c4Onr: // global
           if (%MO_S_Gt_W64(_s4L40::I64, 3)) goto c4Onq; else goto c4Onp;
       c4Onq: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Onp: // global
           R2 = _s4L40::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.135648134 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_info;
         const 0;
 },
 sat_s4L4t_entry() //  [R1]
         { info_tbl: [(c4OoO,
                       label: sat_s4L4t_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OoO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OoP; else goto c4OoQ;
       c4OoP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OoQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L4m_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4r_entry() //  [R1]
         { info_tbl: [(c4Op0,
                       label: sat_s4L4r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Op0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Op1; else goto c4Op9;
       c4Op1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Op9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4n::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4n::I64, 0)) goto c4Op7; else goto c4OoZ;
       c4OoZ: // global
           if (%MO_S_Gt_W64(_s4L4n::I64, 3)) goto c4Op7; else goto c4Op8;
       c4Op7: // global
           R2 = _s4L4n::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Op8: // global
           R1 = I64[(_s4L4n::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4w_entry() //  [R1]
         { info_tbl: [(c4Opk,
                       label: sat_s4L4w_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Opk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Opl; else goto c4Opt;
       c4Opl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Opt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4n::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4n::I64, 0)) goto c4Opr; else goto c4Opj;
       c4Opj: // global
           if (%MO_S_Gt_W64(_s4L4n::I64, 3)) goto c4Opr; else goto c4Ops;
       c4Opr: // global
           R2 = _s4L4n::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Ops: // global
           R1 = I64[(_s4L4n::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L4m_entry() //  [R1, R2]
         { info_tbl: [(c4Opx,
                       label: go_dn_s4L4m_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Opx: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4OpB; else goto c4OpA;
       c4OpB: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OpA: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4Opv; else goto c4Opw;
       c4Opv: // global
           _s4L4k::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L4t_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L4k::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L4r_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Opw: // global
           I64[Hp - 80] = sat_s4L4w_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4OpD::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4OpD::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L4x_entry() //  [R1]
         { info_tbl: [(c4OpE,
                       label: sat_s4L4x_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OpE: // global
           _s4L4x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4OpF; else goto c4OpG;
       c4OpG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4OpI; else goto c4OpH;
       c4OpI: // global
           HpAlloc = 24;
           goto c4OpF;
       c4OpF: // global
           R1 = _s4L4x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OpH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L4x::P64;
           _s4L4d::I64 = I64[_s4L4x::P64 + 24];
           _s4L4k::I64 = _s4L4d::I64 - I64[_s4L4x::P64 + 16];
           I64[Hp - 16] = go_dn_s4L4m_info;
           I64[Hp - 8] = _s4L4k::I64;
           I64[Hp] = 0 - _s4L4k::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L4m_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4j_entry() //  [R1]
         { info_tbl: [(c4OpS,
                       label: sat_s4L4j_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OpS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OpT; else goto c4Oq1;
       c4OpT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oq1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4OpZ; else goto c4OpR;
       c4OpR: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4OpZ; else goto c4Oq0;
       c4OpZ: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Oq0: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4B_entry() //  [R1]
         { info_tbl: [(c4Oqf,
                       label: sat_s4L4B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oqf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oqg; else goto c4Oqo;
       c4Oqg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oqo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Oqm; else goto c4Oqe;
       c4Oqe: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Oqm; else goto c4Oqn;
       c4Oqm: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Oqn: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4P_entry() //  [R1]
         { info_tbl: [(c4OqR,
                       label: sat_s4L4P_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OqR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OqS; else goto c4OqT;
       c4OqS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OqT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L4I_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4N_entry() //  [R1]
         { info_tbl: [(c4Or3,
                       label: sat_s4L4N_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Or3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Or4; else goto c4Orc;
       c4Or4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Orc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4J::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4J::I64, 0)) goto c4Ora; else goto c4Or2;
       c4Or2: // global
           if (%MO_S_Gt_W64(_s4L4J::I64, 3)) goto c4Ora; else goto c4Orb;
       c4Ora: // global
           R2 = _s4L4J::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Orb: // global
           R1 = I64[(_s4L4J::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4S_entry() //  [R1]
         { info_tbl: [(c4Orn,
                       label: sat_s4L4S_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Orn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oro; else goto c4Orw;
       c4Oro: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Orw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4J::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4J::I64, 0)) goto c4Oru; else goto c4Orm;
       c4Orm: // global
           if (%MO_S_Gt_W64(_s4L4J::I64, 3)) goto c4Oru; else goto c4Orv;
       c4Oru: // global
           R2 = _s4L4J::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Orv: // global
           R1 = I64[(_s4L4J::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L4I_entry() //  [R1, R2]
         { info_tbl: [(c4OrA,
                       label: go_up_s4L4I_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OrA: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4OrE; else goto c4OrD;
       c4OrE: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OrD: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4Ory; else goto c4Orz;
       c4Ory: // global
           _s4L4G::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L4P_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L4G::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L4N_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Orz: // global
           I64[Hp - 80] = sat_s4L4S_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4OrG::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4OrG::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L4T_entry() //  [R1]
         { info_tbl: [(c4OrH,
                       label: sat_s4L4T_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OrH: // global
           _s4L4T::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4OrI; else goto c4OrJ;
       c4OrJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4OrL; else goto c4OrK;
       c4OrL: // global
           HpAlloc = 24;
           goto c4OrI;
       c4OrI: // global
           R1 = _s4L4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OrK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L4T::P64;
           _s4L4d::I64 = I64[_s4L4T::P64 + 24];
           _s4L4G::I64 = _s4L4d::I64 - I64[_s4L4T::P64 + 16];
           I64[Hp - 16] = go_up_s4L4I_info;
           I64[Hp - 8] = _s4L4G::I64;
           I64[Hp] = 0 - _s4L4G::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L4I_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4F_entry() //  [R1]
         { info_tbl: [(c4OrV,
                       label: sat_s4L4F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OrV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OrW; else goto c4Os4;
       c4OrW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Os4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Os2; else goto c4OrU;
       c4OrU: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Os2; else goto c4Os3;
       c4Os2: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Os3: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L4X_entry() //  [R1]
         { info_tbl: [(c4Osi,
                       label: sat_s4L4X_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Osi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Osj; else goto c4Osr;
       c4Osj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Osr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Osp; else goto c4Osh;
       c4Osh: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Osp; else goto c4Osq;
       c4Osp: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Osq: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5c_entry() //  [R1]
         { info_tbl: [(c4OsY,
                       label: sat_s4L5c_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OsY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OsZ; else goto c4Ot0;
       c4OsZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ot0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L55_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5a_entry() //  [R1]
         { info_tbl: [(c4Ota,
                       label: sat_s4L5a_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ota: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Otb; else goto c4Otj;
       c4Otb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Otj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L56::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L56::I64, 0)) goto c4Oth; else goto c4Ot9;
       c4Ot9: // global
           if (%MO_S_Gt_W64(_s4L56::I64, 3)) goto c4Oth; else goto c4Oti;
       c4Oth: // global
           R2 = _s4L56::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Oti: // global
           R1 = I64[(_s4L56::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5f_entry() //  [R1]
         { info_tbl: [(c4Otu,
                       label: sat_s4L5f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Otu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Otv; else goto c4OtD;
       c4Otv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OtD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L56::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L56::I64, 0)) goto c4OtB; else goto c4Ott;
       c4Ott: // global
           if (%MO_S_Gt_W64(_s4L56::I64, 3)) goto c4OtB; else goto c4OtC;
       c4OtB: // global
           R2 = _s4L56::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OtC: // global
           R1 = I64[(_s4L56::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L55_entry() //  [R1, R2]
         { info_tbl: [(c4OtH,
                       label: go_dn_s4L55_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OtH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4OtL; else goto c4OtK;
       c4OtL: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OtK: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4OtF; else goto c4OtG;
       c4OtF: // global
           _s4L53::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L5c_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L53::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L5a_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OtG: // global
           I64[Hp - 80] = sat_s4L5f_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4OtN::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4OtN::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L5g_entry() //  [R1]
         { info_tbl: [(c4OtO,
                       label: sat_s4L5g_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OtO: // global
           _s4L5g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4OtP; else goto c4OtQ;
       c4OtQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4OtS; else goto c4OtR;
       c4OtS: // global
           HpAlloc = 24;
           goto c4OtP;
       c4OtP: // global
           R1 = _s4L5g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OtR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L5g::P64;
           _s4L4d::I64 = I64[_s4L5g::P64 + 24];
           _s4L53::I64 = _s4L4d::I64 - I64[_s4L5g::P64 + 16];
           I64[Hp - 16] = go_dn_s4L55_info;
           I64[Hp - 8] = _s4L53::I64;
           I64[Hp] = 1 - _s4L53::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L55_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L52_entry() //  [R1]
         { info_tbl: [(c4Ou2,
                       label: sat_s4L52_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ou2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ou3; else goto c4Oub;
       c4Ou3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oub: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Ou9; else goto c4Ou1;
       c4Ou1: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Ou9; else goto c4Oua;
       c4Ou9: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Oua: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5k_entry() //  [R1]
         { info_tbl: [(c4Oup,
                       label: sat_s4L5k_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oup: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ouq; else goto c4Ouy;
       c4Ouq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ouy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Ouw; else goto c4Ouo;
       c4Ouo: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Ouw; else goto c4Oux;
       c4Ouw: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Oux: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5y_entry() //  [R1]
         { info_tbl: [(c4Ov1,
                       label: sat_s4L5y_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ov1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ov2; else goto c4Ov3;
       c4Ov2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ov3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L5r_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5w_entry() //  [R1]
         { info_tbl: [(c4Ovd,
                       label: sat_s4L5w_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ovd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ove; else goto c4Ovm;
       c4Ove: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ovm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5s::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5s::I64, 0)) goto c4Ovk; else goto c4Ovc;
       c4Ovc: // global
           if (%MO_S_Gt_W64(_s4L5s::I64, 3)) goto c4Ovk; else goto c4Ovl;
       c4Ovk: // global
           R2 = _s4L5s::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Ovl: // global
           R1 = I64[(_s4L5s::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5B_entry() //  [R1]
         { info_tbl: [(c4Ovx,
                       label: sat_s4L5B_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ovx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ovy; else goto c4OvG;
       c4Ovy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OvG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5s::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5s::I64, 0)) goto c4OvE; else goto c4Ovw;
       c4Ovw: // global
           if (%MO_S_Gt_W64(_s4L5s::I64, 3)) goto c4OvE; else goto c4OvF;
       c4OvE: // global
           R2 = _s4L5s::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OvF: // global
           R1 = I64[(_s4L5s::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L5r_entry() //  [R1, R2]
         { info_tbl: [(c4OvK,
                       label: go_up_s4L5r_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OvK: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4OvO; else goto c4OvN;
       c4OvO: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OvN: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4OvI; else goto c4OvJ;
       c4OvI: // global
           _s4L5p::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L5y_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L5p::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L5w_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OvJ: // global
           I64[Hp - 80] = sat_s4L5B_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4OvQ::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4OvQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L5C_entry() //  [R1]
         { info_tbl: [(c4OvR,
                       label: sat_s4L5C_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OvR: // global
           _s4L5C::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4OvS; else goto c4OvT;
       c4OvT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4OvV; else goto c4OvU;
       c4OvV: // global
           HpAlloc = 24;
           goto c4OvS;
       c4OvS: // global
           R1 = _s4L5C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OvU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L5C::P64;
           _s4L4d::I64 = I64[_s4L5C::P64 + 24];
           _s4L5p::I64 = _s4L4d::I64 - I64[_s4L5C::P64 + 16];
           I64[Hp - 16] = go_up_s4L5r_info;
           I64[Hp - 8] = _s4L5p::I64;
           I64[Hp] = 1 - _s4L5p::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L5r_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5o_entry() //  [R1]
         { info_tbl: [(c4Ow5,
                       label: sat_s4L5o_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ow5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ow6; else goto c4Owe;
       c4Ow6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Owe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Owc; else goto c4Ow4;
       c4Ow4: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Owc; else goto c4Owd;
       c4Owc: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Owd: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5G_entry() //  [R1]
         { info_tbl: [(c4Ows,
                       label: sat_s4L5G_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ows: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Owt; else goto c4OwB;
       c4Owt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OwB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Owz; else goto c4Owr;
       c4Owr: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Owz; else goto c4OwA;
       c4Owz: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OwA: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5V_entry() //  [R1]
         { info_tbl: [(c4Ox8,
                       label: sat_s4L5V_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ox8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ox9; else goto c4Oxa;
       c4Ox9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oxa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L5O_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5T_entry() //  [R1]
         { info_tbl: [(c4Oxk,
                       label: sat_s4L5T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oxk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oxl; else goto c4Oxt;
       c4Oxl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oxt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5P::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5P::I64, 0)) goto c4Oxr; else goto c4Oxj;
       c4Oxj: // global
           if (%MO_S_Gt_W64(_s4L5P::I64, 3)) goto c4Oxr; else goto c4Oxs;
       c4Oxr: // global
           R2 = _s4L5P::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Oxs: // global
           R1 = I64[(_s4L5P::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5Y_entry() //  [R1]
         { info_tbl: [(c4OxE,
                       label: sat_s4L5Y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OxE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OxF; else goto c4OxN;
       c4OxF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OxN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L5P::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L5P::I64, 0)) goto c4OxL; else goto c4OxD;
       c4OxD: // global
           if (%MO_S_Gt_W64(_s4L5P::I64, 3)) goto c4OxL; else goto c4OxM;
       c4OxL: // global
           R2 = _s4L5P::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OxM: // global
           R1 = I64[(_s4L5P::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L5O_entry() //  [R1, R2]
         { info_tbl: [(c4OxR,
                       label: go_dn_s4L5O_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OxR: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4OxV; else goto c4OxU;
       c4OxV: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OxU: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4OxP; else goto c4OxQ;
       c4OxP: // global
           _s4L5M::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L5V_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L5M::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L5T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OxQ: // global
           I64[Hp - 80] = sat_s4L5Y_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4OxX::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4OxX::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L5Z_entry() //  [R1]
         { info_tbl: [(c4OxY,
                       label: sat_s4L5Z_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OxY: // global
           _s4L5Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4OxZ; else goto c4Oy0;
       c4Oy0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Oy2; else goto c4Oy1;
       c4Oy2: // global
           HpAlloc = 24;
           goto c4OxZ;
       c4OxZ: // global
           R1 = _s4L5Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oy1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L5Z::P64;
           _s4L4d::I64 = I64[_s4L5Z::P64 + 24];
           _s4L5M::I64 = _s4L4d::I64 - I64[_s4L5Z::P64 + 16];
           I64[Hp - 16] = go_dn_s4L5O_info;
           I64[Hp - 8] = _s4L5M::I64;
           I64[Hp] = 2 - _s4L5M::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L5O_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L5L_entry() //  [R1]
         { info_tbl: [(c4Oyc,
                       label: sat_s4L5L_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oyc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Oyd; else goto c4Oyl;
       c4Oyd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Oyl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4Oyj; else goto c4Oyb;
       c4Oyb: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4Oyj; else goto c4Oyk;
       c4Oyj: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Oyk: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L63_entry() //  [R1]
         { info_tbl: [(c4Oyz,
                       label: sat_s4L63_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oyz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OyA; else goto c4OyI;
       c4OyA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OyI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4OyG; else goto c4Oyy;
       c4Oyy: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4OyG; else goto c4OyH;
       c4OyG: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OyH: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6h_entry() //  [R1]
         { info_tbl: [(c4Ozb,
                       label: sat_s4L6h_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ozb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ozc; else goto c4Ozd;
       c4Ozc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ozd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L6a_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6f_entry() //  [R1]
         { info_tbl: [(c4Ozn,
                       label: sat_s4L6f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ozn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ozo; else goto c4Ozw;
       c4Ozo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ozw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6b::I64, 0)) goto c4Ozu; else goto c4Ozm;
       c4Ozm: // global
           if (%MO_S_Gt_W64(_s4L6b::I64, 3)) goto c4Ozu; else goto c4Ozv;
       c4Ozu: // global
           R2 = _s4L6b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Ozv: // global
           R1 = I64[(_s4L6b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6k_entry() //  [R1]
         { info_tbl: [(c4OzH,
                       label: sat_s4L6k_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OzH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OzI; else goto c4OzQ;
       c4OzI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OzQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6b::I64, 0)) goto c4OzO; else goto c4OzG;
       c4OzG: // global
           if (%MO_S_Gt_W64(_s4L6b::I64, 3)) goto c4OzO; else goto c4OzP;
       c4OzO: // global
           R2 = _s4L6b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OzP: // global
           R1 = I64[(_s4L6b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L6a_entry() //  [R1, R2]
         { info_tbl: [(c4OzU,
                       label: go_up_s4L6a_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OzU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4OzY; else goto c4OzX;
       c4OzY: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OzX: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4OzS; else goto c4OzT;
       c4OzS: // global
           _s4L68::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L6h_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L68::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L6f_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OzT: // global
           I64[Hp - 80] = sat_s4L6k_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4OA0::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4OA0::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L6l_entry() //  [R1]
         { info_tbl: [(c4OA1,
                       label: sat_s4L6l_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OA1: // global
           _s4L6l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4OA2; else goto c4OA3;
       c4OA3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4OA5; else goto c4OA4;
       c4OA5: // global
           HpAlloc = 24;
           goto c4OA2;
       c4OA2: // global
           R1 = _s4L6l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OA4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L6l::P64;
           _s4L4d::I64 = I64[_s4L6l::P64 + 24];
           _s4L68::I64 = _s4L4d::I64 - I64[_s4L6l::P64 + 16];
           I64[Hp - 16] = go_up_s4L6a_info;
           I64[Hp - 8] = _s4L68::I64;
           I64[Hp] = 2 - _s4L68::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L6a_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L67_entry() //  [R1]
         { info_tbl: [(c4OAf,
                       label: sat_s4L67_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OAf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OAg; else goto c4OAo;
       c4OAg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OAo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4OAm; else goto c4OAe;
       c4OAe: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4OAm; else goto c4OAn;
       c4OAm: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OAn: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6p_entry() //  [R1]
         { info_tbl: [(c4OAC,
                       label: sat_s4L6p_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OAC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OAD; else goto c4OAL;
       c4OAD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OAL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4OAJ; else goto c4OAB;
       c4OAB: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4OAJ; else goto c4OAK;
       c4OAJ: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OAK: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6E_entry() //  [R1]
         { info_tbl: [(c4OBi,
                       label: sat_s4L6E_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OBi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OBj; else goto c4OBk;
       c4OBj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OBk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4L6x_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6C_entry() //  [R1]
         { info_tbl: [(c4OBu,
                       label: sat_s4L6C_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OBu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OBv; else goto c4OBD;
       c4OBv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OBD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6y::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6y::I64, 0)) goto c4OBB; else goto c4OBt;
       c4OBt: // global
           if (%MO_S_Gt_W64(_s4L6y::I64, 3)) goto c4OBB; else goto c4OBC;
       c4OBB: // global
           R2 = _s4L6y::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OBC: // global
           R1 = I64[(_s4L6y::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6H_entry() //  [R1]
         { info_tbl: [(c4OBO,
                       label: sat_s4L6H_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OBO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OBP; else goto c4OBX;
       c4OBP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OBX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6y::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6y::I64, 0)) goto c4OBV; else goto c4OBN;
       c4OBN: // global
           if (%MO_S_Gt_W64(_s4L6y::I64, 3)) goto c4OBV; else goto c4OBW;
       c4OBV: // global
           R2 = _s4L6y::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OBW: // global
           R1 = I64[(_s4L6y::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4L6x_entry() //  [R1, R2]
         { info_tbl: [(c4OC1,
                       label: go_dn_s4L6x_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OC1: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4OC5; else goto c4OC4;
       c4OC5: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OC4: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4OBZ; else goto c4OC0;
       c4OBZ: // global
           _s4L6v::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L6E_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L6v::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L6C_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OC0: // global
           I64[Hp - 80] = sat_s4L6H_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4OC7::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4OC7::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L6I_entry() //  [R1]
         { info_tbl: [(c4OC8,
                       label: sat_s4L6I_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OC8: // global
           _s4L6I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4OC9; else goto c4OCa;
       c4OCa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4OCc; else goto c4OCb;
       c4OCc: // global
           HpAlloc = 24;
           goto c4OC9;
       c4OC9: // global
           R1 = _s4L6I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OCb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L6I::P64;
           _s4L4d::I64 = I64[_s4L6I::P64 + 24];
           _s4L6v::I64 = _s4L4d::I64 - I64[_s4L6I::P64 + 16];
           I64[Hp - 16] = go_dn_s4L6x_info;
           I64[Hp - 8] = _s4L6v::I64;
           I64[Hp] = 3 - _s4L6v::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4L6x_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6u_entry() //  [R1]
         { info_tbl: [(c4OCm,
                       label: sat_s4L6u_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OCm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OCn; else goto c4OCv;
       c4OCn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OCv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4OCt; else goto c4OCl;
       c4OCl: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4OCt; else goto c4OCu;
       c4OCt: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OCu: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6M_entry() //  [R1]
         { info_tbl: [(c4OCJ,
                       label: sat_s4L6M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OCJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OCK; else goto c4OCS;
       c4OCK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OCS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4OCQ; else goto c4OCI;
       c4OCI: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4OCQ; else goto c4OCR;
       c4OCQ: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OCR: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L70_entry() //  [R1]
         { info_tbl: [(c4ODl,
                       label: sat_s4L70_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ODl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ODm; else goto c4ODn;
       c4ODm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ODn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4L6T_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6Y_entry() //  [R1]
         { info_tbl: [(c4ODx,
                       label: sat_s4L6Y_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ODx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ODy; else goto c4ODG;
       c4ODy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ODG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6U::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6U::I64, 0)) goto c4ODE; else goto c4ODw;
       c4ODw: // global
           if (%MO_S_Gt_W64(_s4L6U::I64, 3)) goto c4ODE; else goto c4ODF;
       c4ODE: // global
           R2 = _s4L6U::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4ODF: // global
           R1 = I64[(_s4L6U::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L73_entry() //  [R1]
         { info_tbl: [(c4ODR,
                       label: sat_s4L73_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ODR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ODS; else goto c4OE0;
       c4ODS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OE0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L6U::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L6U::I64, 0)) goto c4ODY; else goto c4ODQ;
       c4ODQ: // global
           if (%MO_S_Gt_W64(_s4L6U::I64, 3)) goto c4ODY; else goto c4ODZ;
       c4ODY: // global
           R2 = _s4L6U::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4ODZ: // global
           R1 = I64[(_s4L6U::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4L6T_entry() //  [R1, R2]
         { info_tbl: [(c4OE4,
                       label: go_up_s4L6T_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OE4: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4OE8; else goto c4OE7;
       c4OE8: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OE7: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4OE2; else goto c4OE3;
       c4OE2: // global
           _s4L6R::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4L70_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4L6R::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4L6Y_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OE3: // global
           I64[Hp - 80] = sat_s4L73_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4OEa::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4OEa::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4L74_entry() //  [R1]
         { info_tbl: [(c4OEb,
                       label: sat_s4L74_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OEb: // global
           _s4L74::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4OEc; else goto c4OEd;
       c4OEd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4OEf; else goto c4OEe;
       c4OEf: // global
           HpAlloc = 24;
           goto c4OEc;
       c4OEc: // global
           R1 = _s4L74::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OEe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4L74::P64;
           _s4L4d::I64 = I64[_s4L74::P64 + 24];
           _s4L6R::I64 = _s4L4d::I64 - I64[_s4L74::P64 + 16];
           I64[Hp - 16] = go_up_s4L6T_info;
           I64[Hp - 8] = _s4L6R::I64;
           I64[Hp] = 3 - _s4L6R::I64;
           R2 = _s4L4d::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4L6T_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L6Q_entry() //  [R1]
         { info_tbl: [(c4OEp,
                       label: sat_s4L6Q_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OEp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OEq; else goto c4OEy;
       c4OEq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OEy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4OEw; else goto c4OEo;
       c4OEo: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4OEw; else goto c4OEx;
       c4OEw: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OEx: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4L78_entry() //  [R1]
         { info_tbl: [(c4OEM,
                       label: sat_s4L78_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OEM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OEN; else goto c4OEV;
       c4OEN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OEV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4L4b::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4L4b::I64, 0)) goto c4OET; else goto c4OEL;
       c4OEL: // global
           if (%MO_S_Gt_W64(_s4L4b::I64, 3)) goto c4OET; else goto c4OEU;
       c4OET: // global
           R2 = _s4L4b::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4OEU: // global
           R1 = I64[(_s4L4b::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c4OF5,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OF5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4OF6; else goto c4OF7;
       c4OF6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4OF7: // global
           I64[Sp - 24] = block_c4OEW_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4OHk; else goto c4OEX;
       u4OHk: // global
           call _c4OEW(R1) args: 0, res: 0, upd: 0;
       c4OEX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4OEW() //  [R1]
         { info_tbl: [(c4OEW,
                       label: block_c4OEW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OEW: // global
           _s4L48::P64 = P64[Sp + 8];
           _c4OF4::P64 = R1 & 7;
           if (_c4OF4::P64 < 3) goto u4OHf; else goto u4OHg;
       u4OHf: // global
           if (_c4OF4::P64 < 2) goto c4OF0; else goto c4OF1;
       c4OF0: // global
           _s4L4b::I64 = 0;
           goto s4L4a;
       c4OF1: // global
           _s4L4b::I64 = 1;
           goto s4L4a;
       u4OHg: // global
           if (_c4OF4::P64 < 4) goto c4OF2; else goto c4OF3;
       c4OF2: // global
           _s4L4b::I64 = 2;
           goto s4L4a;
       c4OF3: // global
           _s4L4b::I64 = 3;
           goto s4L4a;
       s4L4a: // global
           I64[Sp] = block_c4OF8_info;
           R1 = _s4L48::P64;
           I64[Sp + 8] = _s4L4b::I64;
           if (R1 & 7 != 0) goto u4OHj; else goto c4OGG;
       u4OHj: // global
           call _c4OF8(R1) args: 0, res: 0, upd: 0;
       c4OGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4OF8() //  [R1]
         { info_tbl: [(c4OF8,
                       label: block_c4OF8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OF8: // global
           _s4L49::P64 = P64[Sp + 16];
           _c4OHb::P64 = R1 & 7;
           if (_c4OHb::P64 < 3) goto u4OHh; else goto u4OHi;
       u4OHh: // global
           if (_c4OHb::P64 < 2) goto c4OGM; else goto c4OGQ;
       c4OGM: // global
           _s4L4d::I64 = 0;
           goto s4L4c;
       c4OGQ: // global
           _s4L4d::I64 = 1;
           goto s4L4c;
       u4OHi: // global
           if (_c4OHb::P64 < 4) goto c4OGU; else goto c4OGY;
       c4OGU: // global
           _s4L4d::I64 = 2;
           goto s4L4c;
       c4OGY: // global
           _s4L4d::I64 = 3;
           goto s4L4c;
       s4L4c: // global
           I64[Sp] = block_c4Oof_info;
           R1 = _s4L49::P64;
           I64[Sp + 16] = _s4L4d::I64;
           if (R1 & 7 != 0) goto u4OHl; else goto c4Oog;
       u4OHl: // global
           call _c4Oof(R1) args: 0, res: 0, upd: 0;
       c4Oog: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Oof() //  [R1]
         { info_tbl: [(c4Oof,
                       label: block_c4Oof_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Oof: // global
           _s4L4b::I64 = I64[Sp + 8];
           _s4L4d::I64 = I64[Sp + 16];
           _c4OHc::P64 = R1 & 7;
           if (_c4OHc::P64 < 3) goto u4OHd; else goto u4OHe;
       u4OHd: // global
           if (_c4OHc::P64 < 2) goto c4OFc; else goto c4OFz;
       c4OFc: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4OGm; else goto c4OFe;
       c4OFe: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4OFp; else goto c4OFy;
       c4OFp: // global
           if (%MO_S_Le_W64(0, _s4L4d::I64)) goto c4OFi; else goto c4OFn;
       c4OFi: // global
           I64[Hp - 72] = sat_s4L4x_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L4j_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OFn: // global
           if (%MO_S_Gt_W64(0, _s4L4b::I64)) goto c4OGD; else goto c4OFl;
       c4OFl: // global
           I64[Hp - 72] = sat_s4L4B_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OFj::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OFj::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OFy: // global
           if (%MO_S_Ge_W64(0, _s4L4d::I64)) goto c4OFs; else goto c4OFx;
       c4OFs: // global
           I64[Hp - 72] = sat_s4L4T_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L4F_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OFx: // global
           if (%MO_S_Lt_W64(0, _s4L4b::I64)) goto c4OGD; else goto c4OFv;
       c4OFv: // global
           I64[Hp - 72] = sat_s4L4X_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OFt::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OFt::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OFz: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4OGm; else goto c4OFB;
       c4OFB: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4OFM; else goto c4OFV;
       c4OFM: // global
           if (%MO_S_Le_W64(1, _s4L4d::I64)) goto c4OFF; else goto c4OFK;
       c4OFF: // global
           I64[Hp - 72] = sat_s4L5g_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L52_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OFK: // global
           if (%MO_S_Gt_W64(1, _s4L4b::I64)) goto c4OGD; else goto c4OFI;
       c4OFI: // global
           I64[Hp - 72] = sat_s4L5k_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OFG::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OFG::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OFV: // global
           if (%MO_S_Ge_W64(1, _s4L4d::I64)) goto c4OFP; else goto c4OFU;
       c4OFP: // global
           I64[Hp - 72] = sat_s4L5C_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L5o_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OFU: // global
           if (%MO_S_Lt_W64(1, _s4L4b::I64)) goto c4OGD; else goto c4OFS;
       c4OFS: // global
           I64[Hp - 72] = sat_s4L5G_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OFQ::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OFQ::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4OHe: // global
           if (_c4OHc::P64 < 4) goto c4OFW; else goto c4OGj;
       c4OFW: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4OGm; else goto c4OFY;
       c4OFY: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4OG9; else goto c4OGi;
       c4OG9: // global
           if (%MO_S_Le_W64(2, _s4L4d::I64)) goto c4OG2; else goto c4OG7;
       c4OG2: // global
           I64[Hp - 72] = sat_s4L5Z_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L5L_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OG7: // global
           if (%MO_S_Gt_W64(2, _s4L4b::I64)) goto c4OGD; else goto c4OG5;
       c4OG5: // global
           I64[Hp - 72] = sat_s4L63_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OG3::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OG3::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OGi: // global
           if (%MO_S_Ge_W64(2, _s4L4d::I64)) goto c4OGc; else goto c4OGh;
       c4OGc: // global
           I64[Hp - 72] = sat_s4L6l_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L67_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OGh: // global
           if (%MO_S_Lt_W64(2, _s4L4b::I64)) goto c4OGD; else goto c4OGf;
       c4OGf: // global
           I64[Hp - 72] = sat_s4L6p_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OGd::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OGd::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OGj: // global
           Hp = Hp + 80;
           _s4L4e::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4OGm; else goto c4OGl;
       c4OGm: // global
           HpAlloc = 80;
           R1 = _s4L4e::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4OGl: // global
           if (%MO_S_Lt_W64(_s4L4d::I64,
                            _s4L4b::I64)) goto c4OGw; else goto c4OGF;
       c4OGw: // global
           if (%MO_S_Le_W64(3, _s4L4d::I64)) goto c4OGp; else goto c4OGu;
       c4OGp: // global
           I64[Hp - 72] = sat_s4L6I_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L6u_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OGu: // global
           if (%MO_S_Gt_W64(3, _s4L4b::I64)) goto c4OGD; else goto c4OGs;
       c4OGs: // global
           I64[Hp - 72] = sat_s4L6M_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OGq::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OGq::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OGF: // global
           if (%MO_S_Ge_W64(3, _s4L4d::I64)) goto c4OGz; else goto c4OGE;
       c4OGz: // global
           I64[Hp - 72] = sat_s4L74_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = _s4L4d::I64;
           I64[Hp - 40] = sat_s4L6Q_info;
           I64[Hp - 24] = _s4L4b::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OGE: // global
           if (%MO_S_Lt_W64(3, _s4L4b::I64)) goto c4OGD; else goto c4OGC;
       c4OGD: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4OGC: // global
           I64[Hp - 72] = sat_s4L78_info;
           I64[Hp - 56] = _s4L4b::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4OGA::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4OGA::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.288379649 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_closure" {
     GHC.IO.IOMode.$fEnumIOMode_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure+2;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure+2;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.290478828 UTC

[section ""data" . GHC.IO.IOMode.$trModule3_closure" {
     GHC.IO.IOMode.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.292332557 UTC

[section ""data" . GHC.IO.IOMode.$trModule1_closure" {
     GHC.IO.IOMode.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.295305756 UTC

[section ""data" . GHC.IO.IOMode.$trModule_closure" {
     GHC.IO.IOMode.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.IOMode.$trModule3_closure+1;
         const GHC.IO.IOMode.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.297123719 UTC

[section ""cstring" . GHC.IO.IOMode.$tcIOMode2_bytes" {
     GHC.IO.IOMode.$tcIOMode2_bytes:
         I8[] [73,79,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.298838823 UTC

[section ""data" . GHC.IO.IOMode.$tcIOMode1_closure" {
     GHC.IO.IOMode.$tcIOMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tcIOMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.300583707 UTC

[section ""data" . GHC.IO.IOMode.$tcIOMode_closure" {
     GHC.IO.IOMode.$tcIOMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tcIOMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9818555080744742578;
         const 14348064797489060312;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.302454311 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode1_closure" {
     GHC.IO.IOMode.$tc'AppendMode1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.IOMode.$tcIOMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.304189004 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'ReadMode2_bytes" {
     GHC.IO.IOMode.$tc'ReadMode2_bytes:
         I8[] [39,82,101,97,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.305929639 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadMode1_closure" {
     GHC.IO.IOMode.$tc'ReadMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'ReadMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.307715498 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadMode_closure" {
     GHC.IO.IOMode.$tc'ReadMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'ReadMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 17697021977009842408;
         const 16081808542294250782;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.309660262 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'WriteMode2_bytes" {
     GHC.IO.IOMode.$tc'WriteMode2_bytes:
         I8[] [39,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.311353527 UTC

[section ""data" . GHC.IO.IOMode.$tc'WriteMode1_closure" {
     GHC.IO.IOMode.$tc'WriteMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'WriteMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.313123933 UTC

[section ""data" . GHC.IO.IOMode.$tc'WriteMode_closure" {
     GHC.IO.IOMode.$tc'WriteMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'WriteMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 16610458722029011495;
         const 11554819901902375488;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.315610555 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'AppendMode3_bytes" {
     GHC.IO.IOMode.$tc'AppendMode3_bytes:
         I8[] [39,65,112,112,101,110,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.31738181 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode2_closure" {
     GHC.IO.IOMode.$tc'AppendMode2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'AppendMode3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.319064556 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode_closure" {
     GHC.IO.IOMode.$tc'AppendMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode2_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 3610623883618650464;
         const 11131639874085434472;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.321515245 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'ReadWriteMode2_bytes" {
     GHC.IO.IOMode.$tc'ReadWriteMode2_bytes:
         I8[] [39,82,101,97,100,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.323222283 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadWriteMode1_closure" {
     GHC.IO.IOMode.$tc'ReadWriteMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'ReadWriteMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.324900549 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadWriteMode_closure" {
     GHC.IO.IOMode.$tc'ReadWriteMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'ReadWriteMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 626157189396725199;
         const 9407417215311302278;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.327287621 UTC

[section ""data" . GHC.IO.IOMode.ReadMode_closure" {
     GHC.IO.IOMode.ReadMode_closure:
         const GHC.IO.IOMode.ReadMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.32890477 UTC

[section ""data" . GHC.IO.IOMode.WriteMode_closure" {
     GHC.IO.IOMode.WriteMode_closure:
         const GHC.IO.IOMode.WriteMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.33065115 UTC

[section ""data" . GHC.IO.IOMode.AppendMode_closure" {
     GHC.IO.IOMode.AppendMode_closure:
         const GHC.IO.IOMode.AppendMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.33227185 UTC

[section ""data" . GHC.IO.IOMode.ReadWriteMode_closure" {
     GHC.IO.IOMode.ReadWriteMode_closure:
         const GHC.IO.IOMode.ReadWriteMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.333932822 UTC

[section ""relreadonly" . GHC.IO.IOMode.IOMode_closure_tbl" {
     GHC.IO.IOMode.IOMode_closure_tbl:
         const GHC.IO.IOMode.ReadMode_closure+1;
         const GHC.IO.IOMode.WriteMode_closure+2;
         const GHC.IO.IOMode.AppendMode_closure+3;
         const GHC.IO.IOMode.ReadWriteMode_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.336266714 UTC

[GHC.IO.IOMode.ReadMode_con_entry() //  [R1]
         { info_tbl: [(c4OOy,
                       label: GHC.IO.IOMode.ReadMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,82,101,97,100,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OOy: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.340116818 UTC

[GHC.IO.IOMode.WriteMode_con_entry() //  [R1]
         { info_tbl: [(c4OOE,
                       label: GHC.IO.IOMode.WriteMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,87,114,105,116,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OOE: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.34353879 UTC

[GHC.IO.IOMode.AppendMode_con_entry() //  [R1]
         { info_tbl: [(c4OOK,
                       label: GHC.IO.IOMode.AppendMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,65,112,112,101,110,100,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OOK: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.347488909 UTC

[GHC.IO.IOMode.ReadWriteMode_con_entry() //  [R1]
         { info_tbl: [(c4OOQ,
                       label: GHC.IO.IOMode.ReadWriteMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,82,101,97,100,87,114,105,116,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OOQ: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:40.35156238 UTC

[section ""relreadonly" . S4L8g_srt" {
     S4L8g_srt:
         const GHC.IO.IOMode.$fReadIOMode8_closure;
         const GHC.IO.IOMode.$fReadIOMode12_closure;
         const GHC.IO.IOMode.$fReadIOMode16_closure;
         const GHC.IO.IOMode.$fReadIOMode20_closure;
         const GHC.IO.IOMode.$w$cshowsPrec_closure;
         const GHC.IO.IOMode.$fShowIOMode_$cshow_closure;
         const GHC.Read.choose2_closure;
         const GHC.IO.IOMode.$fReadIOMode_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.IOMode.$fReadIOMode2_closure;
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.IOMode.$fReadIOMode1_closure;
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
         const GHC.IO.IOMode.$fReadIOMode22_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.IO.IOMode.$fIxIOMode_$cindex_closure;
         const GHC.Err.error_closure;
         const lvl13_r4KYY_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_closure;
         const GHC.IO.IOMode.$fEnumIOMode5_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_closure;
         const GHC.IO.IOMode.$fEnumIOMode6_closure;
         const lvl18_r4KZ3_closure;
         const lvl19_r4KZ4_closure;
         const lvl20_r4KZ5_closure;
         const GHC.IO.IOMode.$wlvl_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure;
         const GHC.IO.IOMode.$w$ctoEnum_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure;
         const GHC.IO.IOMode.$fEnumIOMode1_closure;
         const GHC.IO.IOMode.$fEnumIOMode2_closure;
         const GHC.IO.IOMode.$fEnumIOMode3_closure;
         const GHC.IO.IOMode.$fEnumIOMode4_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go3_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go2_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go1_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.592616345 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:44.594294105 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode21_bytes" {
     GHC.IO.IOMode.$fReadIOMode21_bytes:
         I8[] [82,101,97,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.597282823 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode20_closure" {
     GHC.IO.IOMode.$fReadIOMode20_closure:
         const GHC.IO.IOMode.$fReadIOMode20_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode20_entry() //  [R1]
         { info_tbl: [(c4OX7,
                       label: GHC.IO.IOMode.$fReadIOMode20_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OX7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OX8; else goto c4OX9;
       c4OX8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OX9: // global
           (_c4OX4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4OX4::I64 == 0) goto c4OX6; else goto c4OX5;
       c4OX6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4OX5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4OX4::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode21_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.603665176 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode17_bytes" {
     GHC.IO.IOMode.$fReadIOMode17_bytes:
         I8[] [87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.606762109 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode16_closure" {
     GHC.IO.IOMode.$fReadIOMode16_closure:
         const GHC.IO.IOMode.$fReadIOMode16_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode16_entry() //  [R1]
         { info_tbl: [(c4OXp,
                       label: GHC.IO.IOMode.$fReadIOMode16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OXp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OXq; else goto c4OXr;
       c4OXq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OXr: // global
           (_c4OXm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4OXm::I64 == 0) goto c4OXo; else goto c4OXn;
       c4OXo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4OXn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4OXm::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.613037696 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode13_bytes" {
     GHC.IO.IOMode.$fReadIOMode13_bytes:
         I8[] [65,112,112,101,110,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.616138642 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode12_closure" {
     GHC.IO.IOMode.$fReadIOMode12_closure:
         const GHC.IO.IOMode.$fReadIOMode12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode12_entry() //  [R1]
         { info_tbl: [(c4OXH,
                       label: GHC.IO.IOMode.$fReadIOMode12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OXH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OXI; else goto c4OXJ;
       c4OXI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OXJ: // global
           (_c4OXE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4OXE::I64 == 0) goto c4OXG; else goto c4OXF;
       c4OXG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4OXF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4OXE::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.622407365 UTC

[section ""cstring" . GHC.IO.IOMode.$fReadIOMode9_bytes" {
     GHC.IO.IOMode.$fReadIOMode9_bytes:
         I8[] [82,101,97,100,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.62573478 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode8_closure" {
     GHC.IO.IOMode.$fReadIOMode8_closure:
         const GHC.IO.IOMode.$fReadIOMode8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode8_entry() //  [R1]
         { info_tbl: [(c4OXZ,
                       label: GHC.IO.IOMode.$fReadIOMode8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OXZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OY0; else goto c4OY1;
       c4OY0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4OY1: // global
           (_c4OXW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4OXW::I64 == 0) goto c4OXY; else goto c4OXX;
       c4OXY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4OXX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4OXW::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.630486052 UTC

[section ""data" . GHC.IO.IOMode.$w$cshowsPrec_closure" {
     GHC.IO.IOMode.$w$cshowsPrec_closure:
         const GHC.IO.IOMode.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.IOMode.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4OYn,
                       label: GHC.IO.IOMode.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OYn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4OYo; else goto c4OYp;
       c4OYo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4OYp: // global
           I64[Sp - 16] = block_c4OYe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4OYE; else goto c4OYf;
       u4OYE: // global
           call _c4OYe(R1) args: 0, res: 0, upd: 0;
       c4OYf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4OYe() //  [R1]
         { info_tbl: [(c4OYe,
                       label: block_c4OYe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OYe: // global
           _s4OOY::P64 = P64[Sp + 8];
           _c4OYm::P64 = R1 & 7;
           if (_c4OYm::P64 < 3) goto u4OYC; else goto u4OYD;
       u4OYC: // global
           if (_c4OYm::P64 < 2) goto c4OYi; else goto c4OYj;
       c4OYi: // global
           R3 = _s4OOY::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode20_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c4OYj: // global
           R3 = _s4OOY::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode16_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4OYD: // global
           if (_c4OYm::P64 < 4) goto c4OYk; else goto c4OYl;
       c4OYk: // global
           R3 = _s4OOY::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode12_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c4OYl: // global
           R3 = _s4OOY::P64;
           R2 = GHC.IO.IOMode.$fReadIOMode8_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.637358162 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c4OYV,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OYV: // global
           _s4OP1::P64 = R3;
           R3 = R4;
           R2 = _s4OP1::P64;
           call GHC.IO.IOMode.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.642249176 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshow_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshow_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshow_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshow_entry() //  [R2]
         { info_tbl: [(c4OZf,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OZf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4OZg; else goto c4OZh;
       c4OZg: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fShowIOMode_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4OZh: // global
           I64[Sp - 8] = block_c4OZ6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4OZw; else goto c4OZ7;
       u4OZw: // global
           call _c4OZ6(R1) args: 0, res: 0, upd: 0;
       c4OZ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4OZ6() //  [R1]
         { info_tbl: [(c4OZ6,
                       label: block_c4OZ6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OZ6: // global
           _c4OZe::P64 = R1 & 7;
           if (_c4OZe::P64 < 3) goto u4OZu; else goto u4OZv;
       u4OZu: // global
           if (_c4OZe::P64 < 2) goto c4OZa; else goto c4OZb;
       c4OZa: // global
           R1 = GHC.IO.IOMode.$fReadIOMode20_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4OZb: // global
           R1 = GHC.IO.IOMode.$fReadIOMode16_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u4OZv: // global
           if (_c4OZe::P64 < 4) goto c4OZc; else goto c4OZd;
       c4OZc: // global
           R1 = GHC.IO.IOMode.$fReadIOMode12_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4OZd: // global
           R1 = GHC.IO.IOMode.$fReadIOMode8_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.649331196 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_$cshowList_closure" {
     GHC.IO.IOMode.$fShowIOMode_$cshowList_closure:
         const GHC.IO.IOMode.$fShowIOMode_$cshowList_info;
         const 0;
 },
 GHC.IO.IOMode.$fShowIOMode_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4OZQ,
                       label: GHC.IO.IOMode.$fShowIOMode_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4OZQ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.IOMode.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.652903998 UTC

[section ""data" . GHC.IO.IOMode.$fShowIOMode_closure" {
     GHC.IO.IOMode.$fShowIOMode_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.IOMode.$fShowIOMode_$cshowsPrec_closure+3;
         const GHC.IO.IOMode.$fShowIOMode_$cshow_closure+1;
         const GHC.IO.IOMode.$fShowIOMode_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.655063367 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode19_closure" {
     GHC.IO.IOMode.$fReadIOMode19_closure:
         const GHC.IO.IOMode.$fReadIOMode19_info;
 },
 GHC.IO.IOMode.$fReadIOMode19_entry() //  [R3]
         { info_tbl: [(c4P02,
                       label: GHC.IO.IOMode.$fReadIOMode19_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P02: // global
           R2 = GHC.IO.IOMode.ReadMode_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.658617974 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode18_closure" {
     GHC.IO.IOMode.$fReadIOMode18_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode20_closure;
         const GHC.IO.IOMode.$fReadIOMode19_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.660726432 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode15_closure" {
     GHC.IO.IOMode.$fReadIOMode15_closure:
         const GHC.IO.IOMode.$fReadIOMode15_info;
 },
 GHC.IO.IOMode.$fReadIOMode15_entry() //  [R3]
         { info_tbl: [(c4P0e,
                       label: GHC.IO.IOMode.$fReadIOMode15_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P0e: // global
           R2 = GHC.IO.IOMode.WriteMode_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.664195667 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode14_closure" {
     GHC.IO.IOMode.$fReadIOMode14_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode16_closure;
         const GHC.IO.IOMode.$fReadIOMode15_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.666334594 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode11_closure" {
     GHC.IO.IOMode.$fReadIOMode11_closure:
         const GHC.IO.IOMode.$fReadIOMode11_info;
 },
 GHC.IO.IOMode.$fReadIOMode11_entry() //  [R3]
         { info_tbl: [(c4P0q,
                       label: GHC.IO.IOMode.$fReadIOMode11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P0q: // global
           R2 = GHC.IO.IOMode.AppendMode_closure+3;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.669778999 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode10_closure" {
     GHC.IO.IOMode.$fReadIOMode10_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode12_closure;
         const GHC.IO.IOMode.$fReadIOMode11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.672435485 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode7_closure" {
     GHC.IO.IOMode.$fReadIOMode7_closure:
         const GHC.IO.IOMode.$fReadIOMode7_info;
 },
 GHC.IO.IOMode.$fReadIOMode7_entry() //  [R3]
         { info_tbl: [(c4P0C,
                       label: GHC.IO.IOMode.$fReadIOMode7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P0C: // global
           R2 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.676644104 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode6_closure" {
     GHC.IO.IOMode.$fReadIOMode6_closure:
         const (,)_con_info;
         const GHC.IO.IOMode.$fReadIOMode8_closure;
         const GHC.IO.IOMode.$fReadIOMode7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.678492888 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode5_closure" {
     GHC.IO.IOMode.$fReadIOMode5_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode6_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.680325747 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode4_closure" {
     GHC.IO.IOMode.$fReadIOMode4_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode10_closure+1;
         const GHC.IO.IOMode.$fReadIOMode5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.682174537 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode3_closure" {
     GHC.IO.IOMode.$fReadIOMode3_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode14_closure+1;
         const GHC.IO.IOMode.$fReadIOMode4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.683950782 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_sps_closure" {
     GHC.IO.IOMode.$fReadIOMode_sps_closure:
         const :_con_info;
         const GHC.IO.IOMode.$fReadIOMode18_closure+1;
         const GHC.IO.IOMode.$fReadIOMode3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.686002167 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode2_closure" {
     GHC.IO.IOMode.$fReadIOMode2_closure:
         const GHC.IO.IOMode.$fReadIOMode2_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode2_entry() //  [R2]
         { info_tbl: [(c4P0S,
                       label: GHC.IO.IOMode.$fReadIOMode2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P0S: // global
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.689715714 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode1_closure" {
     GHC.IO.IOMode.$fReadIOMode1_closure:
         const GHC.IO.IOMode.$fReadIOMode1_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode1_entry() //  [R2, R3]
         { info_tbl: [(c4P13,
                       label: GHC.IO.IOMode.$fReadIOMode1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P13: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.693676597 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_info;
         const 0;
 },
 sat_s4OPh_entry() //  [R1]
         { info_tbl: [(c4P1i,
                       label: sat_s4OPh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P1i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4P1j; else goto c4P1k;
       c4P1j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4P1k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.IO.IOMode.$fReadIOMode2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fReadIOMode_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c4P1l,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P1l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4P1p; else goto c4P1o;
       c4P1p: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4P1o: // global
           I64[Hp - 16] = sat_s4OPh_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.700059214 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c4P1I,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P1I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4P1J; else goto c4P1K;
       c4P1J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4P1K: // global
           (_c4P1F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4P1F::I64 == 0) goto c4P1H; else goto c4P1G;
       c4P1H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4P1G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4P1F::I64;
           R2 = GHC.IO.IOMode.$fReadIOMode1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.708540983 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode22_closure" {
     GHC.IO.IOMode.$fReadIOMode22_closure:
         const GHC.IO.IOMode.$fReadIOMode22_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode22_entry() //  [R1]
         { info_tbl: [(c4P1Z,
                       label: GHC.IO.IOMode.$fReadIOMode22_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P1Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4P20; else goto c4P21;
       c4P20: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4P21: // global
           (_c4P1W::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4P1W::I64 == 0) goto c4P1Y; else goto c4P1X;
       c4P1Y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4P1X: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4P1W::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.715362532 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_$creadList_closure" {
     GHC.IO.IOMode.$fReadIOMode_$creadList_closure:
         const GHC.IO.IOMode.$fReadIOMode_$creadList_info;
         const 0;
 },
 GHC.IO.IOMode.$fReadIOMode_$creadList_entry() //  [R2]
         { info_tbl: [(c4P2f,
                       label: GHC.IO.IOMode.$fReadIOMode_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P2f: // global
           R3 = R2;
           R2 = GHC.IO.IOMode.$fReadIOMode22_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.72167126 UTC

[section ""data" . GHC.IO.IOMode.$fReadIOMode_closure" {
     GHC.IO.IOMode.$fReadIOMode_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure+1;
         const GHC.IO.IOMode.$fReadIOMode_$creadList_closure+1;
         const GHC.IO.IOMode.$fReadIOMode1_closure+2;
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.726106461 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_$c==_closure" {
     GHC.IO.IOMode.$fEqIOMode_$c==_closure:
         const GHC.IO.IOMode.$fEqIOMode_$c==_info;
 },
 GHC.IO.IOMode.$fEqIOMode_$c==_entry() //  [R2, R3]
         { info_tbl: [(c4P2A,
                       label: GHC.IO.IOMode.$fEqIOMode_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P2A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4P2B; else goto c4P2C;
       c4P2B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEqIOMode_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4P2C: // global
           I64[Sp - 16] = block_c4P2r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4P3T; else goto c4P2s;
       u4P3T: // global
           call _c4P2r(R1) args: 0, res: 0, upd: 0;
       c4P2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4P2r() //  [R1]
         { info_tbl: [(c4P2r,
                       label: block_c4P2r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P2r: // global
           _s4OPj::P64 = P64[Sp + 8];
           _c4P2z::P64 = R1 & 7;
           if (_c4P2z::P64 < 3) goto u4P3F; else goto u4P3G;
       u4P3F: // global
           if (_c4P2z::P64 < 2) goto c4P2v; else goto c4P2w;
       c4P2v: // global
           I64[Sp + 8] = block_c4P2F_info;
           R1 = _s4OPj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P3P; else goto c4P2H;
       u4P3P: // global
           call _c4P2F(R1) args: 0, res: 0, upd: 0;
       c4P2H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4P2w: // global
           I64[Sp + 8] = block_c4P2U_info;
           R1 = _s4OPj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P3Q; else goto c4P2W;
       u4P3Q: // global
           call _c4P2U(R1) args: 0, res: 0, upd: 0;
       c4P2W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4P3G: // global
           if (_c4P2z::P64 < 4) goto c4P2x; else goto c4P2y;
       c4P2x: // global
           I64[Sp + 8] = block_c4P39_info;
           R1 = _s4OPj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P3R; else goto c4P3b;
       u4P3R: // global
           call _c4P39(R1) args: 0, res: 0, upd: 0;
       c4P3b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4P2y: // global
           I64[Sp + 8] = block_c4P3o_info;
           R1 = _s4OPj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P3S; else goto c4P3q;
       u4P3S: // global
           call _c4P3o(R1) args: 0, res: 0, upd: 0;
       c4P3q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4P2F() //  [R1]
         { info_tbl: [(c4P2F,
                       label: block_c4P2F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P2F: // global
           if (R1 & 7 == 1) goto u4P3H; else goto u4P3I;
       u4P3H: // global
           Sp = Sp + 8;
           call _c4P3A() args: 0, res: 0, upd: 0;
       u4P3I: // global
           Sp = Sp + 8;
           call _c4P3w() args: 0, res: 0, upd: 0;
     }
 },
 _c4P2U() //  [R1]
         { info_tbl: [(c4P2U,
                       label: block_c4P2U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P2U: // global
           if (R1 & 7 == 2) goto u4P3J; else goto u4P3K;
       u4P3J: // global
           Sp = Sp + 8;
           call _c4P3A() args: 0, res: 0, upd: 0;
       u4P3K: // global
           Sp = Sp + 8;
           call _c4P3w() args: 0, res: 0, upd: 0;
     }
 },
 _c4P39() //  [R1]
         { info_tbl: [(c4P39,
                       label: block_c4P39_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P39: // global
           if (R1 & 7 == 3) goto u4P3L; else goto u4P3M;
       u4P3L: // global
           Sp = Sp + 8;
           call _c4P3A() args: 0, res: 0, upd: 0;
       u4P3M: // global
           Sp = Sp + 8;
           call _c4P3w() args: 0, res: 0, upd: 0;
     }
 },
 _c4P3o() //  [R1]
         { info_tbl: [(c4P3o,
                       label: block_c4P3o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P3o: // global
           if (R1 & 7 == 4) goto u4P3N; else goto u4P3O;
       u4P3N: // global
           Sp = Sp + 8;
           call _c4P3A() args: 0, res: 0, upd: 0;
       u4P3O: // global
           Sp = Sp + 8;
           call _c4P3w() args: 0, res: 0, upd: 0;
     }
 },
 _c4P3A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P3A: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4P3w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P3w: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.746587691 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_$c/=_closure" {
     GHC.IO.IOMode.$fEqIOMode_$c/=_closure:
         const GHC.IO.IOMode.$fEqIOMode_$c/=_info;
 },
 GHC.IO.IOMode.$fEqIOMode_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c4P50,
                       label: GHC.IO.IOMode.$fEqIOMode_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P50: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4P51; else goto c4P52;
       c4P51: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEqIOMode_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4P52: // global
           I64[Sp - 16] = block_c4P4R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4P6j; else goto c4P4S;
       u4P6j: // global
           call _c4P4R(R1) args: 0, res: 0, upd: 0;
       c4P4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4P4R() //  [R1]
         { info_tbl: [(c4P4R,
                       label: block_c4P4R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P4R: // global
           _s4OPq::P64 = P64[Sp + 8];
           _c4P4Z::P64 = R1 & 7;
           if (_c4P4Z::P64 < 3) goto u4P65; else goto u4P66;
       u4P65: // global
           if (_c4P4Z::P64 < 2) goto c4P4V; else goto c4P4W;
       c4P4V: // global
           I64[Sp + 8] = block_c4P55_info;
           R1 = _s4OPq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P6f; else goto c4P57;
       u4P6f: // global
           call _c4P55(R1) args: 0, res: 0, upd: 0;
       c4P57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4P4W: // global
           I64[Sp + 8] = block_c4P5k_info;
           R1 = _s4OPq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P6g; else goto c4P5m;
       u4P6g: // global
           call _c4P5k(R1) args: 0, res: 0, upd: 0;
       c4P5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4P66: // global
           if (_c4P4Z::P64 < 4) goto c4P4X; else goto c4P4Y;
       c4P4X: // global
           I64[Sp + 8] = block_c4P5z_info;
           R1 = _s4OPq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P6h; else goto c4P5B;
       u4P6h: // global
           call _c4P5z(R1) args: 0, res: 0, upd: 0;
       c4P5B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4P4Y: // global
           I64[Sp + 8] = block_c4P5O_info;
           R1 = _s4OPq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P6i; else goto c4P5Q;
       u4P6i: // global
           call _c4P5O(R1) args: 0, res: 0, upd: 0;
       c4P5Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4P55() //  [R1]
         { info_tbl: [(c4P55,
                       label: block_c4P55_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P55: // global
           if (R1 & 7 == 1) goto u4P67; else goto u4P68;
       u4P67: // global
           Sp = Sp + 8;
           call _c4P60() args: 0, res: 0, upd: 0;
       u4P68: // global
           Sp = Sp + 8;
           call _c4P5W() args: 0, res: 0, upd: 0;
     }
 },
 _c4P5k() //  [R1]
         { info_tbl: [(c4P5k,
                       label: block_c4P5k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P5k: // global
           if (R1 & 7 == 2) goto u4P69; else goto u4P6a;
       u4P69: // global
           Sp = Sp + 8;
           call _c4P60() args: 0, res: 0, upd: 0;
       u4P6a: // global
           Sp = Sp + 8;
           call _c4P5W() args: 0, res: 0, upd: 0;
     }
 },
 _c4P5z() //  [R1]
         { info_tbl: [(c4P5z,
                       label: block_c4P5z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P5z: // global
           if (R1 & 7 == 3) goto u4P6b; else goto u4P6c;
       u4P6b: // global
           Sp = Sp + 8;
           call _c4P60() args: 0, res: 0, upd: 0;
       u4P6c: // global
           Sp = Sp + 8;
           call _c4P5W() args: 0, res: 0, upd: 0;
     }
 },
 _c4P5O() //  [R1]
         { info_tbl: [(c4P5O,
                       label: block_c4P5O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P5O: // global
           if (R1 & 7 == 4) goto u4P6d; else goto u4P6e;
       u4P6d: // global
           Sp = Sp + 8;
           call _c4P60() args: 0, res: 0, upd: 0;
       u4P6e: // global
           Sp = Sp + 8;
           call _c4P5W() args: 0, res: 0, upd: 0;
     }
 },
 _c4P60() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P60: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4P5W() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P5W: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.763413018 UTC

[section ""data" . GHC.IO.IOMode.$fEqIOMode_closure" {
     GHC.IO.IOMode.$fEqIOMode_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.IOMode.$fEqIOMode_$c==_closure+2;
         const GHC.IO.IOMode.$fEqIOMode_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.766496902 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$ccompare_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4P7r,
                       label: GHC.IO.IOMode.$fOrdIOMode_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P7r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4P7s; else goto c4P7t;
       c4P7s: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4P7t: // global
           I64[Sp - 16] = block_c4P7i_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4P9c; else goto c4P7j;
       u4P9c: // global
           call _c4P7i(R1) args: 0, res: 0, upd: 0;
       c4P7j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4P7i() //  [R1]
         { info_tbl: [(c4P7i,
                       label: block_c4P7i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P7i: // global
           _s4OPx::P64 = P64[Sp + 8];
           _c4P7q::P64 = R1 & 7;
           if (_c4P7q::P64 < 3) goto u4P8Q; else goto u4P8R;
       u4P8Q: // global
           if (_c4P7q::P64 < 2) goto c4P7m; else goto c4P7n;
       c4P7m: // global
           I64[Sp + 8] = block_c4P7w_info;
           R1 = _s4OPx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P98; else goto c4P7y;
       u4P98: // global
           call _c4P7w(R1) args: 0, res: 0, upd: 0;
       c4P7y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4P7n: // global
           I64[Sp + 8] = block_c4P7T_info;
           R1 = _s4OPx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P99; else goto c4P7V;
       u4P99: // global
           call _c4P7T(R1) args: 0, res: 0, upd: 0;
       c4P7V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4P8R: // global
           if (_c4P7q::P64 < 4) goto c4P7o; else goto c4P7p;
       c4P7o: // global
           I64[Sp + 8] = block_c4P8g_info;
           R1 = _s4OPx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P9a; else goto c4P8i;
       u4P9a: // global
           call _c4P8g(R1) args: 0, res: 0, upd: 0;
       c4P8i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4P7p: // global
           I64[Sp + 8] = block_c4P8z_info;
           R1 = _s4OPx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4P9b; else goto c4P8B;
       u4P9b: // global
           call _c4P8z(R1) args: 0, res: 0, upd: 0;
       c4P8B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4P7w() //  [R1]
         { info_tbl: [(c4P7w,
                       label: block_c4P7w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P7w: // global
           _c4P8P::P64 = R1 & 7;
           if (_c4P8P::P64 < 2) goto u4P8W; else goto u4P8S;
       u4P8W: // global
           Sp = Sp + 8;
           call _c4P8L() args: 0, res: 0, upd: 0;
       u4P8S: // global
           if (_c4P8P::P64 != 3) goto u4P8Y; else goto u4P8Y;
       u4P8Y: // global
           Sp = Sp + 8;
           call _c4P8w() args: 0, res: 0, upd: 0;
     }
 },
 _c4P7T() //  [R1]
         { info_tbl: [(c4P7T,
                       label: block_c4P7T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P7T: // global
           _c4P8O::P64 = R1 & 7;
           if (_c4P8O::P64 < 3) goto u4P8T; else goto u4P8U;
       u4P8T: // global
           if (_c4P8O::P64 < 2) goto u4P90; else goto u4P8Z;
       u4P90: // global
           Sp = Sp + 8;
           call _c4P8H() args: 0, res: 0, upd: 0;
       u4P8Z: // global
           Sp = Sp + 8;
           call _c4P8L() args: 0, res: 0, upd: 0;
       u4P8U: // global
           if (_c4P8O::P64 < 4) goto u4P92; else goto u4P92;
       u4P92: // global
           Sp = Sp + 8;
           call _c4P8w() args: 0, res: 0, upd: 0;
     }
 },
 _c4P8g() //  [R1]
         { info_tbl: [(c4P8g,
                       label: block_c4P8g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P8g: // global
           _c4P8N::P64 = R1 & 7;
           if (_c4P8N::P64 != 3) goto u4P8V; else goto u4P93;
       u4P8V: // global
           if (_c4P8N::P64 != 4) goto u4P95; else goto u4P94;
       u4P95: // global
           Sp = Sp + 8;
           call _c4P8H() args: 0, res: 0, upd: 0;
       u4P94: // global
           Sp = Sp + 8;
           call _c4P8w() args: 0, res: 0, upd: 0;
       u4P93: // global
           Sp = Sp + 8;
           call _c4P8L() args: 0, res: 0, upd: 0;
     }
 },
 _c4P8w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P8w: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4P8z() //  [R1]
         { info_tbl: [(c4P8z,
                       label: block_c4P8z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P8z: // global
           if (R1 & 7 == 4) goto u4P96; else goto u4P97;
       u4P96: // global
           Sp = Sp + 8;
           call _c4P8L() args: 0, res: 0, upd: 0;
       u4P97: // global
           Sp = Sp + 8;
           call _c4P8H() args: 0, res: 0, upd: 0;
     }
 },
 _c4P8L() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P8L: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4P8H() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4P8H: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.784165035 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c<_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c<_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c<_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c<_entry() //  [R2, R3]
         { info_tbl: [(c4Pam,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pam: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Pan; else goto c4Pao;
       c4Pan: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Pao: // global
           I64[Sp - 16] = block_c4Pad_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4PbM; else goto c4Pae;
       u4PbM: // global
           call _c4Pad(R1) args: 0, res: 0, upd: 0;
       c4Pae: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Pad() //  [R1]
         { info_tbl: [(c4Pad,
                       label: block_c4Pad_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pad: // global
           _s4OPE::P64 = P64[Sp + 8];
           _c4Pal::P64 = R1 & 7;
           if (_c4Pal::P64 < 3) goto u4Pbw; else goto u4Pbx;
       u4Pbw: // global
           if (_c4Pal::P64 < 2) goto c4Pah; else goto c4Pai;
       c4Pah: // global
           I64[Sp + 8] = block_c4Par_info;
           R1 = _s4OPE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PbI; else goto c4Pat;
       u4PbI: // global
           call _c4Par(R1) args: 0, res: 0, upd: 0;
       c4Pat: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Pai: // global
           I64[Sp + 8] = block_c4PaO_info;
           R1 = _s4OPE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PbJ; else goto c4PaQ;
       u4PbJ: // global
           call _c4PaO(R1) args: 0, res: 0, upd: 0;
       c4PaQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Pbx: // global
           if (_c4Pal::P64 < 4) goto c4Paj; else goto c4Pak;
       c4Paj: // global
           I64[Sp + 8] = block_c4Pb7_info;
           R1 = _s4OPE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PbK; else goto c4Pb9;
       u4PbK: // global
           call _c4Pb7(R1) args: 0, res: 0, upd: 0;
       c4Pb9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Pak: // global
           I64[Sp + 8] = block_c4Pbm_info;
           R1 = _s4OPE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PbL; else goto c4Pbo;
       u4PbL: // global
           call _c4Pbm() args: 0, res: 0, upd: 0;
       c4Pbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Par() //  [R1]
         { info_tbl: [(c4Par,
                       label: block_c4Par_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Par: // global
           _c4Pbv::P64 = R1 & 7;
           if (_c4Pbv::P64 < 2) goto u4PbA; else goto u4Pby;
       u4PbA: // global
           Sp = Sp + 8;
           call _c4Pbf() args: 0, res: 0, upd: 0;
       u4Pby: // global
           if (_c4Pbv::P64 != 3) goto u4PbC; else goto u4PbC;
       u4PbC: // global
           Sp = Sp + 8;
           call _c4Pbj() args: 0, res: 0, upd: 0;
     }
 },
 _c4PaO() //  [R1]
         { info_tbl: [(c4PaO,
                       label: block_c4PaO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PaO: // global
           _c4Pbu::P64 = R1 & 7;
           if (_c4Pbu::P64 != 3) goto u4Pbz; else goto u4PbD;
       u4Pbz: // global
           if (_c4Pbu::P64 != 4) goto u4PbF; else goto u4PbE;
       u4PbF: // global
           Sp = Sp + 8;
           call _c4Pbf() args: 0, res: 0, upd: 0;
       u4PbE: // global
           Sp = Sp + 8;
           goto u4PbQ;
       u4PbD: // global
           Sp = Sp + 8;
           goto u4PbQ;
       u4PbQ: // global
           call _c4Pbj() args: 0, res: 0, upd: 0;
     }
 },
 _c4Pb7() //  [R1]
         { info_tbl: [(c4Pb7,
                       label: block_c4Pb7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pb7: // global
           if (R1 & 7 == 4) goto u4PbG; else goto u4PbH;
       u4PbG: // global
           Sp = Sp + 8;
           call _c4Pbj() args: 0, res: 0, upd: 0;
       u4PbH: // global
           Sp = Sp + 8;
           call _c4Pbf() args: 0, res: 0, upd: 0;
     }
 },
 _c4Pbj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pbj: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pbf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pbf: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pbm() //  []
         { info_tbl: [(c4Pbm,
                       label: block_c4Pbm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pbm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.802201495 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c<=_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c<=_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c<=_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c4PcQ,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PcQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PcR; else goto c4PcS;
       c4PcR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4PcS: // global
           I64[Sp - 16] = block_c4PcH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Peg; else goto c4PcI;
       u4Peg: // global
           call _c4PcH(R1) args: 0, res: 0, upd: 0;
       c4PcI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PcH() //  [R1]
         { info_tbl: [(c4PcH,
                       label: block_c4PcH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PcH: // global
           _s4OPK::P64 = P64[Sp + 8];
           _c4PcP::P64 = R1 & 7;
           if (_c4PcP::P64 < 3) goto u4Pe0; else goto u4Pe1;
       u4Pe0: // global
           if (_c4PcP::P64 < 2) goto c4PcL; else goto c4PcM;
       c4PcL: // global
           I64[Sp + 8] = block_c4PcV_info;
           R1 = _s4OPK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Pec; else goto c4PcX;
       u4Pec: // global
           call _c4PcV(R1) args: 0, res: 0, upd: 0;
       c4PcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PcM: // global
           I64[Sp + 8] = block_c4Pdi_info;
           R1 = _s4OPK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ped; else goto c4Pdk;
       u4Ped: // global
           call _c4Pdi(R1) args: 0, res: 0, upd: 0;
       c4Pdk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Pe1: // global
           if (_c4PcP::P64 < 4) goto c4PcN; else goto c4PcO;
       c4PcN: // global
           I64[Sp + 8] = block_c4PdB_info;
           R1 = _s4OPK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Pee; else goto c4PdD;
       u4Pee: // global
           call _c4PdB(R1) args: 0, res: 0, upd: 0;
       c4PdD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PcO: // global
           I64[Sp + 8] = block_c4PdQ_info;
           R1 = _s4OPK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Pef; else goto c4PdS;
       u4Pef: // global
           call _c4PdQ() args: 0, res: 0, upd: 0;
       c4PdS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PcV() //  [R1]
         { info_tbl: [(c4PcV,
                       label: block_c4PcV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PcV: // global
           _c4PdZ::P64 = R1 & 7;
           if (_c4PdZ::P64 < 2) goto u4Pe4; else goto u4Pe2;
       u4Pe4: // global
           Sp = Sp + 8;
           call _c4PdJ() args: 0, res: 0, upd: 0;
       u4Pe2: // global
           if (_c4PdZ::P64 != 3) goto u4Pe6; else goto u4Pe6;
       u4Pe6: // global
           Sp = Sp + 8;
           call _c4PdN() args: 0, res: 0, upd: 0;
     }
 },
 _c4Pdi() //  [R1]
         { info_tbl: [(c4Pdi,
                       label: block_c4Pdi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pdi: // global
           _c4PdY::P64 = R1 & 7;
           if (_c4PdY::P64 != 3) goto u4Pe3; else goto u4Pe7;
       u4Pe3: // global
           if (_c4PdY::P64 != 4) goto u4Pe9; else goto u4Pe8;
       u4Pe9: // global
           Sp = Sp + 8;
           call _c4PdJ() args: 0, res: 0, upd: 0;
       u4Pe8: // global
           Sp = Sp + 8;
           goto u4Pek;
       u4Pe7: // global
           Sp = Sp + 8;
           goto u4Pek;
       u4Pek: // global
           call _c4PdN() args: 0, res: 0, upd: 0;
     }
 },
 _c4PdB() //  [R1]
         { info_tbl: [(c4PdB,
                       label: block_c4PdB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PdB: // global
           if (R1 & 7 == 4) goto u4Pea; else goto u4Peb;
       u4Pea: // global
           Sp = Sp + 8;
           call _c4PdN() args: 0, res: 0, upd: 0;
       u4Peb: // global
           Sp = Sp + 8;
           call _c4PdJ() args: 0, res: 0, upd: 0;
     }
 },
 _c4PdN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PdN: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PdJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PdJ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PdQ() //  []
         { info_tbl: [(c4PdQ,
                       label: block_c4PdQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PdQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.818750984 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$cmax_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$cmax_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$cmax_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4Pfk,
                       label: GHC.IO.IOMode.$fOrdIOMode_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pfk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Pfl; else goto c4Pfm;
       c4Pfl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Pfm: // global
           I64[Sp - 16] = block_c4Pfb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Pgj; else goto c4Pfc;
       u4Pgj: // global
           call _c4Pfb(R1) args: 0, res: 0, upd: 0;
       c4Pfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Pfb() //  [R1]
         { info_tbl: [(c4Pfb,
                       label: block_c4Pfb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pfb: // global
           _s4OPR::P64 = P64[Sp + 8];
           _c4Pfj::P64 = R1 & 7;
           if (_c4Pfj::P64 < 3) goto u4Pg9; else goto u4Pga;
       u4Pg9: // global
           if (_c4Pfj::P64 < 2) goto c4Pff; else goto c4Pfg;
       c4Pff: // global
           R1 = _s4OPR::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4Pfg: // global
           I64[Sp + 8] = block_c4Pfs_info;
           R1 = _s4OPR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Pgg; else goto c4Pfu;
       u4Pgg: // global
           call _c4Pfs(R1) args: 0, res: 0, upd: 0;
       c4Pfu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Pga: // global
           if (_c4Pfj::P64 < 4) goto c4Pfh; else goto c4Pfi;
       c4Pfh: // global
           I64[Sp + 8] = block_c4PfL_info;
           R1 = _s4OPR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Pgh; else goto c4PfN;
       u4Pgh: // global
           call _c4PfL(R1) args: 0, res: 0, upd: 0;
       c4PfN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Pfi: // global
           I64[Sp + 8] = block_c4Pg0_info;
           R1 = _s4OPR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Pgi; else goto c4Pg2;
       u4Pgi: // global
           call _c4Pg0() args: 0, res: 0, upd: 0;
       c4Pg2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Pfs() //  [R1]
         { info_tbl: [(c4Pfs,
                       label: block_c4Pfs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pfs: // global
           _c4Pg8::P64 = R1 & 7;
           if (_c4Pg8::P64 != 3) goto u4Pgb; else goto u4Pgc;
       u4Pgb: // global
           if (_c4Pg8::P64 != 4) goto c4PfA; else goto u4Pgd;
       c4PfA: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Pgd: // global
           Sp = Sp + 8;
           call _c4PfX() args: 0, res: 0, upd: 0;
       u4Pgc: // global
           Sp = Sp + 8;
           call _c4PfT() args: 0, res: 0, upd: 0;
     }
 },
 _c4PfL() //  [R1]
         { info_tbl: [(c4PfL,
                       label: block_c4PfL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PfL: // global
           if (R1 & 7 == 4) goto u4Pge; else goto u4Pgf;
       u4Pge: // global
           Sp = Sp + 8;
           call _c4PfX() args: 0, res: 0, upd: 0;
       u4Pgf: // global
           Sp = Sp + 8;
           call _c4PfT() args: 0, res: 0, upd: 0;
     }
 },
 _c4PfX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PfX: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PfT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PfT: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pg0() //  []
         { info_tbl: [(c4Pg0,
                       label: block_c4Pg0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pg0: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.83292046 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c>=_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c>=_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c>=_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c4Phe,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Phe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Phf; else goto c4Phg;
       c4Phf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Phg: // global
           I64[Sp - 16] = block_c4Ph5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4PiE; else goto c4Ph6;
       u4PiE: // global
           call _c4Ph5(R1) args: 0, res: 0, upd: 0;
       c4Ph6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ph5() //  [R1]
         { info_tbl: [(c4Ph5,
                       label: block_c4Ph5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ph5: // global
           _s4OPY::P64 = P64[Sp + 8];
           _c4Phd::P64 = R1 & 7;
           if (_c4Phd::P64 < 3) goto u4Pio; else goto u4Pip;
       u4Pio: // global
           if (_c4Phd::P64 < 2) goto c4Ph9; else goto c4Pha;
       c4Ph9: // global
           I64[Sp + 8] = block_c4Phj_info;
           R1 = _s4OPY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PiA; else goto c4Phl;
       u4PiA: // global
           call _c4Phj(R1) args: 0, res: 0, upd: 0;
       c4Phl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Pha: // global
           I64[Sp + 8] = block_c4PhG_info;
           R1 = _s4OPY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PiB; else goto c4PhI;
       u4PiB: // global
           call _c4PhG(R1) args: 0, res: 0, upd: 0;
       c4PhI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Pip: // global
           if (_c4Phd::P64 < 4) goto c4Phb; else goto c4Phc;
       c4Phb: // global
           I64[Sp + 8] = block_c4PhZ_info;
           R1 = _s4OPY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PiC; else goto c4Pi1;
       u4PiC: // global
           call _c4PhZ(R1) args: 0, res: 0, upd: 0;
       c4Pi1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Phc: // global
           I64[Sp + 8] = block_c4Pie_info;
           R1 = _s4OPY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PiD; else goto c4Pig;
       u4PiD: // global
           call _c4Pie() args: 0, res: 0, upd: 0;
       c4Pig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Phj() //  [R1]
         { info_tbl: [(c4Phj,
                       label: block_c4Phj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Phj: // global
           _c4Pin::P64 = R1 & 7;
           if (_c4Pin::P64 < 2) goto u4Pis; else goto u4Piq;
       u4Pis: // global
           Sp = Sp + 8;
           call _c4Pi7() args: 0, res: 0, upd: 0;
       u4Piq: // global
           if (_c4Pin::P64 != 3) goto u4Piu; else goto u4Piu;
       u4Piu: // global
           Sp = Sp + 8;
           call _c4Pib() args: 0, res: 0, upd: 0;
     }
 },
 _c4PhG() //  [R1]
         { info_tbl: [(c4PhG,
                       label: block_c4PhG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PhG: // global
           _c4Pim::P64 = R1 & 7;
           if (_c4Pim::P64 != 3) goto u4Pir; else goto u4Piv;
       u4Pir: // global
           if (_c4Pim::P64 != 4) goto u4Pix; else goto u4Piw;
       u4Pix: // global
           Sp = Sp + 8;
           call _c4Pi7() args: 0, res: 0, upd: 0;
       u4Piw: // global
           Sp = Sp + 8;
           goto u4PiI;
       u4Piv: // global
           Sp = Sp + 8;
           goto u4PiI;
       u4PiI: // global
           call _c4Pib() args: 0, res: 0, upd: 0;
     }
 },
 _c4PhZ() //  [R1]
         { info_tbl: [(c4PhZ,
                       label: block_c4PhZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PhZ: // global
           if (R1 & 7 == 4) goto u4Piy; else goto u4Piz;
       u4Piy: // global
           Sp = Sp + 8;
           call _c4Pib() args: 0, res: 0, upd: 0;
       u4Piz: // global
           Sp = Sp + 8;
           call _c4Pi7() args: 0, res: 0, upd: 0;
     }
 },
 _c4Pib() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pib: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pi7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pi7: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pie() //  []
         { info_tbl: [(c4Pie,
                       label: block_c4Pie_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pie: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.849211644 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$c>_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$c>_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$c>_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$c>_entry() //  [R2, R3]
         { info_tbl: [(c4Pjz,
                       label: GHC.IO.IOMode.$fOrdIOMode_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pjz: // global
           _s4OQ5::P64 = R3;
           R3 = R2;
           R2 = _s4OQ5::P64;
           call GHC.IO.IOMode.$fOrdIOMode_$c<_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.853737576 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_$cmin_closure" {
     GHC.IO.IOMode.$fOrdIOMode_$cmin_closure:
         const GHC.IO.IOMode.$fOrdIOMode_$cmin_info;
 },
 GHC.IO.IOMode.$fOrdIOMode_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4PjT,
                       label: GHC.IO.IOMode.$fOrdIOMode_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PjT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PjU; else goto c4PjV;
       c4PjU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fOrdIOMode_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4PjV: // global
           I64[Sp - 16] = block_c4PjK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4PkO; else goto c4PjL;
       u4PkO: // global
           call _c4PjK(R1) args: 0, res: 0, upd: 0;
       c4PjL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PjK() //  [R1]
         { info_tbl: [(c4PjK,
                       label: block_c4PjK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PjK: // global
           _s4OQ6::P64 = P64[Sp + 8];
           _c4PjS::P64 = R1 & 7;
           if (_c4PjS::P64 < 3) goto u4PkI; else goto u4PkJ;
       u4PkI: // global
           if (_c4PjS::P64 < 2) goto c4PjO; else goto c4PjP;
       c4PjO: // global
           I64[Sp + 8] = block_c4PjY_info;
           R1 = _s4OQ6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PkL; else goto c4Pk0;
       u4PkL: // global
           call _c4PjY() args: 0, res: 0, upd: 0;
       c4Pk0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PjP: // global
           I64[Sp + 8] = block_c4Pk7_info;
           R1 = _s4OQ6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PkM; else goto c4Pk9;
       u4PkM: // global
           call _c4Pk7(R1) args: 0, res: 0, upd: 0;
       c4Pk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4PkJ: // global
           if (_c4PjS::P64 < 4) goto c4PjQ; else goto c4PjR;
       c4PjQ: // global
           I64[Sp + 8] = block_c4Pkq_info;
           R1 = _s4OQ6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PkN; else goto c4Pks;
       u4PkN: // global
           call _c4Pkq(R1) args: 0, res: 0, upd: 0;
       c4Pks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PjR: // global
           R1 = _s4OQ6::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PjY() //  []
         { info_tbl: [(c4PjY,
                       label: block_c4PjY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PjY: // global
           R1 = GHC.IO.IOMode.ReadMode_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pk7() //  [R1]
         { info_tbl: [(c4Pk7,
                       label: block_c4Pk7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pk7: // global
           _c4PkH::P64 = R1 & 7;
           if (_c4PkH::P64 == 3) goto c4Pkn; else goto u4PkK;
       u4PkK: // global
           if (_c4PkH::P64 == 4) goto c4Pkn; else goto c4Pkf;
       c4Pkn: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Pkf: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pkq() //  [R1]
         { info_tbl: [(c4Pkq,
                       label: block_c4Pkq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pkq: // global
           if (R1 & 7 == 4) goto c4PkC; else goto c4Pky;
       c4PkC: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Pky: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.865225761 UTC

[section ""data" . GHC.IO.IOMode.$fOrdIOMode_closure" {
     GHC.IO.IOMode.$fOrdIOMode_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.IO.IOMode.$fEqIOMode_closure+1;
         const GHC.IO.IOMode.$fOrdIOMode_$ccompare_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c<_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c<=_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c>_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$c>=_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$cmax_closure+2;
         const GHC.IO.IOMode.$fOrdIOMode_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.868969196 UTC

[section ""data" . GHC.IO.IOMode.$w$cunsafeIndex_closure" {
     GHC.IO.IOMode.$w$cunsafeIndex_closure:
         const GHC.IO.IOMode.$w$cunsafeIndex_info;
 },
 GHC.IO.IOMode.$w$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4PlF,
                       label: GHC.IO.IOMode.$w$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PlF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PlG; else goto c4PlH;
       c4PlG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4PlH: // global
           I64[Sp - 16] = block_c4Plw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4PnI; else goto c4Plx;
       u4PnI: // global
           call _c4Plw(R1) args: 0, res: 0, upd: 0;
       c4Plx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Plw() //  [R1]
         { info_tbl: [(c4Plw,
                       label: block_c4Plw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Plw: // global
           _s4OQd::P64 = P64[Sp + 8];
           _c4PlE::P64 = R1 & 7;
           if (_c4PlE::P64 < 3) goto u4Png; else goto u4Pnh;
       u4Png: // global
           if (_c4PlE::P64 < 2) goto c4PlA; else goto c4PlB;
       c4PlA: // global
           I64[Sp + 8] = block_c4PlK_info;
           R1 = _s4OQd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PnE; else goto c4PlM;
       u4PnE: // global
           call _c4PlK(R1) args: 0, res: 0, upd: 0;
       c4PlM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PlB: // global
           I64[Sp + 8] = block_c4Pm7_info;
           R1 = _s4OQd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PnF; else goto c4Pm9;
       u4PnF: // global
           call _c4Pm7(R1) args: 0, res: 0, upd: 0;
       c4Pm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4Pnh: // global
           if (_c4PlE::P64 < 4) goto c4PlC; else goto c4PlD;
       c4PlC: // global
           I64[Sp + 8] = block_c4Pmu_info;
           R1 = _s4OQd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PnG; else goto c4Pmw;
       u4PnG: // global
           call _c4Pmu(R1) args: 0, res: 0, upd: 0;
       c4Pmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PlD: // global
           I64[Sp + 8] = block_c4PmR_info;
           R1 = _s4OQd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PnH; else goto c4PmT;
       u4PnH: // global
           call _c4PmR(R1) args: 0, res: 0, upd: 0;
       c4PmT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PlK() //  [R1]
         { info_tbl: [(c4PlK,
                       label: block_c4PlK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PlK: // global
           _c4Pnf::P64 = R1 & 7;
           if (_c4Pnf::P64 < 3) goto u4Pni; else goto u4Pnj;
       u4Pni: // global
           if (_c4Pnf::P64 < 2) goto u4Pnr; else goto u4Pnq;
       u4Pnr: // global
           Sp = Sp + 8;
           call _c4Pnb() args: 0, res: 0, upd: 0;
       u4Pnq: // global
           Sp = Sp + 8;
           call _c4PmO() args: 0, res: 0, upd: 0;
       u4Pnj: // global
           if (_c4Pnf::P64 < 4) goto u4Pns; else goto c4Pm4;
       u4Pns: // global
           Sp = Sp + 8;
           call _c4Pmr() args: 0, res: 0, upd: 0;
       c4Pm4: // global
           R1 = 3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pm7() //  [R1]
         { info_tbl: [(c4Pm7,
                       label: block_c4Pm7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pm7: // global
           _c4Pne::P64 = R1 & 7;
           if (_c4Pne::P64 < 3) goto u4Pnk; else goto u4Pnl;
       u4Pnk: // global
           if (_c4Pne::P64 < 2) goto u4Pnu; else goto u4Pnt;
       u4Pnu: // global
           Sp = Sp + 8;
           call _c4Pn7() args: 0, res: 0, upd: 0;
       u4Pnt: // global
           Sp = Sp + 8;
           call _c4Pnb() args: 0, res: 0, upd: 0;
       u4Pnl: // global
           if (_c4Pne::P64 < 4) goto u4Pnw; else goto u4Pnv;
       u4Pnw: // global
           Sp = Sp + 8;
           call _c4PmO() args: 0, res: 0, upd: 0;
       u4Pnv: // global
           Sp = Sp + 8;
           call _c4Pmr() args: 0, res: 0, upd: 0;
     }
 },
 _c4Pmr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pmr: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pmu() //  [R1]
         { info_tbl: [(c4Pmu,
                       label: block_c4Pmu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pmu: // global
           _c4Pnd::P64 = R1 & 7;
           if (_c4Pnd::P64 < 3) goto u4Pnm; else goto u4Pnn;
       u4Pnm: // global
           if (_c4Pnd::P64 < 2) goto u4Pny; else goto u4Pnx;
       u4Pny: // global
           Sp = Sp + 8;
           call _c4Pn3() args: 0, res: 0, upd: 0;
       u4Pnx: // global
           Sp = Sp + 8;
           call _c4Pn7() args: 0, res: 0, upd: 0;
       u4Pnn: // global
           if (_c4Pnd::P64 < 4) goto u4PnA; else goto u4Pnz;
       u4PnA: // global
           Sp = Sp + 8;
           call _c4Pnb() args: 0, res: 0, upd: 0;
       u4Pnz: // global
           Sp = Sp + 8;
           call _c4PmO() args: 0, res: 0, upd: 0;
     }
 },
 _c4PmO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PmO: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PmR() //  [R1]
         { info_tbl: [(c4PmR,
                       label: block_c4PmR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PmR: // global
           _c4Pnc::P64 = R1 & 7;
           if (_c4Pnc::P64 < 3) goto u4Pno; else goto u4Pnp;
       u4Pno: // global
           if (_c4Pnc::P64 < 2) goto c4PmZ; else goto u4PnB;
       c4PmZ: // global
           R1 = (-3);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4PnB: // global
           Sp = Sp + 8;
           call _c4Pn3() args: 0, res: 0, upd: 0;
       u4Pnp: // global
           if (_c4Pnc::P64 < 4) goto u4PnD; else goto u4PnC;
       u4PnD: // global
           Sp = Sp + 8;
           call _c4Pn7() args: 0, res: 0, upd: 0;
       u4PnC: // global
           Sp = Sp + 8;
           call _c4Pnb() args: 0, res: 0, upd: 0;
     }
 },
 _c4Pn3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pn3: // global
           R1 = (-2);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pn7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pn7: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Pnb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pnb: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.889043775 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4PoU,
                       label: GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PoU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Pp2; else goto c4Pp3;
       c4Pp2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Pp3: // global
           I64[Sp - 16] = block_c4PoR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Pp8; else goto c4PoS;
       u4Pp8: // global
           call _c4PoR(R1) args: 0, res: 0, upd: 0;
       c4PoS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PoR() //  [R1]
         { info_tbl: [(c4PoR,
                       label: block_c4PoR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PoR: // global
           _s4OQk::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4PoX_info;
           R3 = _s4OQk::P64;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$cunsafeIndex_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4PoX() //  [R1]
         { info_tbl: [(c4PoX,
                       label: block_c4PoX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PoX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Pp7; else goto c4Pp6;
       c4Pp7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4Pp6: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.897997899 UTC

[section ""data" . GHC.IO.IOMode.$w$cinRange_closure" {
     GHC.IO.IOMode.$w$cinRange_closure:
         const GHC.IO.IOMode.$w$cinRange_info;
 },
 GHC.IO.IOMode.$w$cinRange_entry() //  [R2, R3, R4]
         { info_tbl: [(c4PpE,
                       label: GHC.IO.IOMode.$w$cinRange_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PpE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4PpF; else goto c4PpG;
       c4PpF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cinRange_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4PpG: // global
           I64[Sp - 24] = block_c4Ppv_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Prm; else goto c4Ppw;
       u4Prm: // global
           call _c4Ppv(R1) args: 0, res: 0, upd: 0;
       c4Ppw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ppv() //  [R1]
         { info_tbl: [(c4Ppv,
                       label: block_c4Ppv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ppv: // global
           _s4OQq::P64 = P64[Sp + 8];
           _c4PpD::P64 = R1 & 7;
           if (_c4PpD::P64 < 3) goto u4Prf; else goto u4Prg;
       u4Prf: // global
           if (_c4PpD::P64 < 2) goto c4Ppz; else goto c4PpA;
       c4Ppz: // global
           _s4OQt::I64 = 0;
           goto s4OQs;
       c4PpA: // global
           _s4OQt::I64 = 1;
           goto s4OQs;
       u4Prg: // global
           if (_c4PpD::P64 < 4) goto c4PpB; else goto c4PpC;
       c4PpB: // global
           _s4OQt::I64 = 2;
           goto s4OQs;
       c4PpC: // global
           _s4OQt::I64 = 3;
           goto s4OQs;
       s4OQs: // global
           I64[Sp] = block_c4PpM_info;
           R1 = _s4OQq::P64;
           I64[Sp + 8] = _s4OQt::I64;
           if (R1 & 7 != 0) goto u4Prl; else goto c4Pqw;
       u4Prl: // global
           call _c4PpM(R1) args: 0, res: 0, upd: 0;
       c4Pqw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PpM() //  [R1]
         { info_tbl: [(c4PpM,
                       label: block_c4PpM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PpM: // global
           _s4OQr::P64 = P64[Sp + 16];
           _c4Pr1::P64 = R1 & 7;
           if (_c4Pr1::P64 < 3) goto u4Prh; else goto u4Pri;
       u4Prh: // global
           if (_c4Pr1::P64 < 2) goto c4PqC; else goto c4PqG;
       c4PqC: // global
           _s4OQv::I64 = 0;
           goto s4OQu;
       c4PqG: // global
           _s4OQv::I64 = 1;
           goto s4OQu;
       u4Pri: // global
           if (_c4Pr1::P64 < 4) goto c4PqK; else goto c4PqO;
       c4PqK: // global
           _s4OQv::I64 = 2;
           goto s4OQu;
       c4PqO: // global
           _s4OQv::I64 = 3;
           goto s4OQu;
       s4OQu: // global
           I64[Sp] = block_c4PpR_info;
           R1 = _s4OQr::P64;
           I64[Sp + 16] = _s4OQv::I64;
           if (R1 & 7 != 0) goto u4Prn; else goto c4PpT;
       u4Prn: // global
           call _c4PpR(R1) args: 0, res: 0, upd: 0;
       c4PpT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PpR() //  [R1]
         { info_tbl: [(c4PpR,
                       label: block_c4PpR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PpR: // global
           _s4OQt::I64 = I64[Sp + 8];
           _s4OQv::I64 = I64[Sp + 16];
           _c4Pr2::P64 = R1 & 7;
           if (_c4Pr2::P64 < 3) goto u4Prj; else goto u4Prk;
       u4Prj: // global
           if (_c4Pr2::P64 < 2) goto c4Pq4; else goto c4Pqd;
       c4Pq4: // global
           if (%MO_S_Lt_W64(0, _s4OQt::I64)) goto c4Pqt; else goto c4Pq2;
       c4Pq2: // global
           R1 = I64[(%MO_S_Le_W64(0,
                                  _s4OQv::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Pqd: // global
           if (%MO_S_Lt_W64(1, _s4OQt::I64)) goto c4Pqt; else goto c4Pqc;
       c4Pqc: // global
           R1 = I64[(%MO_S_Le_W64(1,
                                  _s4OQv::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Prk: // global
           if (_c4Pr2::P64 < 4) goto c4Pqm; else goto c4Pqv;
       c4Pqm: // global
           if (%MO_S_Lt_W64(2, _s4OQt::I64)) goto c4Pqt; else goto c4Pql;
       c4Pql: // global
           R1 = I64[(%MO_S_Le_W64(2,
                                  _s4OQv::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Pqv: // global
           if (%MO_S_Lt_W64(3, _s4OQt::I64)) goto c4Pqt; else goto c4Pqu;
       c4Pqt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Pqu: // global
           R1 = I64[(%MO_S_Le_W64(3,
                                  _s4OQv::I64) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.910044337 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cinRange_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cinRange_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cinRange_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4Psa,
                       label: GHC.IO.IOMode.$fIxIOMode_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Psa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Psb; else goto c4Psc;
       c4Psb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Psc: // global
           I64[Sp - 16] = block_c4Ps7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Psg; else goto c4Ps8;
       u4Psg: // global
           call _c4Ps7(R1) args: 0, res: 0, upd: 0;
       c4Ps8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ps7() //  [R1]
         { info_tbl: [(c4Ps7,
                       label: block_c4Ps7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ps7: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.915437523 UTC

[section ""data" . lvl_r4KYL_closure" {
     lvl_r4KYL_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.917120932 UTC

[section ""data" . lvl1_r4KYM_closure" {
     lvl1_r4KYM_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.918855928 UTC

[section ""data" . lvl2_r4KYN_closure" {
     lvl2_r4KYN_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.920493598 UTC

[section ""data" . lvl3_r4KYO_closure" {
     lvl3_r4KYO_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.923241263 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_info;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4PsI,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PsI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4PsJ; else goto c4PsK;
       c4PsJ: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PsK: // global
           I64[Sp - 8] = block_c4Psz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4PsZ; else goto c4PsA;
       u4PsZ: // global
           call _c4Psz(R1) args: 0, res: 0, upd: 0;
       c4PsA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Psz() //  [R1]
         { info_tbl: [(c4Psz,
                       label: block_c4Psz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Psz: // global
           _c4PsH::P64 = R1 & 7;
           if (_c4PsH::P64 < 3) goto u4PsX; else goto u4PsY;
       u4PsX: // global
           if (_c4PsH::P64 < 2) goto c4PsD; else goto c4PsE;
       c4PsD: // global
           R1 = lvl_r4KYL_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PsE: // global
           R1 = lvl1_r4KYM_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4PsY: // global
           if (_c4PsH::P64 < 4) goto c4PsF; else goto c4PsG;
       c4PsF: // global
           R1 = lvl2_r4KYN_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PsG: // global
           R1 = lvl3_r4KYO_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.929884565 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go2_closure" {
     GHC.IO.IOMode.$fIxIOMode_go2_closure:
         const GHC.IO.IOMode.$fIxIOMode_go2_info;
 },
 sat_s4OQS_entry() //  [R1]
         { info_tbl: [(c4Ptr,
                       label: sat_s4OQS_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ptr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Pts; else goto c4Ptt;
       c4Pts: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ptt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OQQ::I64 = I64[R1 + 16];
           if (_s4OQQ::I64 != 0) goto c4Ptp; else goto c4Ptq;
       c4Ptp: // global
           R2 = _s4OQQ::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go2_entry(R2) args: 24, res: 0, upd: 24;
       c4Ptq: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OQP_entry() //  [R1]
         { info_tbl: [(c4PtA,
                       label: sat_s4OQP_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PtA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PtB; else goto c4PtC;
       c4PtB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PtC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go2_entry() //  [R2]
         { info_tbl: [(c4PtE,
                       label: GHC.IO.IOMode.$fIxIOMode_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PtE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4PtI; else goto c4PtH;
       c4PtI: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PtH: // global
           I64[Hp - 64] = sat_s4OQS_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OQP_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.939340402 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go1_closure" {
     GHC.IO.IOMode.$fIxIOMode_go1_closure:
         const GHC.IO.IOMode.$fIxIOMode_go1_info;
 },
 sat_s4OQX_entry() //  [R1]
         { info_tbl: [(c4Puk,
                       label: sat_s4OQX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Puk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Pul; else goto c4Pum;
       c4Pul: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Pum: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OQV::I64 = I64[R1 + 16];
           if (_s4OQV::I64 != 1) goto c4Pui; else goto c4Puj;
       c4Pui: // global
           R2 = _s4OQV::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go1_entry(R2) args: 24, res: 0, upd: 24;
       c4Puj: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OQU_entry() //  [R1]
         { info_tbl: [(c4Put,
                       label: sat_s4OQU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Put: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Puu; else goto c4Puv;
       c4Puu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Puv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go1_entry() //  [R2]
         { info_tbl: [(c4Pux,
                       label: GHC.IO.IOMode.$fIxIOMode_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pux: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4PuB; else goto c4PuA;
       c4PuB: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PuA: // global
           I64[Hp - 64] = sat_s4OQX_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OQU_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.951256255 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_go_closure" {
     GHC.IO.IOMode.$fIxIOMode_go_closure:
         const GHC.IO.IOMode.$fIxIOMode_go_info;
 },
 sat_s4OR2_entry() //  [R1]
         { info_tbl: [(c4Pvd,
                       label: sat_s4OR2_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pvd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Pve; else goto c4Pvf;
       c4Pve: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Pvf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OR0::I64 = I64[R1 + 16];
           if (_s4OR0::I64 != 2) goto c4Pvb; else goto c4Pvc;
       c4Pvb: // global
           R2 = _s4OR0::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fIxIOMode_go_entry(R2) args: 24, res: 0, upd: 24;
       c4Pvc: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OQZ_entry() //  [R1]
         { info_tbl: [(c4Pvm,
                       label: sat_s4OQZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pvm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Pvn; else goto c4Pvo;
       c4Pvn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Pvo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fIxIOMode_go_entry() //  [R2]
         { info_tbl: [(c4Pvq,
                       label: GHC.IO.IOMode.$fIxIOMode_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pvq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Pvu; else goto c4Pvt;
       c4Pvu: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Pvt: // global
           I64[Hp - 64] = sat_s4OR2_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OQZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.961173475 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go4_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go4_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go4_info;
 },
 sat_s4OR7_entry() //  [R1]
         { info_tbl: [(c4Pw6,
                       label: sat_s4OR7_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pw6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Pw7; else goto c4Pw8;
       c4Pw7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Pw8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OR5::I64 = I64[R1 + 16];
           if (_s4OR5::I64 != 3) goto c4Pw4; else goto c4Pw5;
       c4Pw4: // global
           R2 = _s4OR5::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
       c4Pw5: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OR4_entry() //  [R1]
         { info_tbl: [(c4Pwf,
                       label: sat_s4OR4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pwf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Pwg; else goto c4Pwh;
       c4Pwg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Pwh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go4_entry() //  [R2]
         { info_tbl: [(c4Pwj,
                       label: GHC.IO.IOMode.$fEnumIOMode_go4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pwj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Pwn; else goto c4Pwm;
       c4Pwn: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Pwm: // global
           I64[Hp - 64] = sat_s4OR7_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OR4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.97157167 UTC

[section ""data" . GHC.IO.IOMode.$w$crange_closure" {
     GHC.IO.IOMode.$w$crange_closure:
         const GHC.IO.IOMode.$w$crange_info;
 },
 GHC.IO.IOMode.$w$crange_entry() //  [R2, R3]
         { info_tbl: [(c4Px2,
                       label: GHC.IO.IOMode.$w$crange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Px2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Px3; else goto c4Px4;
       c4Px3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$crange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Px4: // global
           I64[Sp - 16] = block_c4PwT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Py5; else goto c4PwU;
       u4Py5: // global
           call _c4PwT(R1) args: 0, res: 0, upd: 0;
       c4PwU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PwT() //  [R1]
         { info_tbl: [(c4PwT,
                       label: block_c4PwT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PwT: // global
           _s4OR9::P64 = P64[Sp + 8];
           _c4Px1::P64 = R1 & 7;
           if (_c4Px1::P64 < 3) goto u4Py0; else goto u4Py1;
       u4Py0: // global
           if (_c4Px1::P64 < 2) goto c4PwX; else goto c4PwY;
       c4PwX: // global
           _s4ORb::I64 = 0;
           goto s4ORa;
       c4PwY: // global
           _s4ORb::I64 = 1;
           goto s4ORa;
       u4Py1: // global
           if (_c4Px1::P64 < 4) goto c4PwZ; else goto c4Px0;
       c4PwZ: // global
           _s4ORb::I64 = 2;
           goto s4ORa;
       c4Px0: // global
           _s4ORb::I64 = 3;
           goto s4ORa;
       s4ORa: // global
           I64[Sp] = block_c4Px8_info;
           R1 = _s4OR9::P64;
           I64[Sp + 8] = _s4ORb::I64;
           if (R1 & 7 != 0) goto u4Py4; else goto c4Pxa;
       u4Py4: // global
           call _c4Px8(R1) args: 0, res: 0, upd: 0;
       c4Pxa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Px8() //  [R1]
         { info_tbl: [(c4Px8,
                       label: block_c4Px8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Px8: // global
           _s4ORb::I64 = I64[Sp + 8];
           _c4PxZ::P64 = R1 & 7;
           if (_c4PxZ::P64 < 3) goto u4Py2; else goto u4Py3;
       u4Py2: // global
           if (_c4PxZ::P64 < 2) goto c4Pxl; else goto c4Pxu;
       c4Pxl: // global
           if (%MO_S_Gt_W64(_s4ORb::I64, 0)) goto c4PxL; else goto c4Pxi;
       c4Pxi: // global
           R2 = _s4ORb::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go2_entry(R2) args: 8, res: 0, upd: 8;
       c4Pxu: // global
           if (%MO_S_Gt_W64(_s4ORb::I64, 1)) goto c4PxL; else goto c4Pxs;
       c4Pxs: // global
           R2 = _s4ORb::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go1_entry(R2) args: 8, res: 0, upd: 8;
       u4Py3: // global
           if (_c4PxZ::P64 < 4) goto c4PxD; else goto c4PxM;
       c4PxD: // global
           if (%MO_S_Gt_W64(_s4ORb::I64, 2)) goto c4PxL; else goto c4PxB;
       c4PxB: // global
           R2 = _s4ORb::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fIxIOMode_go_entry(R2) args: 8, res: 0, upd: 8;
       c4PxM: // global
           if (%MO_S_Gt_W64(_s4ORb::I64, 3)) goto c4PxL; else goto c4PxK;
       c4PxL: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PxK: // global
           R2 = _s4ORb::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.980866174 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$crange_closure" {
     GHC.IO.IOMode.$fIxIOMode_$crange_closure:
         const GHC.IO.IOMode.$fIxIOMode_$crange_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$crange_entry() //  [R2]
         { info_tbl: [(c4Pyw,
                       label: GHC.IO.IOMode.$fIxIOMode_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pyw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Pyx; else goto c4Pyy;
       c4Pyx: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Pyy: // global
           I64[Sp - 8] = block_c4Pyt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4PyC; else goto c4Pyu;
       u4PyC: // global
           call _c4Pyt(R1) args: 0, res: 0, upd: 0;
       c4Pyu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Pyt() //  [R1]
         { info_tbl: [(c4Pyt,
                       label: block_c4Pyt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pyt: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$crange_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:44.987851279 UTC

[section ""data" . GHC.IO.IOMode.$w$crangeSize_closure" {
     GHC.IO.IOMode.$w$crangeSize_closure:
         const GHC.IO.IOMode.$w$crangeSize_info;
 },
 GHC.IO.IOMode.$w$crangeSize_entry() //  [R2, R3]
         { info_tbl: [(c4PyX,
                       label: GHC.IO.IOMode.$w$crangeSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PyX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4PyY; else goto c4PyZ;
       c4PyY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$crangeSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4PyZ: // global
           I64[Sp - 24] = block_c4PyR_info;
           R4 = R3;
           _s4ORn::P64 = R3;
           R3 = R3;
           _s4ORm::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4ORm::P64;
           P64[Sp - 8] = _s4ORn::P64;
           Sp = Sp - 24;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4PyR() //  [R1]
         { info_tbl: [(c4PyR,
                       label: block_c4PyR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PyR: // global
           if (R1 & 7 == 1) goto u4PAX; else goto c4PyV;
       u4PAX: // global
           Sp = Sp + 24;
           call _c4PAD() args: 0, res: 0, upd: 0;
       c4PyV: // global
           _s4ORm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Pz5_info;
           R1 = _s4ORm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PBc; else goto c4Pz7;
       u4PBc: // global
           call _c4Pz5(R1) args: 0, res: 0, upd: 0;
       c4Pz7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Pz5() //  [R1]
         { info_tbl: [(c4Pz5,
                       label: block_c4Pz5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pz5: // global
           _s4ORn::P64 = P64[Sp + 8];
           _c4PAI::P64 = R1 & 7;
           if (_c4PAI::P64 < 3) goto u4PAN; else goto u4PAO;
       u4PAN: // global
           if (_c4PAI::P64 < 2) goto c4Pze; else goto c4PzC;
       c4Pze: // global
           I64[Sp + 8] = block_c4Pzb_info;
           R1 = _s4ORn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PBe; else goto c4Pzf;
       u4PBe: // global
           call _c4Pzb(R1) args: 0, res: 0, upd: 0;
       c4Pzf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PzC: // global
           I64[Sp + 8] = block_c4PzA_info;
           R1 = _s4ORn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PBf; else goto c4PzD;
       u4PBf: // global
           call _c4PzA(R1) args: 0, res: 0, upd: 0;
       c4PzD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4PAO: // global
           if (_c4PAI::P64 < 4) goto c4PA0; else goto c4PAo;
       c4PA0: // global
           I64[Sp + 8] = block_c4PzY_info;
           R1 = _s4ORn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PBg; else goto c4PA1;
       u4PBg: // global
           call _c4PzY(R1) args: 0, res: 0, upd: 0;
       c4PA1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PAo: // global
           I64[Sp + 8] = block_c4PAm_info;
           R1 = _s4ORn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PBh; else goto c4PAp;
       u4PBh: // global
           call _c4PAm(R1) args: 0, res: 0, upd: 0;
       c4PAp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Pzb() //  [R1]
         { info_tbl: [(c4Pzb,
                       label: block_c4Pzb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Pzb: // global
           _c4PAM::P64 = R1 & 7;
           if (_c4PAM::P64 < 3) goto u4PAP; else goto u4PAQ;
       u4PAP: // global
           if (_c4PAM::P64 < 2) goto u4PAZ; else goto u4PAY;
       u4PAZ: // global
           Sp = Sp + 8;
           call _c4PAH() args: 0, res: 0, upd: 0;
       u4PAY: // global
           Sp = Sp + 8;
           call _c4PAj() args: 0, res: 0, upd: 0;
       u4PAQ: // global
           if (_c4PAM::P64 < 4) goto u4PB0; else goto c4Pzx;
       u4PB0: // global
           Sp = Sp + 8;
           call _c4PzV() args: 0, res: 0, upd: 0;
       c4Pzx: // global
           R1 = 4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PzA() //  [R1]
         { info_tbl: [(c4PzA,
                       label: block_c4PzA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PzA: // global
           _c4PAL::P64 = R1 & 7;
           if (_c4PAL::P64 < 3) goto u4PAR; else goto u4PAS;
       u4PAR: // global
           if (_c4PAL::P64 < 2) goto u4PB2; else goto u4PB1;
       u4PB2: // global
           Sp = Sp + 8;
           call _c4PAD() args: 0, res: 0, upd: 0;
       u4PB1: // global
           Sp = Sp + 8;
           call _c4PAH() args: 0, res: 0, upd: 0;
       u4PAS: // global
           if (_c4PAL::P64 < 4) goto u4PB4; else goto u4PB3;
       u4PB4: // global
           Sp = Sp + 8;
           call _c4PAj() args: 0, res: 0, upd: 0;
       u4PB3: // global
           Sp = Sp + 8;
           call _c4PzV() args: 0, res: 0, upd: 0;
     }
 },
 _c4PzV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PzV: // global
           R1 = 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PzY() //  [R1]
         { info_tbl: [(c4PzY,
                       label: block_c4PzY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PzY: // global
           _c4PAK::P64 = R1 & 7;
           if (_c4PAK::P64 < 3) goto u4PAT; else goto u4PAU;
       u4PAT: // global
           if (_c4PAK::P64 < 2) goto u4PB6; else goto u4PB5;
       u4PB6: // global
           Sp = Sp + 8;
           call _c4PAz() args: 0, res: 0, upd: 0;
       u4PB5: // global
           Sp = Sp + 8;
           call _c4PAD() args: 0, res: 0, upd: 0;
       u4PAU: // global
           if (_c4PAK::P64 < 4) goto u4PB8; else goto u4PB7;
       u4PB8: // global
           Sp = Sp + 8;
           call _c4PAH() args: 0, res: 0, upd: 0;
       u4PB7: // global
           Sp = Sp + 8;
           call _c4PAj() args: 0, res: 0, upd: 0;
     }
 },
 _c4PAj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PAj: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PAm() //  [R1]
         { info_tbl: [(c4PAm,
                       label: block_c4PAm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PAm: // global
           _c4PAJ::P64 = R1 & 7;
           if (_c4PAJ::P64 < 3) goto u4PAV; else goto u4PAW;
       u4PAV: // global
           if (_c4PAJ::P64 < 2) goto c4PAv; else goto u4PB9;
       c4PAv: // global
           R1 = (-2);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4PB9: // global
           Sp = Sp + 8;
           call _c4PAz() args: 0, res: 0, upd: 0;
       u4PAW: // global
           if (_c4PAJ::P64 < 4) goto u4PBb; else goto u4PBa;
       u4PBb: // global
           Sp = Sp + 8;
           call _c4PAD() args: 0, res: 0, upd: 0;
       u4PBa: // global
           Sp = Sp + 8;
           call _c4PAH() args: 0, res: 0, upd: 0;
     }
 },
 _c4PAz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PAz: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PAD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PAD: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PAH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PAH: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.008155423 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure" {
     GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure:
         const GHC.IO.IOMode.$fIxIOMode_$crangeSize_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4PCz,
                       label: GHC.IO.IOMode.$fIxIOMode_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PCz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4PCH; else goto c4PCI;
       c4PCH: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PCI: // global
           I64[Sp - 8] = block_c4PCw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4PCN; else goto c4PCx;
       u4PCN: // global
           call _c4PCw(R1) args: 0, res: 0, upd: 0;
       c4PCx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PCw() //  [R1]
         { info_tbl: [(c4PCw,
                       label: block_c4PCw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PCw: // global
           I64[Sp] = block_c4PCC_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.IOMode.$w$crangeSize_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4PCC() //  [R1]
         { info_tbl: [(c4PCC,
                       label: block_c4PCC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PCC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4PCM; else goto c4PCL;
       c4PCM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4PCL: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.017152239 UTC

[section ""data" . GHC.IO.IOMode.$w$cunsafeRangeSize_closure" {
     GHC.IO.IOMode.$w$cunsafeRangeSize_closure:
         const GHC.IO.IOMode.$w$cunsafeRangeSize_info;
 },
 GHC.IO.IOMode.$w$cunsafeRangeSize_entry() //  [R2, R3]
         { info_tbl: [(c4PDh,
                       label: GHC.IO.IOMode.$w$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PDh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PDi; else goto c4PDj;
       c4PDi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$w$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4PDj: // global
           I64[Sp - 16] = block_c4PD8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4PFk; else goto c4PD9;
       u4PFk: // global
           call _c4PD8(R1) args: 0, res: 0, upd: 0;
       c4PD9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PD8() //  [R1]
         { info_tbl: [(c4PD8,
                       label: block_c4PD8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PD8: // global
           _s4ORA::P64 = P64[Sp + 8];
           _c4PDg::P64 = R1 & 7;
           if (_c4PDg::P64 < 3) goto u4PES; else goto u4PET;
       u4PES: // global
           if (_c4PDg::P64 < 2) goto c4PDc; else goto c4PDd;
       c4PDc: // global
           I64[Sp + 8] = block_c4PDm_info;
           R1 = _s4ORA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PFg; else goto c4PDo;
       u4PFg: // global
           call _c4PDm(R1) args: 0, res: 0, upd: 0;
       c4PDo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PDd: // global
           I64[Sp + 8] = block_c4PDJ_info;
           R1 = _s4ORA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PFh; else goto c4PDL;
       u4PFh: // global
           call _c4PDJ(R1) args: 0, res: 0, upd: 0;
       c4PDL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u4PET: // global
           if (_c4PDg::P64 < 4) goto c4PDe; else goto c4PDf;
       c4PDe: // global
           I64[Sp + 8] = block_c4PE6_info;
           R1 = _s4ORA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PFi; else goto c4PE8;
       u4PFi: // global
           call _c4PE6(R1) args: 0, res: 0, upd: 0;
       c4PE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4PDf: // global
           I64[Sp + 8] = block_c4PEt_info;
           R1 = _s4ORA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4PFj; else goto c4PEv;
       u4PFj: // global
           call _c4PEt(R1) args: 0, res: 0, upd: 0;
       c4PEv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PDm() //  [R1]
         { info_tbl: [(c4PDm,
                       label: block_c4PDm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PDm: // global
           _c4PER::P64 = R1 & 7;
           if (_c4PER::P64 < 3) goto u4PEU; else goto u4PEV;
       u4PEU: // global
           if (_c4PER::P64 < 2) goto u4PF3; else goto u4PF2;
       u4PF3: // global
           Sp = Sp + 8;
           call _c4PEN() args: 0, res: 0, upd: 0;
       u4PF2: // global
           Sp = Sp + 8;
           call _c4PEq() args: 0, res: 0, upd: 0;
       u4PEV: // global
           if (_c4PER::P64 < 4) goto u4PF4; else goto c4PDG;
       u4PF4: // global
           Sp = Sp + 8;
           call _c4PE3() args: 0, res: 0, upd: 0;
       c4PDG: // global
           R1 = 4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PDJ() //  [R1]
         { info_tbl: [(c4PDJ,
                       label: block_c4PDJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PDJ: // global
           _c4PEQ::P64 = R1 & 7;
           if (_c4PEQ::P64 < 3) goto u4PEW; else goto u4PEX;
       u4PEW: // global
           if (_c4PEQ::P64 < 2) goto u4PF6; else goto u4PF5;
       u4PF6: // global
           Sp = Sp + 8;
           call _c4PEJ() args: 0, res: 0, upd: 0;
       u4PF5: // global
           Sp = Sp + 8;
           call _c4PEN() args: 0, res: 0, upd: 0;
       u4PEX: // global
           if (_c4PEQ::P64 < 4) goto u4PF8; else goto u4PF7;
       u4PF8: // global
           Sp = Sp + 8;
           call _c4PEq() args: 0, res: 0, upd: 0;
       u4PF7: // global
           Sp = Sp + 8;
           call _c4PE3() args: 0, res: 0, upd: 0;
     }
 },
 _c4PE3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PE3: // global
           R1 = 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PE6() //  [R1]
         { info_tbl: [(c4PE6,
                       label: block_c4PE6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PE6: // global
           _c4PEP::P64 = R1 & 7;
           if (_c4PEP::P64 < 3) goto u4PEY; else goto u4PEZ;
       u4PEY: // global
           if (_c4PEP::P64 < 2) goto u4PFa; else goto u4PF9;
       u4PFa: // global
           Sp = Sp + 8;
           call _c4PEF() args: 0, res: 0, upd: 0;
       u4PF9: // global
           Sp = Sp + 8;
           call _c4PEJ() args: 0, res: 0, upd: 0;
       u4PEZ: // global
           if (_c4PEP::P64 < 4) goto u4PFc; else goto u4PFb;
       u4PFc: // global
           Sp = Sp + 8;
           call _c4PEN() args: 0, res: 0, upd: 0;
       u4PFb: // global
           Sp = Sp + 8;
           call _c4PEq() args: 0, res: 0, upd: 0;
     }
 },
 _c4PEq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PEq: // global
           R1 = 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PEt() //  [R1]
         { info_tbl: [(c4PEt,
                       label: block_c4PEt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PEt: // global
           _c4PEO::P64 = R1 & 7;
           if (_c4PEO::P64 < 3) goto u4PF0; else goto u4PF1;
       u4PF0: // global
           if (_c4PEO::P64 < 2) goto c4PEB; else goto u4PFd;
       c4PEB: // global
           R1 = (-2);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4PFd: // global
           Sp = Sp + 8;
           call _c4PEF() args: 0, res: 0, upd: 0;
       u4PF1: // global
           if (_c4PEO::P64 < 4) goto u4PFf; else goto u4PFe;
       u4PFf: // global
           Sp = Sp + 8;
           call _c4PEJ() args: 0, res: 0, upd: 0;
       u4PFe: // global
           Sp = Sp + 8;
           call _c4PEN() args: 0, res: 0, upd: 0;
     }
 },
 _c4PEF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PEF: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PEJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PEJ: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PEN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PEN: // global
           R1 = 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.035803987 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_info;
 },
 GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4PGw,
                       label: GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PGw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4PGE; else goto c4PGF;
       c4PGE: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PGF: // global
           I64[Sp - 8] = block_c4PGt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4PGK; else goto c4PGu;
       u4PGK: // global
           call _c4PGt(R1) args: 0, res: 0, upd: 0;
       c4PGu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PGt() //  [R1]
         { info_tbl: [(c4PGt,
                       label: block_c4PGt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PGt: // global
           I64[Sp] = block_c4PGz_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.IO.IOMode.$w$cunsafeRangeSize_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4PGz() //  [R1]
         { info_tbl: [(c4PGz,
                       label: block_c4PGz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PGz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4PGJ; else goto c4PGI;
       c4PGJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4PGI: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.043497701 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_$cindex_closure" {
     GHC.IO.IOMode.$fIxIOMode_$cindex_closure:
         const GHC.IO.IOMode.$fIxIOMode_$cindex_info;
         const 0;
 },
 GHC.IO.IOMode.$fIxIOMode_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4PH8,
                       label: GHC.IO.IOMode.$fIxIOMode_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PH8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4PH9; else goto c4PHa;
       c4PH9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fIxIOMode_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4PHa: // global
           I64[Sp - 16] = block_c4PH5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4PHy; else goto c4PH6;
       u4PHy: // global
           call _c4PH5(R1) args: 0, res: 0, upd: 0;
       c4PH6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PH5() //  [R1]
         { info_tbl: [(c4PH5,
                       label: block_c4PH5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PH5: // global
           I64[Sp - 8] = block_c4PHd_info;
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           _s4ORO::P64 = P64[R1 + 7];
           R2 = _s4ORO::P64;
           P64[Sp] = _s4ORO::P64;
           Sp = Sp - 8;
           call GHC.IO.IOMode.$w$cinRange_entry(R4,
                                                R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4PHd() //  [R1]
         { info_tbl: [(c4PHd,
                       label: block_c4PHd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PHd: // global
           if (R1 & 7 == 1) goto c4PHk; else goto c4PHt;
       c4PHk: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4PHt: // global
           _s4ORM::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4PHn_info;
           R3 = _s4ORM::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.IOMode.$w$cunsafeIndex_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4PHn() //  [R1]
         { info_tbl: [(c4PHn,
                       label: block_c4PHn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PHn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4PHw; else goto c4PHv;
       c4PHw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4PHv: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.053221757 UTC

[section ""data" . GHC.IO.IOMode.$fIxIOMode_closure" {
     GHC.IO.IOMode.$fIxIOMode_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.IO.IOMode.$fOrdIOMode_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$crange_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$cindex_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeIndex_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$cinRange_closure+2;
         const GHC.IO.IOMode.$fIxIOMode_$crangeSize_closure+1;
         const GHC.IO.IOMode.$fIxIOMode_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.05508963 UTC

[section ""cstring" . lvl4_r4KYP_bytes" {
     lvl4_r4KYP_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.056955969 UTC

[section ""data" . lvl5_r4KYQ_closure" {
     lvl5_r4KYQ_closure:
         const lvl5_r4KYQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r4KYQ_entry() //  [R1]
         { info_tbl: [(c4PI4,
                       label: lvl5_r4KYQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PI5; else goto c4PI6;
       c4PI5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PI6: // global
           (_c4PI1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PI1::I64 == 0) goto c4PI3; else goto c4PI2;
       c4PI3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PI2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PI1::I64;
           R2 = lvl4_r4KYP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.060903833 UTC

[section ""cstring" . GHC.IO.IOMode.$trModule4_bytes" {
     GHC.IO.IOMode.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.062911327 UTC

[section ""data" . lvl6_r4KYR_closure" {
     lvl6_r4KYR_closure:
         const lvl6_r4KYR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r4KYR_entry() //  [R1]
         { info_tbl: [(c4PIm,
                       label: lvl6_r4KYR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PIm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PIn; else goto c4PIo;
       c4PIn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PIo: // global
           (_c4PIj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PIj::I64 == 0) goto c4PIl; else goto c4PIk;
       c4PIl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PIk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PIj::I64;
           R2 = GHC.IO.IOMode.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.066926185 UTC

[section ""cstring" . GHC.IO.IOMode.$trModule2_bytes" {
     GHC.IO.IOMode.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,73,79,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.068828666 UTC

[section ""data" . lvl7_r4KYS_closure" {
     lvl7_r4KYS_closure:
         const lvl7_r4KYS_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r4KYS_entry() //  [R1]
         { info_tbl: [(c4PIE,
                       label: lvl7_r4KYS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PIE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PIF; else goto c4PIG;
       c4PIF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PIG: // global
           (_c4PIB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PIB::I64 == 0) goto c4PID; else goto c4PIC;
       c4PID: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PIC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PIB::I64;
           R2 = GHC.IO.IOMode.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.072769552 UTC

[section ""cstring" . lvl8_r4KYT_bytes" {
     lvl8_r4KYT_bytes:
         I8[] [46,47,71,72,67,47,73,79,47,73,79,77,111,100,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.075202029 UTC

[section ""data" . lvl9_r4KYU_closure" {
     lvl9_r4KYU_closure:
         const lvl9_r4KYU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r4KYU_entry() //  [R1]
         { info_tbl: [(c4PIW,
                       label: lvl9_r4KYU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PIW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PIX; else goto c4PIY;
       c4PIX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PIY: // global
           (_c4PIT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PIT::I64 == 0) goto c4PIV; else goto c4PIU;
       c4PIV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PIU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PIT::I64;
           R2 = lvl8_r4KYT_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.079088313 UTC

[section ""data" . lvl10_r4KYV_closure" {
     lvl10_r4KYV_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.080736103 UTC

[section ""data" . lvl11_r4KYW_closure" {
     lvl11_r4KYW_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.083019826 UTC

[section ""data" . lvl12_r4KYX_closure" {
     lvl12_r4KYX_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl6_r4KYR_closure;
         const lvl7_r4KYS_closure;
         const lvl9_r4KYU_closure;
         const lvl10_r4KYV_closure+1;
         const lvl10_r4KYV_closure+1;
         const lvl10_r4KYV_closure+1;
         const lvl11_r4KYW_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.08482246 UTC

[section ""data" . lvl13_r4KYY_closure" {
     lvl13_r4KYY_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl5_r4KYQ_closure;
         const lvl12_r4KYX_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.086639635 UTC

[section ""cstring" . lvl14_r4KYZ_bytes" {
     lvl14_r4KYZ_bytes:
         I8[] [112,114,101,100,123,73,79,77,111,100,101,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.08872541 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode5_closure" {
     GHC.IO.IOMode.$fEnumIOMode5_closure:
         const GHC.IO.IOMode.$fEnumIOMode5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode5_entry() //  [R1]
         { info_tbl: [(c4PJk,
                       label: GHC.IO.IOMode.$fEnumIOMode5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PJk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4PJl; else goto c4PJm;
       c4PJl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PJm: // global
           (_c4PJf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PJf::I64 == 0) goto c4PJh; else goto c4PJg;
       c4PJh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PJg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PJf::I64;
           I64[Sp - 24] = block_c4PJi_info;
           R2 = lvl14_r4KYZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4PJi() //  [R1]
         { info_tbl: [(c4PJi,
                       label: block_c4PJi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PJi: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.095226295 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cpred_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cpred_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cpred_entry() //  [R2]
         { info_tbl: [(c4PJP,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PJP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4PJQ; else goto c4PJR;
       c4PJQ: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PJR: // global
           I64[Sp - 8] = block_c4PJG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4PK6; else goto c4PJH;
       u4PK6: // global
           call _c4PJG(R1) args: 0, res: 0, upd: 0;
       c4PJH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PJG() //  [R1]
         { info_tbl: [(c4PJG,
                       label: block_c4PJG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PJG: // global
           _c4PJO::P64 = R1 & 7;
           if (_c4PJO::P64 < 3) goto u4PK4; else goto u4PK5;
       u4PK4: // global
           if (_c4PJO::P64 < 2) goto c4PJK; else goto c4PJL;
       c4PJK: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4PJL: // global
           R1 = GHC.IO.IOMode.ReadMode_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4PK5: // global
           if (_c4PJO::P64 < 4) goto c4PJM; else goto c4PJN;
       c4PJM: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PJN: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.102355231 UTC

[section ""cstring" . lvl15_r4KZ0_bytes" {
     lvl15_r4KZ0_bytes:
         I8[] [115,117,99,99,123,73,79,77,111,100,101,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.104461232 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode6_closure" {
     GHC.IO.IOMode.$fEnumIOMode6_closure:
         const GHC.IO.IOMode.$fEnumIOMode6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode6_entry() //  [R1]
         { info_tbl: [(c4PKv,
                       label: GHC.IO.IOMode.$fEnumIOMode6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PKv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4PKw; else goto c4PKx;
       c4PKw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PKx: // global
           (_c4PKq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PKq::I64 == 0) goto c4PKs; else goto c4PKr;
       c4PKs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PKr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PKq::I64;
           I64[Sp - 24] = block_c4PKt_info;
           R2 = lvl15_r4KZ0_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4PKt() //  [R1]
         { info_tbl: [(c4PKt,
                       label: block_c4PKt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PKt: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.110632152 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$csucc_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$csucc_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$csucc_entry() //  [R2]
         { info_tbl: [(c4PL0,
                       label: GHC.IO.IOMode.$fEnumIOMode_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PL0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4PL1; else goto c4PL2;
       c4PL1: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PL2: // global
           I64[Sp - 8] = block_c4PKR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4PLh; else goto c4PKS;
       u4PLh: // global
           call _c4PKR(R1) args: 0, res: 0, upd: 0;
       c4PKS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PKR() //  [R1]
         { info_tbl: [(c4PKR,
                       label: block_c4PKR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PKR: // global
           _c4PKZ::P64 = R1 & 7;
           if (_c4PKZ::P64 < 3) goto u4PLf; else goto u4PLg;
       u4PLf: // global
           if (_c4PKZ::P64 < 2) goto c4PKV; else goto c4PKW;
       c4PKV: // global
           R1 = GHC.IO.IOMode.WriteMode_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PKW: // global
           R1 = GHC.IO.IOMode.AppendMode_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4PLg: // global
           if (_c4PKZ::P64 < 4) goto c4PKX; else goto c4PKY;
       c4PKX: // global
           R1 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PKY: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.117177788 UTC

[section ""cstring" . lvl16_r4KZ1_bytes" {
     lvl16_r4KZ1_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.119473454 UTC

[section ""cstring" . lvl17_r4KZ2_bytes" {
     lvl17_r4KZ2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.121453344 UTC

[section ""data" . lvl18_r4KZ3_closure" {
     lvl18_r4KZ3_closure:
         const lvl18_r4KZ3_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_r4KZ3_entry() //  [R1]
         { info_tbl: [(c4PLF,
                       label: lvl18_r4KZ3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PLF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PLG; else goto c4PLH;
       c4PLG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PLH: // global
           (_c4PLC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PLC::I64 == 0) goto c4PLE; else goto c4PLD;
       c4PLE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PLD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PLC::I64;
           R2 = lvl17_r4KZ2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.125878325 UTC

[section ""data" . lvl19_r4KZ4_closure" {
     lvl19_r4KZ4_closure:
         const lvl19_r4KZ4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_r4KZ4_entry() //  [R1]
         { info_tbl: [(c4PLZ,
                       label: lvl19_r4KZ4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PLZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4PM0; else goto c4PM1;
       c4PM0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PM1: // global
           (_c4PLT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PLT::I64 == 0) goto c4PLV; else goto c4PLU;
       c4PLV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PLU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PLT::I64;
           I64[Sp - 24] = block_c4PLW_info;
           R4 = lvl18_r4KZ3_closure;
           R3 = 3;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4PLW() //  [R1, R2]
         { info_tbl: [(c4PLW,
                       label: block_c4PLW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PLW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4PM4; else goto c4PM3;
       c4PM4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4PM3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.132336078 UTC

[section ""data" . lvl20_r4KZ5_closure" {
     lvl20_r4KZ5_closure:
         const lvl20_r4KZ5_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_r4KZ5_entry() //  [R1]
         { info_tbl: [(c4PMp,
                       label: lvl20_r4KZ5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PMp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PMq; else goto c4PMr;
       c4PMq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PMr: // global
           (_c4PMm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PMm::I64 == 0) goto c4PMo; else goto c4PMn;
       c4PMo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PMn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PMm::I64;
           R3 = lvl19_r4KZ4_closure;
           R2 = lvl16_r4KZ1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.136394969 UTC

[section ""cstring" . lvl21_r4KZ6_bytes" {
     lvl21_r4KZ6_bytes:
         I8[] [116,111,69,110,117,109,123,73,79,77,111,100,101,125,58,32,116,97,103,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.138690121 UTC

[section ""data" . GHC.IO.IOMode.$wlvl_closure" {
     GHC.IO.IOMode.$wlvl_closure:
         const GHC.IO.IOMode.$wlvl_info;
         const 0;
 },
 sat_s4OS5_entry() //  [R1]
         { info_tbl: [(c4PMM,
                       label: sat_s4OS5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PMM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4PMN; else goto c4PMO;
       c4PMN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PMO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4PMJ_info;
           R4 = lvl20_r4KZ5_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4PMJ() //  [R1, R2]
         { info_tbl: [(c4PMJ,
                       label: block_c4PMJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PMJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4PMR; else goto c4PMQ;
       c4PMR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4PMQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$wlvl_entry() //  [R2]
         { info_tbl: [(c4PMU,
                       label: GHC.IO.IOMode.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PMU: // global
           _s4OS1::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4PMV; else goto c4PMW;
       c4PMW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4PMY; else goto c4PMX;
       c4PMY: // global
           HpAlloc = 24;
           goto c4PMV;
       c4PMV: // global
           R2 = _s4OS1::I64;
           R1 = GHC.IO.IOMode.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PMX: // global
           I64[Hp - 16] = sat_s4OS5_info;
           I64[Hp] = _s4OS1::I64;
           I64[Sp - 8] = block_c4PMS_info;
           R3 = Hp - 16;
           R2 = lvl21_r4KZ6_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4PMS() //  [R1]
         { info_tbl: [(c4PMS,
                       label: block_c4PMS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PMS: // global
           R3 = R1;
           R2 = lvl13_r4KYY_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.14881781 UTC

[section ""data" . GHC.IO.IOMode.$w$ctoEnum_closure" {
     GHC.IO.IOMode.$w$ctoEnum_closure:
         const GHC.IO.IOMode.$w$ctoEnum_info;
         const 0;
 },
 GHC.IO.IOMode.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4PNw,
                       label: GHC.IO.IOMode.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PNw: // global
           _s4OS7::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c4PNE; else goto c4PNv;
       c4PNv: // global
           if (%MO_S_Gt_W64(_s4OS7::I64, 3)) goto c4PNE; else goto c4PNF;
       c4PNE: // global
           R2 = _s4OS7::I64;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4PNF: // global
           R1 = I64[(_s4OS7::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.152996404 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4PNU,
                       label: GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PNU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4PNV; else goto c4PNW;
       c4PNV: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PNW: // global
           I64[Sp - 8] = block_c4PNR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4PO0; else goto c4PNS;
       u4PO0: // global
           call _c4PNR(R1) args: 0, res: 0, upd: 0;
       c4PNS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PNR() //  [R1]
         { info_tbl: [(c4PNR,
                       label: block_c4PNR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PNR: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.IOMode.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.159694403 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode4_closure" {
     GHC.IO.IOMode.$fEnumIOMode4_closure:
         const GHC.IO.IOMode.$fEnumIOMode4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode4_entry() //  [R1]
         { info_tbl: [(c4POh,
                       label: GHC.IO.IOMode.$fEnumIOMode4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4POh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4POi; else goto c4POj;
       c4POi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4POj: // global
           (_c4POe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4POe::I64 == 0) goto c4POg; else goto c4POf;
       c4POg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4POf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4POe::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.164010084 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode3_closure" {
     GHC.IO.IOMode.$fEnumIOMode3_closure:
         const GHC.IO.IOMode.$fEnumIOMode3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode3_entry() //  [R1]
         { info_tbl: [(c4POy,
                       label: GHC.IO.IOMode.$fEnumIOMode3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4POy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4POz; else goto c4POA;
       c4POz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4POA: // global
           (_c4POv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4POv::I64 == 0) goto c4POx; else goto c4POw;
       c4POx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4POw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4POv::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.168785478 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode2_closure" {
     GHC.IO.IOMode.$fEnumIOMode2_closure:
         const GHC.IO.IOMode.$fEnumIOMode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode2_entry() //  [R1]
         { info_tbl: [(c4POP,
                       label: GHC.IO.IOMode.$fEnumIOMode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4POP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4POQ; else goto c4POR;
       c4POQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4POR: // global
           (_c4POM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4POM::I64 == 0) goto c4POO; else goto c4PON;
       c4POO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PON: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4POM::I64;
           R2 = 2;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.173201989 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode1_closure" {
     GHC.IO.IOMode.$fEnumIOMode1_closure:
         const GHC.IO.IOMode.$fEnumIOMode1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode1_entry() //  [R1]
         { info_tbl: [(c4PP6,
                       label: GHC.IO.IOMode.$fEnumIOMode1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PP6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PP7; else goto c4PP8;
       c4PP7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PP8: // global
           (_c4PP3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4PP3::I64 == 0) goto c4PP5; else goto c4PP4;
       c4PP5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4PP4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4PP3::I64;
           R2 = 3;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go4_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.177734605 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4PPu,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PPu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4PPv; else goto c4PPw;
       c4PPv: // global
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PPw: // global
           I64[Sp - 8] = block_c4PPl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4PPL; else goto c4PPm;
       u4PPL: // global
           call _c4PPl(R1) args: 0, res: 0, upd: 0;
       c4PPm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PPl() //  [R1]
         { info_tbl: [(c4PPl,
                       label: block_c4PPl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PPl: // global
           _c4PPt::P64 = R1 & 7;
           if (_c4PPt::P64 < 3) goto u4PPJ; else goto u4PPK;
       u4PPJ: // global
           if (_c4PPt::P64 < 2) goto c4PPp; else goto c4PPq;
       c4PPp: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4PPq: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u4PPK: // global
           if (_c4PPt::P64 < 4) goto c4PPr; else goto c4PPs;
       c4PPr: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4PPs: // global
           R1 = GHC.IO.IOMode.$fEnumIOMode1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.191251554 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_info;
 },
 sat_s4OSw_entry() //  [R1]
         { info_tbl: [(c4PQM,
                       label: sat_s4OSw_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PQM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PQN; else goto c4PQO;
       c4PQN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PQO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4OSr_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSu_entry() //  [R1]
         { info_tbl: [(c4PQT,
                       label: sat_s4OSu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PQT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PQU; else goto c4PQV;
       c4PQU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PQV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSx_entry() //  [R1]
         { info_tbl: [(c4PR1,
                       label: sat_s4OSx_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PR1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PR2; else goto c4PR3;
       c4PR2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PR3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4OSr_entry() //  [R1, R2]
         { info_tbl: [(c4PR7,
                       label: go_dn_s4OSr_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PR7: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4PRb; else goto c4PRa;
       c4PRb: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PRa: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4PR5; else goto c4PR6;
       c4PR5: // global
           _s4OSp::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OSw_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OSp::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OSu_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PR6: // global
           I64[Hp - 80] = sat_s4OSx_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4PRd::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4PRd::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OSy_entry() //  [R1]
         { info_tbl: [(c4PRe,
                       label: sat_s4OSy_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PRe: // global
           _s4OSy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4PRf; else goto c4PRg;
       c4PRg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4PRi; else goto c4PRh;
       c4PRi: // global
           HpAlloc = 24;
           goto c4PRf;
       c4PRf: // global
           R1 = _s4OSy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PRh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OSy::P64;
           _s4OSk::I64 = I64[_s4OSy::P64 + 24];
           _s4OSp::I64 = _s4OSk::I64 - I64[_s4OSy::P64 + 16];
           I64[Hp - 16] = go_dn_s4OSr_info;
           I64[Hp - 8] = _s4OSp::I64;
           I64[Hp] = 3 - _s4OSp::I64;
           R2 = _s4OSk::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4OSr_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSo_entry() //  [R1]
         { info_tbl: [(c4PRn,
                       label: sat_s4OSo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PRn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PRo; else goto c4PRp;
       c4PRo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PRp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSA_entry() //  [R1]
         { info_tbl: [(c4PRy,
                       label: sat_s4OSA_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PRy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PRz; else goto c4PRA;
       c4PRz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PRA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSK_entry() //  [R1]
         { info_tbl: [(c4PS3,
                       label: sat_s4OSK_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PS3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PS4; else goto c4PS5;
       c4PS4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PS5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4OSF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSI_entry() //  [R1]
         { info_tbl: [(c4PSa,
                       label: sat_s4OSI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PSa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PSb; else goto c4PSc;
       c4PSb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PSc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSL_entry() //  [R1]
         { info_tbl: [(c4PSi,
                       label: sat_s4OSL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PSi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PSj; else goto c4PSk;
       c4PSj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PSk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4OSF_entry() //  [R1, R2]
         { info_tbl: [(c4PSo,
                       label: go_up_s4OSF_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PSo: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4PSs; else goto c4PSr;
       c4PSs: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PSr: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4PSm; else goto c4PSn;
       c4PSm: // global
           _s4OSD::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OSK_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OSD::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OSI_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PSn: // global
           I64[Hp - 80] = sat_s4OSL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4PSu::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4PSu::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OSM_entry() //  [R1]
         { info_tbl: [(c4PSv,
                       label: sat_s4OSM_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PSv: // global
           _s4OSM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4PSw; else goto c4PSx;
       c4PSx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4PSz; else goto c4PSy;
       c4PSz: // global
           HpAlloc = 24;
           goto c4PSw;
       c4PSw: // global
           R1 = _s4OSM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PSy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OSM::P64;
           _s4OSk::I64 = I64[_s4OSM::P64 + 24];
           _s4OSD::I64 = _s4OSk::I64 - I64[_s4OSM::P64 + 16];
           I64[Hp - 16] = go_up_s4OSF_info;
           I64[Hp - 8] = _s4OSD::I64;
           I64[Hp] = 3 - _s4OSD::I64;
           R2 = _s4OSk::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4OSF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSC_entry() //  [R1]
         { info_tbl: [(c4PSE,
                       label: sat_s4OSC_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PSE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PSF; else goto c4PSG;
       c4PSF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PSG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSO_entry() //  [R1]
         { info_tbl: [(c4PSP,
                       label: sat_s4OSO_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PSP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PSQ; else goto c4PSR;
       c4PSQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PSR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSZ_entry() //  [R1]
         { info_tbl: [(c4PTn,
                       label: sat_s4OSZ_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PTn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PTo; else goto c4PTp;
       c4PTo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PTp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4OSU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSX_entry() //  [R1]
         { info_tbl: [(c4PTu,
                       label: sat_s4OSX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PTu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PTv; else goto c4PTw;
       c4PTv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PTw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OT0_entry() //  [R1]
         { info_tbl: [(c4PTC,
                       label: sat_s4OT0_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PTC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PTD; else goto c4PTE;
       c4PTD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PTE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4OSU_entry() //  [R1, R2]
         { info_tbl: [(c4PTI,
                       label: go_dn_s4OSU_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PTI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4PTM; else goto c4PTL;
       c4PTM: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PTL: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4PTG; else goto c4PTH;
       c4PTG: // global
           _s4OSS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OSZ_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OSS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OSX_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PTH: // global
           I64[Hp - 80] = sat_s4OT0_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4PTO::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4PTO::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OT1_entry() //  [R1]
         { info_tbl: [(c4PTP,
                       label: sat_s4OT1_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PTP: // global
           _s4OT1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4PTQ; else goto c4PTR;
       c4PTR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4PTT; else goto c4PTS;
       c4PTT: // global
           HpAlloc = 24;
           goto c4PTQ;
       c4PTQ: // global
           R1 = _s4OT1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PTS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OT1::P64;
           _s4OSk::I64 = I64[_s4OT1::P64 + 24];
           _s4OSS::I64 = _s4OSk::I64 - I64[_s4OT1::P64 + 16];
           I64[Hp - 16] = go_dn_s4OSU_info;
           I64[Hp - 8] = _s4OSS::I64;
           I64[Hp] = 0 - _s4OSS::I64;
           R2 = _s4OSk::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4OSU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OSR_entry() //  [R1]
         { info_tbl: [(c4PTY,
                       label: sat_s4OSR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PTY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PTZ; else goto c4PU0;
       c4PTZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PU0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OT3_entry() //  [R1]
         { info_tbl: [(c4PU9,
                       label: sat_s4OT3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PU9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PUa; else goto c4PUb;
       c4PUa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PUb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OTd_entry() //  [R1]
         { info_tbl: [(c4PUE,
                       label: sat_s4OTd_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PUE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PUF; else goto c4PUG;
       c4PUF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PUG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4OT8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OTb_entry() //  [R1]
         { info_tbl: [(c4PUL,
                       label: sat_s4OTb_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PUL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PUM; else goto c4PUN;
       c4PUM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PUN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OTe_entry() //  [R1]
         { info_tbl: [(c4PUT,
                       label: sat_s4OTe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PUT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PUU; else goto c4PUV;
       c4PUU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4OT8_entry() //  [R1, R2]
         { info_tbl: [(c4PUZ,
                       label: go_up_s4OT8_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PUZ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4PV3; else goto c4PV2;
       c4PV3: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4PV2: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4PUX; else goto c4PUY;
       c4PUX: // global
           _s4OT6::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OTd_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OT6::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OTb_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PUY: // global
           I64[Hp - 80] = sat_s4OTe_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4PV5::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4PV5::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OTf_entry() //  [R1]
         { info_tbl: [(c4PV6,
                       label: sat_s4OTf_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PV6: // global
           _s4OTf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4PV7; else goto c4PV8;
       c4PV8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4PVa; else goto c4PV9;
       c4PVa: // global
           HpAlloc = 24;
           goto c4PV7;
       c4PV7: // global
           R1 = _s4OTf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PV9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OTf::P64;
           _s4OSk::I64 = I64[_s4OTf::P64 + 24];
           _s4OT6::I64 = _s4OSk::I64 - I64[_s4OTf::P64 + 16];
           I64[Hp - 16] = go_up_s4OT8_info;
           I64[Hp - 8] = _s4OT6::I64;
           I64[Hp] = 0 - _s4OT6::I64;
           R2 = _s4OSk::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4OT8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OT5_entry() //  [R1]
         { info_tbl: [(c4PVf,
                       label: sat_s4OT5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PVf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PVg; else goto c4PVh;
       c4PVg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PVh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OTh_entry() //  [R1]
         { info_tbl: [(c4PVq,
                       label: sat_s4OTh_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PVq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PVr; else goto c4PVs;
       c4PVr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4PVs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4PVC,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PVC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4PVD; else goto c4PVE;
       c4PVD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4PVE: // global
           I64[Sp - 16] = block_c4PVt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4PX6; else goto c4PVu;
       u4PX6: // global
           call _c4PVt(R1) args: 0, res: 0, upd: 0;
       c4PVu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PVt() //  [R1]
         { info_tbl: [(c4PVt,
                       label: block_c4PVt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PVt: // global
           _s4OSg::P64 = P64[Sp + 8];
           _c4PVB::P64 = R1 & 7;
           if (_c4PVB::P64 < 3) goto u4PWV; else goto u4PWW;
       u4PWV: // global
           if (_c4PVB::P64 < 2) goto c4PVx; else goto c4PVy;
       c4PVx: // global
           _s4OSi::I64 = 0;
           goto s4OSh;
       c4PVy: // global
           _s4OSi::I64 = 1;
           goto s4OSh;
       u4PWW: // global
           if (_c4PVB::P64 < 4) goto c4PVz; else goto c4PVA;
       c4PVz: // global
           _s4OSi::I64 = 2;
           goto s4OSh;
       c4PVA: // global
           _s4OSi::I64 = 3;
           goto s4OSh;
       s4OSh: // global
           I64[Sp] = block_c4PVF_info;
           R1 = _s4OSg::P64;
           I64[Sp + 8] = _s4OSi::I64;
           if (R1 & 7 != 0) goto u4PX5; else goto c4PWp;
       u4PX5: // global
           call _c4PVF(R1) args: 0, res: 0, upd: 0;
       c4PWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4PVF() //  [R1]
         { info_tbl: [(c4PVF,
                       label: block_c4PVF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PVF: // global
           _c4PWU::P64 = R1 & 7;
           if (_c4PWU::P64 < 3) goto u4PWX; else goto u4PWY;
       u4PWX: // global
           if (_c4PWU::P64 < 2) goto c4PWv; else goto c4PWz;
       c4PWv: // global
           I64[Sp] = 0;
           goto u4PXa;
       c4PWz: // global
           I64[Sp] = 1;
           goto u4PXa;
       u4PWY: // global
           if (_c4PWU::P64 < 4) goto c4PWD; else goto c4PWH;
       c4PWD: // global
           I64[Sp] = 2;
           goto u4PXa;
       c4PWH: // global
           I64[Sp] = 3;
           goto u4PXa;
       u4PXa: // global
           call _c4PQd() args: 0, res: 0, upd: 0;
     }
 },
 _c4PQd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PQd: // global
           Hp = Hp + 80;
           _s4OSk::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c4PVJ; else goto c4PVI;
       c4PVJ: // global
           HpAlloc = 80;
           I64[Sp] = block_c4PQc_info;
           R1 = _s4OSk::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4PVI: // global
           _s4OSi::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_s4OSi::I64,
                            _s4OSk::I64)) goto c4PW4; else goto c4PWo;
       c4PW4: // global
           if (%MO_S_Lt_W64(_s4OSk::I64,
                            _s4OSi::I64)) goto c4PVT; else goto c4PW2;
       c4PVT: // global
           if (%MO_S_Le_W64(3, _s4OSk::I64)) goto c4PVM; else goto c4PVR;
       c4PVM: // global
           I64[Hp - 72] = sat_s4OSy_info;
           I64[Hp - 56] = _s4OSi::I64;
           I64[Hp - 48] = _s4OSk::I64;
           I64[Hp - 40] = sat_s4OSo_info;
           I64[Hp - 24] = _s4OSi::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PVR: // global
           if (%MO_S_Gt_W64(3, _s4OSi::I64)) goto c4PWl; else goto c4PVP;
       c4PVP: // global
           I64[Hp - 72] = sat_s4OSA_info;
           I64[Hp - 56] = _s4OSi::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4PVN::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4PVN::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PW2: // global
           if (%MO_S_Ge_W64(3, _s4OSk::I64)) goto c4PVW; else goto c4PW1;
       c4PVW: // global
           I64[Hp - 72] = sat_s4OSM_info;
           I64[Hp - 56] = _s4OSi::I64;
           I64[Hp - 48] = _s4OSk::I64;
           I64[Hp - 40] = sat_s4OSC_info;
           I64[Hp - 24] = _s4OSi::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PW1: // global
           if (%MO_S_Lt_W64(3, _s4OSi::I64)) goto c4PWl; else goto c4PVZ;
       c4PVZ: // global
           I64[Hp - 72] = sat_s4OSO_info;
           I64[Hp - 56] = _s4OSi::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4PVX::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4PVX::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PWo: // global
           if (%MO_S_Lt_W64(_s4OSk::I64,
                            _s4OSi::I64)) goto c4PWe; else goto c4PWn;
       c4PWe: // global
           if (%MO_S_Le_W64(0, _s4OSk::I64)) goto c4PW7; else goto c4PWc;
       c4PW7: // global
           I64[Hp - 72] = sat_s4OT1_info;
           I64[Hp - 56] = _s4OSi::I64;
           I64[Hp - 48] = _s4OSk::I64;
           I64[Hp - 40] = sat_s4OSR_info;
           I64[Hp - 24] = _s4OSi::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PWc: // global
           if (%MO_S_Gt_W64(0, _s4OSi::I64)) goto c4PWl; else goto c4PWa;
       c4PWa: // global
           I64[Hp - 72] = sat_s4OT3_info;
           I64[Hp - 56] = _s4OSi::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4PW8::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4PW8::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PWn: // global
           if (%MO_S_Ge_W64(0, _s4OSk::I64)) goto c4PWh; else goto c4PWm;
       c4PWh: // global
           I64[Hp - 72] = sat_s4OTf_info;
           I64[Hp - 56] = _s4OSi::I64;
           I64[Hp - 48] = _s4OSk::I64;
           I64[Hp - 40] = sat_s4OT5_info;
           I64[Hp - 24] = _s4OSi::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PWm: // global
           if (%MO_S_Lt_W64(0, _s4OSi::I64)) goto c4PWl; else goto c4PWk;
       c4PWl: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4PWk: // global
           I64[Hp - 72] = sat_s4OTh_info;
           I64[Hp - 56] = _s4OSi::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4PWi::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4PWi::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4PQc() //  [R1]
         { info_tbl: [(c4PQc,
                       label: block_c4PQc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4PQc: // global
           I64[Sp] = R1;
           call _c4PQd() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.290936698 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go3_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go3_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go3_info;
         const 0;
 },
 sat_s4OTq_entry() //  [R1]
         { info_tbl: [(c4Q2C,
                       label: sat_s4OTq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q2C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q2D; else goto c4Q2E;
       c4Q2D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q2E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OTo::I64 = I64[R1 + 16];
           if (_s4OTo::I64 != 0) goto c4Q2A; else goto c4Q2B;
       c4Q2A: // global
           R2 = _s4OTo::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go3_entry(R2) args: 24, res: 0, upd: 24;
       c4Q2B: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OTn_entry() //  [R1]
         { info_tbl: [(c4Q2Q,
                       label: sat_s4OTn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q2Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q2R; else goto c4Q2Z;
       c4Q2R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q2Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OTk::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OTk::I64, 0)) goto c4Q2X; else goto c4Q2P;
       c4Q2P: // global
           if (%MO_S_Gt_W64(_s4OTk::I64, 3)) goto c4Q2X; else goto c4Q2Y;
       c4Q2X: // global
           R2 = _s4OTk::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Q2Y: // global
           R1 = I64[(_s4OTk::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go3_entry() //  [R2]
         { info_tbl: [(c4Q31,
                       label: GHC.IO.IOMode.$fEnumIOMode_go3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q31: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Q35; else goto c4Q34;
       c4Q35: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Q34: // global
           I64[Hp - 64] = sat_s4OTq_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OTn_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.300009982 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go2_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go2_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go2_info;
         const 0;
 },
 sat_s4OTx_entry() //  [R1]
         { info_tbl: [(c4Q3H,
                       label: sat_s4OTx_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q3H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q3I; else goto c4Q3J;
       c4Q3I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q3J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OTv::I64 = I64[R1 + 16];
           if (_s4OTv::I64 != 1) goto c4Q3F; else goto c4Q3G;
       c4Q3F: // global
           R2 = _s4OTv::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go2_entry(R2) args: 24, res: 0, upd: 24;
       c4Q3G: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OTu_entry() //  [R1]
         { info_tbl: [(c4Q3V,
                       label: sat_s4OTu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q3V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q3W; else goto c4Q44;
       c4Q3W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q44: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OTr::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OTr::I64, 0)) goto c4Q42; else goto c4Q3U;
       c4Q3U: // global
           if (%MO_S_Gt_W64(_s4OTr::I64, 3)) goto c4Q42; else goto c4Q43;
       c4Q42: // global
           R2 = _s4OTr::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Q43: // global
           R1 = I64[(_s4OTr::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go2_entry() //  [R2]
         { info_tbl: [(c4Q46,
                       label: GHC.IO.IOMode.$fEnumIOMode_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q46: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Q4a; else goto c4Q49;
       c4Q4a: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Q49: // global
           I64[Hp - 64] = sat_s4OTx_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OTu_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.309527008 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go1_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go1_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go1_info;
         const 0;
 },
 sat_s4OTE_entry() //  [R1]
         { info_tbl: [(c4Q4M,
                       label: sat_s4OTE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q4M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q4N; else goto c4Q4O;
       c4Q4N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q4O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OTC::I64 = I64[R1 + 16];
           if (_s4OTC::I64 != 2) goto c4Q4K; else goto c4Q4L;
       c4Q4K: // global
           R2 = _s4OTC::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go1_entry(R2) args: 24, res: 0, upd: 24;
       c4Q4L: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OTB_entry() //  [R1]
         { info_tbl: [(c4Q50,
                       label: sat_s4OTB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q50: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q51; else goto c4Q59;
       c4Q51: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q59: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OTy::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OTy::I64, 0)) goto c4Q57; else goto c4Q4Z;
       c4Q4Z: // global
           if (%MO_S_Gt_W64(_s4OTy::I64, 3)) goto c4Q57; else goto c4Q58;
       c4Q57: // global
           R2 = _s4OTy::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Q58: // global
           R1 = I64[(_s4OTy::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go1_entry() //  [R2]
         { info_tbl: [(c4Q5b,
                       label: GHC.IO.IOMode.$fEnumIOMode_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q5b: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Q5f; else goto c4Q5e;
       c4Q5f: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Q5e: // global
           I64[Hp - 64] = sat_s4OTE_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OTB_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.319370837 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_go_closure" {
     GHC.IO.IOMode.$fEnumIOMode_go_closure:
         const GHC.IO.IOMode.$fEnumIOMode_go_info;
         const 0;
 },
 sat_s4OTL_entry() //  [R1]
         { info_tbl: [(c4Q5R,
                       label: sat_s4OTL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q5R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q5S; else goto c4Q5T;
       c4Q5S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q5T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OTJ::I64 = I64[R1 + 16];
           if (_s4OTJ::I64 != 3) goto c4Q5P; else goto c4Q5Q;
       c4Q5P: // global
           R2 = _s4OTJ::I64 + 1;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$fEnumIOMode_go_entry(R2) args: 24, res: 0, upd: 24;
       c4Q5Q: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OTI_entry() //  [R1]
         { info_tbl: [(c4Q65,
                       label: sat_s4OTI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q65: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q66; else goto c4Q6e;
       c4Q66: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q6e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OTF::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OTF::I64, 0)) goto c4Q6c; else goto c4Q64;
       c4Q64: // global
           if (%MO_S_Gt_W64(_s4OTF::I64, 3)) goto c4Q6c; else goto c4Q6d;
       c4Q6c: // global
           R2 = _s4OTF::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Q6d: // global
           R1 = I64[(_s4OTF::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_go_entry() //  [R2]
         { info_tbl: [(c4Q6g,
                       label: GHC.IO.IOMode.$fEnumIOMode_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q6g: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Q6k; else goto c4Q6j;
       c4Q6k: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Q6j: // global
           I64[Hp - 64] = sat_s4OTL_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OTI_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.328487972 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_info;
         const 0;
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4Q6Z,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q6Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q70; else goto c4Q71;
       c4Q70: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Q71: // global
           I64[Sp - 16] = block_c4Q6Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Q82; else goto c4Q6R;
       u4Q82: // global
           call _c4Q6Q(R1) args: 0, res: 0, upd: 0;
       c4Q6R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Q6Q() //  [R1]
         { info_tbl: [(c4Q6Q,
                       label: block_c4Q6Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q6Q: // global
           _s4OTN::P64 = P64[Sp + 8];
           _c4Q6Y::P64 = R1 & 7;
           if (_c4Q6Y::P64 < 3) goto u4Q7X; else goto u4Q7Y;
       u4Q7X: // global
           if (_c4Q6Y::P64 < 2) goto c4Q6U; else goto c4Q6V;
       c4Q6U: // global
           _s4OTP::I64 = 0;
           goto s4OTO;
       c4Q6V: // global
           _s4OTP::I64 = 1;
           goto s4OTO;
       u4Q7Y: // global
           if (_c4Q6Y::P64 < 4) goto c4Q6W; else goto c4Q6X;
       c4Q6W: // global
           _s4OTP::I64 = 2;
           goto s4OTO;
       c4Q6X: // global
           _s4OTP::I64 = 3;
           goto s4OTO;
       s4OTO: // global
           I64[Sp] = block_c4Q75_info;
           R1 = _s4OTN::P64;
           I64[Sp + 8] = _s4OTP::I64;
           if (R1 & 7 != 0) goto u4Q81; else goto c4Q77;
       u4Q81: // global
           call _c4Q75(R1) args: 0, res: 0, upd: 0;
       c4Q77: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Q75() //  [R1]
         { info_tbl: [(c4Q75,
                       label: block_c4Q75_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q75: // global
           _s4OTP::I64 = I64[Sp + 8];
           _c4Q7W::P64 = R1 & 7;
           if (_c4Q7W::P64 < 3) goto u4Q7Z; else goto u4Q80;
       u4Q7Z: // global
           if (_c4Q7W::P64 < 2) goto c4Q7i; else goto c4Q7r;
       c4Q7i: // global
           if (%MO_S_Gt_W64(_s4OTP::I64, 0)) goto c4Q7I; else goto c4Q7f;
       c4Q7f: // global
           R2 = _s4OTP::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go3_entry(R2) args: 8, res: 0, upd: 8;
       c4Q7r: // global
           if (%MO_S_Gt_W64(_s4OTP::I64, 1)) goto c4Q7I; else goto c4Q7p;
       c4Q7p: // global
           R2 = _s4OTP::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go2_entry(R2) args: 8, res: 0, upd: 8;
       u4Q80: // global
           if (_c4Q7W::P64 < 4) goto c4Q7A; else goto c4Q7J;
       c4Q7A: // global
           if (%MO_S_Gt_W64(_s4OTP::I64, 2)) goto c4Q7I; else goto c4Q7y;
       c4Q7y: // global
           R2 = _s4OTP::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go1_entry(R2) args: 8, res: 0, upd: 8;
       c4Q7J: // global
           if (%MO_S_Gt_W64(_s4OTP::I64, 3)) goto c4Q7I; else goto c4Q7H;
       c4Q7I: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Q7H: // global
           R2 = _s4OTP::I64;
           Sp = Sp + 16;
           call GHC.IO.IOMode.$fEnumIOMode_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.352009496 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure" {
     GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure:
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_info;
         const 0;
 },
 sat_s4OUi_entry() //  [R1]
         { info_tbl: [(c4Q99,
                       label: sat_s4OUi_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q99: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q9a; else goto c4Q9b;
       c4Q9a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q9b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4OUb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUg_entry() //  [R1]
         { info_tbl: [(c4Q9l,
                       label: sat_s4OUg_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q9l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q9m; else goto c4Q9u;
       c4Q9m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q9u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OUc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OUc::I64, 0)) goto c4Q9s; else goto c4Q9k;
       c4Q9k: // global
           if (%MO_S_Gt_W64(_s4OUc::I64, 3)) goto c4Q9s; else goto c4Q9t;
       c4Q9s: // global
           R2 = _s4OUc::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Q9t: // global
           R1 = I64[(_s4OUc::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUl_entry() //  [R1]
         { info_tbl: [(c4Q9F,
                       label: sat_s4OUl_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q9F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Q9G; else goto c4Q9O;
       c4Q9G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Q9O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OUc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OUc::I64, 0)) goto c4Q9M; else goto c4Q9E;
       c4Q9E: // global
           if (%MO_S_Gt_W64(_s4OUc::I64, 3)) goto c4Q9M; else goto c4Q9N;
       c4Q9M: // global
           R2 = _s4OUc::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Q9N: // global
           R1 = I64[(_s4OUc::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4OUb_entry() //  [R1, R2]
         { info_tbl: [(c4Q9S,
                       label: go_dn_s4OUb_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q9S: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Q9W; else goto c4Q9V;
       c4Q9W: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Q9V: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4Q9Q; else goto c4Q9R;
       c4Q9Q: // global
           _s4OU9::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OUi_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OU9::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OUg_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Q9R: // global
           I64[Hp - 80] = sat_s4OUl_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Q9Y::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Q9Y::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OUm_entry() //  [R1]
         { info_tbl: [(c4Q9Z,
                       label: sat_s4OUm_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q9Z: // global
           _s4OUm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qa0; else goto c4Qa1;
       c4Qa1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Qa3; else goto c4Qa2;
       c4Qa3: // global
           HpAlloc = 24;
           goto c4Qa0;
       c4Qa0: // global
           R1 = _s4OUm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qa2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OUm::P64;
           _s4OU2::I64 = I64[_s4OUm::P64 + 24];
           _s4OU9::I64 = _s4OU2::I64 - I64[_s4OUm::P64 + 16];
           I64[Hp - 16] = go_dn_s4OUb_info;
           I64[Hp - 8] = _s4OU9::I64;
           I64[Hp] = 0 - _s4OU9::I64;
           R2 = _s4OU2::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4OUb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OU8_entry() //  [R1]
         { info_tbl: [(c4Qad,
                       label: sat_s4OU8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qad: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qae; else goto c4Qam;
       c4Qae: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qam: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4Qak; else goto c4Qac;
       c4Qac: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4Qak; else goto c4Qal;
       c4Qak: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qal: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUq_entry() //  [R1]
         { info_tbl: [(c4QaA,
                       label: sat_s4OUq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QaA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QaB; else goto c4QaJ;
       c4QaB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QaJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4QaH; else goto c4Qaz;
       c4Qaz: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4QaH; else goto c4QaI;
       c4QaH: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QaI: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUE_entry() //  [R1]
         { info_tbl: [(c4Qbc,
                       label: sat_s4OUE_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qbc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qbd; else goto c4Qbe;
       c4Qbd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qbe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4OUx_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUC_entry() //  [R1]
         { info_tbl: [(c4Qbo,
                       label: sat_s4OUC_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qbo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qbp; else goto c4Qbx;
       c4Qbp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qbx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OUy::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OUy::I64, 0)) goto c4Qbv; else goto c4Qbn;
       c4Qbn: // global
           if (%MO_S_Gt_W64(_s4OUy::I64, 3)) goto c4Qbv; else goto c4Qbw;
       c4Qbv: // global
           R2 = _s4OUy::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qbw: // global
           R1 = I64[(_s4OUy::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUH_entry() //  [R1]
         { info_tbl: [(c4QbI,
                       label: sat_s4OUH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QbI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QbJ; else goto c4QbR;
       c4QbJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QbR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OUy::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OUy::I64, 0)) goto c4QbP; else goto c4QbH;
       c4QbH: // global
           if (%MO_S_Gt_W64(_s4OUy::I64, 3)) goto c4QbP; else goto c4QbQ;
       c4QbP: // global
           R2 = _s4OUy::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QbQ: // global
           R1 = I64[(_s4OUy::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4OUx_entry() //  [R1, R2]
         { info_tbl: [(c4QbV,
                       label: go_up_s4OUx_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QbV: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4QbZ; else goto c4QbY;
       c4QbZ: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4QbY: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4QbT; else goto c4QbU;
       c4QbT: // global
           _s4OUv::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OUE_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OUv::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OUC_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QbU: // global
           I64[Hp - 80] = sat_s4OUH_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Qc1::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Qc1::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OUI_entry() //  [R1]
         { info_tbl: [(c4Qc2,
                       label: sat_s4OUI_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qc2: // global
           _s4OUI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qc3; else goto c4Qc4;
       c4Qc4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Qc6; else goto c4Qc5;
       c4Qc6: // global
           HpAlloc = 24;
           goto c4Qc3;
       c4Qc3: // global
           R1 = _s4OUI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qc5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OUI::P64;
           _s4OU2::I64 = I64[_s4OUI::P64 + 24];
           _s4OUv::I64 = _s4OU2::I64 - I64[_s4OUI::P64 + 16];
           I64[Hp - 16] = go_up_s4OUx_info;
           I64[Hp - 8] = _s4OUv::I64;
           I64[Hp] = 0 - _s4OUv::I64;
           R2 = _s4OU2::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4OUx_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUu_entry() //  [R1]
         { info_tbl: [(c4Qcg,
                       label: sat_s4OUu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qcg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qch; else goto c4Qcp;
       c4Qch: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qcp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4Qcn; else goto c4Qcf;
       c4Qcf: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4Qcn; else goto c4Qco;
       c4Qcn: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qco: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUM_entry() //  [R1]
         { info_tbl: [(c4QcD,
                       label: sat_s4OUM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QcD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QcE; else goto c4QcM;
       c4QcE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QcM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4QcK; else goto c4QcC;
       c4QcC: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4QcK; else goto c4QcL;
       c4QcK: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QcL: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OV1_entry() //  [R1]
         { info_tbl: [(c4Qdj,
                       label: sat_s4OV1_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qdj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qdk; else goto c4Qdl;
       c4Qdk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qdl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4OUU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUZ_entry() //  [R1]
         { info_tbl: [(c4Qdv,
                       label: sat_s4OUZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qdv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qdw; else goto c4QdE;
       c4Qdw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QdE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OUV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OUV::I64, 0)) goto c4QdC; else goto c4Qdu;
       c4Qdu: // global
           if (%MO_S_Gt_W64(_s4OUV::I64, 3)) goto c4QdC; else goto c4QdD;
       c4QdC: // global
           R2 = _s4OUV::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QdD: // global
           R1 = I64[(_s4OUV::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OV4_entry() //  [R1]
         { info_tbl: [(c4QdP,
                       label: sat_s4OV4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QdP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QdQ; else goto c4QdY;
       c4QdQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QdY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OUV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OUV::I64, 0)) goto c4QdW; else goto c4QdO;
       c4QdO: // global
           if (%MO_S_Gt_W64(_s4OUV::I64, 3)) goto c4QdW; else goto c4QdX;
       c4QdW: // global
           R2 = _s4OUV::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QdX: // global
           R1 = I64[(_s4OUV::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4OUU_entry() //  [R1, R2]
         { info_tbl: [(c4Qe2,
                       label: go_dn_s4OUU_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qe2: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Qe6; else goto c4Qe5;
       c4Qe6: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Qe5: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4Qe0; else goto c4Qe1;
       c4Qe0: // global
           _s4OUS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OV1_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OUS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OUZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qe1: // global
           I64[Hp - 80] = sat_s4OV4_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Qe8::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Qe8::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OV5_entry() //  [R1]
         { info_tbl: [(c4Qe9,
                       label: sat_s4OV5_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qe9: // global
           _s4OV5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qea; else goto c4Qeb;
       c4Qeb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Qed; else goto c4Qec;
       c4Qed: // global
           HpAlloc = 24;
           goto c4Qea;
       c4Qea: // global
           R1 = _s4OV5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qec: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OV5::P64;
           _s4OU2::I64 = I64[_s4OV5::P64 + 24];
           _s4OUS::I64 = _s4OU2::I64 - I64[_s4OV5::P64 + 16];
           I64[Hp - 16] = go_dn_s4OUU_info;
           I64[Hp - 8] = _s4OUS::I64;
           I64[Hp] = 1 - _s4OUS::I64;
           R2 = _s4OU2::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4OUU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OUR_entry() //  [R1]
         { info_tbl: [(c4Qen,
                       label: sat_s4OUR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qen: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qeo; else goto c4Qew;
       c4Qeo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qew: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4Qeu; else goto c4Qem;
       c4Qem: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4Qeu; else goto c4Qev;
       c4Qeu: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qev: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OV9_entry() //  [R1]
         { info_tbl: [(c4QeK,
                       label: sat_s4OV9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QeK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QeL; else goto c4QeT;
       c4QeL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QeT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4QeR; else goto c4QeJ;
       c4QeJ: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4QeR; else goto c4QeS;
       c4QeR: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QeS: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVn_entry() //  [R1]
         { info_tbl: [(c4Qfm,
                       label: sat_s4OVn_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qfm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qfn; else goto c4Qfo;
       c4Qfn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qfo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4OVg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVl_entry() //  [R1]
         { info_tbl: [(c4Qfy,
                       label: sat_s4OVl_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qfy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qfz; else goto c4QfH;
       c4Qfz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QfH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OVh::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OVh::I64, 0)) goto c4QfF; else goto c4Qfx;
       c4Qfx: // global
           if (%MO_S_Gt_W64(_s4OVh::I64, 3)) goto c4QfF; else goto c4QfG;
       c4QfF: // global
           R2 = _s4OVh::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QfG: // global
           R1 = I64[(_s4OVh::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVq_entry() //  [R1]
         { info_tbl: [(c4QfS,
                       label: sat_s4OVq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QfS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QfT; else goto c4Qg1;
       c4QfT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qg1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OVh::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OVh::I64, 0)) goto c4QfZ; else goto c4QfR;
       c4QfR: // global
           if (%MO_S_Gt_W64(_s4OVh::I64, 3)) goto c4QfZ; else goto c4Qg0;
       c4QfZ: // global
           R2 = _s4OVh::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qg0: // global
           R1 = I64[(_s4OVh::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4OVg_entry() //  [R1, R2]
         { info_tbl: [(c4Qg5,
                       label: go_up_s4OVg_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qg5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Qg9; else goto c4Qg8;
       c4Qg9: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Qg8: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4Qg3; else goto c4Qg4;
       c4Qg3: // global
           _s4OVe::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OVn_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OVe::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OVl_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qg4: // global
           I64[Hp - 80] = sat_s4OVq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Qgb::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Qgb::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OVr_entry() //  [R1]
         { info_tbl: [(c4Qgc,
                       label: sat_s4OVr_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qgc: // global
           _s4OVr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qgd; else goto c4Qge;
       c4Qge: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Qgg; else goto c4Qgf;
       c4Qgg: // global
           HpAlloc = 24;
           goto c4Qgd;
       c4Qgd: // global
           R1 = _s4OVr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qgf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OVr::P64;
           _s4OU2::I64 = I64[_s4OVr::P64 + 24];
           _s4OVe::I64 = _s4OU2::I64 - I64[_s4OVr::P64 + 16];
           I64[Hp - 16] = go_up_s4OVg_info;
           I64[Hp - 8] = _s4OVe::I64;
           I64[Hp] = 1 - _s4OVe::I64;
           R2 = _s4OU2::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4OVg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVd_entry() //  [R1]
         { info_tbl: [(c4Qgq,
                       label: sat_s4OVd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qgq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qgr; else goto c4Qgz;
       c4Qgr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qgz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4Qgx; else goto c4Qgp;
       c4Qgp: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4Qgx; else goto c4Qgy;
       c4Qgx: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qgy: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVv_entry() //  [R1]
         { info_tbl: [(c4QgN,
                       label: sat_s4OVv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QgN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QgO; else goto c4QgW;
       c4QgO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QgW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4QgU; else goto c4QgM;
       c4QgM: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4QgU; else goto c4QgV;
       c4QgU: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QgV: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVK_entry() //  [R1]
         { info_tbl: [(c4Qht,
                       label: sat_s4OVK_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qhu; else goto c4Qhv;
       c4Qhu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qhv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4OVD_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVI_entry() //  [R1]
         { info_tbl: [(c4QhF,
                       label: sat_s4OVI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QhF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QhG; else goto c4QhO;
       c4QhG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QhO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OVE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OVE::I64, 0)) goto c4QhM; else goto c4QhE;
       c4QhE: // global
           if (%MO_S_Gt_W64(_s4OVE::I64, 3)) goto c4QhM; else goto c4QhN;
       c4QhM: // global
           R2 = _s4OVE::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QhN: // global
           R1 = I64[(_s4OVE::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVN_entry() //  [R1]
         { info_tbl: [(c4QhZ,
                       label: sat_s4OVN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QhZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qi0; else goto c4Qi8;
       c4Qi0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qi8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OVE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OVE::I64, 0)) goto c4Qi6; else goto c4QhY;
       c4QhY: // global
           if (%MO_S_Gt_W64(_s4OVE::I64, 3)) goto c4Qi6; else goto c4Qi7;
       c4Qi6: // global
           R2 = _s4OVE::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qi7: // global
           R1 = I64[(_s4OVE::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4OVD_entry() //  [R1, R2]
         { info_tbl: [(c4Qic,
                       label: go_dn_s4OVD_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qic: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Qig; else goto c4Qif;
       c4Qig: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Qif: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4Qia; else goto c4Qib;
       c4Qia: // global
           _s4OVB::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OVK_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OVB::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OVI_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qib: // global
           I64[Hp - 80] = sat_s4OVN_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Qii::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Qii::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OVO_entry() //  [R1]
         { info_tbl: [(c4Qij,
                       label: sat_s4OVO_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qij: // global
           _s4OVO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qik; else goto c4Qil;
       c4Qil: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Qin; else goto c4Qim;
       c4Qin: // global
           HpAlloc = 24;
           goto c4Qik;
       c4Qik: // global
           R1 = _s4OVO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qim: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OVO::P64;
           _s4OU2::I64 = I64[_s4OVO::P64 + 24];
           _s4OVB::I64 = _s4OU2::I64 - I64[_s4OVO::P64 + 16];
           I64[Hp - 16] = go_dn_s4OVD_info;
           I64[Hp - 8] = _s4OVB::I64;
           I64[Hp] = 2 - _s4OVB::I64;
           R2 = _s4OU2::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4OVD_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVA_entry() //  [R1]
         { info_tbl: [(c4Qix,
                       label: sat_s4OVA_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qix: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qiy; else goto c4QiG;
       c4Qiy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QiG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4QiE; else goto c4Qiw;
       c4Qiw: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4QiE; else goto c4QiF;
       c4QiE: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QiF: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVS_entry() //  [R1]
         { info_tbl: [(c4QiU,
                       label: sat_s4OVS_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QiU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QiV; else goto c4Qj3;
       c4QiV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qj3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4Qj1; else goto c4QiT;
       c4QiT: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4Qj1; else goto c4Qj2;
       c4Qj1: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qj2: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OW6_entry() //  [R1]
         { info_tbl: [(c4Qjw,
                       label: sat_s4OW6_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qjw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qjx; else goto c4Qjy;
       c4Qjx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qjy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4OVZ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OW4_entry() //  [R1]
         { info_tbl: [(c4QjI,
                       label: sat_s4OW4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QjI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QjJ; else goto c4QjR;
       c4QjJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QjR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OW0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OW0::I64, 0)) goto c4QjP; else goto c4QjH;
       c4QjH: // global
           if (%MO_S_Gt_W64(_s4OW0::I64, 3)) goto c4QjP; else goto c4QjQ;
       c4QjP: // global
           R2 = _s4OW0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QjQ: // global
           R1 = I64[(_s4OW0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OW9_entry() //  [R1]
         { info_tbl: [(c4Qk2,
                       label: sat_s4OW9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qk2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qk3; else goto c4Qkb;
       c4Qk3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qkb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OW0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OW0::I64, 0)) goto c4Qk9; else goto c4Qk1;
       c4Qk1: // global
           if (%MO_S_Gt_W64(_s4OW0::I64, 3)) goto c4Qk9; else goto c4Qka;
       c4Qk9: // global
           R2 = _s4OW0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qka: // global
           R1 = I64[(_s4OW0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4OVZ_entry() //  [R1, R2]
         { info_tbl: [(c4Qkf,
                       label: go_up_s4OVZ_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qkf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Qkj; else goto c4Qki;
       c4Qkj: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Qki: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4Qkd; else goto c4Qke;
       c4Qkd: // global
           _s4OVX::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OW6_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OVX::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OW4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qke: // global
           I64[Hp - 80] = sat_s4OW9_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Qkl::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Qkl::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OWa_entry() //  [R1]
         { info_tbl: [(c4Qkm,
                       label: sat_s4OWa_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qkm: // global
           _s4OWa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qkn; else goto c4Qko;
       c4Qko: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Qkq; else goto c4Qkp;
       c4Qkq: // global
           HpAlloc = 24;
           goto c4Qkn;
       c4Qkn: // global
           R1 = _s4OWa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qkp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OWa::P64;
           _s4OU2::I64 = I64[_s4OWa::P64 + 24];
           _s4OVX::I64 = _s4OU2::I64 - I64[_s4OWa::P64 + 16];
           I64[Hp - 16] = go_up_s4OVZ_info;
           I64[Hp - 8] = _s4OVX::I64;
           I64[Hp] = 2 - _s4OVX::I64;
           R2 = _s4OU2::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4OVZ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OVW_entry() //  [R1]
         { info_tbl: [(c4QkA,
                       label: sat_s4OVW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QkA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QkB; else goto c4QkJ;
       c4QkB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QkJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4QkH; else goto c4Qkz;
       c4Qkz: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4QkH; else goto c4QkI;
       c4QkH: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QkI: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWe_entry() //  [R1]
         { info_tbl: [(c4QkX,
                       label: sat_s4OWe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QkX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QkY; else goto c4Ql6;
       c4QkY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ql6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4Ql4; else goto c4QkW;
       c4QkW: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4Ql4; else goto c4Ql5;
       c4Ql4: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Ql5: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWt_entry() //  [R1]
         { info_tbl: [(c4QlD,
                       label: sat_s4OWt_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QlD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QlE; else goto c4QlF;
       c4QlE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QlF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4OWm_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWr_entry() //  [R1]
         { info_tbl: [(c4QlP,
                       label: sat_s4OWr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QlP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QlQ; else goto c4QlY;
       c4QlQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QlY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OWn::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OWn::I64, 0)) goto c4QlW; else goto c4QlO;
       c4QlO: // global
           if (%MO_S_Gt_W64(_s4OWn::I64, 3)) goto c4QlW; else goto c4QlX;
       c4QlW: // global
           R2 = _s4OWn::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QlX: // global
           R1 = I64[(_s4OWn::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWw_entry() //  [R1]
         { info_tbl: [(c4Qm9,
                       label: sat_s4OWw_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qm9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qma; else goto c4Qmi;
       c4Qma: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qmi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OWn::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OWn::I64, 0)) goto c4Qmg; else goto c4Qm8;
       c4Qm8: // global
           if (%MO_S_Gt_W64(_s4OWn::I64, 3)) goto c4Qmg; else goto c4Qmh;
       c4Qmg: // global
           R2 = _s4OWn::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qmh: // global
           R1 = I64[(_s4OWn::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4OWm_entry() //  [R1, R2]
         { info_tbl: [(c4Qmm,
                       label: go_dn_s4OWm_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qmm: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Qmq; else goto c4Qmp;
       c4Qmq: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Qmp: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4Qmk; else goto c4Qml;
       c4Qmk: // global
           _s4OWk::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OWt_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OWk::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OWr_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qml: // global
           I64[Hp - 80] = sat_s4OWw_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Qms::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Qms::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OWx_entry() //  [R1]
         { info_tbl: [(c4Qmt,
                       label: sat_s4OWx_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qmt: // global
           _s4OWx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qmu; else goto c4Qmv;
       c4Qmv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4Qmx; else goto c4Qmw;
       c4Qmx: // global
           HpAlloc = 24;
           goto c4Qmu;
       c4Qmu: // global
           R1 = _s4OWx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qmw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OWx::P64;
           _s4OU2::I64 = I64[_s4OWx::P64 + 24];
           _s4OWk::I64 = _s4OU2::I64 - I64[_s4OWx::P64 + 16];
           I64[Hp - 16] = go_dn_s4OWm_info;
           I64[Hp - 8] = _s4OWk::I64;
           I64[Hp] = 3 - _s4OWk::I64;
           R2 = _s4OU2::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4OWm_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWj_entry() //  [R1]
         { info_tbl: [(c4QmH,
                       label: sat_s4OWj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QmH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QmI; else goto c4QmQ;
       c4QmI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QmQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4QmO; else goto c4QmG;
       c4QmG: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4QmO; else goto c4QmP;
       c4QmO: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QmP: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWB_entry() //  [R1]
         { info_tbl: [(c4Qn4,
                       label: sat_s4OWB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qn4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qn5; else goto c4Qnd;
       c4Qn5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qnd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4Qnb; else goto c4Qn3;
       c4Qn3: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4Qnb; else goto c4Qnc;
       c4Qnb: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qnc: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWP_entry() //  [R1]
         { info_tbl: [(c4QnG,
                       label: sat_s4OWP_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QnG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QnH; else goto c4QnI;
       c4QnH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QnI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4OWI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWN_entry() //  [R1]
         { info_tbl: [(c4QnS,
                       label: sat_s4OWN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QnS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QnT; else goto c4Qo1;
       c4QnT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qo1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OWJ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OWJ::I64, 0)) goto c4QnZ; else goto c4QnR;
       c4QnR: // global
           if (%MO_S_Gt_W64(_s4OWJ::I64, 3)) goto c4QnZ; else goto c4Qo0;
       c4QnZ: // global
           R2 = _s4OWJ::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qo0: // global
           R1 = I64[(_s4OWJ::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWS_entry() //  [R1]
         { info_tbl: [(c4Qoc,
                       label: sat_s4OWS_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qoc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qod; else goto c4Qol;
       c4Qod: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qol: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OWJ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OWJ::I64, 0)) goto c4Qoj; else goto c4Qob;
       c4Qob: // global
           if (%MO_S_Gt_W64(_s4OWJ::I64, 3)) goto c4Qoj; else goto c4Qok;
       c4Qoj: // global
           R2 = _s4OWJ::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qok: // global
           R1 = I64[(_s4OWJ::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4OWI_entry() //  [R1, R2]
         { info_tbl: [(c4Qop,
                       label: go_up_s4OWI_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qop: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4Qot; else goto c4Qos;
       c4Qot: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Qos: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4Qon; else goto c4Qoo;
       c4Qon: // global
           _s4OWG::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4OWP_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4OWG::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4OWN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qoo: // global
           I64[Hp - 80] = sat_s4OWS_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4Qov::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4Qov::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4OWT_entry() //  [R1]
         { info_tbl: [(c4Qow,
                       label: sat_s4OWT_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qow: // global
           _s4OWT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qox; else goto c4Qoy;
       c4Qoy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4QoA; else goto c4Qoz;
       c4QoA: // global
           HpAlloc = 24;
           goto c4Qox;
       c4Qox: // global
           R1 = _s4OWT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qoz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4OWT::P64;
           _s4OU2::I64 = I64[_s4OWT::P64 + 24];
           _s4OWG::I64 = _s4OU2::I64 - I64[_s4OWT::P64 + 16];
           I64[Hp - 16] = go_up_s4OWI_info;
           I64[Hp - 8] = _s4OWG::I64;
           I64[Hp] = 3 - _s4OWG::I64;
           R2 = _s4OU2::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4OWI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWF_entry() //  [R1]
         { info_tbl: [(c4QoK,
                       label: sat_s4OWF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QoK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4QoL; else goto c4QoT;
       c4QoL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4QoT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4QoR; else goto c4QoJ;
       c4QoJ: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4QoR; else goto c4QoS;
       c4QoR: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4QoS: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4OWX_entry() //  [R1]
         { info_tbl: [(c4Qp7,
                       label: sat_s4OWX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qp7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Qp8; else goto c4Qpg;
       c4Qp8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Qpg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4OU0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_s4OU0::I64, 0)) goto c4Qpe; else goto c4Qp6;
       c4Qp6: // global
           if (%MO_S_Gt_W64(_s4OU0::I64, 3)) goto c4Qpe; else goto c4Qpf;
       c4Qpe: // global
           R2 = _s4OU0::I64;
           Sp = Sp - 16;
           call GHC.IO.IOMode.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4Qpf: // global
           R1 = I64[(_s4OU0::I64 << 3) + GHC.IO.IOMode.IOMode_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c4Qpq,
                       label: GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qpq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Qpr; else goto c4Qps;
       c4Qpr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Qps: // global
           I64[Sp - 24] = block_c4Qph_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4QrF; else goto c4Qpi;
       u4QrF: // global
           call _c4Qph(R1) args: 0, res: 0, upd: 0;
       c4Qpi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Qph() //  [R1]
         { info_tbl: [(c4Qph,
                       label: block_c4Qph_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qph: // global
           _s4OTX::P64 = P64[Sp + 8];
           _c4Qpp::P64 = R1 & 7;
           if (_c4Qpp::P64 < 3) goto u4QrA; else goto u4QrB;
       u4QrA: // global
           if (_c4Qpp::P64 < 2) goto c4Qpl; else goto c4Qpm;
       c4Qpl: // global
           _s4OU0::I64 = 0;
           goto s4OTZ;
       c4Qpm: // global
           _s4OU0::I64 = 1;
           goto s4OTZ;
       u4QrB: // global
           if (_c4Qpp::P64 < 4) goto c4Qpn; else goto c4Qpo;
       c4Qpn: // global
           _s4OU0::I64 = 2;
           goto s4OTZ;
       c4Qpo: // global
           _s4OU0::I64 = 3;
           goto s4OTZ;
       s4OTZ: // global
           I64[Sp] = block_c4Qpt_info;
           R1 = _s4OTX::P64;
           I64[Sp + 8] = _s4OU0::I64;
           if (R1 & 7 != 0) goto u4QrE; else goto c4Qr1;
       u4QrE: // global
           call _c4Qpt(R1) args: 0, res: 0, upd: 0;
       c4Qr1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Qpt() //  [R1]
         { info_tbl: [(c4Qpt,
                       label: block_c4Qpt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Qpt: // global
           _s4OTY::P64 = P64[Sp + 16];
           _c4Qrw::P64 = R1 & 7;
           if (_c4Qrw::P64 < 3) goto u4QrC; else goto u4QrD;
       u4QrC: // global
           if (_c4Qrw::P64 < 2) goto c4Qr7; else goto c4Qrb;
       c4Qr7: // global
           _s4OU2::I64 = 0;
           goto s4OU1;
       c4Qrb: // global
           _s4OU2::I64 = 1;
           goto s4OU1;
       u4QrD: // global
           if (_c4Qrw::P64 < 4) goto c4Qrf; else goto c4Qrj;
       c4Qrf: // global
           _s4OU2::I64 = 2;
           goto s4OU1;
       c4Qrj: // global
           _s4OU2::I64 = 3;
           goto s4OU1;
       s4OU1: // global
           I64[Sp] = block_c4Q8A_info;
           R1 = _s4OTY::P64;
           I64[Sp + 16] = _s4OU2::I64;
           if (R1 & 7 != 0) goto u4QrG; else goto c4Q8B;
       u4QrG: // global
           call _c4Q8A(R1) args: 0, res: 0, upd: 0;
       c4Q8B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Q8A() //  [R1]
         { info_tbl: [(c4Q8A,
                       label: block_c4Q8A_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Q8A: // global
           _s4OU0::I64 = I64[Sp + 8];
           _s4OU2::I64 = I64[Sp + 16];
           _c4Qrx::P64 = R1 & 7;
           if (_c4Qrx::P64 < 3) goto u4Qry; else goto u4Qrz;
       u4Qry: // global
           if (_c4Qrx::P64 < 2) goto c4Qpx; else goto c4QpU;
       c4Qpx: // global
           Hp = Hp + 80;
           _s4OU3::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4QqH; else goto c4Qpz;
       c4Qpz: // global
           if (%MO_S_Lt_W64(_s4OU2::I64,
                            _s4OU0::I64)) goto c4QpK; else goto c4QpT;
       c4QpK: // global
           if (%MO_S_Le_W64(0, _s4OU2::I64)) goto c4QpD; else goto c4QpI;
       c4QpD: // global
           I64[Hp - 72] = sat_s4OUm_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = _s4OU2::I64;
           I64[Hp - 40] = sat_s4OU8_info;
           I64[Hp - 24] = _s4OU0::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QpI: // global
           if (%MO_S_Gt_W64(0, _s4OU0::I64)) goto c4QqY; else goto c4QpG;
       c4QpG: // global
           I64[Hp - 72] = sat_s4OUq_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4QpE::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4QpE::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QpT: // global
           if (%MO_S_Ge_W64(0, _s4OU2::I64)) goto c4QpN; else goto c4QpS;
       c4QpN: // global
           I64[Hp - 72] = sat_s4OUI_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = _s4OU2::I64;
           I64[Hp - 40] = sat_s4OUu_info;
           I64[Hp - 24] = _s4OU0::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QpS: // global
           if (%MO_S_Lt_W64(0, _s4OU0::I64)) goto c4QqY; else goto c4QpQ;
       c4QpQ: // global
           I64[Hp - 72] = sat_s4OUM_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4QpO::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4QpO::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QpU: // global
           Hp = Hp + 80;
           _s4OU3::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4QqH; else goto c4QpW;
       c4QpW: // global
           if (%MO_S_Lt_W64(_s4OU2::I64,
                            _s4OU0::I64)) goto c4Qq7; else goto c4Qqg;
       c4Qq7: // global
           if (%MO_S_Le_W64(1, _s4OU2::I64)) goto c4Qq0; else goto c4Qq5;
       c4Qq0: // global
           I64[Hp - 72] = sat_s4OV5_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = _s4OU2::I64;
           I64[Hp - 40] = sat_s4OUR_info;
           I64[Hp - 24] = _s4OU0::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qq5: // global
           if (%MO_S_Gt_W64(1, _s4OU0::I64)) goto c4QqY; else goto c4Qq3;
       c4Qq3: // global
           I64[Hp - 72] = sat_s4OV9_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Qq1::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Qq1::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qqg: // global
           if (%MO_S_Ge_W64(1, _s4OU2::I64)) goto c4Qqa; else goto c4Qqf;
       c4Qqa: // global
           I64[Hp - 72] = sat_s4OVr_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = _s4OU2::I64;
           I64[Hp - 40] = sat_s4OVd_info;
           I64[Hp - 24] = _s4OU0::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qqf: // global
           if (%MO_S_Lt_W64(1, _s4OU0::I64)) goto c4QqY; else goto c4Qqd;
       c4Qqd: // global
           I64[Hp - 72] = sat_s4OVv_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Qqb::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Qqb::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u4Qrz: // global
           if (_c4Qrx::P64 < 4) goto c4Qqh; else goto c4QqE;
       c4Qqh: // global
           Hp = Hp + 80;
           _s4OU3::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4QqH; else goto c4Qqj;
       c4Qqj: // global
           if (%MO_S_Lt_W64(_s4OU2::I64,
                            _s4OU0::I64)) goto c4Qqu; else goto c4QqD;
       c4Qqu: // global
           if (%MO_S_Le_W64(2, _s4OU2::I64)) goto c4Qqn; else goto c4Qqs;
       c4Qqn: // global
           I64[Hp - 72] = sat_s4OVO_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = _s4OU2::I64;
           I64[Hp - 40] = sat_s4OVA_info;
           I64[Hp - 24] = _s4OU0::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qqs: // global
           if (%MO_S_Gt_W64(2, _s4OU0::I64)) goto c4QqY; else goto c4Qqq;
       c4Qqq: // global
           I64[Hp - 72] = sat_s4OVS_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Qqo::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Qqo::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QqD: // global
           if (%MO_S_Ge_W64(2, _s4OU2::I64)) goto c4Qqx; else goto c4QqC;
       c4Qqx: // global
           I64[Hp - 72] = sat_s4OWa_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = _s4OU2::I64;
           I64[Hp - 40] = sat_s4OVW_info;
           I64[Hp - 24] = _s4OU0::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QqC: // global
           if (%MO_S_Lt_W64(2, _s4OU0::I64)) goto c4QqY; else goto c4QqA;
       c4QqA: // global
           I64[Hp - 72] = sat_s4OWe_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4Qqy::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4Qqy::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QqE: // global
           Hp = Hp + 80;
           _s4OU3::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c4QqH; else goto c4QqG;
       c4QqH: // global
           HpAlloc = 80;
           R1 = _s4OU3::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4QqG: // global
           if (%MO_S_Lt_W64(_s4OU2::I64,
                            _s4OU0::I64)) goto c4QqR; else goto c4Qr0;
       c4QqR: // global
           if (%MO_S_Le_W64(3, _s4OU2::I64)) goto c4QqK; else goto c4QqP;
       c4QqK: // global
           I64[Hp - 72] = sat_s4OWx_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = _s4OU2::I64;
           I64[Hp - 40] = sat_s4OWj_info;
           I64[Hp - 24] = _s4OU0::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QqP: // global
           if (%MO_S_Gt_W64(3, _s4OU0::I64)) goto c4QqY; else goto c4QqN;
       c4QqN: // global
           I64[Hp - 72] = sat_s4OWB_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4QqL::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4QqL::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Qr0: // global
           if (%MO_S_Ge_W64(3, _s4OU2::I64)) goto c4QqU; else goto c4QqZ;
       c4QqU: // global
           I64[Hp - 72] = sat_s4OWT_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = _s4OU2::I64;
           I64[Hp - 40] = sat_s4OWF_info;
           I64[Hp - 24] = _s4OU0::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QqZ: // global
           if (%MO_S_Lt_W64(3, _s4OU0::I64)) goto c4QqY; else goto c4QqX;
       c4QqY: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4QqX: // global
           I64[Hp - 72] = sat_s4OWX_info;
           I64[Hp - 56] = _s4OU0::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c4QqV::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c4QqV::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.530301254 UTC

[section ""data" . GHC.IO.IOMode.$fEnumIOMode_closure" {
     GHC.IO.IOMode.$fEnumIOMode_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cfromEnum_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure+1;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThen_closure+2;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure+2;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.532214486 UTC

[section ""data" . GHC.IO.IOMode.$trModule3_closure" {
     GHC.IO.IOMode.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.534077709 UTC

[section ""data" . GHC.IO.IOMode.$trModule1_closure" {
     GHC.IO.IOMode.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.536529036 UTC

[section ""data" . GHC.IO.IOMode.$trModule_closure" {
     GHC.IO.IOMode.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.IOMode.$trModule3_closure+1;
         const GHC.IO.IOMode.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.538398463 UTC

[section ""cstring" . GHC.IO.IOMode.$tcIOMode2_bytes" {
     GHC.IO.IOMode.$tcIOMode2_bytes:
         I8[] [73,79,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.540128276 UTC

[section ""data" . GHC.IO.IOMode.$tcIOMode1_closure" {
     GHC.IO.IOMode.$tcIOMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tcIOMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.542476553 UTC

[section ""data" . GHC.IO.IOMode.$tcIOMode_closure" {
     GHC.IO.IOMode.$tcIOMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tcIOMode1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9818555080744742578;
         const 14348064797489060312;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.544432177 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode1_closure" {
     GHC.IO.IOMode.$tc'AppendMode1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.IOMode.$tcIOMode_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.546277151 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'ReadMode2_bytes" {
     GHC.IO.IOMode.$tc'ReadMode2_bytes:
         I8[] [39,82,101,97,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.548084468 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadMode1_closure" {
     GHC.IO.IOMode.$tc'ReadMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'ReadMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.550036443 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadMode_closure" {
     GHC.IO.IOMode.$tc'ReadMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'ReadMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 17697021977009842408;
         const 16081808542294250782;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.551952086 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'WriteMode2_bytes" {
     GHC.IO.IOMode.$tc'WriteMode2_bytes:
         I8[] [39,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.553787955 UTC

[section ""data" . GHC.IO.IOMode.$tc'WriteMode1_closure" {
     GHC.IO.IOMode.$tc'WriteMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'WriteMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.555476007 UTC

[section ""data" . GHC.IO.IOMode.$tc'WriteMode_closure" {
     GHC.IO.IOMode.$tc'WriteMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'WriteMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 16610458722029011495;
         const 11554819901902375488;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.55735649 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'AppendMode3_bytes" {
     GHC.IO.IOMode.$tc'AppendMode3_bytes:
         I8[] [39,65,112,112,101,110,100,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.559192271 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode2_closure" {
     GHC.IO.IOMode.$tc'AppendMode2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'AppendMode3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.561074894 UTC

[section ""data" . GHC.IO.IOMode.$tc'AppendMode_closure" {
     GHC.IO.IOMode.$tc'AppendMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode2_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 3610623883618650464;
         const 11131639874085434472;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.56416684 UTC

[section ""cstring" . GHC.IO.IOMode.$tc'ReadWriteMode2_bytes" {
     GHC.IO.IOMode.$tc'ReadWriteMode2_bytes:
         I8[] [39,82,101,97,100,87,114,105,116,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.566777161 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadWriteMode1_closure" {
     GHC.IO.IOMode.$tc'ReadWriteMode1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.IOMode.$tc'ReadWriteMode2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.57010084 UTC

[section ""data" . GHC.IO.IOMode.$tc'ReadWriteMode_closure" {
     GHC.IO.IOMode.$tc'ReadWriteMode_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.IOMode.$trModule_closure+1;
         const GHC.IO.IOMode.$tc'ReadWriteMode1_closure+1;
         const GHC.IO.IOMode.$tc'AppendMode1_closure+1;
         const 626157189396725199;
         const 9407417215311302278;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.57229674 UTC

[section ""data" . GHC.IO.IOMode.ReadMode_closure" {
     GHC.IO.IOMode.ReadMode_closure:
         const GHC.IO.IOMode.ReadMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.574110727 UTC

[section ""data" . GHC.IO.IOMode.WriteMode_closure" {
     GHC.IO.IOMode.WriteMode_closure:
         const GHC.IO.IOMode.WriteMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.575850817 UTC

[section ""data" . GHC.IO.IOMode.AppendMode_closure" {
     GHC.IO.IOMode.AppendMode_closure:
         const GHC.IO.IOMode.AppendMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.577627328 UTC

[section ""data" . GHC.IO.IOMode.ReadWriteMode_closure" {
     GHC.IO.IOMode.ReadWriteMode_closure:
         const GHC.IO.IOMode.ReadWriteMode_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.57938785 UTC

[section ""relreadonly" . GHC.IO.IOMode.IOMode_closure_tbl" {
     GHC.IO.IOMode.IOMode_closure_tbl:
         const GHC.IO.IOMode.ReadMode_closure+1;
         const GHC.IO.IOMode.WriteMode_closure+2;
         const GHC.IO.IOMode.AppendMode_closure+3;
         const GHC.IO.IOMode.ReadWriteMode_closure+4;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.581351639 UTC

[GHC.IO.IOMode.ReadMode_con_entry() //  [R1]
         { info_tbl: [(c4QCb,
                       label: GHC.IO.IOMode.ReadMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,82,101,97,100,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QCb: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.584763536 UTC

[GHC.IO.IOMode.WriteMode_con_entry() //  [R1]
         { info_tbl: [(c4QCi,
                       label: GHC.IO.IOMode.WriteMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,87,114,105,116,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QCi: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.589003368 UTC

[GHC.IO.IOMode.AppendMode_con_entry() //  [R1]
         { info_tbl: [(c4QCp,
                       label: GHC.IO.IOMode.AppendMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,65,112,112,101,110,100,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QCp: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.592494154 UTC

[GHC.IO.IOMode.ReadWriteMode_con_entry() //  [R1]
         { info_tbl: [(c4QCw,
                       label: GHC.IO.IOMode.ReadWriteMode_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,73,79,77,111,100,101,46,82,101,97,100,87,114,105,116,101,77,111,100,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4QCw: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:45.596371298 UTC

[section ""relreadonly" . S4OYF_srt" {
     S4OYF_srt:
         const GHC.IO.IOMode.$fReadIOMode8_closure;
         const GHC.IO.IOMode.$fReadIOMode12_closure;
         const GHC.IO.IOMode.$fReadIOMode16_closure;
         const GHC.IO.IOMode.$fReadIOMode20_closure;
         const GHC.IO.IOMode.$w$cshowsPrec_closure;
         const GHC.IO.IOMode.$fShowIOMode_$cshow_closure;
         const GHC.Read.choose2_closure;
         const GHC.IO.IOMode.$fReadIOMode_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.IO.IOMode.$fReadIOMode2_closure;
         const GHC.IO.IOMode.$fReadIOMode_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.IO.IOMode.$fReadIOMode1_closure;
         const GHC.IO.IOMode.$fReadIOMode_$creadListPrec_closure;
         const GHC.IO.IOMode.$fReadIOMode22_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.IO.IOMode.$fIxIOMode_$cindex_closure;
         const GHC.Err.error_closure;
         const lvl13_r4KYY_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cpred_closure;
         const GHC.IO.IOMode.$fEnumIOMode5_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$csucc_closure;
         const GHC.IO.IOMode.$fEnumIOMode6_closure;
         const lvl18_r4KZ3_closure;
         const lvl19_r4KZ4_closure;
         const lvl20_r4KZ5_closure;
         const GHC.IO.IOMode.$wlvl_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$ctoEnum_closure;
         const GHC.IO.IOMode.$w$ctoEnum_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFrom_closure;
         const GHC.IO.IOMode.$fEnumIOMode1_closure;
         const GHC.IO.IOMode.$fEnumIOMode2_closure;
         const GHC.IO.IOMode.$fEnumIOMode3_closure;
         const GHC.IO.IOMode.$fEnumIOMode4_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go3_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go2_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go1_closure;
         const GHC.IO.IOMode.$fEnumIOMode_go_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromTo_closure;
         const GHC.IO.IOMode.$fEnumIOMode_$cenumFromThenTo_closure;
 }]

