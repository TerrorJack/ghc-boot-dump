
==================== Output Cmm ====================
2018-03-16 16:02:55.203828184 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:55.205455985 UTC

[section ""data" . GHC.IO.Buffer.$WBuffer_closure" {
     GHC.IO.Buffer.$WBuffer_closure:
         const GHC.IO.Buffer.$WBuffer_info;
 },
 GHC.IO.Buffer.$WBuffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7OQy,
                       label: GHC.IO.Buffer.$WBuffer_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OQy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7OQR; else goto c7OQS;
       c7OQR: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$WBuffer_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7OQS: // global
           I64[Sp - 40] = block_c7OQv_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7OR0; else goto c7OQw;
       u7OR0: // global
           call _c7OQv(R1) args: 0, res: 0, upd: 0;
       c7OQw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OQv() //  [R1]
         { info_tbl: [(c7OQv,
                       label: block_c7OQv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OQv: // global
           I64[Sp - 8] = block_c7OQB_info;
           _s7OK5::P64 = P64[R1 + 7];
           _s7OK4::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s7OK5::P64;
           I64[Sp + 16] = _s7OK4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OQZ; else goto c7OQC;
       u7OQZ: // global
           call _c7OQB(R1) args: 0, res: 0, upd: 0;
       c7OQC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OQB() //  [R1]
         { info_tbl: [(c7OQB,
                       label: block_c7OQB_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OQB: // global
           I64[Sp] = block_c7OQG_info;
           _s7OK7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _s7OK7::I64;
           if (R1 & 7 != 0) goto u7OR1; else goto c7OQH;
       u7OR1: // global
           call _c7OQG(R1) args: 0, res: 0, upd: 0;
       c7OQH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OQG() //  [R1]
         { info_tbl: [(c7OQG,
                       label: block_c7OQG_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OQG: // global
           I64[Sp] = block_c7OQL_info;
           _s7OK9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _s7OK9::I64;
           if (R1 & 7 != 0) goto u7OR2; else goto c7OQM;
       u7OR2: // global
           call _c7OQL(R1) args: 0, res: 0, upd: 0;
       c7OQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OQL() //  [R1]
         { info_tbl: [(c7OQL,
                       label: block_c7OQL_info
                       rep:StackRep [False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OQL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7OQY; else goto c7OQX;
       c7OQY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7OQX: // global
           _s7OKb::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s7OKb::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.208163664 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_$c==_closure" {
     GHC.IO.Buffer.$fEqBufferState_$c==_closure:
         const GHC.IO.Buffer.$fEqBufferState_$c==_info;
 },
 GHC.IO.Buffer.$fEqBufferState_$c==_entry() //  [R2, R3]
         { info_tbl: [(c7ORe,
                       label: GHC.IO.Buffer.$fEqBufferState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ORe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ORf; else goto c7ORg;
       c7ORf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$fEqBufferState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ORg: // global
           I64[Sp - 16] = block_c7OR7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7ORT; else goto c7OR8;
       u7ORT: // global
           call _c7OR7(R1) args: 0, res: 0, upd: 0;
       c7OR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OR7() //  [R1]
         { info_tbl: [(c7OR7,
                       label: block_c7OR7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OR7: // global
           _s7OKd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7ORb; else goto c7ORc;
       c7ORb: // global
           I64[Sp + 8] = block_c7ORj_info;
           R1 = _s7OKd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7ORR; else goto c7ORl;
       u7ORR: // global
           call _c7ORj(R1) args: 0, res: 0, upd: 0;
       c7ORl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7ORc: // global
           I64[Sp + 8] = block_c7ORy_info;
           R1 = _s7OKd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7ORS; else goto c7ORA;
       u7ORS: // global
           call _c7ORy(R1) args: 0, res: 0, upd: 0;
       c7ORA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ORj() //  [R1]
         { info_tbl: [(c7ORj,
                       label: block_c7ORj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ORj: // global
           if (R1 & 7 == 1) goto u7ORP; else goto u7ORQ;
       u7ORP: // global
           Sp = Sp + 8;
           call _c7ORK() args: 0, res: 0, upd: 0;
       u7ORQ: // global
           Sp = Sp + 8;
           call _c7ORG() args: 0, res: 0, upd: 0;
     }
 },
 _c7ORy() //  [R1]
         { info_tbl: [(c7ORy,
                       label: block_c7ORy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ORy: // global
           if (R1 & 7 == 1) goto u7ORN; else goto u7ORO;
       u7ORN: // global
           Sp = Sp + 8;
           call _c7ORG() args: 0, res: 0, upd: 0;
       u7ORO: // global
           Sp = Sp + 8;
           call _c7ORK() args: 0, res: 0, upd: 0;
     }
 },
 _c7ORG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ORG: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ORK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ORK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.210556497 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_$c/=_closure" {
     GHC.IO.Buffer.$fEqBufferState_$c/=_closure:
         const GHC.IO.Buffer.$fEqBufferState_$c/=_info;
 },
 GHC.IO.Buffer.$fEqBufferState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c7OS9,
                       label: GHC.IO.Buffer.$fEqBufferState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OS9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7OSa; else goto c7OSb;
       c7OSa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$fEqBufferState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7OSb: // global
           I64[Sp - 16] = block_c7OS2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7OSO; else goto c7OS3;
       u7OSO: // global
           call _c7OS2(R1) args: 0, res: 0, upd: 0;
       c7OS3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OS2() //  [R1]
         { info_tbl: [(c7OS2,
                       label: block_c7OS2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OS2: // global
           _s7OKi::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7OS6; else goto c7OS7;
       c7OS6: // global
           I64[Sp + 8] = block_c7OSe_info;
           R1 = _s7OKi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7OSM; else goto c7OSg;
       u7OSM: // global
           call _c7OSe(R1) args: 0, res: 0, upd: 0;
       c7OSg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7OS7: // global
           I64[Sp + 8] = block_c7OSt_info;
           R1 = _s7OKi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7OSN; else goto c7OSv;
       u7OSN: // global
           call _c7OSt(R1) args: 0, res: 0, upd: 0;
       c7OSv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OSe() //  [R1]
         { info_tbl: [(c7OSe,
                       label: block_c7OSe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OSe: // global
           if (R1 & 7 == 1) goto u7OSK; else goto u7OSL;
       u7OSK: // global
           Sp = Sp + 8;
           call _c7OSF() args: 0, res: 0, upd: 0;
       u7OSL: // global
           Sp = Sp + 8;
           call _c7OSB() args: 0, res: 0, upd: 0;
     }
 },
 _c7OSt() //  [R1]
         { info_tbl: [(c7OSt,
                       label: block_c7OSt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OSt: // global
           if (R1 & 7 == 1) goto u7OSI; else goto u7OSJ;
       u7OSI: // global
           Sp = Sp + 8;
           call _c7OSB() args: 0, res: 0, upd: 0;
       u7OSJ: // global
           Sp = Sp + 8;
           call _c7OSF() args: 0, res: 0, upd: 0;
     }
 },
 _c7OSB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OSB: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7OSF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OSF: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.212341484 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_closure" {
     GHC.IO.Buffer.$fEqBufferState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Buffer.$fEqBufferState_$c==_closure+2;
         const GHC.IO.Buffer.$fEqBufferState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.213333667 UTC

[section ""data" . GHC.IO.Buffer.bufR_closure" {
     GHC.IO.Buffer.bufR_closure:
         const GHC.IO.Buffer.bufR_info;
 },
 GHC.IO.Buffer.bufR_entry() //  [R2]
         { info_tbl: [(c7OT0,
                       label: GHC.IO.Buffer.bufR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OT0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OT4; else goto c7OT5;
       c7OT4: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OT5: // global
           I64[Sp - 8] = block_c7OSX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OT9; else goto c7OSY;
       u7OT9: // global
           call _c7OSX(R1) args: 0, res: 0, upd: 0;
       c7OSY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OSX() //  [R1]
         { info_tbl: [(c7OSX,
                       label: block_c7OSX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OSX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7OT8; else goto c7OT7;
       c7OT8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7OT7: // global
           _s7OKt::I64 = I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OKt::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.214770009 UTC

[section ""data" . GHC.IO.Buffer.bufL_closure" {
     GHC.IO.Buffer.bufL_closure:
         const GHC.IO.Buffer.bufL_info;
 },
 GHC.IO.Buffer.bufL_entry() //  [R2]
         { info_tbl: [(c7OTh,
                       label: GHC.IO.Buffer.bufL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OTh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OTl; else goto c7OTm;
       c7OTl: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OTm: // global
           I64[Sp - 8] = block_c7OTe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OTq; else goto c7OTf;
       u7OTq: // global
           call _c7OTe(R1) args: 0, res: 0, upd: 0;
       c7OTf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OTe() //  [R1]
         { info_tbl: [(c7OTe,
                       label: block_c7OTe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OTe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7OTp; else goto c7OTo;
       c7OTp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7OTo: // global
           _s7OKA::I64 = I64[R1 + 39];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OKA::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.216227057 UTC

[section ""data" . GHC.IO.Buffer.bufSize_closure" {
     GHC.IO.Buffer.bufSize_closure:
         const GHC.IO.Buffer.bufSize_info;
 },
 GHC.IO.Buffer.bufSize_entry() //  [R2]
         { info_tbl: [(c7OTy,
                       label: GHC.IO.Buffer.bufSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OTy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OTC; else goto c7OTD;
       c7OTC: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OTD: // global
           I64[Sp - 8] = block_c7OTv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OTH; else goto c7OTw;
       u7OTH: // global
           call _c7OTv(R1) args: 0, res: 0, upd: 0;
       c7OTw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OTv() //  [R1]
         { info_tbl: [(c7OTv,
                       label: block_c7OTv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OTv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7OTG; else goto c7OTF;
       c7OTG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7OTF: // global
           _s7OKH::I64 = I64[R1 + 31];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OKH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.217678423 UTC

[section ""data" . GHC.IO.Buffer.bufState_closure" {
     GHC.IO.Buffer.bufState_closure:
         const GHC.IO.Buffer.bufState_info;
 },
 GHC.IO.Buffer.bufState_entry() //  [R2]
         { info_tbl: [(c7OTP,
                       label: GHC.IO.Buffer.bufState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OTP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OTQ; else goto c7OTR;
       c7OTQ: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OTR: // global
           I64[Sp - 8] = block_c7OTM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OTV; else goto c7OTN;
       u7OTV: // global
           call _c7OTM(R1) args: 0, res: 0, upd: 0;
       c7OTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OTM() //  [R1]
         { info_tbl: [(c7OTM,
                       label: block_c7OTM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OTM: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.219015564 UTC

[section ""data" . GHC.IO.Buffer.bufRaw_closure" {
     GHC.IO.Buffer.bufRaw_closure:
         const GHC.IO.Buffer.bufRaw_info;
 },
 GHC.IO.Buffer.bufRaw_entry() //  [R2]
         { info_tbl: [(c7OU3,
                       label: GHC.IO.Buffer.bufRaw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OU3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OU7; else goto c7OU8;
       c7OU7: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufRaw_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OU8: // global
           I64[Sp - 8] = block_c7OU0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OUc; else goto c7OU1;
       u7OUc: // global
           call _c7OU0(R1) args: 0, res: 0, upd: 0;
       c7OU1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OU0() //  [R1]
         { info_tbl: [(c7OU0,
                       label: block_c7OU0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OU0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7OUb; else goto c7OUa;
       c7OUb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7OUa: // global
           _s7OKV::P64 = P64[R1 + 7];
           _s7OKU::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = _s7OKV::P64;
           I64[Hp] = _s7OKU::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.220271907 UTC

[section ""data" . GHC.IO.Buffer.charSize_closure" {
     GHC.IO.Buffer.charSize_closure:
         const GHC.Types.I#_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.221499671 UTC

[section ""data" . GHC.IO.Buffer.withBuffer1_closure" {
     GHC.IO.Buffer.withBuffer1_closure:
         const GHC.IO.Buffer.withBuffer1_info;
 },
 GHC.IO.Buffer.withBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7OUk,
                       label: GHC.IO.Buffer.withBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OUk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7OUl; else goto c7OUm;
       c7OUl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.withBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7OUm: // global
           I64[Sp - 16] = block_c7OUh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7OUx; else goto c7OUi;
       u7OUx: // global
           call _c7OUh(R1) args: 0, res: 0, upd: 0;
       c7OUi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OUh() //  [R1]
         { info_tbl: [(c7OUh,
                       label: block_c7OUh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OUh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7OUt; else goto c7OUs;
       c7OUt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7OUs: // global
           _s7OL5::P64 = P64[R1 + 7];
           _s7OL4::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7OL4::I64;
           I64[Sp] = block_c7OUq_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7OL5::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OUq() //  [R1]
         { info_tbl: [(c7OUq,
                       label: block_c7OUq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OUq: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.223090032 UTC

[section ""data" . GHC.IO.Buffer.withBuffer_closure" {
     GHC.IO.Buffer.withBuffer_closure:
         const GHC.IO.Buffer.withBuffer_info;
 },
 GHC.IO.Buffer.withBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7OUC,
                       label: GHC.IO.Buffer.withBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OUC: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.withBuffer1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.224356745 UTC

[section ""data" . GHC.IO.Buffer.withRawBuffer1_closure" {
     GHC.IO.Buffer.withRawBuffer1_closure:
         const GHC.IO.Buffer.withRawBuffer1_info;
 },
 sat_s7OLi_entry() //  [R1]
         { info_tbl: [(c7OUN,
                       label: sat_s7OLi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OUN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7OUO; else goto c7OUP;
       c7OUO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7OUP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.ForeignPtr.unsafeForeignPtrToPtr_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.withRawBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7OUV,
                       label: GHC.IO.Buffer.withRawBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OUV: // global
           _s7OLg::P64 = R3;
           _s7OLf::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c7OUW; else goto c7OUX;
       c7OUX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7OUZ; else goto c7OUY;
       c7OUZ: // global
           HpAlloc = 24;
           goto c7OUW;
       c7OUW: // global
           R3 = _s7OLg::P64;
           R2 = _s7OLf::P64;
           R1 = GHC.IO.Buffer.withRawBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7OUY: // global
           I64[Hp - 16] = sat_s7OLi_info;
           P64[Hp] = _s7OLf::P64;
           I64[Sp - 16] = block_c7OUQ_info;
           R2 = Hp - 16;
           R1 = _s7OLg::P64;
           P64[Sp - 8] = _s7OLf::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OUQ() //  [R1]
         { info_tbl: [(c7OUQ,
                       label: block_c7OUQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OUQ: // global
           I64[Sp] = block_c7OUS_info;
           _s7OLl::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7OLl::P64;
           if (R1 & 7 != 0) goto u7OV5; else goto c7OUT;
       u7OV5: // global
           call _c7OUS(R1) args: 0, res: 0, upd: 0;
       c7OUT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OUS() //  [R1]
         { info_tbl: [(c7OUS,
                       label: block_c7OUS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OUS: // global
           _s7OLl::P64 = P64[Sp + 8];
           call MO_Touch(P64[R1 + 7]);
           R1 = _s7OLl::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.226121106 UTC

[section ""data" . GHC.IO.Buffer.withRawBuffer_closure" {
     GHC.IO.Buffer.withRawBuffer_closure:
         const GHC.IO.Buffer.withRawBuffer_info;
 },
 GHC.IO.Buffer.withRawBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7OVa,
                       label: GHC.IO.Buffer.withRawBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OVa: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.withRawBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.227201313 UTC

[section ""data" . GHC.IO.Buffer.isEmptyBuffer_closure" {
     GHC.IO.Buffer.isEmptyBuffer_closure:
         const GHC.IO.Buffer.isEmptyBuffer_info;
 },
 GHC.IO.Buffer.isEmptyBuffer_entry() //  [R2]
         { info_tbl: [(c7OVk,
                       label: GHC.IO.Buffer.isEmptyBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OVk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OVl; else goto c7OVm;
       c7OVl: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isEmptyBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OVm: // global
           I64[Sp - 8] = block_c7OVh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OVr; else goto c7OVi;
       u7OVr: // global
           call _c7OVh(R1) args: 0, res: 0, upd: 0;
       c7OVi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OVh() //  [R1]
         { info_tbl: [(c7OVh,
                       label: block_c7OVh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OVh: // global
           R1 = I64[((I64[R1 + 39] == I64[R1 + 47]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.228541729 UTC

[section ""data" . GHC.IO.Buffer.isFullBuffer_closure" {
     GHC.IO.Buffer.isFullBuffer_closure:
         const GHC.IO.Buffer.isFullBuffer_info;
 },
 GHC.IO.Buffer.isFullBuffer_entry() //  [R2]
         { info_tbl: [(c7OVz,
                       label: GHC.IO.Buffer.isFullBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OVz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OVA; else goto c7OVB;
       c7OVA: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isFullBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OVB: // global
           I64[Sp - 8] = block_c7OVw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OVG; else goto c7OVx;
       u7OVG: // global
           call _c7OVw(R1) args: 0, res: 0, upd: 0;
       c7OVx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OVw() //  [R1]
         { info_tbl: [(c7OVw,
                       label: block_c7OVw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OVw: // global
           R1 = I64[((I64[R1 + 31] == I64[R1 + 47]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.2301658 UTC

[section ""data" . GHC.IO.Buffer.isFullCharBuffer_closure" {
     GHC.IO.Buffer.isFullCharBuffer_closure:
         const GHC.IO.Buffer.isFullCharBuffer_info;
 },
 GHC.IO.Buffer.isFullCharBuffer_entry() //  [R2]
         { info_tbl: [(c7OVL,
                       label: GHC.IO.Buffer.isFullCharBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OVL: // global
           R2 = R2;
           call GHC.IO.Buffer.isFullBuffer_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.231634057 UTC

[section ""data" . GHC.IO.Buffer.isWriteBuffer_closure" {
     GHC.IO.Buffer.isWriteBuffer_closure:
         const GHC.IO.Buffer.isWriteBuffer_info;
 },
 GHC.IO.Buffer.isWriteBuffer_entry() //  [R2]
         { info_tbl: [(c7OVV,
                       label: GHC.IO.Buffer.isWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OVV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OVW; else goto c7OVX;
       c7OVW: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isWriteBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OVX: // global
           I64[Sp - 8] = block_c7OVS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OWf; else goto c7OVT;
       u7OWf: // global
           call _c7OVS(R1) args: 0, res: 0, upd: 0;
       c7OVT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OVS() //  [R1]
         { info_tbl: [(c7OVS,
                       label: block_c7OVS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OVS: // global
           I64[Sp] = block_c7OW0_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto u7OWe; else goto c7OW2;
       u7OWe: // global
           call _c7OW0(R1) args: 0, res: 0, upd: 0;
       c7OW2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OW0() //  [R1]
         { info_tbl: [(c7OW0,
                       label: block_c7OW0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OW0: // global
           if (R1 & 7 == 1) goto c7OW8; else goto c7OWc;
       c7OW8: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7OWc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.234325513 UTC

[section ""data" . GHC.IO.Buffer.bufferAdjustL_closure" {
     GHC.IO.Buffer.bufferAdjustL_closure:
         const GHC.IO.Buffer.bufferAdjustL_info;
 },
 GHC.IO.Buffer.bufferAdjustL_entry() //  [R2, R3]
         { info_tbl: [(c7OWn,
                       label: GHC.IO.Buffer.bufferAdjustL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OWn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7OWr; else goto c7OWs;
       c7OWr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAdjustL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7OWs: // global
           I64[Sp - 16] = block_c7OWk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7OWL; else goto c7OWl;
       u7OWL: // global
           call _c7OWk(R1) args: 0, res: 0, upd: 0;
       c7OWl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OWk() //  [R1]
         { info_tbl: [(c7OWk,
                       label: block_c7OWk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OWk: // global
           I64[Sp - 32] = block_c7OWq_info;
           _s7OLV::P64 = P64[R1 + 7];
           _s7OLW::P64 = P64[R1 + 15];
           _s7OLU::I64 = I64[R1 + 23];
           _s7OLX::I64 = I64[R1 + 31];
           _s7OLZ::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _s7OLW::P64;
           I64[Sp - 16] = _s7OLX::I64;
           I64[Sp - 8] = _s7OLZ::I64;
           P64[Sp] = _s7OLV::P64;
           I64[Sp + 8] = _s7OLU::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7OWK; else goto c7OWu;
       u7OWK: // global
           call _c7OWq(R1) args: 0, res: 0, upd: 0;
       c7OWu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OWq() //  [R1]
         { info_tbl: [(c7OWq,
                       label: block_c7OWq_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OWq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7OWA; else goto c7OWz;
       c7OWA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7OWz: // global
           _s7OLU::I64 = I64[Sp + 40];
           _s7OLV::P64 = P64[Sp + 32];
           _s7OLW::P64 = P64[Sp + 8];
           _s7OLX::I64 = I64[Sp + 16];
           _s7OLZ::I64 = I64[Sp + 24];
           _s7OM1::I64 = I64[R1 + 7];
           if (_s7OM1::I64 == _s7OLZ::I64) goto c7OWJ; else goto c7OWG;
       c7OWJ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7OLV::P64;
           P64[Hp - 32] = _s7OLW::P64;
           I64[Hp - 24] = _s7OLU::I64;
           I64[Hp - 16] = _s7OLX::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7OWG: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7OLV::P64;
           P64[Hp - 32] = _s7OLW::P64;
           I64[Hp - 24] = _s7OLU::I64;
           I64[Hp - 16] = _s7OLX::I64;
           I64[Hp - 8] = _s7OM1::I64;
           I64[Hp] = _s7OLZ::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.240079176 UTC

[section ""data" . GHC.IO.Buffer.emptyBuffer_closure" {
     GHC.IO.Buffer.emptyBuffer_closure:
         const GHC.IO.Buffer.emptyBuffer_info;
 },
 GHC.IO.Buffer.emptyBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7OWT,
                       label: GHC.IO.Buffer.emptyBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OWT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7OX2; else goto c7OX3;
       c7OX2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.emptyBuffer_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7OX3: // global
           I64[Sp - 24] = block_c7OWQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7OX9; else goto c7OWR;
       u7OX9: // global
           call _c7OWQ(R1) args: 0, res: 0, upd: 0;
       c7OWR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OWQ() //  [R1]
         { info_tbl: [(c7OWQ,
                       label: block_c7OWQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OWQ: // global
           I64[Sp - 8] = block_c7OWW_info;
           _s7OM8::P64 = P64[R1 + 7];
           _s7OM7::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OM8::P64;
           I64[Sp + 8] = _s7OM7::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OX8; else goto c7OWX;
       u7OX8: // global
           call _c7OWW(R1) args: 0, res: 0, upd: 0;
       c7OWX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OWW() //  [R1]
         { info_tbl: [(c7OWW,
                       label: block_c7OWW_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OWW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7OX7; else goto c7OX6;
       c7OX7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7OX6: // global
           _s7OMa::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = _s7OMa::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.242124926 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer5_bytes" {
     GHC.IO.Buffer.summaryBuffer5_bytes:
         I8[] [98,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.242934475 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer4_bytes" {
     GHC.IO.Buffer.summaryBuffer4_bytes:
         I8[] [40]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.24372374 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer3_bytes" {
     GHC.IO.Buffer.summaryBuffer3_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.244482072 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer2_bytes" {
     GHC.IO.Buffer.summaryBuffer2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.245894557 UTC

[section ""data" . GHC.IO.Buffer.summaryBuffer1_closure" {
     GHC.IO.Buffer.summaryBuffer1_closure:
         const GHC.IO.Buffer.summaryBuffer1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Buffer.summaryBuffer1_entry() //  [R1]
         { info_tbl: [(c7OXg,
                       label: GHC.IO.Buffer.summaryBuffer1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OXg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7OXh; else goto c7OXi;
       c7OXh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7OXi: // global
           (_c7OXd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7OXd::I64 == 0) goto c7OXf; else goto c7OXe;
       c7OXf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7OXe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7OXd::I64;
           R2 = GHC.IO.Buffer.summaryBuffer2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.248895163 UTC

[section ""data" . GHC.IO.Buffer.$wsummaryBuffer_closure" {
     GHC.IO.Buffer.$wsummaryBuffer_closure:
         const GHC.IO.Buffer.$wsummaryBuffer_info;
         const 0;
 },
 sat_s7OMq_entry() //  [R1]
         { info_tbl: [(c7OXO,
                       label: sat_s7OMq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OXO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7OXP; else goto c7OXQ;
       c7OXP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7OXQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7OXL_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7OXL() //  [R1, R2]
         { info_tbl: [(c7OXL,
                       label: block_c7OXL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OXL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7OXT; else goto c7OXS;
       c7OXT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7OXS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.IO.Buffer.summaryBuffer1_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7OMr_entry() //  [R1]
         { info_tbl: [(c7OXU,
                       label: sat_s7OMr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OXU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7OXY; else goto c7OXX;
       c7OXY: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7OXX: // global
           _s7OMd::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7OMq_info;
           I64[Hp] = _s7OMd::I64;
           R3 = Hp - 16;
           R2 = GHC.IO.Buffer.summaryBuffer3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7OMs_entry() //  [R1]
         { info_tbl: [(c7OY0,
                       label: sat_s7OMs_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OY0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7OY1; else goto c7OY2;
       c7OY1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7OY2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7OXB_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7OXB() //  [R1, R2]
         { info_tbl: [(c7OXB,
                       label: block_c7OXB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OXB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7OY5; else goto c7OY4;
       c7OY5: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7OY4: // global
           I64[Hp - 40] = sat_s7OMr_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7OMt_entry() //  [R1]
         { info_tbl: [(c7OY6,
                       label: sat_s7OMt_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OY6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7OYa; else goto c7OY9;
       c7OYa: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7OY9: // global
           _s7OMc::I64 = I64[R1 + 16];
           _s7OMd::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_s7OMs_info;
           I64[Hp - 8] = _s7OMc::I64;
           I64[Hp] = _s7OMd::I64;
           R3 = Hp - 24;
           R2 = GHC.IO.Buffer.summaryBuffer4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7OMu_entry() //  [R1]
         { info_tbl: [(c7OYc,
                       label: sat_s7OMu_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OYc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7OYd; else goto c7OYe;
       c7OYd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7OYe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c7OXr_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           I64[Sp - 32] = I64[R1 + 24];
           I64[Sp - 24] = I64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7OXr() //  [R1, R2]
         { info_tbl: [(c7OXr,
                       label: block_c7OXr_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OXr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7OYh; else goto c7OYg;
       c7OYh: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7OYg: // global
           I64[Hp - 48] = sat_s7OMt_info;
           I64[Hp - 32] = I64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.$wsummaryBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7OYi,
                       label: GHC.IO.Buffer.$wsummaryBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OYi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7OYm; else goto c7OYl;
       c7OYm: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$wsummaryBuffer_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7OYl: // global
           I64[Hp - 32] = sat_s7OMu_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R3 = Hp - 32;
           R2 = GHC.IO.Buffer.summaryBuffer5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.253852464 UTC

[section ""data" . GHC.IO.Buffer.summaryBuffer_closure" {
     GHC.IO.Buffer.summaryBuffer_closure:
         const GHC.IO.Buffer.summaryBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.summaryBuffer_entry() //  [R2]
         { info_tbl: [(c7OYv,
                       label: GHC.IO.Buffer.summaryBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OYv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7OYw; else goto c7OYx;
       c7OYw: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.summaryBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7OYx: // global
           I64[Sp - 8] = block_c7OYs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OYB; else goto c7OYt;
       u7OYB: // global
           call _c7OYs(R1) args: 0, res: 0, upd: 0;
       c7OYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OYs() //  [R1]
         { info_tbl: [(c7OYs,
                       label: block_c7OYs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OYs: // global
           R4 = I64[R1 + 47];
           R3 = I64[R1 + 39];
           R2 = I64[R1 + 31];
           Sp = Sp + 8;
           call GHC.IO.Buffer.$wsummaryBuffer_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.255423796 UTC

[section ""cstring" . GHC.IO.Buffer.$trModule4_bytes" {
     GHC.IO.Buffer.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.256210024 UTC

[section ""data" . GHC.IO.Buffer.$trModule3_closure" {
     GHC.IO.Buffer.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.256986446 UTC

[section ""cstring" . GHC.IO.Buffer.$trModule2_bytes" {
     GHC.IO.Buffer.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.25781557 UTC

[section ""data" . GHC.IO.Buffer.$trModule1_closure" {
     GHC.IO.Buffer.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.258607986 UTC

[section ""data" . GHC.IO.Buffer.$trModule_closure" {
     GHC.IO.Buffer.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Buffer.$trModule3_closure+1;
         const GHC.IO.Buffer.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.259507639 UTC

[section ""data" . $krep_r7OJJ_closure" {
     $krep_r7OJJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.26050178 UTC

[section ""data" . $krep1_r7OJK_closure" {
     $krep1_r7OJK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.261309012 UTC

[section ""data" . $krep2_r7OJL_closure" {
     $krep2_r7OJL_closure:
         const :_con_info;
         const $krep1_r7OJK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.262154938 UTC

[section ""data" . $krep3_r7OJM_closure" {
     $krep3_r7OJM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep2_r7OJL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.263035115 UTC

[section ""cstring" . GHC.IO.Buffer.$tcBufferState2_bytes" {
     GHC.IO.Buffer.$tcBufferState2_bytes:
         I8[] [66,117,102,102,101,114,83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.263775451 UTC

[section ""data" . GHC.IO.Buffer.$tcBufferState1_closure" {
     GHC.IO.Buffer.$tcBufferState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tcBufferState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.264608995 UTC

[section ""data" . GHC.IO.Buffer.$tcBufferState_closure" {
     GHC.IO.Buffer.$tcBufferState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tcBufferState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 15354245406219544442;
         const 3075510984364124805;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.265886565 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer1_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBufferState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.266806212 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'ReadBuffer3_bytes" {
     GHC.IO.Buffer.$tc'ReadBuffer3_bytes:
         I8[] [39,82,101,97,100,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.267540686 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer2_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'ReadBuffer3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.268316605 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer2_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const 18127629064171759490;
         const 12249378994783130540;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.269183955 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'WriteBuffer2_bytes" {
     GHC.IO.Buffer.$tc'WriteBuffer2_bytes:
         I8[] [39,87,114,105,116,101,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.269959477 UTC

[section ""data" . GHC.IO.Buffer.$tc'WriteBuffer1_closure" {
     GHC.IO.Buffer.$tc'WriteBuffer1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'WriteBuffer2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.270787963 UTC

[section ""data" . GHC.IO.Buffer.$tc'WriteBuffer_closure" {
     GHC.IO.Buffer.$tc'WriteBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'WriteBuffer1_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const 17535537923682101798;
         const 5353421715631386637;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.271608051 UTC

[section ""cstring" . GHC.IO.Buffer.$tcBuffer2_bytes" {
     GHC.IO.Buffer.$tcBuffer2_bytes:
         I8[] [66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.272364131 UTC

[section ""data" . GHC.IO.Buffer.$tcBuffer1_closure" {
     GHC.IO.Buffer.$tcBuffer1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tcBuffer2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.273153336 UTC

[section ""data" . GHC.IO.Buffer.$tcBuffer_closure" {
     GHC.IO.Buffer.$tcBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tcBuffer1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 18372445388029251215;
         const 8106905342043791875;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.274039211 UTC

[section ""data" . $krep4_r7OJN_closure" {
     $krep4_r7OJN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure+1;
         const $krep2_r7OJL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.27486754 UTC

[section ""data" . $krep5_r7OJO_closure" {
     $krep5_r7OJO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep4_r7OJN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.275603211 UTC

[section ""data" . $krep6_r7OJP_closure" {
     $krep6_r7OJP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep5_r7OJO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.276330927 UTC

[section ""data" . $krep7_r7OJQ_closure" {
     $krep7_r7OJQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep6_r7OJP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.2769365 UTC

[section ""data" . $krep8_r7OJR_closure" {
     $krep8_r7OJR_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const $krep7_r7OJQ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.277539869 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer1_closure" {
     GHC.IO.Buffer.$tc'Buffer1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r7OJM_closure+1;
         const $krep8_r7OJR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.278154396 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'Buffer3_bytes" {
     GHC.IO.Buffer.$tc'Buffer3_bytes:
         I8[] [39,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.278692927 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer2_closure" {
     GHC.IO.Buffer.$tc'Buffer2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'Buffer3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.279246642 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer_closure" {
     GHC.IO.Buffer.$tc'Buffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'Buffer2_closure+1;
         const GHC.IO.Buffer.$tc'Buffer1_closure+4;
         const 6953290879310668230;
         const 8839152842293094522;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.280503124 UTC

[section ""data" . GHC.IO.Buffer.writeWord8Buf1_closure" {
     GHC.IO.Buffer.writeWord8Buf1_closure:
         const GHC.IO.Buffer.writeWord8Buf1_info;
 },
 GHC.IO.Buffer.writeWord8Buf1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7OYJ,
                       label: GHC.IO.Buffer.writeWord8Buf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OYJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7OYS; else goto c7OYT;
       c7OYS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.writeWord8Buf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7OYT: // global
           I64[Sp - 24] = block_c7OYG_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7OZ6; else goto c7OYH;
       u7OZ6: // global
           call _c7OYG(R1) args: 0, res: 0, upd: 0;
       c7OYH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OYG() //  [R1]
         { info_tbl: [(c7OYG,
                       label: block_c7OYG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OYG: // global
           I64[Sp - 8] = block_c7OYM_info;
           _s7OMJ::P64 = P64[R1 + 7];
           _s7OMI::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OMJ::P64;
           I64[Sp + 8] = _s7OMI::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OZ5; else goto c7OYN;
       u7OZ5: // global
           call _c7OYM(R1) args: 0, res: 0, upd: 0;
       c7OYN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OYM() //  [R1]
         { info_tbl: [(c7OYM,
                       label: block_c7OYM_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OYM: // global
           I64[Sp] = block_c7OYR_info;
           _s7OML::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7OML::I64;
           if (R1 & 7 != 0) goto u7OZ7; else goto c7OYW;
       u7OZ7: // global
           call _c7OYR(R1) args: 0, res: 0, upd: 0;
       c7OYW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OYR() //  [R1]
         { info_tbl: [(c7OYR,
                       label: block_c7OYR_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OYR: // global
           _s7OMJ::P64 = P64[Sp + 8];
           I8[I64[Sp + 16] + I64[Sp + 24]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           call MO_Touch(_s7OMJ::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.282186319 UTC

[section ""data" . GHC.IO.Buffer.writeWord8Buf_closure" {
     GHC.IO.Buffer.writeWord8Buf_closure:
         const GHC.IO.Buffer.writeWord8Buf_info;
 },
 GHC.IO.Buffer.writeWord8Buf_entry() //  [R2, R3, R4]
         { info_tbl: [(c7OZc,
                       label: GHC.IO.Buffer.writeWord8Buf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OZc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.writeWord8Buf1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.283404289 UTC

[section ""data" . GHC.IO.Buffer.readWord8Buf1_closure" {
     GHC.IO.Buffer.readWord8Buf1_closure:
         const GHC.IO.Buffer.readWord8Buf1_info;
 },
 GHC.IO.Buffer.readWord8Buf1_entry() //  [R2, R3]
         { info_tbl: [(c7OZm,
                       label: GHC.IO.Buffer.readWord8Buf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OZm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7OZz; else goto c7OZA;
       c7OZz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.readWord8Buf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7OZA: // global
           I64[Sp - 16] = block_c7OZj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7OZG; else goto c7OZk;
       u7OZG: // global
           call _c7OZj(R1) args: 0, res: 0, upd: 0;
       c7OZk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OZj() //  [R1]
         { info_tbl: [(c7OZj,
                       label: block_c7OZj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OZj: // global
           I64[Sp - 8] = block_c7OZp_info;
           _s7OMW::P64 = P64[R1 + 7];
           _s7OMV::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OMW::P64;
           I64[Sp + 8] = _s7OMV::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7OZF; else goto c7OZq;
       u7OZF: // global
           call _c7OZp(R1) args: 0, res: 0, upd: 0;
       c7OZq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OZp() //  [R1]
         { info_tbl: [(c7OZp,
                       label: block_c7OZp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OZp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7OZE; else goto c7OZD;
       c7OZE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7OZD: // global
           _s7ON2::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 16] + I64[R1 + 7]]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s7ON2::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.286205174 UTC

[section ""data" . GHC.IO.Buffer.readWord8Buf_closure" {
     GHC.IO.Buffer.readWord8Buf_closure:
         const GHC.IO.Buffer.readWord8Buf_info;
 },
 GHC.IO.Buffer.readWord8Buf_entry() //  [R2, R3]
         { info_tbl: [(c7OZL,
                       label: GHC.IO.Buffer.readWord8Buf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OZL: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.readWord8Buf1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.287364971 UTC

[section ""data" . GHC.IO.Buffer.bufferAdd_closure" {
     GHC.IO.Buffer.bufferAdd_closure:
         const GHC.IO.Buffer.bufferAdd_info;
 },
 GHC.IO.Buffer.bufferAdd_entry() //  [R2, R3]
         { info_tbl: [(c7OZV,
                       label: GHC.IO.Buffer.bufferAdd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OZV: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c7P07; else goto c7P08;
       c7P07: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAdd_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P08: // global
           I64[Sp - 16] = block_c7OZS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7P0e; else goto c7OZT;
       u7P0e: // global
           call _c7OZS(R1) args: 0, res: 0, upd: 0;
       c7OZT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OZS() //  [R1]
         { info_tbl: [(c7OZS,
                       label: block_c7OZS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OZS: // global
           I64[Sp - 40] = block_c7OZY_info;
           _s7ON9::P64 = P64[R1 + 7];
           _s7ONa::P64 = P64[R1 + 15];
           _s7ON8::I64 = I64[R1 + 23];
           _s7ONb::I64 = I64[R1 + 31];
           _s7ONc::I64 = I64[R1 + 39];
           _s7ONd::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s7ONa::P64;
           I64[Sp - 24] = _s7ONb::I64;
           I64[Sp - 16] = _s7ONc::I64;
           I64[Sp - 8] = _s7ONd::I64;
           P64[Sp] = _s7ON9::P64;
           I64[Sp + 8] = _s7ON8::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7P0d; else goto c7OZZ;
       u7P0d: // global
           call _c7OZY(R1) args: 0, res: 0, upd: 0;
       c7OZZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7OZY() //  [R1]
         { info_tbl: [(c7OZY,
                       label: block_c7OZY_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7OZY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7P0c; else goto c7P0b;
       c7P0c: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P0b: // global
           _s7ONg::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = _s7ONg::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.289409582 UTC

[section ""data" . GHC.IO.Buffer.bufferRemove_closure" {
     GHC.IO.Buffer.bufferRemove_closure:
         const GHC.IO.Buffer.bufferRemove_info;
 },
 GHC.IO.Buffer.bufferRemove_entry() //  [R2, R3]
         { info_tbl: [(c7P0m,
                       label: GHC.IO.Buffer.bufferRemove_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P0m: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c7P0q; else goto c7P0r;
       c7P0q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferRemove_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P0r: // global
           I64[Sp - 16] = block_c7P0j_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7P0N; else goto c7P0k;
       u7P0N: // global
           call _c7P0j(R1) args: 0, res: 0, upd: 0;
       c7P0k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P0j() //  [R1]
         { info_tbl: [(c7P0j,
                       label: block_c7P0j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P0j: // global
           I64[Sp - 40] = block_c7P0p_info;
           _s7ONl::P64 = P64[R1 + 7];
           _s7ONm::P64 = P64[R1 + 15];
           _s7ONk::I64 = I64[R1 + 23];
           _s7ONn::I64 = I64[R1 + 31];
           _s7ONo::I64 = I64[R1 + 39];
           _s7ONp::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s7ONm::P64;
           I64[Sp - 24] = _s7ONn::I64;
           I64[Sp - 16] = _s7ONo::I64;
           I64[Sp - 8] = _s7ONp::I64;
           P64[Sp] = _s7ONl::P64;
           I64[Sp + 8] = _s7ONk::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7P0M; else goto c7P0t;
       u7P0M: // global
           call _c7P0p(R1) args: 0, res: 0, upd: 0;
       c7P0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P0p() //  [R1]
         { info_tbl: [(c7P0p,
                       label: block_c7P0p_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P0p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7P0z; else goto c7P0y;
       c7P0z: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P0y: // global
           _s7ONk::I64 = I64[Sp + 48];
           _s7ONl::P64 = P64[Sp + 40];
           _s7ONm::P64 = P64[Sp + 8];
           _s7ONn::I64 = I64[Sp + 16];
           _s7ONp::I64 = I64[Sp + 32];
           _s7ONs::I64 = I64[Sp + 24] + I64[R1 + 7];
           if (_s7ONs::I64 == _s7ONp::I64) goto c7P0L; else goto c7P0I;
       c7P0L: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7ONl::P64;
           P64[Hp - 32] = _s7ONm::P64;
           I64[Hp - 24] = _s7ONk::I64;
           I64[Hp - 16] = _s7ONn::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7P0I: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7ONl::P64;
           P64[Hp - 32] = _s7ONm::P64;
           I64[Hp - 24] = _s7ONk::I64;
           I64[Hp - 16] = _s7ONn::I64;
           I64[Hp - 8] = _s7ONs::I64;
           I64[Hp] = _s7ONp::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.291353356 UTC

[section ""data" . GHC.IO.Buffer.bufferAvailable_closure" {
     GHC.IO.Buffer.bufferAvailable_closure:
         const GHC.IO.Buffer.bufferAvailable_info;
 },
 GHC.IO.Buffer.bufferAvailable_entry() //  [R2]
         { info_tbl: [(c7P0V,
                       label: GHC.IO.Buffer.bufferAvailable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P0V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7P12; else goto c7P13;
       c7P12: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAvailable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7P13: // global
           I64[Sp - 8] = block_c7P0S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7P17; else goto c7P0T;
       u7P17: // global
           call _c7P0S(R1) args: 0, res: 0, upd: 0;
       c7P0T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P0S() //  [R1]
         { info_tbl: [(c7P0S,
                       label: block_c7P0S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P0S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7P16; else goto c7P15;
       c7P16: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P15: // global
           _s7ONC::I64 = I64[R1 + 31] - I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7ONC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.292666492 UTC

[section ""data" . GHC.IO.Buffer.bufferElems_closure" {
     GHC.IO.Buffer.bufferElems_closure:
         const GHC.IO.Buffer.bufferElems_info;
 },
 GHC.IO.Buffer.bufferElems_entry() //  [R2]
         { info_tbl: [(c7P1f,
                       label: GHC.IO.Buffer.bufferElems_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P1f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7P1m; else goto c7P1n;
       c7P1m: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferElems_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7P1n: // global
           I64[Sp - 8] = block_c7P1c_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7P1r; else goto c7P1d;
       u7P1r: // global
           call _c7P1c(R1) args: 0, res: 0, upd: 0;
       c7P1d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P1c() //  [R1]
         { info_tbl: [(c7P1c,
                       label: block_c7P1c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P1c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7P1q; else goto c7P1p;
       c7P1q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P1p: // global
           _s7ONL::I64 = I64[R1 + 47] - I64[R1 + 39];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7ONL::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.294039201 UTC

[section ""cstring" . lvl_r7OJS_bytes" {
     lvl_r7OJS_bytes:
         I8[] [98,117,102,102,101,114,32,105,110,118,97,114,105,97,110,116,32,118,105,111,108,97,116,105,111,110,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.294973871 UTC

[section ""data" . GHC.IO.Buffer.$wlvl_closure" {
     GHC.IO.Buffer.$wlvl_closure:
         const GHC.IO.Buffer.$wlvl_info;
         const 0;
 },
 sat_s7ONP_entry() //  [R1]
         { info_tbl: [(c7P1A,
                       label: sat_s7ONP_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P1A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7P1B; else goto c7P1C;
       c7P1B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7P1C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = I64[R1 + 32];
           R3 = I64[R1 + 24];
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Buffer.$wsummaryBuffer_entry(R4,
                                                    R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(c7P1F,
                       label: GHC.IO.Buffer.$wlvl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P1F: // global
           _s7ONO::I64 = R4;
           _s7ONN::I64 = R3;
           _s7ONM::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7P1G; else goto c7P1H;
       c7P1H: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7P1J; else goto c7P1I;
       c7P1J: // global
           HpAlloc = 40;
           goto c7P1G;
       c7P1G: // global
           R4 = _s7ONO::I64;
           R3 = _s7ONN::I64;
           R2 = _s7ONM::I64;
           R1 = GHC.IO.Buffer.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P1I: // global
           I64[Hp - 32] = sat_s7ONP_info;
           I64[Hp - 16] = _s7ONM::I64;
           I64[Hp - 8] = _s7ONN::I64;
           I64[Hp] = _s7ONO::I64;
           I64[Sp - 8] = block_c7P1D_info;
           R3 = Hp - 32;
           R2 = lvl_r7OJS_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7P1D() //  [R1]
         { info_tbl: [(c7P1D,
                       label: block_c7P1D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P1D: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.296480833 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer2_closure" {
     GHC.IO.Buffer.checkBuffer2_closure:
         const GHC.IO.Buffer.checkBuffer2_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer2_entry() //  [R2, R3]
         { info_tbl: [(c7P1R,
                       label: GHC.IO.Buffer.checkBuffer2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P1R: // global
           R4 = R3;
           R3 = 0;
           R2 = R2;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.298324443 UTC

[section ""data" . GHC.IO.Buffer.$wcheckBuffer_closure" {
     GHC.IO.Buffer.$wcheckBuffer_closure:
         const GHC.IO.Buffer.$wcheckBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.$wcheckBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P1V: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Buffer.$wcheckBuffer_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Buffer.$wcheckBuffer_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7P24,
                       label: GHC.IO.Buffer.$wcheckBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P24: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7P25; else goto c7P26;
       c7P25: // global
           R1 = GHC.IO.Buffer.$wcheckBuffer_closure;
           P64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c7P26: // global
           if (%MO_S_Le_W64(R3, 0)) goto u7P3e; else goto c7P23;
       u7P3e: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7P3r;
       c7P23: // global
           if (%MO_S_Gt_W64(R4, R5)) goto u7P3f; else goto c7P3b;
       u7P3f: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7P3r;
       c7P3b: // global
           if (%MO_S_Gt_W64(R5, R3)) goto u7P3g; else goto c7P3a;
       u7P3g: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7P3r;
       u7P3r: // global
           call _c7P37() args: 0, res: 0, upd: 0;
       c7P3a: // global
           if (R4 == R5) goto c7P2q; else goto c7P2T;
       c7P2q: // global
           I64[Sp - 32] = block_c7P2o_info;
           R1 = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7P3n; else goto c7P2r;
       u7P3n: // global
           call _c7P2o(R1) args: 0, res: 0, upd: 0;
       c7P2r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7P2T: // global
           I64[Sp - 32] = block_c7P2S_info;
           R1 = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7P3o; else goto c7P2U;
       u7P3o: // global
           call _c7P2S(R1) args: 0, res: 0, upd: 0;
       c7P2U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P2o() //  [R1]
         { info_tbl: [(c7P2o,
                       label: block_c7P2o_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P2o: // global
           _s7ONU::I64 = I64[Sp + 8];
           _s7ONW::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c7P2H; else goto c7P2Q;
       c7P2H: // global
           _s7OO6::I64 = I64[Sp + 16];
           if (_s7OO6::I64 != 0) goto c7P2y; else goto c7P2F;
       c7P2y: // global
           R4 = _s7ONW::I64;
           R3 = _s7OO6::I64;
           R2 = _s7ONU::I64;
           Sp = Sp + 32;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c7P2F: // global
           if (_s7ONW::I64 == 0) goto u7P3j; else goto c7P2D;
       u7P3j: // global
           Sp = Sp + 32;
           goto u7P3u;
       c7P2D: // global
           R3 = _s7ONW::I64;
           R2 = _s7ONU::I64;
           Sp = Sp + 32;
           call GHC.IO.Buffer.checkBuffer2_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
       c7P2Q: // global
           if (%MO_S_Ge_W64(_s7ONW::I64,
                            _s7ONU::I64)) goto u7P3i; else goto u7P3h;
       u7P3i: // global
           Sp = Sp + 8;
           call _c7P37() args: 0, res: 0, upd: 0;
       u7P3h: // global
           Sp = Sp + 32;
           goto u7P3u;
       u7P3u: // global
           call _c7P38() args: 0, res: 0, upd: 0;
     }
 },
 _c7P2S() //  [R1]
         { info_tbl: [(c7P2S,
                       label: block_c7P2S_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P2S: // global
           if (R1 & 7 == 1) goto u7P3k; else goto c7P39;
       u7P3k: // global
           Sp = Sp + 32;
           goto u7P3w;
       c7P39: // global
           if (%MO_S_Ge_W64(I64[Sp + 24],
                            I64[Sp + 8])) goto u7P3m; else goto u7P3l;
       u7P3m: // global
           Sp = Sp + 8;
           call _c7P37() args: 0, res: 0, upd: 0;
       u7P3l: // global
           Sp = Sp + 32;
           goto u7P3w;
       u7P3w: // global
           call _c7P38() args: 0, res: 0, upd: 0;
     }
 },
 _c7P37() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P37: // global
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7P38() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P38: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.300952965 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer1_closure" {
     GHC.IO.Buffer.checkBuffer1_closure:
         const GHC.IO.Buffer.checkBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer1_entry() //  [R2]
         { info_tbl: [(c7P3F,
                       label: GHC.IO.Buffer.checkBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P3F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7P3G; else goto c7P3H;
       c7P3G: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.checkBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7P3H: // global
           I64[Sp - 8] = block_c7P3C_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7P3L; else goto c7P3D;
       u7P3L: // global
           call _c7P3C(R1) args: 0, res: 0, upd: 0;
       c7P3D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P3C() //  [R1]
         { info_tbl: [(c7P3C,
                       label: block_c7P3C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P3C: // global
           R5 = I64[R1 + 47];
           R4 = I64[R1 + 39];
           R3 = I64[R1 + 31];
           R2 = P64[R1 + 15];
           Sp = Sp + 8;
           call GHC.IO.Buffer.$wcheckBuffer_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.302117161 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer_closure" {
     GHC.IO.Buffer.checkBuffer_closure:
         const GHC.IO.Buffer.checkBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer_entry() //  [R2]
         { info_tbl: [(c7P3Q,
                       label: GHC.IO.Buffer.checkBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P3Q: // global
           R2 = R2;
           call GHC.IO.Buffer.checkBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.303698923 UTC

[section ""data" . GHC.IO.Buffer.newBuffer1_closure" {
     GHC.IO.Buffer.newBuffer1_closure:
         const GHC.IO.Buffer.newBuffer1_info;
         const 0;
 },
 sat_s7OOF_entry() //  [R1]
         { info_tbl: [(c7P4g,
                       label: sat_s7OOF_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P4g: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7P4o; else goto c7P4p;
       c7P4o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7P4p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_c7P4d_info;
           _s7OOq::P64 = P64[R1 + 24];
           _s7OOx::P64 = P64[R1 + 32];
           _s7OOA::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _s7OOq::P64;
           P64[Sp - 32] = _s7OOx::P64;
           P64[Sp - 24] = _s7OOA::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u7P4t; else goto c7P4e;
       u7P4t: // global
           call _c7P4d(R1) args: 0, res: 0, upd: 0;
       c7P4e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c7P4d() //  [R1]
         { info_tbl: [(c7P4d,
                       label: block_c7P4d_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P4d: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c7P4s; else goto c7P4r;
       c7P4s: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c7P4r: // global
           _s7OOC::I64 = I64[R1 + 7];
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           _s7OOA::P64 = P64[Sp + 24];
           P64[Hp - 64] = _s7OOA::P64;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s7OOA::P64 + 16;
           I64[Hp - 16] = _s7OOC::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.newBuffer1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7P4u,
                       label: GHC.IO.Buffer.newBuffer1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P4u: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7P4v; else goto c7P4w;
       c7P4v: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.newBuffer1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P4w: // global
           I64[Sp - 24] = block_c7P3X_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7P4F; else goto c7P3Y;
       u7P4F: // global
           call _c7P3X(R1) args: 0, res: 0, upd: 0;
       c7P3Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P3X() //  [R1]
         { info_tbl: [(c7P3X,
                       label: block_c7P3X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P3X: // global
           _s7OOt::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7OOt::I64, 0)) goto c7P4z; else goto c7P4E;
       c7P4z: // global
           I64[Sp - 8] = block_c7P45_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s7OOt::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7P4E: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7P45() //  [R1]
         { info_tbl: [(c7P45,
                       label: block_c7P45_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P45: // global
           I64[Sp] = block_c7P47_info;
           _s7OOx::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7OOx::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P47() //  [R1]
         { info_tbl: [(c7P47,
                       label: block_c7P47_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P47: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7P4D; else goto c7P4C;
       c7P4D: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P4C: // global
           I64[Hp - 40] = sat_s7OOF_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.306025079 UTC

[section ""data" . GHC.IO.Buffer.newBuffer_closure" {
     GHC.IO.Buffer.newBuffer_closure:
         const GHC.IO.Buffer.newBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7P4K,
                       label: GHC.IO.Buffer.newBuffer_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P4K: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newBuffer1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.306904985 UTC

[section ""data" . GHC.IO.Buffer.newByteBuffer1_closure" {
     GHC.IO.Buffer.newByteBuffer1_closure:
         const GHC.IO.Buffer.newByteBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.newByteBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7P4R,
                       label: GHC.IO.Buffer.newByteBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P4R: // global
           R4 = R3;
           R3 = R2;
           R2 = R2;
           call GHC.IO.Buffer.newBuffer1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.307748676 UTC

[section ""data" . GHC.IO.Buffer.newByteBuffer_closure" {
     GHC.IO.Buffer.newByteBuffer_closure:
         const GHC.IO.Buffer.newByteBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newByteBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7P4Y,
                       label: GHC.IO.Buffer.newByteBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P4Y: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newByteBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.309265788 UTC

[section ""data" . GHC.IO.Buffer.newCharBuffer1_closure" {
     GHC.IO.Buffer.newCharBuffer1_closure:
         const GHC.IO.Buffer.newCharBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.newCharBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7P58,
                       label: GHC.IO.Buffer.newCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P58: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7P59; else goto c7P5a;
       c7P59: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.newCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P5a: // global
           I64[Sp - 16] = block_c7P55_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7P5A; else goto c7P56;
       u7P5A: // global
           call _c7P55(R1) args: 0, res: 0, upd: 0;
       c7P56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P55() //  [R1]
         { info_tbl: [(c7P55,
                       label: block_c7P55_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P55: // global
           _s7OON::I64 = I64[R1 + 7];
           _s7OOO::I64 = _s7OON::I64 << 2;
           if (%MO_S_Ge_W64(_s7OOO::I64, 0)) goto c7P5u; else goto c7P5z;
       c7P5u: // global
           I64[Sp - 16] = block_c7P5k_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _s7OOO::I64;
           I64[Sp] = _s7OON::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7P5z: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7P5k() //  [R1]
         { info_tbl: [(c7P5k,
                       label: block_c7P5k_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P5k: // global
           I64[Sp] = block_c7P5m_info;
           _s7OOS::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7OOS::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P5m() //  [R1]
         { info_tbl: [(c7P5m,
                       label: block_c7P5m_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P5m: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c7P5y; else goto c7P5x;
       c7P5y: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P5x: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.311313945 UTC

[section ""data" . GHC.IO.Buffer.newCharBuffer_closure" {
     GHC.IO.Buffer.newCharBuffer_closure:
         const GHC.IO.Buffer.newCharBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newCharBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7P5F,
                       label: GHC.IO.Buffer.newCharBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P5F: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newCharBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.312598848 UTC

[section ""data" . GHC.IO.Buffer.slideContents1_closure" {
     GHC.IO.Buffer.slideContents1_closure:
         const GHC.IO.Buffer.slideContents1_info;
 },
 GHC.IO.Buffer.slideContents1_entry() //  [R2]
         { info_tbl: [(c7P5P,
                       label: GHC.IO.Buffer.slideContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P5P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7P67; else goto c7P68;
       c7P67: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.slideContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7P68: // global
           I64[Sp - 8] = block_c7P5M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7P6c; else goto c7P5N;
       u7P6c: // global
           call _c7P5M(R1) args: 0, res: 0, upd: 0;
       c7P5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P5M() //  [R1]
         { info_tbl: [(c7P5M,
                       label: block_c7P5M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P5M: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7P6b; else goto c7P6a;
       c7P6b: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P6a: // global
           _s7OP4::P64 = P64[R1 + 7];
           _s7OP5::P64 = P64[R1 + 15];
           _s7OP3::I64 = I64[R1 + 23];
           _s7OP6::I64 = I64[R1 + 31];
           _s7OP7::I64 = I64[R1 + 39];
           _s7OP9::I64 = I64[R1 + 47] - _s7OP7::I64;
           (_s7OPf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_s7OP3::I64, _s7OP3::I64 + _s7OP7::I64, _s7OP9::I64);
           call MO_Touch(_s7OP4::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7OP4::P64;
           P64[Hp - 32] = _s7OP5::P64;
           I64[Hp - 24] = _s7OP3::I64;
           I64[Hp - 16] = _s7OP6::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s7OP9::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.314017015 UTC

[section ""data" . GHC.IO.Buffer.slideContents_closure" {
     GHC.IO.Buffer.slideContents_closure:
         const GHC.IO.Buffer.slideContents_info;
 },
 GHC.IO.Buffer.slideContents_entry() //  [R2]
         { info_tbl: [(c7P6h,
                       label: GHC.IO.Buffer.slideContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P6h: // global
           R2 = R2;
           call GHC.IO.Buffer.slideContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.31524428 UTC

[section ""data" . writeCharBufPtr1_r7OJT_closure" {
     writeCharBufPtr1_r7OJT_closure:
         const writeCharBufPtr1_r7OJT_info;
 },
 writeCharBufPtr1_r7OJT_entry() //  [R2, R3, R4]
         { info_tbl: [(c7P6r,
                       label: writeCharBufPtr1_r7OJT_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P6r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7P6I; else goto c7P6J;
       c7P6I: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = writeCharBufPtr1_r7OJT_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P6J: // global
           I64[Sp - 24] = block_c7P6o_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7P6Q; else goto c7P6p;
       u7P6Q: // global
           call _c7P6o(R1) args: 0, res: 0, upd: 0;
       c7P6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P6o() //  [R1]
         { info_tbl: [(c7P6o,
                       label: block_c7P6o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P6o: // global
           I64[Sp] = block_c7P6u_info;
           _s7OPn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7OPn::I64;
           if (R1 & 7 != 0) goto u7P6P; else goto c7P6v;
       u7P6P: // global
           call _c7P6u(R1) args: 0, res: 0, upd: 0;
       c7P6v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P6u() //  [R1]
         { info_tbl: [(c7P6u,
                       label: block_c7P6u_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P6u: // global
           I64[Sp] = block_c7P6z_info;
           _s7OPp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7OPp::I64;
           if (R1 & 7 != 0) goto u7P6R; else goto c7P6A;
       u7P6R: // global
           call _c7P6z(R1) args: 0, res: 0, upd: 0;
       c7P6A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P6z() //  [R1]
         { info_tbl: [(c7P6z,
                       label: block_c7P6z_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P6z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7P6O; else goto c7P6N;
       c7P6O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P6N: // global
           _s7OPp::I64 = I64[Sp + 16];
           I32[I64[Sp + 8] + (_s7OPp::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OPp::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.316972457 UTC

[section ""data" . GHC.IO.Buffer.writeCharBufPtr_closure" {
     GHC.IO.Buffer.writeCharBufPtr_closure:
         const GHC.IO.Buffer.writeCharBufPtr_info;
 },
 GHC.IO.Buffer.writeCharBufPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c7P6W,
                       label: GHC.IO.Buffer.writeCharBufPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P6W: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call writeCharBufPtr1_r7OJT_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.318331903 UTC

[section ""data" . writeCharBuf1_r7OJU_closure" {
     writeCharBuf1_r7OJU_closure:
         const writeCharBuf1_r7OJU_info;
 },
 writeCharBuf1_r7OJU_entry() //  [R2, R3, R4]
         { info_tbl: [(c7P76,
                       label: writeCharBuf1_r7OJU_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P76: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7P7o; else goto c7P7p;
       c7P7o: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = writeCharBuf1_r7OJU_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P7p: // global
           I64[Sp - 24] = block_c7P73_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7P7w; else goto c7P74;
       u7P7w: // global
           call _c7P73(R1) args: 0, res: 0, upd: 0;
       c7P74: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P73() //  [R1]
         { info_tbl: [(c7P73,
                       label: block_c7P73_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P73: // global
           I64[Sp - 8] = block_c7P79_info;
           _s7OPB::P64 = P64[R1 + 7];
           _s7OPA::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OPB::P64;
           I64[Sp + 8] = _s7OPA::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7P7v; else goto c7P7a;
       u7P7v: // global
           call _c7P79(R1) args: 0, res: 0, upd: 0;
       c7P7a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P79() //  [R1]
         { info_tbl: [(c7P79,
                       label: block_c7P79_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P79: // global
           I64[Sp] = block_c7P7e_info;
           _s7OPD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7OPD::I64;
           if (R1 & 7 != 0) goto u7P7x; else goto c7P7f;
       u7P7x: // global
           call _c7P7e(R1) args: 0, res: 0, upd: 0;
       c7P7f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P7e() //  [R1]
         { info_tbl: [(c7P7e,
                       label: block_c7P7e_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P7e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7P7u; else goto c7P7t;
       c7P7u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P7t: // global
           _s7OPB::P64 = P64[Sp + 8];
           _s7OPD::I64 = I64[Sp + 24];
           I32[I64[Sp + 16] + (_s7OPD::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           call MO_Touch(_s7OPB::P64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OPD::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.320153855 UTC

[section ""data" . GHC.IO.Buffer.writeCharBuf_closure" {
     GHC.IO.Buffer.writeCharBuf_closure:
         const GHC.IO.Buffer.writeCharBuf_info;
 },
 GHC.IO.Buffer.writeCharBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(c7P7C,
                       label: GHC.IO.Buffer.writeCharBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P7C: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call writeCharBuf1_r7OJU_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.321429251 UTC

[section ""data" . readCharBufPtr1_r7OJV_closure" {
     readCharBufPtr1_r7OJV_closure:
         const readCharBufPtr1_r7OJV_info;
 },
 readCharBufPtr1_r7OJV_entry() //  [R2, R3]
         { info_tbl: [(c7P7M,
                       label: readCharBufPtr1_r7OJV_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P7M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7P80; else goto c7P81;
       c7P80: // global
           R3 = R3;
           R2 = R2;
           R1 = readCharBufPtr1_r7OJV_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P81: // global
           I64[Sp - 16] = block_c7P7J_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7P87; else goto c7P7K;
       u7P87: // global
           call _c7P7J(R1) args: 0, res: 0, upd: 0;
       c7P7K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P7J() //  [R1]
         { info_tbl: [(c7P7J,
                       label: block_c7P7J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P7J: // global
           I64[Sp] = block_c7P7P_info;
           _s7OPO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7OPO::I64;
           if (R1 & 7 != 0) goto u7P86; else goto c7P7Q;
       u7P86: // global
           call _c7P7P(R1) args: 0, res: 0, upd: 0;
       c7P7Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P7P() //  [R1]
         { info_tbl: [(c7P7P,
                       label: block_c7P7P_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P7P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7P85; else goto c7P84;
       c7P85: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P84: // global
           _s7OPQ::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7OPQ::I64 + 1;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (_s7OPQ::I64 << 2)]);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.322993532 UTC

[section ""data" . GHC.IO.Buffer.readCharBufPtr_closure" {
     GHC.IO.Buffer.readCharBufPtr_closure:
         const GHC.IO.Buffer.readCharBufPtr_info;
 },
 GHC.IO.Buffer.readCharBufPtr_entry() //  [R2, R3]
         { info_tbl: [(c7P8c,
                       label: GHC.IO.Buffer.readCharBufPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P8c: // global
           R3 = R3;
           R2 = R2;
           call readCharBufPtr1_r7OJV_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.324229188 UTC

[section ""data" . readCharBuf1_r7OJW_closure" {
     readCharBuf1_r7OJW_closure:
         const readCharBuf1_r7OJW_info;
 },
 readCharBuf1_r7OJW_entry() //  [R2, R3]
         { info_tbl: [(c7P8m,
                       label: readCharBuf1_r7OJW_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P8m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7P8B; else goto c7P8C;
       c7P8B: // global
           R3 = R3;
           R2 = R2;
           R1 = readCharBuf1_r7OJW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P8C: // global
           I64[Sp - 16] = block_c7P8j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7P8I; else goto c7P8k;
       u7P8I: // global
           call _c7P8j(R1) args: 0, res: 0, upd: 0;
       c7P8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P8j() //  [R1]
         { info_tbl: [(c7P8j,
                       label: block_c7P8j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P8j: // global
           I64[Sp - 8] = block_c7P8p_info;
           _s7OQ3::P64 = P64[R1 + 7];
           _s7OQ2::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OQ3::P64;
           I64[Sp + 8] = _s7OQ2::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7P8H; else goto c7P8q;
       u7P8H: // global
           call _c7P8p(R1) args: 0, res: 0, upd: 0;
       c7P8q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P8p() //  [R1]
         { info_tbl: [(c7P8p,
                       label: block_c7P8p_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P8p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7P8G; else goto c7P8F;
       c7P8G: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P8F: // global
           _s7OQ5::I64 = I64[R1 + 7];
           _s7OQ8::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 16] + (_s7OQ5::I64 << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7OQ5::I64 + 1;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s7OQ8::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.325877714 UTC

[section ""data" . GHC.IO.Buffer.readCharBuf_closure" {
     GHC.IO.Buffer.readCharBuf_closure:
         const GHC.IO.Buffer.readCharBuf_info;
 },
 GHC.IO.Buffer.readCharBuf_entry() //  [R2, R3]
         { info_tbl: [(c7P8N,
                       label: GHC.IO.Buffer.readCharBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P8N: // global
           R3 = R3;
           R2 = R2;
           call readCharBuf1_r7OJW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.327066425 UTC

[section ""data" . GHC.IO.Buffer.peekCharBuf1_closure" {
     GHC.IO.Buffer.peekCharBuf1_closure:
         const GHC.IO.Buffer.peekCharBuf1_info;
 },
 GHC.IO.Buffer.peekCharBuf1_entry() //  [R2, R3]
         { info_tbl: [(c7P8X,
                       label: GHC.IO.Buffer.peekCharBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P8X: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7P97; else goto c7P98;
       c7P97: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.peekCharBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7P98: // global
           I64[Sp - 16] = block_c7P8U_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7P9e; else goto c7P8V;
       u7P9e: // global
           call _c7P8U(R1) args: 0, res: 0, upd: 0;
       c7P8V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P8U() //  [R1]
         { info_tbl: [(c7P8U,
                       label: block_c7P8U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P8U: // global
           I64[Sp - 8] = block_c7P90_info;
           _s7OQj::P64 = P64[R1 + 7];
           _s7OQi::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OQj::P64;
           I64[Sp + 8] = _s7OQi::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7P9d; else goto c7P91;
       u7P9d: // global
           call _c7P90(R1) args: 0, res: 0, upd: 0;
       c7P91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P90() //  [R1]
         { info_tbl: [(c7P90,
                       label: block_c7P90_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P90: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7P9c; else goto c7P9b;
       c7P9c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7P9b: // global
           _s7OQo::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 16] + (I64[R1 + 7] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s7OQo::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.328624317 UTC

[section ""data" . GHC.IO.Buffer.peekCharBuf_closure" {
     GHC.IO.Buffer.peekCharBuf_closure:
         const GHC.IO.Buffer.peekCharBuf_info;
 },
 GHC.IO.Buffer.peekCharBuf_entry() //  [R2, R3]
         { info_tbl: [(c7P9j,
                       label: GHC.IO.Buffer.peekCharBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9j: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.peekCharBuf1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.329474494 UTC

[section ""data" . GHC.IO.Buffer.ReadBuffer_closure" {
     GHC.IO.Buffer.ReadBuffer_closure:
         const GHC.IO.Buffer.ReadBuffer_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.330259309 UTC

[section ""data" . GHC.IO.Buffer.WriteBuffer_closure" {
     GHC.IO.Buffer.WriteBuffer_closure:
         const GHC.IO.Buffer.WriteBuffer_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.331271266 UTC

[section ""data" . GHC.IO.Buffer.Buffer_closure" {
     GHC.IO.Buffer.Buffer_closure:
         const GHC.IO.Buffer.Buffer_info;
 },
 GHC.IO.Buffer.Buffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9n: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Buffer.Buffer_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2,
                                           R1) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Buffer.Buffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7P9s,
                       label: GHC.IO.Buffer.Buffer_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [True, False, False, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9s: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7P9w; else goto c7P9v;
       c7P9w: // global
           HpAlloc = 56;
           R1 = GHC.IO.Buffer.Buffer_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       c7P9v: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = R5;
           I64[Hp - 8] = R6;
           I64[Hp] = I64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.332927145 UTC

[section ""relreadonly" . GHC.IO.Buffer.BufferState_closure_tbl" {
     GHC.IO.Buffer.BufferState_closure_tbl:
         const GHC.IO.Buffer.ReadBuffer_closure+1;
         const GHC.IO.Buffer.WriteBuffer_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.334069118 UTC

[GHC.IO.Buffer.ReadBuffer_con_entry() //  [R1]
         { info_tbl: [(c7P9x,
                       label: GHC.IO.Buffer.ReadBuffer_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,82,101,97,100,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9x: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.335078258 UTC

[GHC.IO.Buffer.WriteBuffer_con_entry() //  [R1]
         { info_tbl: [(c7P9y,
                       label: GHC.IO.Buffer.WriteBuffer_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,87,114,105,116,101,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9y: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.336015648 UTC

[GHC.IO.Buffer.Buffer_con_entry() //  [R1]
         { info_tbl: [(c7P9z,
                       label: GHC.IO.Buffer.Buffer_con_info
                       rep:HeapRep 2 ptrs 4 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9z: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.336969684 UTC

[section ""relreadonly" . S7OYn_srt" {
     S7OYn_srt:
         const GHC.IO.Buffer.summaryBuffer1_closure;
         const GHC.IO.Buffer.$wsummaryBuffer_closure;
         const GHC.IO.Buffer.summaryBuffer_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Buffer.$wlvl_closure;
         const GHC.IO.Buffer.$wcheckBuffer_closure;
         const GHC.IO.Buffer.checkBuffer2_closure;
         const GHC.IO.Buffer.checkBuffer1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const GHC.IO.Buffer.newBuffer1_closure;
         const GHC.IO.Buffer.newByteBuffer1_closure;
         const GHC.IO.Buffer.newCharBuffer1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.337925006 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:55.339528257 UTC

[section ""data" . GHC.IO.Buffer.$WBuffer_closure" {
     GHC.IO.Buffer.$WBuffer_closure:
         const GHC.IO.Buffer.$WBuffer_info;
 },
 GHC.IO.Buffer.$WBuffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7P9H,
                       label: GHC.IO.Buffer.$WBuffer_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9H: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Pa0; else goto c7Pa1;
       c7Pa0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$WBuffer_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pa1: // global
           I64[Sp - 40] = block_c7P9E_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Pa9; else goto c7P9F;
       u7Pa9: // global
           call _c7P9E(R1) args: 0, res: 0, upd: 0;
       c7P9F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P9E() //  [R1]
         { info_tbl: [(c7P9E,
                       label: block_c7P9E_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9E: // global
           I64[Sp - 8] = block_c7P9K_info;
           _s7OK5::P64 = P64[R1 + 7];
           _s7OK4::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s7OK5::P64;
           I64[Sp + 16] = _s7OK4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pa8; else goto c7P9L;
       u7Pa8: // global
           call _c7P9K(R1) args: 0, res: 0, upd: 0;
       c7P9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P9K() //  [R1]
         { info_tbl: [(c7P9K,
                       label: block_c7P9K_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9K: // global
           I64[Sp] = block_c7P9P_info;
           _s7OK7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _s7OK7::I64;
           if (R1 & 7 != 0) goto u7Paa; else goto c7P9Q;
       u7Paa: // global
           call _c7P9P(R1) args: 0, res: 0, upd: 0;
       c7P9Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P9P() //  [R1]
         { info_tbl: [(c7P9P,
                       label: block_c7P9P_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9P: // global
           I64[Sp] = block_c7P9U_info;
           _s7OK9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _s7OK9::I64;
           if (R1 & 7 != 0) goto u7Pab; else goto c7P9V;
       u7Pab: // global
           call _c7P9U(R1) args: 0, res: 0, upd: 0;
       c7P9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7P9U() //  [R1]
         { info_tbl: [(c7P9U,
                       label: block_c7P9U_info
                       rep:StackRep [False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7P9U: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Pa7; else goto c7Pa6;
       c7Pa7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pa6: // global
           _s7OKb::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s7OKb::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.343126615 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_$c==_closure" {
     GHC.IO.Buffer.$fEqBufferState_$c==_closure:
         const GHC.IO.Buffer.$fEqBufferState_$c==_info;
 },
 GHC.IO.Buffer.$fEqBufferState_$c==_entry() //  [R2, R3]
         { info_tbl: [(c7Pan,
                       label: GHC.IO.Buffer.$fEqBufferState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pan: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Pao; else goto c7Pap;
       c7Pao: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$fEqBufferState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pap: // global
           I64[Sp - 16] = block_c7Pag_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Pb2; else goto c7Pah;
       u7Pb2: // global
           call _c7Pag(R1) args: 0, res: 0, upd: 0;
       c7Pah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pag() //  [R1]
         { info_tbl: [(c7Pag,
                       label: block_c7Pag_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pag: // global
           _s7OKd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7Pak; else goto c7Pal;
       c7Pak: // global
           I64[Sp + 8] = block_c7Pas_info;
           R1 = _s7OKd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Pb0; else goto c7Pau;
       u7Pb0: // global
           call _c7Pas(R1) args: 0, res: 0, upd: 0;
       c7Pau: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Pal: // global
           I64[Sp + 8] = block_c7PaH_info;
           R1 = _s7OKd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Pb1; else goto c7PaJ;
       u7Pb1: // global
           call _c7PaH(R1) args: 0, res: 0, upd: 0;
       c7PaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pas() //  [R1]
         { info_tbl: [(c7Pas,
                       label: block_c7Pas_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pas: // global
           if (R1 & 7 == 1) goto u7PaY; else goto u7PaZ;
       u7PaY: // global
           Sp = Sp + 8;
           call _c7PaT() args: 0, res: 0, upd: 0;
       u7PaZ: // global
           Sp = Sp + 8;
           call _c7PaP() args: 0, res: 0, upd: 0;
     }
 },
 _c7PaH() //  [R1]
         { info_tbl: [(c7PaH,
                       label: block_c7PaH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PaH: // global
           if (R1 & 7 == 1) goto u7PaW; else goto u7PaX;
       u7PaW: // global
           Sp = Sp + 8;
           call _c7PaP() args: 0, res: 0, upd: 0;
       u7PaX: // global
           Sp = Sp + 8;
           call _c7PaT() args: 0, res: 0, upd: 0;
     }
 },
 _c7PaP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PaP: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7PaT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PaT: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.346339655 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_$c/=_closure" {
     GHC.IO.Buffer.$fEqBufferState_$c/=_closure:
         const GHC.IO.Buffer.$fEqBufferState_$c/=_info;
 },
 GHC.IO.Buffer.$fEqBufferState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c7Pbi,
                       label: GHC.IO.Buffer.$fEqBufferState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pbi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Pbj; else goto c7Pbk;
       c7Pbj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$fEqBufferState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pbk: // global
           I64[Sp - 16] = block_c7Pbb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PbX; else goto c7Pbc;
       u7PbX: // global
           call _c7Pbb(R1) args: 0, res: 0, upd: 0;
       c7Pbc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pbb() //  [R1]
         { info_tbl: [(c7Pbb,
                       label: block_c7Pbb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pbb: // global
           _s7OKi::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7Pbf; else goto c7Pbg;
       c7Pbf: // global
           I64[Sp + 8] = block_c7Pbn_info;
           R1 = _s7OKi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7PbV; else goto c7Pbp;
       u7PbV: // global
           call _c7Pbn(R1) args: 0, res: 0, upd: 0;
       c7Pbp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Pbg: // global
           I64[Sp + 8] = block_c7PbC_info;
           R1 = _s7OKi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7PbW; else goto c7PbE;
       u7PbW: // global
           call _c7PbC(R1) args: 0, res: 0, upd: 0;
       c7PbE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pbn() //  [R1]
         { info_tbl: [(c7Pbn,
                       label: block_c7Pbn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pbn: // global
           if (R1 & 7 == 1) goto u7PbT; else goto u7PbU;
       u7PbT: // global
           Sp = Sp + 8;
           call _c7PbO() args: 0, res: 0, upd: 0;
       u7PbU: // global
           Sp = Sp + 8;
           call _c7PbK() args: 0, res: 0, upd: 0;
     }
 },
 _c7PbC() //  [R1]
         { info_tbl: [(c7PbC,
                       label: block_c7PbC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PbC: // global
           if (R1 & 7 == 1) goto u7PbR; else goto u7PbS;
       u7PbR: // global
           Sp = Sp + 8;
           call _c7PbK() args: 0, res: 0, upd: 0;
       u7PbS: // global
           Sp = Sp + 8;
           call _c7PbO() args: 0, res: 0, upd: 0;
     }
 },
 _c7PbK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PbK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7PbO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PbO: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.348820455 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_closure" {
     GHC.IO.Buffer.$fEqBufferState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Buffer.$fEqBufferState_$c==_closure+2;
         const GHC.IO.Buffer.$fEqBufferState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.350060526 UTC

[section ""data" . GHC.IO.Buffer.bufR_closure" {
     GHC.IO.Buffer.bufR_closure:
         const GHC.IO.Buffer.bufR_info;
 },
 GHC.IO.Buffer.bufR_entry() //  [R2]
         { info_tbl: [(c7Pc9,
                       label: GHC.IO.Buffer.bufR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pc9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Pcd; else goto c7Pce;
       c7Pcd: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pce: // global
           I64[Sp - 8] = block_c7Pc6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pci; else goto c7Pc7;
       u7Pci: // global
           call _c7Pc6(R1) args: 0, res: 0, upd: 0;
       c7Pc7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pc6() //  [R1]
         { info_tbl: [(c7Pc6,
                       label: block_c7Pc6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pc6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Pch; else goto c7Pcg;
       c7Pch: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pcg: // global
           _s7OKt::I64 = I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OKt::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.354754938 UTC

[section ""data" . GHC.IO.Buffer.bufL_closure" {
     GHC.IO.Buffer.bufL_closure:
         const GHC.IO.Buffer.bufL_info;
 },
 GHC.IO.Buffer.bufL_entry() //  [R2]
         { info_tbl: [(c7Pcq,
                       label: GHC.IO.Buffer.bufL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pcq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Pcu; else goto c7Pcv;
       c7Pcu: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pcv: // global
           I64[Sp - 8] = block_c7Pcn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pcz; else goto c7Pco;
       u7Pcz: // global
           call _c7Pcn(R1) args: 0, res: 0, upd: 0;
       c7Pco: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pcn() //  [R1]
         { info_tbl: [(c7Pcn,
                       label: block_c7Pcn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pcn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Pcy; else goto c7Pcx;
       c7Pcy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pcx: // global
           _s7OKA::I64 = I64[R1 + 39];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OKA::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.356285034 UTC

[section ""data" . GHC.IO.Buffer.bufSize_closure" {
     GHC.IO.Buffer.bufSize_closure:
         const GHC.IO.Buffer.bufSize_info;
 },
 GHC.IO.Buffer.bufSize_entry() //  [R2]
         { info_tbl: [(c7PcH,
                       label: GHC.IO.Buffer.bufSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PcH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PcL; else goto c7PcM;
       c7PcL: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PcM: // global
           I64[Sp - 8] = block_c7PcE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PcQ; else goto c7PcF;
       u7PcQ: // global
           call _c7PcE(R1) args: 0, res: 0, upd: 0;
       c7PcF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PcE() //  [R1]
         { info_tbl: [(c7PcE,
                       label: block_c7PcE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PcE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PcP; else goto c7PcO;
       c7PcP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PcO: // global
           _s7OKH::I64 = I64[R1 + 31];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OKH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.357977767 UTC

[section ""data" . GHC.IO.Buffer.bufState_closure" {
     GHC.IO.Buffer.bufState_closure:
         const GHC.IO.Buffer.bufState_info;
 },
 GHC.IO.Buffer.bufState_entry() //  [R2]
         { info_tbl: [(c7PcY,
                       label: GHC.IO.Buffer.bufState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PcY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PcZ; else goto c7Pd0;
       c7PcZ: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pd0: // global
           I64[Sp - 8] = block_c7PcV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pd4; else goto c7PcW;
       u7Pd4: // global
           call _c7PcV(R1) args: 0, res: 0, upd: 0;
       c7PcW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PcV() //  [R1]
         { info_tbl: [(c7PcV,
                       label: block_c7PcV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PcV: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.359330467 UTC

[section ""data" . GHC.IO.Buffer.bufRaw_closure" {
     GHC.IO.Buffer.bufRaw_closure:
         const GHC.IO.Buffer.bufRaw_info;
 },
 GHC.IO.Buffer.bufRaw_entry() //  [R2]
         { info_tbl: [(c7Pdc,
                       label: GHC.IO.Buffer.bufRaw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pdc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Pdg; else goto c7Pdh;
       c7Pdg: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufRaw_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pdh: // global
           I64[Sp - 8] = block_c7Pd9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pdl; else goto c7Pda;
       u7Pdl: // global
           call _c7Pd9(R1) args: 0, res: 0, upd: 0;
       c7Pda: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pd9() //  [R1]
         { info_tbl: [(c7Pd9,
                       label: block_c7Pd9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pd9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Pdk; else goto c7Pdj;
       c7Pdk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pdj: // global
           _s7OKV::P64 = P64[R1 + 7];
           _s7OKU::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = _s7OKV::P64;
           I64[Hp] = _s7OKU::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.360538782 UTC

[section ""data" . GHC.IO.Buffer.charSize_closure" {
     GHC.IO.Buffer.charSize_closure:
         const GHC.Types.I#_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.361624898 UTC

[section ""data" . GHC.IO.Buffer.withBuffer1_closure" {
     GHC.IO.Buffer.withBuffer1_closure:
         const GHC.IO.Buffer.withBuffer1_info;
 },
 GHC.IO.Buffer.withBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7Pdt,
                       label: GHC.IO.Buffer.withBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pdt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Pdu; else goto c7Pdv;
       c7Pdu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.withBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pdv: // global
           I64[Sp - 16] = block_c7Pdq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PdG; else goto c7Pdr;
       u7PdG: // global
           call _c7Pdq(R1) args: 0, res: 0, upd: 0;
       c7Pdr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pdq() //  [R1]
         { info_tbl: [(c7Pdq,
                       label: block_c7Pdq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pdq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PdC; else goto c7PdB;
       c7PdC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PdB: // global
           _s7OL5::P64 = P64[R1 + 7];
           _s7OL4::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7OL4::I64;
           I64[Sp] = block_c7Pdz_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7OL5::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pdz() //  [R1]
         { info_tbl: [(c7Pdz,
                       label: block_c7Pdz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pdz: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.363072799 UTC

[section ""data" . GHC.IO.Buffer.withBuffer_closure" {
     GHC.IO.Buffer.withBuffer_closure:
         const GHC.IO.Buffer.withBuffer_info;
 },
 GHC.IO.Buffer.withBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7PdL,
                       label: GHC.IO.Buffer.withBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PdL: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.withBuffer1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.364371357 UTC

[section ""data" . GHC.IO.Buffer.withRawBuffer1_closure" {
     GHC.IO.Buffer.withRawBuffer1_closure:
         const GHC.IO.Buffer.withRawBuffer1_info;
 },
 sat_s7OLi_entry() //  [R1]
         { info_tbl: [(c7PdW,
                       label: sat_s7OLi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PdW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7PdX; else goto c7PdY;
       c7PdX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PdY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.ForeignPtr.unsafeForeignPtrToPtr_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.withRawBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7Pe4,
                       label: GHC.IO.Buffer.withRawBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pe4: // global
           _s7OLg::P64 = R3;
           _s7OLf::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Pe5; else goto c7Pe6;
       c7Pe6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Pe8; else goto c7Pe7;
       c7Pe8: // global
           HpAlloc = 24;
           goto c7Pe5;
       c7Pe5: // global
           R3 = _s7OLg::P64;
           R2 = _s7OLf::P64;
           R1 = GHC.IO.Buffer.withRawBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pe7: // global
           I64[Hp - 16] = sat_s7OLi_info;
           P64[Hp] = _s7OLf::P64;
           I64[Sp - 16] = block_c7PdZ_info;
           R2 = Hp - 16;
           R1 = _s7OLg::P64;
           P64[Sp - 8] = _s7OLf::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PdZ() //  [R1]
         { info_tbl: [(c7PdZ,
                       label: block_c7PdZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PdZ: // global
           I64[Sp] = block_c7Pe1_info;
           _s7OLl::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7OLl::P64;
           if (R1 & 7 != 0) goto u7Pee; else goto c7Pe2;
       u7Pee: // global
           call _c7Pe1(R1) args: 0, res: 0, upd: 0;
       c7Pe2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pe1() //  [R1]
         { info_tbl: [(c7Pe1,
                       label: block_c7Pe1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pe1: // global
           _s7OLl::P64 = P64[Sp + 8];
           call MO_Touch(P64[R1 + 7]);
           R1 = _s7OLl::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.366151566 UTC

[section ""data" . GHC.IO.Buffer.withRawBuffer_closure" {
     GHC.IO.Buffer.withRawBuffer_closure:
         const GHC.IO.Buffer.withRawBuffer_info;
 },
 GHC.IO.Buffer.withRawBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7Pej,
                       label: GHC.IO.Buffer.withRawBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pej: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.withRawBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.367229837 UTC

[section ""data" . GHC.IO.Buffer.isEmptyBuffer_closure" {
     GHC.IO.Buffer.isEmptyBuffer_closure:
         const GHC.IO.Buffer.isEmptyBuffer_info;
 },
 GHC.IO.Buffer.isEmptyBuffer_entry() //  [R2]
         { info_tbl: [(c7Pet,
                       label: GHC.IO.Buffer.isEmptyBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pet: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Peu; else goto c7Pev;
       c7Peu: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isEmptyBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pev: // global
           I64[Sp - 8] = block_c7Peq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PeA; else goto c7Per;
       u7PeA: // global
           call _c7Peq(R1) args: 0, res: 0, upd: 0;
       c7Per: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Peq() //  [R1]
         { info_tbl: [(c7Peq,
                       label: block_c7Peq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Peq: // global
           R1 = I64[((I64[R1 + 39] == I64[R1 + 47]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.368521835 UTC

[section ""data" . GHC.IO.Buffer.isFullBuffer_closure" {
     GHC.IO.Buffer.isFullBuffer_closure:
         const GHC.IO.Buffer.isFullBuffer_info;
 },
 GHC.IO.Buffer.isFullBuffer_entry() //  [R2]
         { info_tbl: [(c7PeI,
                       label: GHC.IO.Buffer.isFullBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PeI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PeJ; else goto c7PeK;
       c7PeJ: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isFullBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PeK: // global
           I64[Sp - 8] = block_c7PeF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PeP; else goto c7PeG;
       u7PeP: // global
           call _c7PeF(R1) args: 0, res: 0, upd: 0;
       c7PeG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PeF() //  [R1]
         { info_tbl: [(c7PeF,
                       label: block_c7PeF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PeF: // global
           R1 = I64[((I64[R1 + 31] == I64[R1 + 47]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.369698387 UTC

[section ""data" . GHC.IO.Buffer.isFullCharBuffer_closure" {
     GHC.IO.Buffer.isFullCharBuffer_closure:
         const GHC.IO.Buffer.isFullCharBuffer_info;
 },
 GHC.IO.Buffer.isFullCharBuffer_entry() //  [R2]
         { info_tbl: [(c7PeU,
                       label: GHC.IO.Buffer.isFullCharBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PeU: // global
           R2 = R2;
           call GHC.IO.Buffer.isFullBuffer_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.370815204 UTC

[section ""data" . GHC.IO.Buffer.isWriteBuffer_closure" {
     GHC.IO.Buffer.isWriteBuffer_closure:
         const GHC.IO.Buffer.isWriteBuffer_info;
 },
 GHC.IO.Buffer.isWriteBuffer_entry() //  [R2]
         { info_tbl: [(c7Pf4,
                       label: GHC.IO.Buffer.isWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pf4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Pf5; else goto c7Pf6;
       c7Pf5: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isWriteBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pf6: // global
           I64[Sp - 8] = block_c7Pf1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pfo; else goto c7Pf2;
       u7Pfo: // global
           call _c7Pf1(R1) args: 0, res: 0, upd: 0;
       c7Pf2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pf1() //  [R1]
         { info_tbl: [(c7Pf1,
                       label: block_c7Pf1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pf1: // global
           I64[Sp] = block_c7Pf9_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto u7Pfn; else goto c7Pfb;
       u7Pfn: // global
           call _c7Pf9(R1) args: 0, res: 0, upd: 0;
       c7Pfb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pf9() //  [R1]
         { info_tbl: [(c7Pf9,
                       label: block_c7Pf9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pf9: // global
           if (R1 & 7 == 1) goto c7Pfh; else goto c7Pfl;
       c7Pfh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Pfl: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.372685256 UTC

[section ""data" . GHC.IO.Buffer.bufferAdjustL_closure" {
     GHC.IO.Buffer.bufferAdjustL_closure:
         const GHC.IO.Buffer.bufferAdjustL_info;
 },
 GHC.IO.Buffer.bufferAdjustL_entry() //  [R2, R3]
         { info_tbl: [(c7Pfw,
                       label: GHC.IO.Buffer.bufferAdjustL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pfw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7PfA; else goto c7PfB;
       c7PfA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAdjustL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PfB: // global
           I64[Sp - 16] = block_c7Pft_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PfU; else goto c7Pfu;
       u7PfU: // global
           call _c7Pft(R1) args: 0, res: 0, upd: 0;
       c7Pfu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pft() //  [R1]
         { info_tbl: [(c7Pft,
                       label: block_c7Pft_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pft: // global
           I64[Sp - 32] = block_c7Pfz_info;
           _s7OLV::P64 = P64[R1 + 7];
           _s7OLW::P64 = P64[R1 + 15];
           _s7OLU::I64 = I64[R1 + 23];
           _s7OLX::I64 = I64[R1 + 31];
           _s7OLZ::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _s7OLW::P64;
           I64[Sp - 16] = _s7OLX::I64;
           I64[Sp - 8] = _s7OLZ::I64;
           P64[Sp] = _s7OLV::P64;
           I64[Sp + 8] = _s7OLU::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7PfT; else goto c7PfD;
       u7PfT: // global
           call _c7Pfz(R1) args: 0, res: 0, upd: 0;
       c7PfD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pfz() //  [R1]
         { info_tbl: [(c7Pfz,
                       label: block_c7Pfz_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pfz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PfJ; else goto c7PfI;
       c7PfJ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PfI: // global
           _s7OLU::I64 = I64[Sp + 40];
           _s7OLV::P64 = P64[Sp + 32];
           _s7OLW::P64 = P64[Sp + 8];
           _s7OLX::I64 = I64[Sp + 16];
           _s7OLZ::I64 = I64[Sp + 24];
           _s7OM1::I64 = I64[R1 + 7];
           if (_s7OM1::I64 == _s7OLZ::I64) goto c7PfS; else goto c7PfP;
       c7PfS: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7OLV::P64;
           P64[Hp - 32] = _s7OLW::P64;
           I64[Hp - 24] = _s7OLU::I64;
           I64[Hp - 16] = _s7OLX::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7PfP: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7OLV::P64;
           P64[Hp - 32] = _s7OLW::P64;
           I64[Hp - 24] = _s7OLU::I64;
           I64[Hp - 16] = _s7OLX::I64;
           I64[Hp - 8] = _s7OM1::I64;
           I64[Hp] = _s7OLZ::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.375106453 UTC

[section ""data" . GHC.IO.Buffer.emptyBuffer_closure" {
     GHC.IO.Buffer.emptyBuffer_closure:
         const GHC.IO.Buffer.emptyBuffer_info;
 },
 GHC.IO.Buffer.emptyBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Pg2,
                       label: GHC.IO.Buffer.emptyBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pg2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Pgb; else goto c7Pgc;
       c7Pgb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.emptyBuffer_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pgc: // global
           I64[Sp - 24] = block_c7PfZ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Pgi; else goto c7Pg0;
       u7Pgi: // global
           call _c7PfZ(R1) args: 0, res: 0, upd: 0;
       c7Pg0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PfZ() //  [R1]
         { info_tbl: [(c7PfZ,
                       label: block_c7PfZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PfZ: // global
           I64[Sp - 8] = block_c7Pg5_info;
           _s7OM8::P64 = P64[R1 + 7];
           _s7OM7::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OM8::P64;
           I64[Sp + 8] = _s7OM7::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pgh; else goto c7Pg6;
       u7Pgh: // global
           call _c7Pg5(R1) args: 0, res: 0, upd: 0;
       c7Pg6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pg5() //  [R1]
         { info_tbl: [(c7Pg5,
                       label: block_c7Pg5_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pg5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Pgg; else goto c7Pgf;
       c7Pgg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pgf: // global
           _s7OMa::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = _s7OMa::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.376635588 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer5_bytes" {
     GHC.IO.Buffer.summaryBuffer5_bytes:
         I8[] [98,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.377275903 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer4_bytes" {
     GHC.IO.Buffer.summaryBuffer4_bytes:
         I8[] [40]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.377895968 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer3_bytes" {
     GHC.IO.Buffer.summaryBuffer3_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.378467319 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer2_bytes" {
     GHC.IO.Buffer.summaryBuffer2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.379387426 UTC

[section ""data" . GHC.IO.Buffer.summaryBuffer1_closure" {
     GHC.IO.Buffer.summaryBuffer1_closure:
         const GHC.IO.Buffer.summaryBuffer1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Buffer.summaryBuffer1_entry() //  [R1]
         { info_tbl: [(c7Pgp,
                       label: GHC.IO.Buffer.summaryBuffer1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pgp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Pgq; else goto c7Pgr;
       c7Pgq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Pgr: // global
           (_c7Pgm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Pgm::I64 == 0) goto c7Pgo; else goto c7Pgn;
       c7Pgo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Pgn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Pgm::I64;
           R2 = GHC.IO.Buffer.summaryBuffer2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.381930555 UTC

[section ""data" . GHC.IO.Buffer.$wsummaryBuffer_closure" {
     GHC.IO.Buffer.$wsummaryBuffer_closure:
         const GHC.IO.Buffer.$wsummaryBuffer_info;
         const 0;
 },
 sat_s7OMq_entry() //  [R1]
         { info_tbl: [(c7PgX,
                       label: sat_s7OMq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PgX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7PgY; else goto c7PgZ;
       c7PgY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PgZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7PgU_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7PgU() //  [R1, R2]
         { info_tbl: [(c7PgU,
                       label: block_c7PgU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PgU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Ph2; else goto c7Ph1;
       c7Ph2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7Ph1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.IO.Buffer.summaryBuffer1_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7OMr_entry() //  [R1]
         { info_tbl: [(c7Ph3,
                       label: sat_s7OMr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ph3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Ph7; else goto c7Ph6;
       c7Ph7: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Ph6: // global
           _s7OMd::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7OMq_info;
           I64[Hp] = _s7OMd::I64;
           R3 = Hp - 16;
           R2 = GHC.IO.Buffer.summaryBuffer3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7OMs_entry() //  [R1]
         { info_tbl: [(c7Ph9,
                       label: sat_s7OMs_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ph9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Pha; else goto c7Phb;
       c7Pha: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Phb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7PgK_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7PgK() //  [R1, R2]
         { info_tbl: [(c7PgK,
                       label: block_c7PgK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PgK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Phe; else goto c7Phd;
       c7Phe: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7Phd: // global
           I64[Hp - 40] = sat_s7OMr_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7OMt_entry() //  [R1]
         { info_tbl: [(c7Phf,
                       label: sat_s7OMt_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Phf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Phj; else goto c7Phi;
       c7Phj: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Phi: // global
           _s7OMc::I64 = I64[R1 + 16];
           _s7OMd::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_s7OMs_info;
           I64[Hp - 8] = _s7OMc::I64;
           I64[Hp] = _s7OMd::I64;
           R3 = Hp - 24;
           R2 = GHC.IO.Buffer.summaryBuffer4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7OMu_entry() //  [R1]
         { info_tbl: [(c7Phl,
                       label: sat_s7OMu_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Phl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Phm; else goto c7Phn;
       c7Phm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Phn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c7PgA_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           I64[Sp - 32] = I64[R1 + 24];
           I64[Sp - 24] = I64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7PgA() //  [R1, R2]
         { info_tbl: [(c7PgA,
                       label: block_c7PgA_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PgA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Phq; else goto c7Php;
       c7Phq: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7Php: // global
           I64[Hp - 48] = sat_s7OMt_info;
           I64[Hp - 32] = I64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.$wsummaryBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Phr,
                       label: GHC.IO.Buffer.$wsummaryBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Phr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Phv; else goto c7Phu;
       c7Phv: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$wsummaryBuffer_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Phu: // global
           I64[Hp - 32] = sat_s7OMu_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R3 = Hp - 32;
           R2 = GHC.IO.Buffer.summaryBuffer5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.385746268 UTC

[section ""data" . GHC.IO.Buffer.summaryBuffer_closure" {
     GHC.IO.Buffer.summaryBuffer_closure:
         const GHC.IO.Buffer.summaryBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.summaryBuffer_entry() //  [R2]
         { info_tbl: [(c7PhD,
                       label: GHC.IO.Buffer.summaryBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PhD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PhE; else goto c7PhF;
       c7PhE: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.summaryBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PhF: // global
           I64[Sp - 8] = block_c7PhA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PhJ; else goto c7PhB;
       u7PhJ: // global
           call _c7PhA(R1) args: 0, res: 0, upd: 0;
       c7PhB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PhA() //  [R1]
         { info_tbl: [(c7PhA,
                       label: block_c7PhA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PhA: // global
           R4 = I64[R1 + 47];
           R3 = I64[R1 + 39];
           R2 = I64[R1 + 31];
           Sp = Sp + 8;
           call GHC.IO.Buffer.$wsummaryBuffer_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.386867617 UTC

[section ""cstring" . GHC.IO.Buffer.$trModule4_bytes" {
     GHC.IO.Buffer.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.387466397 UTC

[section ""data" . GHC.IO.Buffer.$trModule3_closure" {
     GHC.IO.Buffer.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.388101642 UTC

[section ""cstring" . GHC.IO.Buffer.$trModule2_bytes" {
     GHC.IO.Buffer.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.388695659 UTC

[section ""data" . GHC.IO.Buffer.$trModule1_closure" {
     GHC.IO.Buffer.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.389302891 UTC

[section ""data" . GHC.IO.Buffer.$trModule_closure" {
     GHC.IO.Buffer.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Buffer.$trModule3_closure+1;
         const GHC.IO.Buffer.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.389943151 UTC

[section ""data" . $krep_r7OJJ_closure" {
     $krep_r7OJJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.390622244 UTC

[section ""data" . $krep1_r7OJK_closure" {
     $krep1_r7OJK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.391218705 UTC

[section ""data" . $krep2_r7OJL_closure" {
     $krep2_r7OJL_closure:
         const :_con_info;
         const $krep1_r7OJK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.3918575 UTC

[section ""data" . $krep3_r7OJM_closure" {
     $krep3_r7OJM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep2_r7OJL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.392390524 UTC

[section ""cstring" . GHC.IO.Buffer.$tcBufferState2_bytes" {
     GHC.IO.Buffer.$tcBufferState2_bytes:
         I8[] [66,117,102,102,101,114,83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.392965813 UTC

[section ""data" . GHC.IO.Buffer.$tcBufferState1_closure" {
     GHC.IO.Buffer.$tcBufferState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tcBufferState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.393637984 UTC

[section ""data" . GHC.IO.Buffer.$tcBufferState_closure" {
     GHC.IO.Buffer.$tcBufferState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tcBufferState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 15354245406219544442;
         const 3075510984364124805;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.394312169 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer1_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBufferState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.394931491 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'ReadBuffer3_bytes" {
     GHC.IO.Buffer.$tc'ReadBuffer3_bytes:
         I8[] [39,82,101,97,100,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.395529457 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer2_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'ReadBuffer3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.396148125 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer2_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const 18127629064171759490;
         const 12249378994783130540;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.396756835 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'WriteBuffer2_bytes" {
     GHC.IO.Buffer.$tc'WriteBuffer2_bytes:
         I8[] [39,87,114,105,116,101,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.397355538 UTC

[section ""data" . GHC.IO.Buffer.$tc'WriteBuffer1_closure" {
     GHC.IO.Buffer.$tc'WriteBuffer1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'WriteBuffer2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.397954277 UTC

[section ""data" . GHC.IO.Buffer.$tc'WriteBuffer_closure" {
     GHC.IO.Buffer.$tc'WriteBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'WriteBuffer1_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const 17535537923682101798;
         const 5353421715631386637;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.398618111 UTC

[section ""cstring" . GHC.IO.Buffer.$tcBuffer2_bytes" {
     GHC.IO.Buffer.$tcBuffer2_bytes:
         I8[] [66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.399225504 UTC

[section ""data" . GHC.IO.Buffer.$tcBuffer1_closure" {
     GHC.IO.Buffer.$tcBuffer1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tcBuffer2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.401765578 UTC

[section ""data" . GHC.IO.Buffer.$tcBuffer_closure" {
     GHC.IO.Buffer.$tcBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tcBuffer1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 18372445388029251215;
         const 8106905342043791875;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.402402979 UTC

[section ""data" . $krep4_r7OJN_closure" {
     $krep4_r7OJN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure+1;
         const $krep2_r7OJL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.403002907 UTC

[section ""data" . $krep5_r7OJO_closure" {
     $krep5_r7OJO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep4_r7OJN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.403616448 UTC

[section ""data" . $krep6_r7OJP_closure" {
     $krep6_r7OJP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep5_r7OJO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.404225799 UTC

[section ""data" . $krep7_r7OJQ_closure" {
     $krep7_r7OJQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep6_r7OJP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.404816195 UTC

[section ""data" . $krep8_r7OJR_closure" {
     $krep8_r7OJR_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const $krep7_r7OJQ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.405753016 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer1_closure" {
     GHC.IO.Buffer.$tc'Buffer1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r7OJM_closure+1;
         const $krep8_r7OJR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.406366543 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'Buffer3_bytes" {
     GHC.IO.Buffer.$tc'Buffer3_bytes:
         I8[] [39,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.406959852 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer2_closure" {
     GHC.IO.Buffer.$tc'Buffer2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'Buffer3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.407552902 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer_closure" {
     GHC.IO.Buffer.$tc'Buffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'Buffer2_closure+1;
         const GHC.IO.Buffer.$tc'Buffer1_closure+4;
         const 6953290879310668230;
         const 8839152842293094522;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.408974926 UTC

[section ""data" . GHC.IO.Buffer.writeWord8Buf1_closure" {
     GHC.IO.Buffer.writeWord8Buf1_closure:
         const GHC.IO.Buffer.writeWord8Buf1_info;
 },
 GHC.IO.Buffer.writeWord8Buf1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PhR,
                       label: GHC.IO.Buffer.writeWord8Buf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PhR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Pi0; else goto c7Pi1;
       c7Pi0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.writeWord8Buf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pi1: // global
           I64[Sp - 24] = block_c7PhO_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Pie; else goto c7PhP;
       u7Pie: // global
           call _c7PhO(R1) args: 0, res: 0, upd: 0;
       c7PhP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PhO() //  [R1]
         { info_tbl: [(c7PhO,
                       label: block_c7PhO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PhO: // global
           I64[Sp - 8] = block_c7PhU_info;
           _s7OMJ::P64 = P64[R1 + 7];
           _s7OMI::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OMJ::P64;
           I64[Sp + 8] = _s7OMI::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pid; else goto c7PhV;
       u7Pid: // global
           call _c7PhU(R1) args: 0, res: 0, upd: 0;
       c7PhV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PhU() //  [R1]
         { info_tbl: [(c7PhU,
                       label: block_c7PhU_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PhU: // global
           I64[Sp] = block_c7PhZ_info;
           _s7OML::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7OML::I64;
           if (R1 & 7 != 0) goto u7Pif; else goto c7Pi4;
       u7Pif: // global
           call _c7PhZ(R1) args: 0, res: 0, upd: 0;
       c7Pi4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PhZ() //  [R1]
         { info_tbl: [(c7PhZ,
                       label: block_c7PhZ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PhZ: // global
           _s7OMJ::P64 = P64[Sp + 8];
           I8[I64[Sp + 16] + I64[Sp + 24]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           call MO_Touch(_s7OMJ::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.410779282 UTC

[section ""data" . GHC.IO.Buffer.writeWord8Buf_closure" {
     GHC.IO.Buffer.writeWord8Buf_closure:
         const GHC.IO.Buffer.writeWord8Buf_info;
 },
 GHC.IO.Buffer.writeWord8Buf_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Pik,
                       label: GHC.IO.Buffer.writeWord8Buf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pik: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.writeWord8Buf1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.412018616 UTC

[section ""data" . GHC.IO.Buffer.readWord8Buf1_closure" {
     GHC.IO.Buffer.readWord8Buf1_closure:
         const GHC.IO.Buffer.readWord8Buf1_info;
 },
 GHC.IO.Buffer.readWord8Buf1_entry() //  [R2, R3]
         { info_tbl: [(c7Piu,
                       label: GHC.IO.Buffer.readWord8Buf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Piu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7PiH; else goto c7PiI;
       c7PiH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.readWord8Buf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PiI: // global
           I64[Sp - 16] = block_c7Pir_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PiO; else goto c7Pis;
       u7PiO: // global
           call _c7Pir(R1) args: 0, res: 0, upd: 0;
       c7Pis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pir() //  [R1]
         { info_tbl: [(c7Pir,
                       label: block_c7Pir_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pir: // global
           I64[Sp - 8] = block_c7Pix_info;
           _s7OMW::P64 = P64[R1 + 7];
           _s7OMV::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OMW::P64;
           I64[Sp + 8] = _s7OMV::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PiN; else goto c7Piy;
       u7PiN: // global
           call _c7Pix(R1) args: 0, res: 0, upd: 0;
       c7Piy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pix() //  [R1]
         { info_tbl: [(c7Pix,
                       label: block_c7Pix_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pix: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PiM; else goto c7PiL;
       c7PiM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PiL: // global
           _s7ON2::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 16] + I64[R1 + 7]]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s7ON2::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.413598868 UTC

[section ""data" . GHC.IO.Buffer.readWord8Buf_closure" {
     GHC.IO.Buffer.readWord8Buf_closure:
         const GHC.IO.Buffer.readWord8Buf_info;
 },
 GHC.IO.Buffer.readWord8Buf_entry() //  [R2, R3]
         { info_tbl: [(c7PiT,
                       label: GHC.IO.Buffer.readWord8Buf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PiT: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.readWord8Buf1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.414887938 UTC

[section ""data" . GHC.IO.Buffer.bufferAdd_closure" {
     GHC.IO.Buffer.bufferAdd_closure:
         const GHC.IO.Buffer.bufferAdd_info;
 },
 GHC.IO.Buffer.bufferAdd_entry() //  [R2, R3]
         { info_tbl: [(c7Pj3,
                       label: GHC.IO.Buffer.bufferAdd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pj3: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c7Pjf; else goto c7Pjg;
       c7Pjf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAdd_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pjg: // global
           I64[Sp - 16] = block_c7Pj0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Pjm; else goto c7Pj1;
       u7Pjm: // global
           call _c7Pj0(R1) args: 0, res: 0, upd: 0;
       c7Pj1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pj0() //  [R1]
         { info_tbl: [(c7Pj0,
                       label: block_c7Pj0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pj0: // global
           I64[Sp - 40] = block_c7Pj6_info;
           _s7ON9::P64 = P64[R1 + 7];
           _s7ONa::P64 = P64[R1 + 15];
           _s7ON8::I64 = I64[R1 + 23];
           _s7ONb::I64 = I64[R1 + 31];
           _s7ONc::I64 = I64[R1 + 39];
           _s7ONd::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s7ONa::P64;
           I64[Sp - 24] = _s7ONb::I64;
           I64[Sp - 16] = _s7ONc::I64;
           I64[Sp - 8] = _s7ONd::I64;
           P64[Sp] = _s7ON9::P64;
           I64[Sp + 8] = _s7ON8::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Pjl; else goto c7Pj7;
       u7Pjl: // global
           call _c7Pj6(R1) args: 0, res: 0, upd: 0;
       c7Pj7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pj6() //  [R1]
         { info_tbl: [(c7Pj6,
                       label: block_c7Pj6_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pj6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Pjk; else goto c7Pjj;
       c7Pjk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pjj: // global
           _s7ONg::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = _s7ONg::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.417097734 UTC

[section ""data" . GHC.IO.Buffer.bufferRemove_closure" {
     GHC.IO.Buffer.bufferRemove_closure:
         const GHC.IO.Buffer.bufferRemove_info;
 },
 GHC.IO.Buffer.bufferRemove_entry() //  [R2, R3]
         { info_tbl: [(c7Pju,
                       label: GHC.IO.Buffer.bufferRemove_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pju: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c7Pjy; else goto c7Pjz;
       c7Pjy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferRemove_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pjz: // global
           I64[Sp - 16] = block_c7Pjr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PjV; else goto c7Pjs;
       u7PjV: // global
           call _c7Pjr(R1) args: 0, res: 0, upd: 0;
       c7Pjs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pjr() //  [R1]
         { info_tbl: [(c7Pjr,
                       label: block_c7Pjr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pjr: // global
           I64[Sp - 40] = block_c7Pjx_info;
           _s7ONl::P64 = P64[R1 + 7];
           _s7ONm::P64 = P64[R1 + 15];
           _s7ONk::I64 = I64[R1 + 23];
           _s7ONn::I64 = I64[R1 + 31];
           _s7ONo::I64 = I64[R1 + 39];
           _s7ONp::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s7ONm::P64;
           I64[Sp - 24] = _s7ONn::I64;
           I64[Sp - 16] = _s7ONo::I64;
           I64[Sp - 8] = _s7ONp::I64;
           P64[Sp] = _s7ONl::P64;
           I64[Sp + 8] = _s7ONk::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7PjU; else goto c7PjB;
       u7PjU: // global
           call _c7Pjx(R1) args: 0, res: 0, upd: 0;
       c7PjB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pjx() //  [R1]
         { info_tbl: [(c7Pjx,
                       label: block_c7Pjx_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pjx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PjH; else goto c7PjG;
       c7PjH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PjG: // global
           _s7ONk::I64 = I64[Sp + 48];
           _s7ONl::P64 = P64[Sp + 40];
           _s7ONm::P64 = P64[Sp + 8];
           _s7ONn::I64 = I64[Sp + 16];
           _s7ONp::I64 = I64[Sp + 32];
           _s7ONs::I64 = I64[Sp + 24] + I64[R1 + 7];
           if (_s7ONs::I64 == _s7ONp::I64) goto c7PjT; else goto c7PjQ;
       c7PjT: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7ONl::P64;
           P64[Hp - 32] = _s7ONm::P64;
           I64[Hp - 24] = _s7ONk::I64;
           I64[Hp - 16] = _s7ONn::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7PjQ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7ONl::P64;
           P64[Hp - 32] = _s7ONm::P64;
           I64[Hp - 24] = _s7ONk::I64;
           I64[Hp - 16] = _s7ONn::I64;
           I64[Hp - 8] = _s7ONs::I64;
           I64[Hp] = _s7ONp::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.419807408 UTC

[section ""data" . GHC.IO.Buffer.bufferAvailable_closure" {
     GHC.IO.Buffer.bufferAvailable_closure:
         const GHC.IO.Buffer.bufferAvailable_info;
 },
 GHC.IO.Buffer.bufferAvailable_entry() //  [R2]
         { info_tbl: [(c7Pk3,
                       label: GHC.IO.Buffer.bufferAvailable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pk3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Pka; else goto c7Pkb;
       c7Pka: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAvailable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pkb: // global
           I64[Sp - 8] = block_c7Pk0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pkf; else goto c7Pk1;
       u7Pkf: // global
           call _c7Pk0(R1) args: 0, res: 0, upd: 0;
       c7Pk1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pk0() //  [R1]
         { info_tbl: [(c7Pk0,
                       label: block_c7Pk0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pk0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Pke; else goto c7Pkd;
       c7Pke: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pkd: // global
           _s7ONC::I64 = I64[R1 + 31] - I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7ONC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.42122907 UTC

[section ""data" . GHC.IO.Buffer.bufferElems_closure" {
     GHC.IO.Buffer.bufferElems_closure:
         const GHC.IO.Buffer.bufferElems_info;
 },
 GHC.IO.Buffer.bufferElems_entry() //  [R2]
         { info_tbl: [(c7Pkn,
                       label: GHC.IO.Buffer.bufferElems_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pkn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Pku; else goto c7Pkv;
       c7Pku: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferElems_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pkv: // global
           I64[Sp - 8] = block_c7Pkk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pkz; else goto c7Pkl;
       u7Pkz: // global
           call _c7Pkk(R1) args: 0, res: 0, upd: 0;
       c7Pkl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pkk() //  [R1]
         { info_tbl: [(c7Pkk,
                       label: block_c7Pkk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pkk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Pky; else goto c7Pkx;
       c7Pky: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pkx: // global
           _s7ONL::I64 = I64[R1 + 47] - I64[R1 + 39];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7ONL::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.422414455 UTC

[section ""cstring" . lvl_r7OJS_bytes" {
     lvl_r7OJS_bytes:
         I8[] [98,117,102,102,101,114,32,105,110,118,97,114,105,97,110,116,32,118,105,111,108,97,116,105,111,110,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.42340092 UTC

[section ""data" . GHC.IO.Buffer.$wlvl_closure" {
     GHC.IO.Buffer.$wlvl_closure:
         const GHC.IO.Buffer.$wlvl_info;
         const 0;
 },
 sat_s7ONP_entry() //  [R1]
         { info_tbl: [(c7PkI,
                       label: sat_s7ONP_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PkI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7PkJ; else goto c7PkK;
       c7PkJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PkK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = I64[R1 + 32];
           R3 = I64[R1 + 24];
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Buffer.$wsummaryBuffer_entry(R4,
                                                    R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PkN,
                       label: GHC.IO.Buffer.$wlvl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PkN: // global
           _s7ONO::I64 = R4;
           _s7ONN::I64 = R3;
           _s7ONM::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7PkO; else goto c7PkP;
       c7PkP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7PkR; else goto c7PkQ;
       c7PkR: // global
           HpAlloc = 40;
           goto c7PkO;
       c7PkO: // global
           R4 = _s7ONO::I64;
           R3 = _s7ONN::I64;
           R2 = _s7ONM::I64;
           R1 = GHC.IO.Buffer.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PkQ: // global
           I64[Hp - 32] = sat_s7ONP_info;
           I64[Hp - 16] = _s7ONM::I64;
           I64[Hp - 8] = _s7ONN::I64;
           I64[Hp] = _s7ONO::I64;
           I64[Sp - 8] = block_c7PkL_info;
           R3 = Hp - 32;
           R2 = lvl_r7OJS_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7PkL() //  [R1]
         { info_tbl: [(c7PkL,
                       label: block_c7PkL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PkL: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.424958108 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer2_closure" {
     GHC.IO.Buffer.checkBuffer2_closure:
         const GHC.IO.Buffer.checkBuffer2_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer2_entry() //  [R2, R3]
         { info_tbl: [(c7PkZ,
                       label: GHC.IO.Buffer.checkBuffer2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PkZ: // global
           R4 = R3;
           R3 = 0;
           R2 = R2;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.426998005 UTC

[section ""data" . GHC.IO.Buffer.$wcheckBuffer_closure" {
     GHC.IO.Buffer.$wcheckBuffer_closure:
         const GHC.IO.Buffer.$wcheckBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.$wcheckBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pl3: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Buffer.$wcheckBuffer_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Buffer.$wcheckBuffer_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7Plc,
                       label: GHC.IO.Buffer.$wcheckBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Plc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Pld; else goto c7Ple;
       c7Pld: // global
           R1 = GHC.IO.Buffer.$wcheckBuffer_closure;
           P64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c7Ple: // global
           if (%MO_S_Le_W64(R3, 0)) goto u7Pmm; else goto c7Plb;
       u7Pmm: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7Pmz;
       c7Plb: // global
           if (%MO_S_Gt_W64(R4, R5)) goto u7Pmn; else goto c7Pmj;
       u7Pmn: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7Pmz;
       c7Pmj: // global
           if (%MO_S_Gt_W64(R5, R3)) goto u7Pmo; else goto c7Pmi;
       u7Pmo: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7Pmz;
       u7Pmz: // global
           call _c7Pmf() args: 0, res: 0, upd: 0;
       c7Pmi: // global
           if (R4 == R5) goto c7Ply; else goto c7Pm1;
       c7Ply: // global
           I64[Sp - 32] = block_c7Plw_info;
           R1 = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Pmv; else goto c7Plz;
       u7Pmv: // global
           call _c7Plw(R1) args: 0, res: 0, upd: 0;
       c7Plz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Pm1: // global
           I64[Sp - 32] = block_c7Pm0_info;
           R1 = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Pmw; else goto c7Pm2;
       u7Pmw: // global
           call _c7Pm0(R1) args: 0, res: 0, upd: 0;
       c7Pm2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Plw() //  [R1]
         { info_tbl: [(c7Plw,
                       label: block_c7Plw_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Plw: // global
           _s7ONU::I64 = I64[Sp + 8];
           _s7ONW::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c7PlP; else goto c7PlY;
       c7PlP: // global
           _s7OO6::I64 = I64[Sp + 16];
           if (_s7OO6::I64 != 0) goto c7PlG; else goto c7PlN;
       c7PlG: // global
           R4 = _s7ONW::I64;
           R3 = _s7OO6::I64;
           R2 = _s7ONU::I64;
           Sp = Sp + 32;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c7PlN: // global
           if (_s7ONW::I64 == 0) goto u7Pmr; else goto c7PlL;
       u7Pmr: // global
           Sp = Sp + 32;
           goto u7PmC;
       c7PlL: // global
           R3 = _s7ONW::I64;
           R2 = _s7ONU::I64;
           Sp = Sp + 32;
           call GHC.IO.Buffer.checkBuffer2_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
       c7PlY: // global
           if (%MO_S_Ge_W64(_s7ONW::I64,
                            _s7ONU::I64)) goto u7Pmq; else goto u7Pmp;
       u7Pmq: // global
           Sp = Sp + 8;
           call _c7Pmf() args: 0, res: 0, upd: 0;
       u7Pmp: // global
           Sp = Sp + 32;
           goto u7PmC;
       u7PmC: // global
           call _c7Pmg() args: 0, res: 0, upd: 0;
     }
 },
 _c7Pm0() //  [R1]
         { info_tbl: [(c7Pm0,
                       label: block_c7Pm0_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pm0: // global
           if (R1 & 7 == 1) goto u7Pms; else goto c7Pmh;
       u7Pms: // global
           Sp = Sp + 32;
           goto u7PmE;
       c7Pmh: // global
           if (%MO_S_Ge_W64(I64[Sp + 24],
                            I64[Sp + 8])) goto u7Pmu; else goto u7Pmt;
       u7Pmu: // global
           Sp = Sp + 8;
           call _c7Pmf() args: 0, res: 0, upd: 0;
       u7Pmt: // global
           Sp = Sp + 32;
           goto u7PmE;
       u7PmE: // global
           call _c7Pmg() args: 0, res: 0, upd: 0;
     }
 },
 _c7Pmf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pmf: // global
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7Pmg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pmg: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.43030406 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer1_closure" {
     GHC.IO.Buffer.checkBuffer1_closure:
         const GHC.IO.Buffer.checkBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer1_entry() //  [R2]
         { info_tbl: [(c7PmN,
                       label: GHC.IO.Buffer.checkBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PmN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PmO; else goto c7PmP;
       c7PmO: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.checkBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PmP: // global
           I64[Sp - 8] = block_c7PmK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PmT; else goto c7PmL;
       u7PmT: // global
           call _c7PmK(R1) args: 0, res: 0, upd: 0;
       c7PmL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PmK() //  [R1]
         { info_tbl: [(c7PmK,
                       label: block_c7PmK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PmK: // global
           R5 = I64[R1 + 47];
           R4 = I64[R1 + 39];
           R3 = I64[R1 + 31];
           R2 = P64[R1 + 15];
           Sp = Sp + 8;
           call GHC.IO.Buffer.$wcheckBuffer_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.431509321 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer_closure" {
     GHC.IO.Buffer.checkBuffer_closure:
         const GHC.IO.Buffer.checkBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer_entry() //  [R2]
         { info_tbl: [(c7PmY,
                       label: GHC.IO.Buffer.checkBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PmY: // global
           R2 = R2;
           call GHC.IO.Buffer.checkBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.433089451 UTC

[section ""data" . GHC.IO.Buffer.newBuffer1_closure" {
     GHC.IO.Buffer.newBuffer1_closure:
         const GHC.IO.Buffer.newBuffer1_info;
         const 0;
 },
 sat_s7OOF_entry() //  [R1]
         { info_tbl: [(c7Pno,
                       label: sat_s7OOF_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pno: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Pnw; else goto c7Pnx;
       c7Pnw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Pnx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_c7Pnl_info;
           _s7OOq::P64 = P64[R1 + 24];
           _s7OOx::P64 = P64[R1 + 32];
           _s7OOA::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _s7OOq::P64;
           P64[Sp - 32] = _s7OOx::P64;
           P64[Sp - 24] = _s7OOA::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u7PnB; else goto c7Pnm;
       u7PnB: // global
           call _c7Pnl(R1) args: 0, res: 0, upd: 0;
       c7Pnm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c7Pnl() //  [R1]
         { info_tbl: [(c7Pnl,
                       label: block_c7Pnl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pnl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c7PnA; else goto c7Pnz;
       c7PnA: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c7Pnz: // global
           _s7OOC::I64 = I64[R1 + 7];
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           _s7OOA::P64 = P64[Sp + 24];
           P64[Hp - 64] = _s7OOA::P64;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s7OOA::P64 + 16;
           I64[Hp - 16] = _s7OOC::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.newBuffer1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PnC,
                       label: GHC.IO.Buffer.newBuffer1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PnC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7PnD; else goto c7PnE;
       c7PnD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.newBuffer1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PnE: // global
           I64[Sp - 24] = block_c7Pn5_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7PnN; else goto c7Pn6;
       u7PnN: // global
           call _c7Pn5(R1) args: 0, res: 0, upd: 0;
       c7Pn6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pn5() //  [R1]
         { info_tbl: [(c7Pn5,
                       label: block_c7Pn5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pn5: // global
           _s7OOt::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7OOt::I64, 0)) goto c7PnH; else goto c7PnM;
       c7PnH: // global
           I64[Sp - 8] = block_c7Pnd_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s7OOt::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7PnM: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Pnd() //  [R1]
         { info_tbl: [(c7Pnd,
                       label: block_c7Pnd_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pnd: // global
           I64[Sp] = block_c7Pnf_info;
           _s7OOx::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7OOx::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pnf() //  [R1]
         { info_tbl: [(c7Pnf,
                       label: block_c7Pnf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pnf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7PnL; else goto c7PnK;
       c7PnL: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PnK: // global
           I64[Hp - 40] = sat_s7OOF_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.435435236 UTC

[section ""data" . GHC.IO.Buffer.newBuffer_closure" {
     GHC.IO.Buffer.newBuffer_closure:
         const GHC.IO.Buffer.newBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PnS,
                       label: GHC.IO.Buffer.newBuffer_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PnS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newBuffer1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.436282806 UTC

[section ""data" . GHC.IO.Buffer.newByteBuffer1_closure" {
     GHC.IO.Buffer.newByteBuffer1_closure:
         const GHC.IO.Buffer.newByteBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.newByteBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7PnZ,
                       label: GHC.IO.Buffer.newByteBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PnZ: // global
           R4 = R3;
           R3 = R2;
           R2 = R2;
           call GHC.IO.Buffer.newBuffer1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.437150278 UTC

[section ""data" . GHC.IO.Buffer.newByteBuffer_closure" {
     GHC.IO.Buffer.newByteBuffer_closure:
         const GHC.IO.Buffer.newByteBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newByteBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7Po6,
                       label: GHC.IO.Buffer.newByteBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Po6: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newByteBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.438444229 UTC

[section ""data" . GHC.IO.Buffer.newCharBuffer1_closure" {
     GHC.IO.Buffer.newCharBuffer1_closure:
         const GHC.IO.Buffer.newCharBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.newCharBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7Pog,
                       label: GHC.IO.Buffer.newCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pog: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Poh; else goto c7Poi;
       c7Poh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.newCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Poi: // global
           I64[Sp - 16] = block_c7Pod_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PoI; else goto c7Poe;
       u7PoI: // global
           call _c7Pod(R1) args: 0, res: 0, upd: 0;
       c7Poe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pod() //  [R1]
         { info_tbl: [(c7Pod,
                       label: block_c7Pod_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pod: // global
           _s7OON::I64 = I64[R1 + 7];
           _s7OOO::I64 = _s7OON::I64 << 2;
           if (%MO_S_Ge_W64(_s7OOO::I64, 0)) goto c7PoC; else goto c7PoH;
       c7PoC: // global
           I64[Sp - 16] = block_c7Pos_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _s7OOO::I64;
           I64[Sp] = _s7OON::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7PoH: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Pos() //  [R1]
         { info_tbl: [(c7Pos,
                       label: block_c7Pos_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pos: // global
           I64[Sp] = block_c7Pou_info;
           _s7OOS::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7OOS::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pou() //  [R1]
         { info_tbl: [(c7Pou,
                       label: block_c7Pou_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pou: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c7PoG; else goto c7PoF;
       c7PoG: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PoF: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.440140906 UTC

[section ""data" . GHC.IO.Buffer.newCharBuffer_closure" {
     GHC.IO.Buffer.newCharBuffer_closure:
         const GHC.IO.Buffer.newCharBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newCharBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7PoN,
                       label: GHC.IO.Buffer.newCharBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PoN: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newCharBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.441328389 UTC

[section ""data" . GHC.IO.Buffer.slideContents1_closure" {
     GHC.IO.Buffer.slideContents1_closure:
         const GHC.IO.Buffer.slideContents1_info;
 },
 GHC.IO.Buffer.slideContents1_entry() //  [R2]
         { info_tbl: [(c7PoX,
                       label: GHC.IO.Buffer.slideContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PoX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Ppf; else goto c7Ppg;
       c7Ppf: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.slideContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Ppg: // global
           I64[Sp - 8] = block_c7PoU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Ppk; else goto c7PoV;
       u7Ppk: // global
           call _c7PoU(R1) args: 0, res: 0, upd: 0;
       c7PoV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PoU() //  [R1]
         { info_tbl: [(c7PoU,
                       label: block_c7PoU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PoU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Ppj; else goto c7Ppi;
       c7Ppj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ppi: // global
           _s7OP4::P64 = P64[R1 + 7];
           _s7OP5::P64 = P64[R1 + 15];
           _s7OP3::I64 = I64[R1 + 23];
           _s7OP6::I64 = I64[R1 + 31];
           _s7OP7::I64 = I64[R1 + 39];
           _s7OP9::I64 = I64[R1 + 47] - _s7OP7::I64;
           (_s7OPf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_s7OP3::I64, _s7OP3::I64 + _s7OP7::I64, _s7OP9::I64);
           call MO_Touch(_s7OP4::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7OP4::P64;
           P64[Hp - 32] = _s7OP5::P64;
           I64[Hp - 24] = _s7OP3::I64;
           I64[Hp - 16] = _s7OP6::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s7OP9::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.442672166 UTC

[section ""data" . GHC.IO.Buffer.slideContents_closure" {
     GHC.IO.Buffer.slideContents_closure:
         const GHC.IO.Buffer.slideContents_info;
 },
 GHC.IO.Buffer.slideContents_entry() //  [R2]
         { info_tbl: [(c7Ppp,
                       label: GHC.IO.Buffer.slideContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ppp: // global
           R2 = R2;
           call GHC.IO.Buffer.slideContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.4438298 UTC

[section ""data" . writeCharBufPtr1_r7OJT_closure" {
     writeCharBufPtr1_r7OJT_closure:
         const writeCharBufPtr1_r7OJT_info;
 },
 writeCharBufPtr1_r7OJT_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Ppz,
                       label: writeCharBufPtr1_r7OJT_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ppz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7PpQ; else goto c7PpR;
       c7PpQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = writeCharBufPtr1_r7OJT_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PpR: // global
           I64[Sp - 24] = block_c7Ppw_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7PpY; else goto c7Ppx;
       u7PpY: // global
           call _c7Ppw(R1) args: 0, res: 0, upd: 0;
       c7Ppx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ppw() //  [R1]
         { info_tbl: [(c7Ppw,
                       label: block_c7Ppw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ppw: // global
           I64[Sp] = block_c7PpC_info;
           _s7OPn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7OPn::I64;
           if (R1 & 7 != 0) goto u7PpX; else goto c7PpD;
       u7PpX: // global
           call _c7PpC(R1) args: 0, res: 0, upd: 0;
       c7PpD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PpC() //  [R1]
         { info_tbl: [(c7PpC,
                       label: block_c7PpC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PpC: // global
           I64[Sp] = block_c7PpH_info;
           _s7OPp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7OPp::I64;
           if (R1 & 7 != 0) goto u7PpZ; else goto c7PpI;
       u7PpZ: // global
           call _c7PpH(R1) args: 0, res: 0, upd: 0;
       c7PpI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PpH() //  [R1]
         { info_tbl: [(c7PpH,
                       label: block_c7PpH_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PpH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PpW; else goto c7PpV;
       c7PpW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PpV: // global
           _s7OPp::I64 = I64[Sp + 16];
           I32[I64[Sp + 8] + (_s7OPp::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OPp::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.445485692 UTC

[section ""data" . GHC.IO.Buffer.writeCharBufPtr_closure" {
     GHC.IO.Buffer.writeCharBufPtr_closure:
         const GHC.IO.Buffer.writeCharBufPtr_info;
 },
 GHC.IO.Buffer.writeCharBufPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Pq4,
                       label: GHC.IO.Buffer.writeCharBufPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pq4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call writeCharBufPtr1_r7OJT_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.446714143 UTC

[section ""data" . writeCharBuf1_r7OJU_closure" {
     writeCharBuf1_r7OJU_closure:
         const writeCharBuf1_r7OJU_info;
 },
 writeCharBuf1_r7OJU_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Pqe,
                       label: writeCharBuf1_r7OJU_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pqe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Pqw; else goto c7Pqx;
       c7Pqw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = writeCharBuf1_r7OJU_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pqx: // global
           I64[Sp - 24] = block_c7Pqb_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7PqE; else goto c7Pqc;
       u7PqE: // global
           call _c7Pqb(R1) args: 0, res: 0, upd: 0;
       c7Pqc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pqb() //  [R1]
         { info_tbl: [(c7Pqb,
                       label: block_c7Pqb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pqb: // global
           I64[Sp - 8] = block_c7Pqh_info;
           _s7OPB::P64 = P64[R1 + 7];
           _s7OPA::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OPB::P64;
           I64[Sp + 8] = _s7OPA::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PqD; else goto c7Pqi;
       u7PqD: // global
           call _c7Pqh(R1) args: 0, res: 0, upd: 0;
       c7Pqi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pqh() //  [R1]
         { info_tbl: [(c7Pqh,
                       label: block_c7Pqh_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pqh: // global
           I64[Sp] = block_c7Pqm_info;
           _s7OPD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7OPD::I64;
           if (R1 & 7 != 0) goto u7PqF; else goto c7Pqn;
       u7PqF: // global
           call _c7Pqm(R1) args: 0, res: 0, upd: 0;
       c7Pqn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pqm() //  [R1]
         { info_tbl: [(c7Pqm,
                       label: block_c7Pqm_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pqm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PqC; else goto c7PqB;
       c7PqC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PqB: // global
           _s7OPB::P64 = P64[Sp + 8];
           _s7OPD::I64 = I64[Sp + 24];
           I32[I64[Sp + 16] + (_s7OPD::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           call MO_Touch(_s7OPB::P64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OPD::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.448475086 UTC

[section ""data" . GHC.IO.Buffer.writeCharBuf_closure" {
     GHC.IO.Buffer.writeCharBuf_closure:
         const GHC.IO.Buffer.writeCharBuf_info;
 },
 GHC.IO.Buffer.writeCharBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PqK,
                       label: GHC.IO.Buffer.writeCharBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PqK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call writeCharBuf1_r7OJU_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.449710499 UTC

[section ""data" . readCharBufPtr1_r7OJV_closure" {
     readCharBufPtr1_r7OJV_closure:
         const readCharBufPtr1_r7OJV_info;
 },
 readCharBufPtr1_r7OJV_entry() //  [R2, R3]
         { info_tbl: [(c7PqU,
                       label: readCharBufPtr1_r7OJV_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PqU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Pr8; else goto c7Pr9;
       c7Pr8: // global
           R3 = R3;
           R2 = R2;
           R1 = readCharBufPtr1_r7OJV_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pr9: // global
           I64[Sp - 16] = block_c7PqR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Prf; else goto c7PqS;
       u7Prf: // global
           call _c7PqR(R1) args: 0, res: 0, upd: 0;
       c7PqS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PqR() //  [R1]
         { info_tbl: [(c7PqR,
                       label: block_c7PqR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PqR: // global
           I64[Sp] = block_c7PqX_info;
           _s7OPO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7OPO::I64;
           if (R1 & 7 != 0) goto u7Pre; else goto c7PqY;
       u7Pre: // global
           call _c7PqX(R1) args: 0, res: 0, upd: 0;
       c7PqY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PqX() //  [R1]
         { info_tbl: [(c7PqX,
                       label: block_c7PqX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PqX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Prd; else goto c7Prc;
       c7Prd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Prc: // global
           _s7OPQ::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7OPQ::I64 + 1;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (_s7OPQ::I64 << 2)]);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.451244661 UTC

[section ""data" . GHC.IO.Buffer.readCharBufPtr_closure" {
     GHC.IO.Buffer.readCharBufPtr_closure:
         const GHC.IO.Buffer.readCharBufPtr_info;
 },
 GHC.IO.Buffer.readCharBufPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Prk,
                       label: GHC.IO.Buffer.readCharBufPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Prk: // global
           R3 = R3;
           R2 = R2;
           call readCharBufPtr1_r7OJV_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.45244917 UTC

[section ""data" . readCharBuf1_r7OJW_closure" {
     readCharBuf1_r7OJW_closure:
         const readCharBuf1_r7OJW_info;
 },
 readCharBuf1_r7OJW_entry() //  [R2, R3]
         { info_tbl: [(c7Pru,
                       label: readCharBuf1_r7OJW_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pru: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7PrJ; else goto c7PrK;
       c7PrJ: // global
           R3 = R3;
           R2 = R2;
           R1 = readCharBuf1_r7OJW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PrK: // global
           I64[Sp - 16] = block_c7Prr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PrQ; else goto c7Prs;
       u7PrQ: // global
           call _c7Prr(R1) args: 0, res: 0, upd: 0;
       c7Prs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Prr() //  [R1]
         { info_tbl: [(c7Prr,
                       label: block_c7Prr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Prr: // global
           I64[Sp - 8] = block_c7Prx_info;
           _s7OQ3::P64 = P64[R1 + 7];
           _s7OQ2::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OQ3::P64;
           I64[Sp + 8] = _s7OQ2::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PrP; else goto c7Pry;
       u7PrP: // global
           call _c7Prx(R1) args: 0, res: 0, upd: 0;
       c7Pry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Prx() //  [R1]
         { info_tbl: [(c7Prx,
                       label: block_c7Prx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Prx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PrO; else goto c7PrN;
       c7PrO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PrN: // global
           _s7OQ5::I64 = I64[R1 + 7];
           _s7OQ8::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 16] + (_s7OQ5::I64 << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7OQ5::I64 + 1;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s7OQ8::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.454036857 UTC

[section ""data" . GHC.IO.Buffer.readCharBuf_closure" {
     GHC.IO.Buffer.readCharBuf_closure:
         const GHC.IO.Buffer.readCharBuf_info;
 },
 GHC.IO.Buffer.readCharBuf_entry() //  [R2, R3]
         { info_tbl: [(c7PrV,
                       label: GHC.IO.Buffer.readCharBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PrV: // global
           R3 = R3;
           R2 = R2;
           call readCharBuf1_r7OJW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.455165857 UTC

[section ""data" . GHC.IO.Buffer.peekCharBuf1_closure" {
     GHC.IO.Buffer.peekCharBuf1_closure:
         const GHC.IO.Buffer.peekCharBuf1_info;
 },
 GHC.IO.Buffer.peekCharBuf1_entry() //  [R2, R3]
         { info_tbl: [(c7Ps5,
                       label: GHC.IO.Buffer.peekCharBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ps5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Psf; else goto c7Psg;
       c7Psf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.peekCharBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Psg: // global
           I64[Sp - 16] = block_c7Ps2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Psm; else goto c7Ps3;
       u7Psm: // global
           call _c7Ps2(R1) args: 0, res: 0, upd: 0;
       c7Ps3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ps2() //  [R1]
         { info_tbl: [(c7Ps2,
                       label: block_c7Ps2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ps2: // global
           I64[Sp - 8] = block_c7Ps8_info;
           _s7OQj::P64 = P64[R1 + 7];
           _s7OQi::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OQj::P64;
           I64[Sp + 8] = _s7OQi::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Psl; else goto c7Ps9;
       u7Psl: // global
           call _c7Ps8(R1) args: 0, res: 0, upd: 0;
       c7Ps9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ps8() //  [R1]
         { info_tbl: [(c7Ps8,
                       label: block_c7Ps8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ps8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Psk; else goto c7Psj;
       c7Psk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Psj: // global
           _s7OQo::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 16] + (I64[R1 + 7] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s7OQo::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.456645943 UTC

[section ""data" . GHC.IO.Buffer.peekCharBuf_closure" {
     GHC.IO.Buffer.peekCharBuf_closure:
         const GHC.IO.Buffer.peekCharBuf_info;
 },
 GHC.IO.Buffer.peekCharBuf_entry() //  [R2, R3]
         { info_tbl: [(c7Psr,
                       label: GHC.IO.Buffer.peekCharBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Psr: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.peekCharBuf1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.458975044 UTC

[section ""data" . GHC.IO.Buffer.ReadBuffer_closure" {
     GHC.IO.Buffer.ReadBuffer_closure:
         const GHC.IO.Buffer.ReadBuffer_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.459550495 UTC

[section ""data" . GHC.IO.Buffer.WriteBuffer_closure" {
     GHC.IO.Buffer.WriteBuffer_closure:
         const GHC.IO.Buffer.WriteBuffer_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.4604363 UTC

[section ""data" . GHC.IO.Buffer.Buffer_closure" {
     GHC.IO.Buffer.Buffer_closure:
         const GHC.IO.Buffer.Buffer_info;
 },
 GHC.IO.Buffer.Buffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Psv: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Buffer.Buffer_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2,
                                           R1) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Buffer.Buffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7PsA,
                       label: GHC.IO.Buffer.Buffer_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [True, False, False, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PsA: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PsE; else goto c7PsD;
       c7PsE: // global
           HpAlloc = 56;
           R1 = GHC.IO.Buffer.Buffer_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       c7PsD: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = R5;
           I64[Hp - 8] = R6;
           I64[Hp] = I64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.461821966 UTC

[section ""relreadonly" . GHC.IO.Buffer.BufferState_closure_tbl" {
     GHC.IO.Buffer.BufferState_closure_tbl:
         const GHC.IO.Buffer.ReadBuffer_closure+1;
         const GHC.IO.Buffer.WriteBuffer_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.462408782 UTC

[GHC.IO.Buffer.ReadBuffer_con_entry() //  [R1]
         { info_tbl: [(c7PsF,
                       label: GHC.IO.Buffer.ReadBuffer_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,82,101,97,100,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PsF: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.463165009 UTC

[GHC.IO.Buffer.WriteBuffer_con_entry() //  [R1]
         { info_tbl: [(c7PsH,
                       label: GHC.IO.Buffer.WriteBuffer_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,87,114,105,116,101,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PsH: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.463849132 UTC

[GHC.IO.Buffer.Buffer_con_entry() //  [R1]
         { info_tbl: [(c7PsJ,
                       label: GHC.IO.Buffer.Buffer_con_info
                       rep:HeapRep 2 ptrs 4 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PsJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.464527695 UTC

[section ""relreadonly" . S7OYn_srt" {
     S7OYn_srt:
         const GHC.IO.Buffer.summaryBuffer1_closure;
         const GHC.IO.Buffer.$wsummaryBuffer_closure;
         const GHC.IO.Buffer.summaryBuffer_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Buffer.$wlvl_closure;
         const GHC.IO.Buffer.$wcheckBuffer_closure;
         const GHC.IO.Buffer.checkBuffer2_closure;
         const GHC.IO.Buffer.checkBuffer1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const GHC.IO.Buffer.newBuffer1_closure;
         const GHC.IO.Buffer.newByteBuffer1_closure;
         const GHC.IO.Buffer.newCharBuffer1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.46542432 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:55.467154139 UTC

[section ""data" . GHC.IO.Buffer.$WBuffer_closure" {
     GHC.IO.Buffer.$WBuffer_closure:
         const GHC.IO.Buffer.$WBuffer_info;
 },
 GHC.IO.Buffer.$WBuffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7PsS,
                       label: GHC.IO.Buffer.$WBuffer_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PsS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Ptb; else goto c7Ptc;
       c7Ptb: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$WBuffer_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ptc: // global
           I64[Sp - 40] = block_c7PsP_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Ptk; else goto c7PsQ;
       u7Ptk: // global
           call _c7PsP(R1) args: 0, res: 0, upd: 0;
       c7PsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PsP() //  [R1]
         { info_tbl: [(c7PsP,
                       label: block_c7PsP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PsP: // global
           I64[Sp - 8] = block_c7PsV_info;
           _s7OK5::P64 = P64[R1 + 7];
           _s7OK4::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s7OK5::P64;
           I64[Sp + 16] = _s7OK4::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Ptj; else goto c7PsW;
       u7Ptj: // global
           call _c7PsV(R1) args: 0, res: 0, upd: 0;
       c7PsW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PsV() //  [R1]
         { info_tbl: [(c7PsV,
                       label: block_c7PsV_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PsV: // global
           I64[Sp] = block_c7Pt0_info;
           _s7OK7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _s7OK7::I64;
           if (R1 & 7 != 0) goto u7Ptl; else goto c7Pt1;
       u7Ptl: // global
           call _c7Pt0(R1) args: 0, res: 0, upd: 0;
       c7Pt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pt0() //  [R1]
         { info_tbl: [(c7Pt0,
                       label: block_c7Pt0_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pt0: // global
           I64[Sp] = block_c7Pt5_info;
           _s7OK9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _s7OK9::I64;
           if (R1 & 7 != 0) goto u7Ptm; else goto c7Pt6;
       u7Ptm: // global
           call _c7Pt5(R1) args: 0, res: 0, upd: 0;
       c7Pt6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pt5() //  [R1]
         { info_tbl: [(c7Pt5,
                       label: block_c7Pt5_info
                       rep:StackRep [False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pt5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Pti; else goto c7Pth;
       c7Pti: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pth: // global
           _s7OKb::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s7OKb::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.479990073 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_$c==_closure" {
     GHC.IO.Buffer.$fEqBufferState_$c==_closure:
         const GHC.IO.Buffer.$fEqBufferState_$c==_info;
 },
 GHC.IO.Buffer.$fEqBufferState_$c==_entry() //  [R2, R3]
         { info_tbl: [(c7PtZ,
                       label: GHC.IO.Buffer.$fEqBufferState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PtZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Pu0; else goto c7Pu1;
       c7Pu0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$fEqBufferState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pu1: // global
           I64[Sp - 16] = block_c7PtS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PuE; else goto c7PtT;
       u7PuE: // global
           call _c7PtS(R1) args: 0, res: 0, upd: 0;
       c7PtT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PtS() //  [R1]
         { info_tbl: [(c7PtS,
                       label: block_c7PtS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PtS: // global
           _s7OKd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7PtW; else goto c7PtX;
       c7PtW: // global
           I64[Sp + 8] = block_c7Pu4_info;
           R1 = _s7OKd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7PuC; else goto c7Pu6;
       u7PuC: // global
           call _c7Pu4(R1) args: 0, res: 0, upd: 0;
       c7Pu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7PtX: // global
           I64[Sp + 8] = block_c7Puj_info;
           R1 = _s7OKd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7PuD; else goto c7Pul;
       u7PuD: // global
           call _c7Puj(R1) args: 0, res: 0, upd: 0;
       c7Pul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pu4() //  [R1]
         { info_tbl: [(c7Pu4,
                       label: block_c7Pu4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pu4: // global
           if (R1 & 7 == 1) goto u7PuA; else goto u7PuB;
       u7PuA: // global
           Sp = Sp + 8;
           call _c7Puv() args: 0, res: 0, upd: 0;
       u7PuB: // global
           Sp = Sp + 8;
           call _c7Pur() args: 0, res: 0, upd: 0;
     }
 },
 _c7Puj() //  [R1]
         { info_tbl: [(c7Puj,
                       label: block_c7Puj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Puj: // global
           if (R1 & 7 == 1) goto u7Puy; else goto u7Puz;
       u7Puy: // global
           Sp = Sp + 8;
           call _c7Pur() args: 0, res: 0, upd: 0;
       u7Puz: // global
           Sp = Sp + 8;
           call _c7Puv() args: 0, res: 0, upd: 0;
     }
 },
 _c7Pur() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pur: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Puv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Puv: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.49201065 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_$c/=_closure" {
     GHC.IO.Buffer.$fEqBufferState_$c/=_closure:
         const GHC.IO.Buffer.$fEqBufferState_$c/=_info;
 },
 GHC.IO.Buffer.$fEqBufferState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c7Pvn,
                       label: GHC.IO.Buffer.$fEqBufferState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pvn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Pvo; else goto c7Pvp;
       c7Pvo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$fEqBufferState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Pvp: // global
           I64[Sp - 16] = block_c7Pvg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Pw2; else goto c7Pvh;
       u7Pw2: // global
           call _c7Pvg(R1) args: 0, res: 0, upd: 0;
       c7Pvh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pvg() //  [R1]
         { info_tbl: [(c7Pvg,
                       label: block_c7Pvg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pvg: // global
           _s7OKi::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7Pvk; else goto c7Pvl;
       c7Pvk: // global
           I64[Sp + 8] = block_c7Pvs_info;
           R1 = _s7OKi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Pw0; else goto c7Pvu;
       u7Pw0: // global
           call _c7Pvs(R1) args: 0, res: 0, upd: 0;
       c7Pvu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Pvl: // global
           I64[Sp + 8] = block_c7PvH_info;
           R1 = _s7OKi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Pw1; else goto c7PvJ;
       u7Pw1: // global
           call _c7PvH(R1) args: 0, res: 0, upd: 0;
       c7PvJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pvs() //  [R1]
         { info_tbl: [(c7Pvs,
                       label: block_c7Pvs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pvs: // global
           if (R1 & 7 == 1) goto u7PvY; else goto u7PvZ;
       u7PvY: // global
           Sp = Sp + 8;
           call _c7PvT() args: 0, res: 0, upd: 0;
       u7PvZ: // global
           Sp = Sp + 8;
           call _c7PvP() args: 0, res: 0, upd: 0;
     }
 },
 _c7PvH() //  [R1]
         { info_tbl: [(c7PvH,
                       label: block_c7PvH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PvH: // global
           if (R1 & 7 == 1) goto u7PvW; else goto u7PvX;
       u7PvW: // global
           Sp = Sp + 8;
           call _c7PvP() args: 0, res: 0, upd: 0;
       u7PvX: // global
           Sp = Sp + 8;
           call _c7PvT() args: 0, res: 0, upd: 0;
     }
 },
 _c7PvP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PvP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7PvT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PvT: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.504318494 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_closure" {
     GHC.IO.Buffer.$fEqBufferState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Buffer.$fEqBufferState_$c==_closure+2;
         const GHC.IO.Buffer.$fEqBufferState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.506473888 UTC

[section ""data" . GHC.IO.Buffer.bufR_closure" {
     GHC.IO.Buffer.bufR_closure:
         const GHC.IO.Buffer.bufR_info;
 },
 GHC.IO.Buffer.bufR_entry() //  [R2]
         { info_tbl: [(c7PwI,
                       label: GHC.IO.Buffer.bufR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PwI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PwM; else goto c7PwN;
       c7PwM: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PwN: // global
           I64[Sp - 8] = block_c7PwF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PwR; else goto c7PwG;
       u7PwR: // global
           call _c7PwF(R1) args: 0, res: 0, upd: 0;
       c7PwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PwF() //  [R1]
         { info_tbl: [(c7PwF,
                       label: block_c7PwF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PwF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PwQ; else goto c7PwP;
       c7PwQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PwP: // global
           _s7OKt::I64 = I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OKt::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.512234499 UTC

[section ""data" . GHC.IO.Buffer.bufL_closure" {
     GHC.IO.Buffer.bufL_closure:
         const GHC.IO.Buffer.bufL_info;
 },
 GHC.IO.Buffer.bufL_entry() //  [R2]
         { info_tbl: [(c7Px9,
                       label: GHC.IO.Buffer.bufL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Px9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Pxd; else goto c7Pxe;
       c7Pxd: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pxe: // global
           I64[Sp - 8] = block_c7Px6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pxi; else goto c7Px7;
       u7Pxi: // global
           call _c7Px6(R1) args: 0, res: 0, upd: 0;
       c7Px7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Px6() //  [R1]
         { info_tbl: [(c7Px6,
                       label: block_c7Px6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Px6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Pxh; else goto c7Pxg;
       c7Pxh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pxg: // global
           _s7OKA::I64 = I64[R1 + 39];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OKA::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.51804494 UTC

[section ""data" . GHC.IO.Buffer.bufSize_closure" {
     GHC.IO.Buffer.bufSize_closure:
         const GHC.IO.Buffer.bufSize_info;
 },
 GHC.IO.Buffer.bufSize_entry() //  [R2]
         { info_tbl: [(c7PxA,
                       label: GHC.IO.Buffer.bufSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PxA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PxE; else goto c7PxF;
       c7PxE: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PxF: // global
           I64[Sp - 8] = block_c7Pxx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PxJ; else goto c7Pxy;
       u7PxJ: // global
           call _c7Pxx(R1) args: 0, res: 0, upd: 0;
       c7Pxy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pxx() //  [R1]
         { info_tbl: [(c7Pxx,
                       label: block_c7Pxx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pxx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PxI; else goto c7PxH;
       c7PxI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PxH: // global
           _s7OKH::I64 = I64[R1 + 31];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OKH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.52367619 UTC

[section ""data" . GHC.IO.Buffer.bufState_closure" {
     GHC.IO.Buffer.bufState_closure:
         const GHC.IO.Buffer.bufState_info;
 },
 GHC.IO.Buffer.bufState_entry() //  [R2]
         { info_tbl: [(c7Py1,
                       label: GHC.IO.Buffer.bufState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Py1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Py2; else goto c7Py3;
       c7Py2: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Py3: // global
           I64[Sp - 8] = block_c7PxY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Py7; else goto c7PxZ;
       u7Py7: // global
           call _c7PxY(R1) args: 0, res: 0, upd: 0;
       c7PxZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PxY() //  [R1]
         { info_tbl: [(c7PxY,
                       label: block_c7PxY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PxY: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.529768979 UTC

[section ""data" . GHC.IO.Buffer.bufRaw_closure" {
     GHC.IO.Buffer.bufRaw_closure:
         const GHC.IO.Buffer.bufRaw_info;
 },
 GHC.IO.Buffer.bufRaw_entry() //  [R2]
         { info_tbl: [(c7Pyq,
                       label: GHC.IO.Buffer.bufRaw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pyq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Pyu; else goto c7Pyv;
       c7Pyu: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufRaw_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Pyv: // global
           I64[Sp - 8] = block_c7Pyn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Pyz; else goto c7Pyo;
       u7Pyz: // global
           call _c7Pyn(R1) args: 0, res: 0, upd: 0;
       c7Pyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Pyn() //  [R1]
         { info_tbl: [(c7Pyn,
                       label: block_c7Pyn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pyn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Pyy; else goto c7Pyx;
       c7Pyy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pyx: // global
           _s7OKV::P64 = P64[R1 + 7];
           _s7OKU::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = _s7OKV::P64;
           I64[Hp] = _s7OKU::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.535958177 UTC

[section ""data" . GHC.IO.Buffer.charSize_closure" {
     GHC.IO.Buffer.charSize_closure:
         const GHC.Types.I#_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.538480225 UTC

[section ""data" . GHC.IO.Buffer.withBuffer1_closure" {
     GHC.IO.Buffer.withBuffer1_closure:
         const GHC.IO.Buffer.withBuffer1_info;
 },
 GHC.IO.Buffer.withBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7PyS,
                       label: GHC.IO.Buffer.withBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PyS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7PyT; else goto c7PyU;
       c7PyT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.withBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PyU: // global
           I64[Sp - 16] = block_c7PyP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Pz5; else goto c7PyQ;
       u7Pz5: // global
           call _c7PyP(R1) args: 0, res: 0, upd: 0;
       c7PyQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PyP() //  [R1]
         { info_tbl: [(c7PyP,
                       label: block_c7PyP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PyP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Pz1; else goto c7Pz0;
       c7Pz1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Pz0: // global
           _s7OL5::P64 = P64[R1 + 7];
           _s7OL4::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7OL4::I64;
           I64[Sp] = block_c7PyY_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7OL5::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PyY() //  [R1]
         { info_tbl: [(c7PyY,
                       label: block_c7PyY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PyY: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.548299554 UTC

[section ""data" . GHC.IO.Buffer.withBuffer_closure" {
     GHC.IO.Buffer.withBuffer_closure:
         const GHC.IO.Buffer.withBuffer_info;
 },
 GHC.IO.Buffer.withBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7Pzn,
                       label: GHC.IO.Buffer.withBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Pzn: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.withBuffer1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.552223866 UTC

[section ""data" . GHC.IO.Buffer.withRawBuffer1_closure" {
     GHC.IO.Buffer.withRawBuffer1_closure:
         const GHC.IO.Buffer.withRawBuffer1_info;
 },
 sat_s7OLi_entry() //  [R1]
         { info_tbl: [(c7PzC,
                       label: sat_s7OLi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PzC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7PzD; else goto c7PzE;
       c7PzD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PzE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.ForeignPtr.unsafeForeignPtrToPtr_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.withRawBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7PzK,
                       label: GHC.IO.Buffer.withRawBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PzK: // global
           _s7OLg::P64 = R3;
           _s7OLf::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c7PzL; else goto c7PzM;
       c7PzM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7PzO; else goto c7PzN;
       c7PzO: // global
           HpAlloc = 24;
           goto c7PzL;
       c7PzL: // global
           R3 = _s7OLg::P64;
           R2 = _s7OLf::P64;
           R1 = GHC.IO.Buffer.withRawBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PzN: // global
           I64[Hp - 16] = sat_s7OLi_info;
           P64[Hp] = _s7OLf::P64;
           I64[Sp - 16] = block_c7PzF_info;
           R2 = Hp - 16;
           R1 = _s7OLg::P64;
           P64[Sp - 8] = _s7OLf::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PzF() //  [R1]
         { info_tbl: [(c7PzF,
                       label: block_c7PzF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PzF: // global
           I64[Sp] = block_c7PzH_info;
           _s7OLl::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7OLl::P64;
           if (R1 & 7 != 0) goto u7PzU; else goto c7PzI;
       u7PzU: // global
           call _c7PzH(R1) args: 0, res: 0, upd: 0;
       c7PzI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PzH() //  [R1]
         { info_tbl: [(c7PzH,
                       label: block_c7PzH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PzH: // global
           _s7OLl::P64 = P64[Sp + 8];
           call MO_Touch(P64[R1 + 7]);
           R1 = _s7OLl::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.561222501 UTC

[section ""data" . GHC.IO.Buffer.withRawBuffer_closure" {
     GHC.IO.Buffer.withRawBuffer_closure:
         const GHC.IO.Buffer.withRawBuffer_info;
 },
 GHC.IO.Buffer.withRawBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7PAg,
                       label: GHC.IO.Buffer.withRawBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PAg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.withRawBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.564726157 UTC

[section ""data" . GHC.IO.Buffer.isEmptyBuffer_closure" {
     GHC.IO.Buffer.isEmptyBuffer_closure:
         const GHC.IO.Buffer.isEmptyBuffer_info;
 },
 GHC.IO.Buffer.isEmptyBuffer_entry() //  [R2]
         { info_tbl: [(c7PAu,
                       label: GHC.IO.Buffer.isEmptyBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PAu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PAv; else goto c7PAw;
       c7PAv: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isEmptyBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PAw: // global
           I64[Sp - 8] = block_c7PAr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PAB; else goto c7PAs;
       u7PAB: // global
           call _c7PAr(R1) args: 0, res: 0, upd: 0;
       c7PAs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PAr() //  [R1]
         { info_tbl: [(c7PAr,
                       label: block_c7PAr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PAr: // global
           R1 = I64[((I64[R1 + 39] == I64[R1 + 47]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.570974155 UTC

[section ""data" . GHC.IO.Buffer.isFullBuffer_closure" {
     GHC.IO.Buffer.isFullBuffer_closure:
         const GHC.IO.Buffer.isFullBuffer_info;
 },
 GHC.IO.Buffer.isFullBuffer_entry() //  [R2]
         { info_tbl: [(c7PAW,
                       label: GHC.IO.Buffer.isFullBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PAW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PAX; else goto c7PAY;
       c7PAX: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isFullBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PAY: // global
           I64[Sp - 8] = block_c7PAT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PB3; else goto c7PAU;
       u7PB3: // global
           call _c7PAT(R1) args: 0, res: 0, upd: 0;
       c7PAU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PAT() //  [R1]
         { info_tbl: [(c7PAT,
                       label: block_c7PAT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PAT: // global
           R1 = I64[((I64[R1 + 31] == I64[R1 + 47]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.576966206 UTC

[section ""data" . GHC.IO.Buffer.isFullCharBuffer_closure" {
     GHC.IO.Buffer.isFullCharBuffer_closure:
         const GHC.IO.Buffer.isFullCharBuffer_info;
 },
 GHC.IO.Buffer.isFullCharBuffer_entry() //  [R2]
         { info_tbl: [(c7PBl,
                       label: GHC.IO.Buffer.isFullCharBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PBl: // global
           R2 = R2;
           call GHC.IO.Buffer.isFullBuffer_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.58097491 UTC

[section ""data" . GHC.IO.Buffer.isWriteBuffer_closure" {
     GHC.IO.Buffer.isWriteBuffer_closure:
         const GHC.IO.Buffer.isWriteBuffer_info;
 },
 GHC.IO.Buffer.isWriteBuffer_entry() //  [R2]
         { info_tbl: [(c7PBz,
                       label: GHC.IO.Buffer.isWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PBz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PBA; else goto c7PBB;
       c7PBA: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isWriteBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PBB: // global
           I64[Sp - 8] = block_c7PBw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PBT; else goto c7PBx;
       u7PBT: // global
           call _c7PBw(R1) args: 0, res: 0, upd: 0;
       c7PBx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PBw() //  [R1]
         { info_tbl: [(c7PBw,
                       label: block_c7PBw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PBw: // global
           I64[Sp] = block_c7PBE_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto u7PBS; else goto c7PBG;
       u7PBS: // global
           call _c7PBE(R1) args: 0, res: 0, upd: 0;
       c7PBG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PBE() //  [R1]
         { info_tbl: [(c7PBE,
                       label: block_c7PBE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PBE: // global
           if (R1 & 7 == 1) goto c7PBM; else goto c7PBQ;
       c7PBM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7PBQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.588674414 UTC

[section ""data" . GHC.IO.Buffer.bufferAdjustL_closure" {
     GHC.IO.Buffer.bufferAdjustL_closure:
         const GHC.IO.Buffer.bufferAdjustL_info;
 },
 GHC.IO.Buffer.bufferAdjustL_entry() //  [R2, R3]
         { info_tbl: [(c7PCi,
                       label: GHC.IO.Buffer.bufferAdjustL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PCi: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7PCm; else goto c7PCn;
       c7PCm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAdjustL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PCn: // global
           I64[Sp - 16] = block_c7PCf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PCG; else goto c7PCg;
       u7PCG: // global
           call _c7PCf(R1) args: 0, res: 0, upd: 0;
       c7PCg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PCf() //  [R1]
         { info_tbl: [(c7PCf,
                       label: block_c7PCf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PCf: // global
           I64[Sp - 32] = block_c7PCl_info;
           _s7OLV::P64 = P64[R1 + 7];
           _s7OLW::P64 = P64[R1 + 15];
           _s7OLU::I64 = I64[R1 + 23];
           _s7OLX::I64 = I64[R1 + 31];
           _s7OLZ::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _s7OLW::P64;
           I64[Sp - 16] = _s7OLX::I64;
           I64[Sp - 8] = _s7OLZ::I64;
           P64[Sp] = _s7OLV::P64;
           I64[Sp + 8] = _s7OLU::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7PCF; else goto c7PCp;
       u7PCF: // global
           call _c7PCl(R1) args: 0, res: 0, upd: 0;
       c7PCp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PCl() //  [R1]
         { info_tbl: [(c7PCl,
                       label: block_c7PCl_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PCl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PCv; else goto c7PCu;
       c7PCv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PCu: // global
           _s7OLU::I64 = I64[Sp + 40];
           _s7OLV::P64 = P64[Sp + 32];
           _s7OLW::P64 = P64[Sp + 8];
           _s7OLX::I64 = I64[Sp + 16];
           _s7OLZ::I64 = I64[Sp + 24];
           _s7OM1::I64 = I64[R1 + 7];
           if (_s7OM1::I64 == _s7OLZ::I64) goto c7PCE; else goto c7PCB;
       c7PCE: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7OLV::P64;
           P64[Hp - 32] = _s7OLW::P64;
           I64[Hp - 24] = _s7OLU::I64;
           I64[Hp - 16] = _s7OLX::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7PCB: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7OLV::P64;
           P64[Hp - 32] = _s7OLW::P64;
           I64[Hp - 24] = _s7OLU::I64;
           I64[Hp - 16] = _s7OLX::I64;
           I64[Hp - 8] = _s7OM1::I64;
           I64[Hp] = _s7OLZ::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.597905474 UTC

[section ""data" . GHC.IO.Buffer.emptyBuffer_closure" {
     GHC.IO.Buffer.emptyBuffer_closure:
         const GHC.IO.Buffer.emptyBuffer_info;
 },
 GHC.IO.Buffer.emptyBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PD3,
                       label: GHC.IO.Buffer.emptyBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PD3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7PDc; else goto c7PDd;
       c7PDc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.emptyBuffer_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PDd: // global
           I64[Sp - 24] = block_c7PD0_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7PDj; else goto c7PD1;
       u7PDj: // global
           call _c7PD0(R1) args: 0, res: 0, upd: 0;
       c7PD1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PD0() //  [R1]
         { info_tbl: [(c7PD0,
                       label: block_c7PD0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PD0: // global
           I64[Sp - 8] = block_c7PD6_info;
           _s7OM8::P64 = P64[R1 + 7];
           _s7OM7::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OM8::P64;
           I64[Sp + 8] = _s7OM7::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PDi; else goto c7PD7;
       u7PDi: // global
           call _c7PD6(R1) args: 0, res: 0, upd: 0;
       c7PD7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PD6() //  [R1]
         { info_tbl: [(c7PD6,
                       label: block_c7PD6_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PD6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PDh; else goto c7PDg;
       c7PDh: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PDg: // global
           _s7OMa::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = _s7OMa::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.605662744 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer5_bytes" {
     GHC.IO.Buffer.summaryBuffer5_bytes:
         I8[] [98,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.607338052 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer4_bytes" {
     GHC.IO.Buffer.summaryBuffer4_bytes:
         I8[] [40]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.609576357 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer3_bytes" {
     GHC.IO.Buffer.summaryBuffer3_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.611254441 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer2_bytes" {
     GHC.IO.Buffer.summaryBuffer2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.613311111 UTC

[section ""data" . GHC.IO.Buffer.summaryBuffer1_closure" {
     GHC.IO.Buffer.summaryBuffer1_closure:
         const GHC.IO.Buffer.summaryBuffer1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Buffer.summaryBuffer1_entry() //  [R1]
         { info_tbl: [(c7PDL,
                       label: GHC.IO.Buffer.summaryBuffer1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PDL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7PDM; else goto c7PDN;
       c7PDM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PDN: // global
           (_c7PDI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7PDI::I64 == 0) goto c7PDK; else goto c7PDJ;
       c7PDK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7PDJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7PDI::I64;
           R2 = GHC.IO.Buffer.summaryBuffer2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.618742573 UTC

[section ""data" . GHC.IO.Buffer.$wsummaryBuffer_closure" {
     GHC.IO.Buffer.$wsummaryBuffer_closure:
         const GHC.IO.Buffer.$wsummaryBuffer_info;
         const 0;
 },
 sat_s7OMq_entry() //  [R1]
         { info_tbl: [(c7PEq,
                       label: sat_s7OMq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PEq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7PEr; else goto c7PEs;
       c7PEr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PEs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7PEn_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7PEn() //  [R1, R2]
         { info_tbl: [(c7PEn,
                       label: block_c7PEn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PEn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7PEv; else goto c7PEu;
       c7PEv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7PEu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.IO.Buffer.summaryBuffer1_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7OMr_entry() //  [R1]
         { info_tbl: [(c7PEw,
                       label: sat_s7OMr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PEw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7PEA; else goto c7PEz;
       c7PEA: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PEz: // global
           _s7OMd::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7OMq_info;
           I64[Hp] = _s7OMd::I64;
           R3 = Hp - 16;
           R2 = GHC.IO.Buffer.summaryBuffer3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7OMs_entry() //  [R1]
         { info_tbl: [(c7PEC,
                       label: sat_s7OMs_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PEC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7PED; else goto c7PEE;
       c7PED: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PEE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7PEd_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7PEd() //  [R1, R2]
         { info_tbl: [(c7PEd,
                       label: block_c7PEd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PEd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7PEH; else goto c7PEG;
       c7PEH: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7PEG: // global
           I64[Hp - 40] = sat_s7OMr_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7OMt_entry() //  [R1]
         { info_tbl: [(c7PEI,
                       label: sat_s7OMt_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PEI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7PEM; else goto c7PEL;
       c7PEM: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PEL: // global
           _s7OMc::I64 = I64[R1 + 16];
           _s7OMd::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_s7OMs_info;
           I64[Hp - 8] = _s7OMc::I64;
           I64[Hp] = _s7OMd::I64;
           R3 = Hp - 24;
           R2 = GHC.IO.Buffer.summaryBuffer4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7OMu_entry() //  [R1]
         { info_tbl: [(c7PEO,
                       label: sat_s7OMu_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PEO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7PEP; else goto c7PEQ;
       c7PEP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PEQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c7PE3_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           I64[Sp - 32] = I64[R1 + 24];
           I64[Sp - 24] = I64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7PE3() //  [R1, R2]
         { info_tbl: [(c7PE3,
                       label: block_c7PE3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PE3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PET; else goto c7PES;
       c7PET: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7PES: // global
           I64[Hp - 48] = sat_s7OMt_info;
           I64[Hp - 32] = I64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.$wsummaryBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PEU,
                       label: GHC.IO.Buffer.$wsummaryBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PEU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7PEY; else goto c7PEX;
       c7PEY: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$wsummaryBuffer_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PEX: // global
           I64[Hp - 32] = sat_s7OMu_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R3 = Hp - 32;
           R2 = GHC.IO.Buffer.summaryBuffer5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.639080844 UTC

[section ""data" . GHC.IO.Buffer.summaryBuffer_closure" {
     GHC.IO.Buffer.summaryBuffer_closure:
         const GHC.IO.Buffer.summaryBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.summaryBuffer_entry() //  [R2]
         { info_tbl: [(c7PFH,
                       label: GHC.IO.Buffer.summaryBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PFH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PFI; else goto c7PFJ;
       c7PFI: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.summaryBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PFJ: // global
           I64[Sp - 8] = block_c7PFE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PFN; else goto c7PFF;
       u7PFN: // global
           call _c7PFE(R1) args: 0, res: 0, upd: 0;
       c7PFF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PFE() //  [R1]
         { info_tbl: [(c7PFE,
                       label: block_c7PFE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PFE: // global
           R4 = I64[R1 + 47];
           R3 = I64[R1 + 39];
           R2 = I64[R1 + 31];
           Sp = Sp + 8;
           call GHC.IO.Buffer.$wsummaryBuffer_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.644424864 UTC

[section ""cstring" . GHC.IO.Buffer.$trModule4_bytes" {
     GHC.IO.Buffer.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.647031652 UTC

[section ""data" . GHC.IO.Buffer.$trModule3_closure" {
     GHC.IO.Buffer.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.648745138 UTC

[section ""cstring" . GHC.IO.Buffer.$trModule2_bytes" {
     GHC.IO.Buffer.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.650418206 UTC

[section ""data" . GHC.IO.Buffer.$trModule1_closure" {
     GHC.IO.Buffer.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.652105725 UTC

[section ""data" . GHC.IO.Buffer.$trModule_closure" {
     GHC.IO.Buffer.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Buffer.$trModule3_closure+1;
         const GHC.IO.Buffer.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.653816573 UTC

[section ""data" . $krep_r7OJJ_closure" {
     $krep_r7OJJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.655551033 UTC

[section ""data" . $krep1_r7OJK_closure" {
     $krep1_r7OJK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.657848849 UTC

[section ""data" . $krep2_r7OJL_closure" {
     $krep2_r7OJL_closure:
         const :_con_info;
         const $krep1_r7OJK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.659613865 UTC

[section ""data" . $krep3_r7OJM_closure" {
     $krep3_r7OJM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep2_r7OJL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.661320791 UTC

[section ""cstring" . GHC.IO.Buffer.$tcBufferState2_bytes" {
     GHC.IO.Buffer.$tcBufferState2_bytes:
         I8[] [66,117,102,102,101,114,83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.662963703 UTC

[section ""data" . GHC.IO.Buffer.$tcBufferState1_closure" {
     GHC.IO.Buffer.$tcBufferState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tcBufferState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.664683904 UTC

[section ""data" . GHC.IO.Buffer.$tcBufferState_closure" {
     GHC.IO.Buffer.$tcBufferState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tcBufferState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 15354245406219544442;
         const 3075510984364124805;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.666450158 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer1_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBufferState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.668169061 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'ReadBuffer3_bytes" {
     GHC.IO.Buffer.$tc'ReadBuffer3_bytes:
         I8[] [39,82,101,97,100,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.669889152 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer2_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'ReadBuffer3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.672127043 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer2_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const 18127629064171759490;
         const 12249378994783130540;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.674380163 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'WriteBuffer2_bytes" {
     GHC.IO.Buffer.$tc'WriteBuffer2_bytes:
         I8[] [39,87,114,105,116,101,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.676001604 UTC

[section ""data" . GHC.IO.Buffer.$tc'WriteBuffer1_closure" {
     GHC.IO.Buffer.$tc'WriteBuffer1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'WriteBuffer2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.677712259 UTC

[section ""data" . GHC.IO.Buffer.$tc'WriteBuffer_closure" {
     GHC.IO.Buffer.$tc'WriteBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'WriteBuffer1_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const 17535537923682101798;
         const 5353421715631386637;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.679521546 UTC

[section ""cstring" . GHC.IO.Buffer.$tcBuffer2_bytes" {
     GHC.IO.Buffer.$tcBuffer2_bytes:
         I8[] [66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.681129112 UTC

[section ""data" . GHC.IO.Buffer.$tcBuffer1_closure" {
     GHC.IO.Buffer.$tcBuffer1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tcBuffer2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.682796666 UTC

[section ""data" . GHC.IO.Buffer.$tcBuffer_closure" {
     GHC.IO.Buffer.$tcBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tcBuffer1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 18372445388029251215;
         const 8106905342043791875;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.684608457 UTC

[section ""data" . $krep4_r7OJN_closure" {
     $krep4_r7OJN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure+1;
         const $krep2_r7OJL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.686390833 UTC

[section ""data" . $krep5_r7OJO_closure" {
     $krep5_r7OJO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep4_r7OJN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.688099089 UTC

[section ""data" . $krep6_r7OJP_closure" {
     $krep6_r7OJP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep5_r7OJO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.68985265 UTC

[section ""data" . $krep7_r7OJQ_closure" {
     $krep7_r7OJQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep6_r7OJP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.691510653 UTC

[section ""data" . $krep8_r7OJR_closure" {
     $krep8_r7OJR_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const $krep7_r7OJQ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.693209887 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer1_closure" {
     GHC.IO.Buffer.$tc'Buffer1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r7OJM_closure+1;
         const $krep8_r7OJR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.695507528 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'Buffer3_bytes" {
     GHC.IO.Buffer.$tc'Buffer3_bytes:
         I8[] [39,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.697662921 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer2_closure" {
     GHC.IO.Buffer.$tc'Buffer2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'Buffer3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.699394496 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer_closure" {
     GHC.IO.Buffer.$tc'Buffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'Buffer2_closure+1;
         const GHC.IO.Buffer.$tc'Buffer1_closure+4;
         const 6953290879310668230;
         const 8839152842293094522;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.702148145 UTC

[section ""data" . GHC.IO.Buffer.writeWord8Buf1_closure" {
     GHC.IO.Buffer.writeWord8Buf1_closure:
         const GHC.IO.Buffer.writeWord8Buf1_info;
 },
 GHC.IO.Buffer.writeWord8Buf1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PGz,
                       label: GHC.IO.Buffer.writeWord8Buf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PGz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7PGI; else goto c7PGJ;
       c7PGI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.writeWord8Buf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PGJ: // global
           I64[Sp - 24] = block_c7PGw_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7PGW; else goto c7PGx;
       u7PGW: // global
           call _c7PGw(R1) args: 0, res: 0, upd: 0;
       c7PGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PGw() //  [R1]
         { info_tbl: [(c7PGw,
                       label: block_c7PGw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PGw: // global
           I64[Sp - 8] = block_c7PGC_info;
           _s7OMJ::P64 = P64[R1 + 7];
           _s7OMI::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OMJ::P64;
           I64[Sp + 8] = _s7OMI::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PGV; else goto c7PGD;
       u7PGV: // global
           call _c7PGC(R1) args: 0, res: 0, upd: 0;
       c7PGD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PGC() //  [R1]
         { info_tbl: [(c7PGC,
                       label: block_c7PGC_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PGC: // global
           I64[Sp] = block_c7PGH_info;
           _s7OML::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7OML::I64;
           if (R1 & 7 != 0) goto u7PGX; else goto c7PGM;
       u7PGX: // global
           call _c7PGH(R1) args: 0, res: 0, upd: 0;
       c7PGM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PGH() //  [R1]
         { info_tbl: [(c7PGH,
                       label: block_c7PGH_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PGH: // global
           _s7OMJ::P64 = P64[Sp + 8];
           I8[I64[Sp + 16] + I64[Sp + 24]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           call MO_Touch(_s7OMJ::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.711315081 UTC

[section ""data" . GHC.IO.Buffer.writeWord8Buf_closure" {
     GHC.IO.Buffer.writeWord8Buf_closure:
         const GHC.IO.Buffer.writeWord8Buf_info;
 },
 GHC.IO.Buffer.writeWord8Buf_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PHn,
                       label: GHC.IO.Buffer.writeWord8Buf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PHn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.writeWord8Buf1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.71507835 UTC

[section ""data" . GHC.IO.Buffer.readWord8Buf1_closure" {
     GHC.IO.Buffer.readWord8Buf1_closure:
         const GHC.IO.Buffer.readWord8Buf1_info;
 },
 GHC.IO.Buffer.readWord8Buf1_entry() //  [R2, R3]
         { info_tbl: [(c7PHB,
                       label: GHC.IO.Buffer.readWord8Buf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PHB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7PHO; else goto c7PHP;
       c7PHO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.readWord8Buf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PHP: // global
           I64[Sp - 16] = block_c7PHy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PHV; else goto c7PHz;
       u7PHV: // global
           call _c7PHy(R1) args: 0, res: 0, upd: 0;
       c7PHz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PHy() //  [R1]
         { info_tbl: [(c7PHy,
                       label: block_c7PHy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PHy: // global
           I64[Sp - 8] = block_c7PHE_info;
           _s7OMW::P64 = P64[R1 + 7];
           _s7OMV::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OMW::P64;
           I64[Sp + 8] = _s7OMV::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PHU; else goto c7PHF;
       u7PHU: // global
           call _c7PHE(R1) args: 0, res: 0, upd: 0;
       c7PHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PHE() //  [R1]
         { info_tbl: [(c7PHE,
                       label: block_c7PHE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PHE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PHT; else goto c7PHS;
       c7PHT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PHS: // global
           _s7ON2::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 16] + I64[R1 + 7]]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s7ON2::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.723256719 UTC

[section ""data" . GHC.IO.Buffer.readWord8Buf_closure" {
     GHC.IO.Buffer.readWord8Buf_closure:
         const GHC.IO.Buffer.readWord8Buf_info;
 },
 GHC.IO.Buffer.readWord8Buf_entry() //  [R2, R3]
         { info_tbl: [(c7PIg,
                       label: GHC.IO.Buffer.readWord8Buf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PIg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.readWord8Buf1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.727088765 UTC

[section ""data" . GHC.IO.Buffer.bufferAdd_closure" {
     GHC.IO.Buffer.bufferAdd_closure:
         const GHC.IO.Buffer.bufferAdd_info;
 },
 GHC.IO.Buffer.bufferAdd_entry() //  [R2, R3]
         { info_tbl: [(c7PIu,
                       label: GHC.IO.Buffer.bufferAdd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PIu: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c7PIG; else goto c7PIH;
       c7PIG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAdd_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PIH: // global
           I64[Sp - 16] = block_c7PIr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PIN; else goto c7PIs;
       u7PIN: // global
           call _c7PIr(R1) args: 0, res: 0, upd: 0;
       c7PIs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PIr() //  [R1]
         { info_tbl: [(c7PIr,
                       label: block_c7PIr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PIr: // global
           I64[Sp - 40] = block_c7PIx_info;
           _s7ON9::P64 = P64[R1 + 7];
           _s7ONa::P64 = P64[R1 + 15];
           _s7ON8::I64 = I64[R1 + 23];
           _s7ONb::I64 = I64[R1 + 31];
           _s7ONc::I64 = I64[R1 + 39];
           _s7ONd::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s7ONa::P64;
           I64[Sp - 24] = _s7ONb::I64;
           I64[Sp - 16] = _s7ONc::I64;
           I64[Sp - 8] = _s7ONd::I64;
           P64[Sp] = _s7ON9::P64;
           I64[Sp + 8] = _s7ON8::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7PIM; else goto c7PIy;
       u7PIM: // global
           call _c7PIx(R1) args: 0, res: 0, upd: 0;
       c7PIy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PIx() //  [R1]
         { info_tbl: [(c7PIx,
                       label: block_c7PIx_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PIx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PIL; else goto c7PIK;
       c7PIL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PIK: // global
           _s7ONg::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = _s7ONg::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.736765757 UTC

[section ""data" . GHC.IO.Buffer.bufferRemove_closure" {
     GHC.IO.Buffer.bufferRemove_closure:
         const GHC.IO.Buffer.bufferRemove_info;
 },
 GHC.IO.Buffer.bufferRemove_entry() //  [R2, R3]
         { info_tbl: [(c7PJg,
                       label: GHC.IO.Buffer.bufferRemove_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PJg: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c7PJk; else goto c7PJl;
       c7PJk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferRemove_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PJl: // global
           I64[Sp - 16] = block_c7PJd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PJH; else goto c7PJe;
       u7PJH: // global
           call _c7PJd(R1) args: 0, res: 0, upd: 0;
       c7PJe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PJd() //  [R1]
         { info_tbl: [(c7PJd,
                       label: block_c7PJd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PJd: // global
           I64[Sp - 40] = block_c7PJj_info;
           _s7ONl::P64 = P64[R1 + 7];
           _s7ONm::P64 = P64[R1 + 15];
           _s7ONk::I64 = I64[R1 + 23];
           _s7ONn::I64 = I64[R1 + 31];
           _s7ONo::I64 = I64[R1 + 39];
           _s7ONp::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s7ONm::P64;
           I64[Sp - 24] = _s7ONn::I64;
           I64[Sp - 16] = _s7ONo::I64;
           I64[Sp - 8] = _s7ONp::I64;
           P64[Sp] = _s7ONl::P64;
           I64[Sp + 8] = _s7ONk::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7PJG; else goto c7PJn;
       u7PJG: // global
           call _c7PJj(R1) args: 0, res: 0, upd: 0;
       c7PJn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PJj() //  [R1]
         { info_tbl: [(c7PJj,
                       label: block_c7PJj_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PJj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PJt; else goto c7PJs;
       c7PJt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PJs: // global
           _s7ONk::I64 = I64[Sp + 48];
           _s7ONl::P64 = P64[Sp + 40];
           _s7ONm::P64 = P64[Sp + 8];
           _s7ONn::I64 = I64[Sp + 16];
           _s7ONp::I64 = I64[Sp + 32];
           _s7ONs::I64 = I64[Sp + 24] + I64[R1 + 7];
           if (_s7ONs::I64 == _s7ONp::I64) goto c7PJF; else goto c7PJC;
       c7PJF: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7ONl::P64;
           P64[Hp - 32] = _s7ONm::P64;
           I64[Hp - 24] = _s7ONk::I64;
           I64[Hp - 16] = _s7ONn::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7PJC: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7ONl::P64;
           P64[Hp - 32] = _s7ONm::P64;
           I64[Hp - 24] = _s7ONk::I64;
           I64[Hp - 16] = _s7ONn::I64;
           I64[Hp - 8] = _s7ONs::I64;
           I64[Hp] = _s7ONp::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.746035944 UTC

[section ""data" . GHC.IO.Buffer.bufferAvailable_closure" {
     GHC.IO.Buffer.bufferAvailable_closure:
         const GHC.IO.Buffer.bufferAvailable_info;
 },
 GHC.IO.Buffer.bufferAvailable_entry() //  [R2]
         { info_tbl: [(c7PK6,
                       label: GHC.IO.Buffer.bufferAvailable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PK6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PKd; else goto c7PKe;
       c7PKd: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAvailable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PKe: // global
           I64[Sp - 8] = block_c7PK3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PKi; else goto c7PK4;
       u7PKi: // global
           call _c7PK3(R1) args: 0, res: 0, upd: 0;
       c7PK4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PK3() //  [R1]
         { info_tbl: [(c7PK3,
                       label: block_c7PK3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PK3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PKh; else goto c7PKg;
       c7PKh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PKg: // global
           _s7ONC::I64 = I64[R1 + 31] - I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7ONC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.751804671 UTC

[section ""data" . GHC.IO.Buffer.bufferElems_closure" {
     GHC.IO.Buffer.bufferElems_closure:
         const GHC.IO.Buffer.bufferElems_info;
 },
 GHC.IO.Buffer.bufferElems_entry() //  [R2]
         { info_tbl: [(c7PKC,
                       label: GHC.IO.Buffer.bufferElems_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PKC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PKJ; else goto c7PKK;
       c7PKJ: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferElems_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PKK: // global
           I64[Sp - 8] = block_c7PKz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PKO; else goto c7PKA;
       u7PKO: // global
           call _c7PKz(R1) args: 0, res: 0, upd: 0;
       c7PKA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PKz() //  [R1]
         { info_tbl: [(c7PKz,
                       label: block_c7PKz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PKz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PKN; else goto c7PKM;
       c7PKN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PKM: // global
           _s7ONL::I64 = I64[R1 + 47] - I64[R1 + 39];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7ONL::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.757315003 UTC

[section ""cstring" . lvl_r7OJS_bytes" {
     lvl_r7OJS_bytes:
         I8[] [98,117,102,102,101,114,32,105,110,118,97,114,105,97,110,116,32,118,105,111,108,97,116,105,111,110,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.759386166 UTC

[section ""data" . GHC.IO.Buffer.$wlvl_closure" {
     GHC.IO.Buffer.$wlvl_closure:
         const GHC.IO.Buffer.$wlvl_info;
         const 0;
 },
 sat_s7ONP_entry() //  [R1]
         { info_tbl: [(c7PLa,
                       label: sat_s7ONP_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PLa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7PLb; else goto c7PLc;
       c7PLb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7PLc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = I64[R1 + 32];
           R3 = I64[R1 + 24];
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Buffer.$wsummaryBuffer_entry(R4,
                                                    R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PLf,
                       label: GHC.IO.Buffer.$wlvl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PLf: // global
           _s7ONO::I64 = R4;
           _s7ONN::I64 = R3;
           _s7ONM::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7PLg; else goto c7PLh;
       c7PLh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7PLj; else goto c7PLi;
       c7PLj: // global
           HpAlloc = 40;
           goto c7PLg;
       c7PLg: // global
           R4 = _s7ONO::I64;
           R3 = _s7ONN::I64;
           R2 = _s7ONM::I64;
           R1 = GHC.IO.Buffer.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PLi: // global
           I64[Hp - 32] = sat_s7ONP_info;
           I64[Hp - 16] = _s7ONM::I64;
           I64[Hp - 8] = _s7ONN::I64;
           I64[Hp] = _s7ONO::I64;
           I64[Sp - 8] = block_c7PLd_info;
           R3 = Hp - 32;
           R2 = lvl_r7OJS_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7PLd() //  [R1]
         { info_tbl: [(c7PLd,
                       label: block_c7PLd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PLd: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.767081041 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer2_closure" {
     GHC.IO.Buffer.checkBuffer2_closure:
         const GHC.IO.Buffer.checkBuffer2_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer2_entry() //  [R2, R3]
         { info_tbl: [(c7PLD,
                       label: GHC.IO.Buffer.checkBuffer2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PLD: // global
           R4 = R3;
           R3 = 0;
           R2 = R2;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.771724857 UTC

[section ""data" . GHC.IO.Buffer.$wcheckBuffer_closure" {
     GHC.IO.Buffer.$wcheckBuffer_closure:
         const GHC.IO.Buffer.$wcheckBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.$wcheckBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PLL: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Buffer.$wcheckBuffer_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Buffer.$wcheckBuffer_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7PLU,
                       label: GHC.IO.Buffer.$wcheckBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PLU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7PLV; else goto c7PLW;
       c7PLV: // global
           R1 = GHC.IO.Buffer.$wcheckBuffer_closure;
           P64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c7PLW: // global
           if (%MO_S_Le_W64(R3, 0)) goto u7PN4; else goto c7PLT;
       u7PN4: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7PNh;
       c7PLT: // global
           if (%MO_S_Gt_W64(R4, R5)) goto u7PN5; else goto c7PN1;
       u7PN5: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7PNh;
       c7PN1: // global
           if (%MO_S_Gt_W64(R5, R3)) goto u7PN6; else goto c7PN0;
       u7PN6: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7PNh;
       u7PNh: // global
           call _c7PMX() args: 0, res: 0, upd: 0;
       c7PN0: // global
           if (R4 == R5) goto c7PMg; else goto c7PMJ;
       c7PMg: // global
           I64[Sp - 32] = block_c7PMe_info;
           R1 = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7PNd; else goto c7PMh;
       u7PNd: // global
           call _c7PMe(R1) args: 0, res: 0, upd: 0;
       c7PMh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7PMJ: // global
           I64[Sp - 32] = block_c7PMI_info;
           R1 = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7PNe; else goto c7PMK;
       u7PNe: // global
           call _c7PMI(R1) args: 0, res: 0, upd: 0;
       c7PMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PMe() //  [R1]
         { info_tbl: [(c7PMe,
                       label: block_c7PMe_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PMe: // global
           _s7ONU::I64 = I64[Sp + 8];
           _s7ONW::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c7PMx; else goto c7PMG;
       c7PMx: // global
           _s7OO6::I64 = I64[Sp + 16];
           if (_s7OO6::I64 != 0) goto c7PMo; else goto c7PMv;
       c7PMo: // global
           R4 = _s7ONW::I64;
           R3 = _s7OO6::I64;
           R2 = _s7ONU::I64;
           Sp = Sp + 32;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c7PMv: // global
           if (_s7ONW::I64 == 0) goto u7PN9; else goto c7PMt;
       u7PN9: // global
           Sp = Sp + 32;
           goto u7PNk;
       c7PMt: // global
           R3 = _s7ONW::I64;
           R2 = _s7ONU::I64;
           Sp = Sp + 32;
           call GHC.IO.Buffer.checkBuffer2_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
       c7PMG: // global
           if (%MO_S_Ge_W64(_s7ONW::I64,
                            _s7ONU::I64)) goto u7PN8; else goto u7PN7;
       u7PN8: // global
           Sp = Sp + 8;
           call _c7PMX() args: 0, res: 0, upd: 0;
       u7PN7: // global
           Sp = Sp + 32;
           goto u7PNk;
       u7PNk: // global
           call _c7PMY() args: 0, res: 0, upd: 0;
     }
 },
 _c7PMI() //  [R1]
         { info_tbl: [(c7PMI,
                       label: block_c7PMI_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PMI: // global
           if (R1 & 7 == 1) goto u7PNa; else goto c7PMZ;
       u7PNa: // global
           Sp = Sp + 32;
           goto u7PNm;
       c7PMZ: // global
           if (%MO_S_Ge_W64(I64[Sp + 24],
                            I64[Sp + 8])) goto u7PNc; else goto u7PNb;
       u7PNc: // global
           Sp = Sp + 8;
           call _c7PMX() args: 0, res: 0, upd: 0;
       u7PNb: // global
           Sp = Sp + 32;
           goto u7PNm;
       u7PNm: // global
           call _c7PMY() args: 0, res: 0, upd: 0;
     }
 },
 _c7PMX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PMX: // global
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7PMY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PMY: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.785567251 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer1_closure" {
     GHC.IO.Buffer.checkBuffer1_closure:
         const GHC.IO.Buffer.checkBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer1_entry() //  [R2]
         { info_tbl: [(c7PNU,
                       label: GHC.IO.Buffer.checkBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PNU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PNV; else goto c7PNW;
       c7PNV: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.checkBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PNW: // global
           I64[Sp - 8] = block_c7PNR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PO0; else goto c7PNS;
       u7PO0: // global
           call _c7PNR(R1) args: 0, res: 0, upd: 0;
       c7PNS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PNR() //  [R1]
         { info_tbl: [(c7PNR,
                       label: block_c7PNR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PNR: // global
           R5 = I64[R1 + 47];
           R4 = I64[R1 + 39];
           R3 = I64[R1 + 31];
           R2 = P64[R1 + 15];
           Sp = Sp + 8;
           call GHC.IO.Buffer.$wcheckBuffer_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.793821081 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer_closure" {
     GHC.IO.Buffer.checkBuffer_closure:
         const GHC.IO.Buffer.checkBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer_entry() //  [R2]
         { info_tbl: [(c7POe,
                       label: GHC.IO.Buffer.checkBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7POe: // global
           R2 = R2;
           call GHC.IO.Buffer.checkBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.798006495 UTC

[section ""data" . GHC.IO.Buffer.newBuffer1_closure" {
     GHC.IO.Buffer.newBuffer1_closure:
         const GHC.IO.Buffer.newBuffer1_info;
         const 0;
 },
 sat_s7OOF_entry() //  [R1]
         { info_tbl: [(c7POI,
                       label: sat_s7OOF_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7POI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7POQ; else goto c7POR;
       c7POQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7POR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_c7POF_info;
           _s7OOq::P64 = P64[R1 + 24];
           _s7OOx::P64 = P64[R1 + 32];
           _s7OOA::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _s7OOq::P64;
           P64[Sp - 32] = _s7OOx::P64;
           P64[Sp - 24] = _s7OOA::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u7POV; else goto c7POG;
       u7POV: // global
           call _c7POF(R1) args: 0, res: 0, upd: 0;
       c7POG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c7POF() //  [R1]
         { info_tbl: [(c7POF,
                       label: block_c7POF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7POF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c7POU; else goto c7POT;
       c7POU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c7POT: // global
           _s7OOC::I64 = I64[R1 + 7];
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           _s7OOA::P64 = P64[Sp + 24];
           P64[Hp - 64] = _s7OOA::P64;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s7OOA::P64 + 16;
           I64[Hp - 16] = _s7OOC::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.newBuffer1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7POW,
                       label: GHC.IO.Buffer.newBuffer1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7POW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7POX; else goto c7POY;
       c7POX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.newBuffer1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7POY: // global
           I64[Sp - 24] = block_c7POp_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7PP7; else goto c7POq;
       u7PP7: // global
           call _c7POp(R1) args: 0, res: 0, upd: 0;
       c7POq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7POp() //  [R1]
         { info_tbl: [(c7POp,
                       label: block_c7POp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7POp: // global
           _s7OOt::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7OOt::I64, 0)) goto c7PP1; else goto c7PP6;
       c7PP1: // global
           I64[Sp - 8] = block_c7POx_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s7OOt::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7PP6: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7POx() //  [R1]
         { info_tbl: [(c7POx,
                       label: block_c7POx_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7POx: // global
           I64[Sp] = block_c7POz_info;
           _s7OOx::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7OOx::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7POz() //  [R1]
         { info_tbl: [(c7POz,
                       label: block_c7POz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7POz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7PP5; else goto c7PP4;
       c7PP5: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PP4: // global
           I64[Hp - 40] = sat_s7OOF_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.811961077 UTC

[section ""data" . GHC.IO.Buffer.newBuffer_closure" {
     GHC.IO.Buffer.newBuffer_closure:
         const GHC.IO.Buffer.newBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PPI,
                       label: GHC.IO.Buffer.newBuffer_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PPI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newBuffer1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.81608326 UTC

[section ""data" . GHC.IO.Buffer.newByteBuffer1_closure" {
     GHC.IO.Buffer.newByteBuffer1_closure:
         const GHC.IO.Buffer.newByteBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.newByteBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7PPT,
                       label: GHC.IO.Buffer.newByteBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PPT: // global
           R4 = R3;
           R3 = R2;
           R2 = R2;
           call GHC.IO.Buffer.newBuffer1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.819645096 UTC

[section ""data" . GHC.IO.Buffer.newByteBuffer_closure" {
     GHC.IO.Buffer.newByteBuffer_closure:
         const GHC.IO.Buffer.newByteBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newByteBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7PQ4,
                       label: GHC.IO.Buffer.newByteBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PQ4: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newByteBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.823559217 UTC

[section ""data" . GHC.IO.Buffer.newCharBuffer1_closure" {
     GHC.IO.Buffer.newCharBuffer1_closure:
         const GHC.IO.Buffer.newCharBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.newCharBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7PQi,
                       label: GHC.IO.Buffer.newCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PQi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7PQj; else goto c7PQk;
       c7PQj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.newCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PQk: // global
           I64[Sp - 16] = block_c7PQf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PQK; else goto c7PQg;
       u7PQK: // global
           call _c7PQf(R1) args: 0, res: 0, upd: 0;
       c7PQg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PQf() //  [R1]
         { info_tbl: [(c7PQf,
                       label: block_c7PQf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PQf: // global
           _s7OON::I64 = I64[R1 + 7];
           _s7OOO::I64 = _s7OON::I64 << 2;
           if (%MO_S_Ge_W64(_s7OOO::I64, 0)) goto c7PQE; else goto c7PQJ;
       c7PQE: // global
           I64[Sp - 16] = block_c7PQu_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _s7OOO::I64;
           I64[Sp] = _s7OON::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7PQJ: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7PQu() //  [R1]
         { info_tbl: [(c7PQu,
                       label: block_c7PQu_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PQu: // global
           I64[Sp] = block_c7PQw_info;
           _s7OOS::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7OOS::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PQw() //  [R1]
         { info_tbl: [(c7PQw,
                       label: block_c7PQw_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PQw: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c7PQI; else goto c7PQH;
       c7PQI: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PQH: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.833173309 UTC

[section ""data" . GHC.IO.Buffer.newCharBuffer_closure" {
     GHC.IO.Buffer.newCharBuffer_closure:
         const GHC.IO.Buffer.newCharBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newCharBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7PRa,
                       label: GHC.IO.Buffer.newCharBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PRa: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newCharBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.837226896 UTC

[section ""data" . GHC.IO.Buffer.slideContents1_closure" {
     GHC.IO.Buffer.slideContents1_closure:
         const GHC.IO.Buffer.slideContents1_info;
 },
 GHC.IO.Buffer.slideContents1_entry() //  [R2]
         { info_tbl: [(c7PRo,
                       label: GHC.IO.Buffer.slideContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PRo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7PRG; else goto c7PRH;
       c7PRG: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.slideContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7PRH: // global
           I64[Sp - 8] = block_c7PRl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PRL; else goto c7PRm;
       u7PRL: // global
           call _c7PRl(R1) args: 0, res: 0, upd: 0;
       c7PRm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PRl() //  [R1]
         { info_tbl: [(c7PRl,
                       label: block_c7PRl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PRl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PRK; else goto c7PRJ;
       c7PRK: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PRJ: // global
           _s7OP4::P64 = P64[R1 + 7];
           _s7OP5::P64 = P64[R1 + 15];
           _s7OP3::I64 = I64[R1 + 23];
           _s7OP6::I64 = I64[R1 + 31];
           _s7OP7::I64 = I64[R1 + 39];
           _s7OP9::I64 = I64[R1 + 47] - _s7OP7::I64;
           (_s7OPf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_s7OP3::I64, _s7OP3::I64 + _s7OP7::I64, _s7OP9::I64);
           call MO_Touch(_s7OP4::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7OP4::P64;
           P64[Hp - 32] = _s7OP5::P64;
           I64[Hp - 24] = _s7OP3::I64;
           I64[Hp - 16] = _s7OP6::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s7OP9::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.843701173 UTC

[section ""data" . GHC.IO.Buffer.slideContents_closure" {
     GHC.IO.Buffer.slideContents_closure:
         const GHC.IO.Buffer.slideContents_info;
 },
 GHC.IO.Buffer.slideContents_entry() //  [R2]
         { info_tbl: [(c7PS4,
                       label: GHC.IO.Buffer.slideContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PS4: // global
           R2 = R2;
           call GHC.IO.Buffer.slideContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.8475687 UTC

[section ""data" . writeCharBufPtr1_r7OJT_closure" {
     writeCharBufPtr1_r7OJT_closure:
         const writeCharBufPtr1_r7OJT_info;
 },
 writeCharBufPtr1_r7OJT_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PSi,
                       label: writeCharBufPtr1_r7OJT_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PSi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7PSz; else goto c7PSA;
       c7PSz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = writeCharBufPtr1_r7OJT_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PSA: // global
           I64[Sp - 24] = block_c7PSf_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7PSH; else goto c7PSg;
       u7PSH: // global
           call _c7PSf(R1) args: 0, res: 0, upd: 0;
       c7PSg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PSf() //  [R1]
         { info_tbl: [(c7PSf,
                       label: block_c7PSf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PSf: // global
           I64[Sp] = block_c7PSl_info;
           _s7OPn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7OPn::I64;
           if (R1 & 7 != 0) goto u7PSG; else goto c7PSm;
       u7PSG: // global
           call _c7PSl(R1) args: 0, res: 0, upd: 0;
       c7PSm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PSl() //  [R1]
         { info_tbl: [(c7PSl,
                       label: block_c7PSl_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PSl: // global
           I64[Sp] = block_c7PSq_info;
           _s7OPp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7OPp::I64;
           if (R1 & 7 != 0) goto u7PSI; else goto c7PSr;
       u7PSI: // global
           call _c7PSq(R1) args: 0, res: 0, upd: 0;
       c7PSr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PSq() //  [R1]
         { info_tbl: [(c7PSq,
                       label: block_c7PSq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PSq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PSF; else goto c7PSE;
       c7PSF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PSE: // global
           _s7OPp::I64 = I64[Sp + 16];
           I32[I64[Sp + 8] + (_s7OPp::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OPp::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.857893372 UTC

[section ""data" . GHC.IO.Buffer.writeCharBufPtr_closure" {
     GHC.IO.Buffer.writeCharBufPtr_closure:
         const GHC.IO.Buffer.writeCharBufPtr_info;
 },
 GHC.IO.Buffer.writeCharBufPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PT8,
                       label: GHC.IO.Buffer.writeCharBufPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PT8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call writeCharBufPtr1_r7OJT_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.861651273 UTC

[section ""data" . writeCharBuf1_r7OJU_closure" {
     writeCharBuf1_r7OJU_closure:
         const writeCharBuf1_r7OJU_info;
 },
 writeCharBuf1_r7OJU_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PTm,
                       label: writeCharBuf1_r7OJU_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PTm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7PTE; else goto c7PTF;
       c7PTE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = writeCharBuf1_r7OJU_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PTF: // global
           I64[Sp - 24] = block_c7PTj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7PTM; else goto c7PTk;
       u7PTM: // global
           call _c7PTj(R1) args: 0, res: 0, upd: 0;
       c7PTk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PTj() //  [R1]
         { info_tbl: [(c7PTj,
                       label: block_c7PTj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PTj: // global
           I64[Sp - 8] = block_c7PTp_info;
           _s7OPB::P64 = P64[R1 + 7];
           _s7OPA::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OPB::P64;
           I64[Sp + 8] = _s7OPA::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PTL; else goto c7PTq;
       u7PTL: // global
           call _c7PTp(R1) args: 0, res: 0, upd: 0;
       c7PTq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PTp() //  [R1]
         { info_tbl: [(c7PTp,
                       label: block_c7PTp_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PTp: // global
           I64[Sp] = block_c7PTu_info;
           _s7OPD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7OPD::I64;
           if (R1 & 7 != 0) goto u7PTN; else goto c7PTv;
       u7PTN: // global
           call _c7PTu(R1) args: 0, res: 0, upd: 0;
       c7PTv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PTu() //  [R1]
         { info_tbl: [(c7PTu,
                       label: block_c7PTu_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PTu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PTK; else goto c7PTJ;
       c7PTK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PTJ: // global
           _s7OPB::P64 = P64[Sp + 8];
           _s7OPD::I64 = I64[Sp + 24];
           I32[I64[Sp + 16] + (_s7OPD::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           call MO_Touch(_s7OPB::P64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7OPD::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.87159422 UTC

[section ""data" . GHC.IO.Buffer.writeCharBuf_closure" {
     GHC.IO.Buffer.writeCharBuf_closure:
         const GHC.IO.Buffer.writeCharBuf_info;
 },
 GHC.IO.Buffer.writeCharBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(c7PUd,
                       label: GHC.IO.Buffer.writeCharBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PUd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call writeCharBuf1_r7OJU_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.875385936 UTC

[section ""data" . readCharBufPtr1_r7OJV_closure" {
     readCharBufPtr1_r7OJV_closure:
         const readCharBufPtr1_r7OJV_info;
 },
 readCharBufPtr1_r7OJV_entry() //  [R2, R3]
         { info_tbl: [(c7PUr,
                       label: readCharBufPtr1_r7OJV_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PUr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7PUF; else goto c7PUG;
       c7PUF: // global
           R3 = R3;
           R2 = R2;
           R1 = readCharBufPtr1_r7OJV_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PUG: // global
           I64[Sp - 16] = block_c7PUo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PUM; else goto c7PUp;
       u7PUM: // global
           call _c7PUo(R1) args: 0, res: 0, upd: 0;
       c7PUp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PUo() //  [R1]
         { info_tbl: [(c7PUo,
                       label: block_c7PUo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PUo: // global
           I64[Sp] = block_c7PUu_info;
           _s7OPO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7OPO::I64;
           if (R1 & 7 != 0) goto u7PUL; else goto c7PUv;
       u7PUL: // global
           call _c7PUu(R1) args: 0, res: 0, upd: 0;
       c7PUv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PUu() //  [R1]
         { info_tbl: [(c7PUu,
                       label: block_c7PUu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PUu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PUK; else goto c7PUJ;
       c7PUK: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PUJ: // global
           _s7OPQ::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7OPQ::I64 + 1;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (_s7OPQ::I64 << 2)]);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.883448511 UTC

[section ""data" . GHC.IO.Buffer.readCharBufPtr_closure" {
     GHC.IO.Buffer.readCharBufPtr_closure:
         const GHC.IO.Buffer.readCharBufPtr_info;
 },
 GHC.IO.Buffer.readCharBufPtr_entry() //  [R2, R3]
         { info_tbl: [(c7PVa,
                       label: GHC.IO.Buffer.readCharBufPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PVa: // global
           R3 = R3;
           R2 = R2;
           call readCharBufPtr1_r7OJV_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.88742773 UTC

[section ""data" . readCharBuf1_r7OJW_closure" {
     readCharBuf1_r7OJW_closure:
         const readCharBuf1_r7OJW_info;
 },
 readCharBuf1_r7OJW_entry() //  [R2, R3]
         { info_tbl: [(c7PVo,
                       label: readCharBuf1_r7OJW_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PVo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7PVD; else goto c7PVE;
       c7PVD: // global
           R3 = R3;
           R2 = R2;
           R1 = readCharBuf1_r7OJW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PVE: // global
           I64[Sp - 16] = block_c7PVl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PVK; else goto c7PVm;
       u7PVK: // global
           call _c7PVl(R1) args: 0, res: 0, upd: 0;
       c7PVm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PVl() //  [R1]
         { info_tbl: [(c7PVl,
                       label: block_c7PVl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PVl: // global
           I64[Sp - 8] = block_c7PVr_info;
           _s7OQ3::P64 = P64[R1 + 7];
           _s7OQ2::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OQ3::P64;
           I64[Sp + 8] = _s7OQ2::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PVJ; else goto c7PVs;
       u7PVJ: // global
           call _c7PVr(R1) args: 0, res: 0, upd: 0;
       c7PVs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PVr() //  [R1]
         { info_tbl: [(c7PVr,
                       label: block_c7PVr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PVr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PVI; else goto c7PVH;
       c7PVI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PVH: // global
           _s7OQ5::I64 = I64[R1 + 7];
           _s7OQ8::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 16] + (_s7OQ5::I64 << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7OQ5::I64 + 1;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s7OQ8::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.896552804 UTC

[section ""data" . GHC.IO.Buffer.readCharBuf_closure" {
     GHC.IO.Buffer.readCharBuf_closure:
         const GHC.IO.Buffer.readCharBuf_info;
 },
 GHC.IO.Buffer.readCharBuf_entry() //  [R2, R3]
         { info_tbl: [(c7PW7,
                       label: GHC.IO.Buffer.readCharBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PW7: // global
           R3 = R3;
           R2 = R2;
           call readCharBuf1_r7OJW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.900321095 UTC

[section ""data" . GHC.IO.Buffer.peekCharBuf1_closure" {
     GHC.IO.Buffer.peekCharBuf1_closure:
         const GHC.IO.Buffer.peekCharBuf1_info;
 },
 GHC.IO.Buffer.peekCharBuf1_entry() //  [R2, R3]
         { info_tbl: [(c7PWl,
                       label: GHC.IO.Buffer.peekCharBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PWl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7PWv; else goto c7PWw;
       c7PWv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.peekCharBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7PWw: // global
           I64[Sp - 16] = block_c7PWi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7PWC; else goto c7PWj;
       u7PWC: // global
           call _c7PWi(R1) args: 0, res: 0, upd: 0;
       c7PWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PWi() //  [R1]
         { info_tbl: [(c7PWi,
                       label: block_c7PWi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PWi: // global
           I64[Sp - 8] = block_c7PWo_info;
           _s7OQj::P64 = P64[R1 + 7];
           _s7OQi::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7OQj::P64;
           I64[Sp + 8] = _s7OQi::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7PWB; else goto c7PWp;
       u7PWB: // global
           call _c7PWo(R1) args: 0, res: 0, upd: 0;
       c7PWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7PWo() //  [R1]
         { info_tbl: [(c7PWo,
                       label: block_c7PWo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PWo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7PWA; else goto c7PWz;
       c7PWA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7PWz: // global
           _s7OQo::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 16] + (I64[R1 + 7] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s7OQo::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.908082547 UTC

[section ""data" . GHC.IO.Buffer.peekCharBuf_closure" {
     GHC.IO.Buffer.peekCharBuf_closure:
         const GHC.IO.Buffer.peekCharBuf_info;
 },
 GHC.IO.Buffer.peekCharBuf_entry() //  [R2, R3]
         { info_tbl: [(c7PWX,
                       label: GHC.IO.Buffer.peekCharBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PWX: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.peekCharBuf1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.911248583 UTC

[section ""data" . GHC.IO.Buffer.ReadBuffer_closure" {
     GHC.IO.Buffer.ReadBuffer_closure:
         const GHC.IO.Buffer.ReadBuffer_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.912901243 UTC

[section ""data" . GHC.IO.Buffer.WriteBuffer_closure" {
     GHC.IO.Buffer.WriteBuffer_closure:
         const GHC.IO.Buffer.WriteBuffer_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.915086935 UTC

[section ""data" . GHC.IO.Buffer.Buffer_closure" {
     GHC.IO.Buffer.Buffer_closure:
         const GHC.IO.Buffer.Buffer_info;
 },
 GHC.IO.Buffer.Buffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PX7: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Buffer.Buffer_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2,
                                           R1) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Buffer.Buffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7PXc,
                       label: GHC.IO.Buffer.Buffer_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [True, False, False, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PXc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7PXg; else goto c7PXf;
       c7PXg: // global
           HpAlloc = 56;
           R1 = GHC.IO.Buffer.Buffer_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       c7PXf: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = R5;
           I64[Hp - 8] = R6;
           I64[Hp] = I64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.920380103 UTC

[section ""relreadonly" . GHC.IO.Buffer.BufferState_closure_tbl" {
     GHC.IO.Buffer.BufferState_closure_tbl:
         const GHC.IO.Buffer.ReadBuffer_closure+1;
         const GHC.IO.Buffer.WriteBuffer_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.922819349 UTC

[GHC.IO.Buffer.ReadBuffer_con_entry() //  [R1]
         { info_tbl: [(c7PXq,
                       label: GHC.IO.Buffer.ReadBuffer_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,82,101,97,100,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PXq: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.926142829 UTC

[GHC.IO.Buffer.WriteBuffer_con_entry() //  [R1]
         { info_tbl: [(c7PXw,
                       label: GHC.IO.Buffer.WriteBuffer_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,87,114,105,116,101,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PXw: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.929333936 UTC

[GHC.IO.Buffer.Buffer_con_entry() //  [R1]
         { info_tbl: [(c7PXC,
                       label: GHC.IO.Buffer.Buffer_con_info
                       rep:HeapRep 2 ptrs 4 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7PXC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:55.932438005 UTC

[section ""relreadonly" . S7OYn_srt" {
     S7OYn_srt:
         const GHC.IO.Buffer.summaryBuffer1_closure;
         const GHC.IO.Buffer.$wsummaryBuffer_closure;
         const GHC.IO.Buffer.summaryBuffer_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Buffer.$wlvl_closure;
         const GHC.IO.Buffer.$wcheckBuffer_closure;
         const GHC.IO.Buffer.checkBuffer2_closure;
         const GHC.IO.Buffer.checkBuffer1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const GHC.IO.Buffer.newBuffer1_closure;
         const GHC.IO.Buffer.newByteBuffer1_closure;
         const GHC.IO.Buffer.newCharBuffer1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.047271131 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:57.049103344 UTC

[section ""data" . GHC.IO.Buffer.$WBuffer_closure" {
     GHC.IO.Buffer.$WBuffer_closure:
         const GHC.IO.Buffer.$WBuffer_info;
 },
 GHC.IO.Buffer.$WBuffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7Q4j,
                       label: GHC.IO.Buffer.$WBuffer_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q4j: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Q4C; else goto c7Q4D;
       c7Q4C: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$WBuffer_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Q4D: // global
           I64[Sp - 40] = block_c7Q4g_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Q4L; else goto c7Q4h;
       u7Q4L: // global
           call _c7Q4g(R1) args: 0, res: 0, upd: 0;
       c7Q4h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q4g() //  [R1]
         { info_tbl: [(c7Q4g,
                       label: block_c7Q4g_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q4g: // global
           I64[Sp - 8] = block_c7Q4m_info;
           _s7PXQ::P64 = P64[R1 + 7];
           _s7PXP::I64 = I64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s7PXQ::P64;
           I64[Sp + 16] = _s7PXP::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Q4K; else goto c7Q4n;
       u7Q4K: // global
           call _c7Q4m(R1) args: 0, res: 0, upd: 0;
       c7Q4n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q4m() //  [R1]
         { info_tbl: [(c7Q4m,
                       label: block_c7Q4m_info
                       rep:StackRep [False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q4m: // global
           I64[Sp] = block_c7Q4r_info;
           _s7PXS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 32] = _s7PXS::I64;
           if (R1 & 7 != 0) goto u7Q4M; else goto c7Q4s;
       u7Q4M: // global
           call _c7Q4r(R1) args: 0, res: 0, upd: 0;
       c7Q4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q4r() //  [R1]
         { info_tbl: [(c7Q4r,
                       label: block_c7Q4r_info
                       rep:StackRep [False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q4r: // global
           I64[Sp] = block_c7Q4w_info;
           _s7PXU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _s7PXU::I64;
           if (R1 & 7 != 0) goto u7Q4N; else goto c7Q4x;
       u7Q4N: // global
           call _c7Q4w(R1) args: 0, res: 0, upd: 0;
       c7Q4x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q4w() //  [R1]
         { info_tbl: [(c7Q4w,
                       label: block_c7Q4w_info
                       rep:StackRep [False, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q4w: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Q4J; else goto c7Q4I;
       c7Q4J: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Q4I: // global
           _s7PXW::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = _s7PXW::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.064414096 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_$c==_closure" {
     GHC.IO.Buffer.$fEqBufferState_$c==_closure:
         const GHC.IO.Buffer.$fEqBufferState_$c==_info;
 },
 GHC.IO.Buffer.$fEqBufferState_$c==_entry() //  [R2, R3]
         { info_tbl: [(c7Q5v,
                       label: GHC.IO.Buffer.$fEqBufferState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q5v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Q5w; else goto c7Q5x;
       c7Q5w: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$fEqBufferState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Q5x: // global
           I64[Sp - 16] = block_c7Q5o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Q6a; else goto c7Q5p;
       u7Q6a: // global
           call _c7Q5o(R1) args: 0, res: 0, upd: 0;
       c7Q5p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q5o() //  [R1]
         { info_tbl: [(c7Q5o,
                       label: block_c7Q5o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q5o: // global
           _s7PXY::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7Q5s; else goto c7Q5t;
       c7Q5s: // global
           I64[Sp + 8] = block_c7Q5A_info;
           R1 = _s7PXY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Q68; else goto c7Q5C;
       u7Q68: // global
           call _c7Q5A(R1) args: 0, res: 0, upd: 0;
       c7Q5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Q5t: // global
           I64[Sp + 8] = block_c7Q5P_info;
           R1 = _s7PXY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Q69; else goto c7Q5R;
       u7Q69: // global
           call _c7Q5P(R1) args: 0, res: 0, upd: 0;
       c7Q5R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q5A() //  [R1]
         { info_tbl: [(c7Q5A,
                       label: block_c7Q5A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q5A: // global
           if (R1 & 7 == 1) goto u7Q66; else goto u7Q67;
       u7Q66: // global
           Sp = Sp + 8;
           call _c7Q61() args: 0, res: 0, upd: 0;
       u7Q67: // global
           Sp = Sp + 8;
           call _c7Q5X() args: 0, res: 0, upd: 0;
     }
 },
 _c7Q5P() //  [R1]
         { info_tbl: [(c7Q5P,
                       label: block_c7Q5P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q5P: // global
           if (R1 & 7 == 1) goto u7Q64; else goto u7Q65;
       u7Q64: // global
           Sp = Sp + 8;
           call _c7Q5X() args: 0, res: 0, upd: 0;
       u7Q65: // global
           Sp = Sp + 8;
           call _c7Q61() args: 0, res: 0, upd: 0;
     }
 },
 _c7Q5X() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q5X: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Q61() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q61: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.077173951 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_$c/=_closure" {
     GHC.IO.Buffer.$fEqBufferState_$c/=_closure:
         const GHC.IO.Buffer.$fEqBufferState_$c/=_info;
 },
 GHC.IO.Buffer.$fEqBufferState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c7Q6Y,
                       label: GHC.IO.Buffer.$fEqBufferState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q6Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Q6Z; else goto c7Q70;
       c7Q6Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$fEqBufferState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Q70: // global
           I64[Sp - 16] = block_c7Q6R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Q7D; else goto c7Q6S;
       u7Q7D: // global
           call _c7Q6R(R1) args: 0, res: 0, upd: 0;
       c7Q6S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q6R() //  [R1]
         { info_tbl: [(c7Q6R,
                       label: block_c7Q6R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q6R: // global
           _s7PY3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c7Q6V; else goto c7Q6W;
       c7Q6V: // global
           I64[Sp + 8] = block_c7Q73_info;
           R1 = _s7PY3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Q7B; else goto c7Q75;
       u7Q7B: // global
           call _c7Q73(R1) args: 0, res: 0, upd: 0;
       c7Q75: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Q6W: // global
           I64[Sp + 8] = block_c7Q7i_info;
           R1 = _s7PY3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Q7C; else goto c7Q7k;
       u7Q7C: // global
           call _c7Q7i(R1) args: 0, res: 0, upd: 0;
       c7Q7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q73() //  [R1]
         { info_tbl: [(c7Q73,
                       label: block_c7Q73_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q73: // global
           if (R1 & 7 == 1) goto u7Q7z; else goto u7Q7A;
       u7Q7z: // global
           Sp = Sp + 8;
           call _c7Q7u() args: 0, res: 0, upd: 0;
       u7Q7A: // global
           Sp = Sp + 8;
           call _c7Q7q() args: 0, res: 0, upd: 0;
     }
 },
 _c7Q7i() //  [R1]
         { info_tbl: [(c7Q7i,
                       label: block_c7Q7i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q7i: // global
           if (R1 & 7 == 1) goto u7Q7x; else goto u7Q7y;
       u7Q7x: // global
           Sp = Sp + 8;
           call _c7Q7q() args: 0, res: 0, upd: 0;
       u7Q7y: // global
           Sp = Sp + 8;
           call _c7Q7u() args: 0, res: 0, upd: 0;
     }
 },
 _c7Q7q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q7q: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Q7u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q7u: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.088806943 UTC

[section ""data" . GHC.IO.Buffer.$fEqBufferState_closure" {
     GHC.IO.Buffer.$fEqBufferState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Buffer.$fEqBufferState_$c==_closure+2;
         const GHC.IO.Buffer.$fEqBufferState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.091003686 UTC

[section ""data" . GHC.IO.Buffer.bufR_closure" {
     GHC.IO.Buffer.bufR_closure:
         const GHC.IO.Buffer.bufR_info;
 },
 GHC.IO.Buffer.bufR_entry() //  [R2]
         { info_tbl: [(c7Q8o,
                       label: GHC.IO.Buffer.bufR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q8o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Q8s; else goto c7Q8t;
       c7Q8s: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Q8t: // global
           I64[Sp - 8] = block_c7Q8l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Q8x; else goto c7Q8m;
       u7Q8x: // global
           call _c7Q8l(R1) args: 0, res: 0, upd: 0;
       c7Q8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q8l() //  [R1]
         { info_tbl: [(c7Q8l,
                       label: block_c7Q8l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q8l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Q8w; else goto c7Q8v;
       c7Q8w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Q8v: // global
           _s7PYe::I64 = I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7PYe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.098035449 UTC

[section ""data" . GHC.IO.Buffer.bufL_closure" {
     GHC.IO.Buffer.bufL_closure:
         const GHC.IO.Buffer.bufL_info;
 },
 GHC.IO.Buffer.bufL_entry() //  [R2]
         { info_tbl: [(c7Q8R,
                       label: GHC.IO.Buffer.bufL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q8R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Q8V; else goto c7Q8W;
       c7Q8V: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Q8W: // global
           I64[Sp - 8] = block_c7Q8O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Q90; else goto c7Q8P;
       u7Q90: // global
           call _c7Q8O(R1) args: 0, res: 0, upd: 0;
       c7Q8P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q8O() //  [R1]
         { info_tbl: [(c7Q8O,
                       label: block_c7Q8O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q8O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Q8Z; else goto c7Q8Y;
       c7Q8Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Q8Y: // global
           _s7PYl::I64 = I64[R1 + 39];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7PYl::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.104360507 UTC

[section ""data" . GHC.IO.Buffer.bufSize_closure" {
     GHC.IO.Buffer.bufSize_closure:
         const GHC.IO.Buffer.bufSize_info;
 },
 GHC.IO.Buffer.bufSize_entry() //  [R2]
         { info_tbl: [(c7Q9k,
                       label: GHC.IO.Buffer.bufSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q9k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Q9o; else goto c7Q9p;
       c7Q9o: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Q9p: // global
           I64[Sp - 8] = block_c7Q9h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Q9t; else goto c7Q9i;
       u7Q9t: // global
           call _c7Q9h(R1) args: 0, res: 0, upd: 0;
       c7Q9i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q9h() //  [R1]
         { info_tbl: [(c7Q9h,
                       label: block_c7Q9h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q9h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Q9s; else goto c7Q9r;
       c7Q9s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Q9r: // global
           _s7PYs::I64 = I64[R1 + 31];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7PYs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.111268638 UTC

[section ""data" . GHC.IO.Buffer.bufState_closure" {
     GHC.IO.Buffer.bufState_closure:
         const GHC.IO.Buffer.bufState_info;
 },
 GHC.IO.Buffer.bufState_entry() //  [R2]
         { info_tbl: [(c7Q9N,
                       label: GHC.IO.Buffer.bufState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q9N: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Q9O; else goto c7Q9P;
       c7Q9O: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufState_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Q9P: // global
           I64[Sp - 8] = block_c7Q9K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Q9T; else goto c7Q9L;
       u7Q9T: // global
           call _c7Q9K(R1) args: 0, res: 0, upd: 0;
       c7Q9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Q9K() //  [R1]
         { info_tbl: [(c7Q9K,
                       label: block_c7Q9K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Q9K: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.117753659 UTC

[section ""data" . GHC.IO.Buffer.bufRaw_closure" {
     GHC.IO.Buffer.bufRaw_closure:
         const GHC.IO.Buffer.bufRaw_info;
 },
 GHC.IO.Buffer.bufRaw_entry() //  [R2]
         { info_tbl: [(c7Qad,
                       label: GHC.IO.Buffer.bufRaw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qad: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Qah; else goto c7Qai;
       c7Qah: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufRaw_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Qai: // global
           I64[Sp - 8] = block_c7Qaa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qam; else goto c7Qab;
       u7Qam: // global
           call _c7Qaa(R1) args: 0, res: 0, upd: 0;
       c7Qab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qaa() //  [R1]
         { info_tbl: [(c7Qaa,
                       label: block_c7Qaa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qaa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Qal; else goto c7Qak;
       c7Qal: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Qak: // global
           _s7PYG::P64 = P64[R1 + 7];
           _s7PYF::I64 = I64[R1 + 23];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = _s7PYG::P64;
           I64[Hp] = _s7PYF::I64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.124067363 UTC

[section ""data" . GHC.IO.Buffer.charSize_closure" {
     GHC.IO.Buffer.charSize_closure:
         const GHC.Types.I#_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.12688043 UTC

[section ""data" . GHC.IO.Buffer.withBuffer1_closure" {
     GHC.IO.Buffer.withBuffer1_closure:
         const GHC.IO.Buffer.withBuffer1_info;
 },
 GHC.IO.Buffer.withBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7QaH,
                       label: GHC.IO.Buffer.withBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QaH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7QaI; else goto c7QaJ;
       c7QaI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.withBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7QaJ: // global
           I64[Sp - 16] = block_c7QaE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7QaU; else goto c7QaF;
       u7QaU: // global
           call _c7QaE(R1) args: 0, res: 0, upd: 0;
       c7QaF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QaE() //  [R1]
         { info_tbl: [(c7QaE,
                       label: block_c7QaE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QaE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7QaQ; else goto c7QaP;
       c7QaQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7QaP: // global
           _s7PYQ::P64 = P64[R1 + 7];
           _s7PYP::I64 = I64[R1 + 23];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s7PYP::I64;
           I64[Sp] = block_c7QaN_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7PYQ::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QaN() //  [R1]
         { info_tbl: [(c7QaN,
                       label: block_c7QaN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QaN: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.134756939 UTC

[section ""data" . GHC.IO.Buffer.withBuffer_closure" {
     GHC.IO.Buffer.withBuffer_closure:
         const GHC.IO.Buffer.withBuffer_info;
 },
 GHC.IO.Buffer.withBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7Qbf,
                       label: GHC.IO.Buffer.withBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qbf: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.withBuffer1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.139467063 UTC

[section ""data" . GHC.IO.Buffer.withRawBuffer1_closure" {
     GHC.IO.Buffer.withRawBuffer1_closure:
         const GHC.IO.Buffer.withRawBuffer1_info;
 },
 sat_s7PZ3_entry() //  [R1]
         { info_tbl: [(c7Qbu,
                       label: sat_s7PZ3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qbu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Qbv; else goto c7Qbw;
       c7Qbv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Qbw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.ForeignPtr.unsafeForeignPtrToPtr_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.withRawBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7QbC,
                       label: GHC.IO.Buffer.withRawBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QbC: // global
           _s7PZ1::P64 = R3;
           _s7PZ0::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c7QbD; else goto c7QbE;
       c7QbE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7QbG; else goto c7QbF;
       c7QbG: // global
           HpAlloc = 24;
           goto c7QbD;
       c7QbD: // global
           R3 = _s7PZ1::P64;
           R2 = _s7PZ0::P64;
           R1 = GHC.IO.Buffer.withRawBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7QbF: // global
           I64[Hp - 16] = sat_s7PZ3_info;
           P64[Hp] = _s7PZ0::P64;
           I64[Sp - 16] = block_c7Qbx_info;
           R2 = Hp - 16;
           R1 = _s7PZ1::P64;
           P64[Sp - 8] = _s7PZ0::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qbx() //  [R1]
         { info_tbl: [(c7Qbx,
                       label: block_c7Qbx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qbx: // global
           I64[Sp] = block_c7Qbz_info;
           _s7PZ6::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7PZ6::P64;
           if (R1 & 7 != 0) goto u7QbM; else goto c7QbA;
       u7QbM: // global
           call _c7Qbz(R1) args: 0, res: 0, upd: 0;
       c7QbA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qbz() //  [R1]
         { info_tbl: [(c7Qbz,
                       label: block_c7Qbz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qbz: // global
           _s7PZ6::P64 = P64[Sp + 8];
           call MO_Touch(P64[R1 + 7]);
           R1 = _s7PZ6::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.149571468 UTC

[section ""data" . GHC.IO.Buffer.withRawBuffer_closure" {
     GHC.IO.Buffer.withRawBuffer_closure:
         const GHC.IO.Buffer.withRawBuffer_info;
 },
 GHC.IO.Buffer.withRawBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7Qcc,
                       label: GHC.IO.Buffer.withRawBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qcc: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.withRawBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.153153428 UTC

[section ""data" . GHC.IO.Buffer.isEmptyBuffer_closure" {
     GHC.IO.Buffer.isEmptyBuffer_closure:
         const GHC.IO.Buffer.isEmptyBuffer_info;
 },
 GHC.IO.Buffer.isEmptyBuffer_entry() //  [R2]
         { info_tbl: [(c7Qcq,
                       label: GHC.IO.Buffer.isEmptyBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qcq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Qcr; else goto c7Qcs;
       c7Qcr: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isEmptyBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Qcs: // global
           I64[Sp - 8] = block_c7Qcn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qcx; else goto c7Qco;
       u7Qcx: // global
           call _c7Qcn(R1) args: 0, res: 0, upd: 0;
       c7Qco: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qcn() //  [R1]
         { info_tbl: [(c7Qcn,
                       label: block_c7Qcn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qcn: // global
           R1 = I64[((I64[R1 + 39] == I64[R1 + 47]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.159958413 UTC

[section ""data" . GHC.IO.Buffer.isFullBuffer_closure" {
     GHC.IO.Buffer.isFullBuffer_closure:
         const GHC.IO.Buffer.isFullBuffer_info;
 },
 GHC.IO.Buffer.isFullBuffer_entry() //  [R2]
         { info_tbl: [(c7QcU,
                       label: GHC.IO.Buffer.isFullBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QcU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7QcV; else goto c7QcW;
       c7QcV: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isFullBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7QcW: // global
           I64[Sp - 8] = block_c7QcR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qd1; else goto c7QcS;
       u7Qd1: // global
           call _c7QcR(R1) args: 0, res: 0, upd: 0;
       c7QcS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QcR() //  [R1]
         { info_tbl: [(c7QcR,
                       label: block_c7QcR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QcR: // global
           R1 = I64[((I64[R1 + 31] == I64[R1 + 47]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.165809609 UTC

[section ""data" . GHC.IO.Buffer.isFullCharBuffer_closure" {
     GHC.IO.Buffer.isFullCharBuffer_closure:
         const GHC.IO.Buffer.isFullCharBuffer_info;
 },
 GHC.IO.Buffer.isFullCharBuffer_entry() //  [R2]
         { info_tbl: [(c7Qdl,
                       label: GHC.IO.Buffer.isFullCharBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qdl: // global
           R2 = R2;
           call GHC.IO.Buffer.isFullBuffer_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.16993473 UTC

[section ""data" . GHC.IO.Buffer.isWriteBuffer_closure" {
     GHC.IO.Buffer.isWriteBuffer_closure:
         const GHC.IO.Buffer.isWriteBuffer_info;
 },
 GHC.IO.Buffer.isWriteBuffer_entry() //  [R2]
         { info_tbl: [(c7Qdz,
                       label: GHC.IO.Buffer.isWriteBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qdz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7QdA; else goto c7QdB;
       c7QdA: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.isWriteBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7QdB: // global
           I64[Sp - 8] = block_c7Qdw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7QdT; else goto c7Qdx;
       u7QdT: // global
           call _c7Qdw(R1) args: 0, res: 0, upd: 0;
       c7Qdx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qdw() //  [R1]
         { info_tbl: [(c7Qdw,
                       label: block_c7Qdw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qdw: // global
           I64[Sp] = block_c7QdE_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto u7QdS; else goto c7QdG;
       u7QdS: // global
           call _c7QdE(R1) args: 0, res: 0, upd: 0;
       c7QdG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QdE() //  [R1]
         { info_tbl: [(c7QdE,
                       label: block_c7QdE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QdE: // global
           if (R1 & 7 == 1) goto c7QdM; else goto c7QdQ;
       c7QdM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7QdQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.17914703 UTC

[section ""data" . GHC.IO.Buffer.bufferAdjustL_closure" {
     GHC.IO.Buffer.bufferAdjustL_closure:
         const GHC.IO.Buffer.bufferAdjustL_info;
 },
 GHC.IO.Buffer.bufferAdjustL_entry() //  [R2, R3]
         { info_tbl: [(c7Qem,
                       label: GHC.IO.Buffer.bufferAdjustL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qem: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7Qeq; else goto c7Qer;
       c7Qeq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAdjustL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qer: // global
           I64[Sp - 16] = block_c7Qej_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7QeK; else goto c7Qek;
       u7QeK: // global
           call _c7Qej(R1) args: 0, res: 0, upd: 0;
       c7Qek: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qej() //  [R1]
         { info_tbl: [(c7Qej,
                       label: block_c7Qej_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qej: // global
           I64[Sp - 32] = block_c7Qep_info;
           _s7PZG::P64 = P64[R1 + 7];
           _s7PZH::P64 = P64[R1 + 15];
           _s7PZF::I64 = I64[R1 + 23];
           _s7PZI::I64 = I64[R1 + 31];
           _s7PZK::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 24] = _s7PZH::P64;
           I64[Sp - 16] = _s7PZI::I64;
           I64[Sp - 8] = _s7PZK::I64;
           P64[Sp] = _s7PZG::P64;
           I64[Sp + 8] = _s7PZF::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7QeJ; else goto c7Qet;
       u7QeJ: // global
           call _c7Qep(R1) args: 0, res: 0, upd: 0;
       c7Qet: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qep() //  [R1]
         { info_tbl: [(c7Qep,
                       label: block_c7Qep_info
                       rep:StackRep [False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qep: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Qez; else goto c7Qey;
       c7Qez: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Qey: // global
           _s7PZF::I64 = I64[Sp + 40];
           _s7PZG::P64 = P64[Sp + 32];
           _s7PZH::P64 = P64[Sp + 8];
           _s7PZI::I64 = I64[Sp + 16];
           _s7PZK::I64 = I64[Sp + 24];
           _s7PZM::I64 = I64[R1 + 7];
           if (_s7PZM::I64 == _s7PZK::I64) goto c7QeI; else goto c7QeF;
       c7QeI: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7PZG::P64;
           P64[Hp - 32] = _s7PZH::P64;
           I64[Hp - 24] = _s7PZF::I64;
           I64[Hp - 16] = _s7PZI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7QeF: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7PZG::P64;
           P64[Hp - 32] = _s7PZH::P64;
           I64[Hp - 24] = _s7PZF::I64;
           I64[Hp - 16] = _s7PZI::I64;
           I64[Hp - 8] = _s7PZM::I64;
           I64[Hp] = _s7PZK::I64;
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.189142107 UTC

[section ""data" . GHC.IO.Buffer.emptyBuffer_closure" {
     GHC.IO.Buffer.emptyBuffer_closure:
         const GHC.IO.Buffer.emptyBuffer_info;
 },
 GHC.IO.Buffer.emptyBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Qfb,
                       label: GHC.IO.Buffer.emptyBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qfb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Qfk; else goto c7Qfl;
       c7Qfk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.emptyBuffer_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qfl: // global
           I64[Sp - 24] = block_c7Qf8_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Qfr; else goto c7Qf9;
       u7Qfr: // global
           call _c7Qf8(R1) args: 0, res: 0, upd: 0;
       c7Qf9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qf8() //  [R1]
         { info_tbl: [(c7Qf8,
                       label: block_c7Qf8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qf8: // global
           I64[Sp - 8] = block_c7Qfe_info;
           _s7PZT::P64 = P64[R1 + 7];
           _s7PZS::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7PZT::P64;
           I64[Sp + 8] = _s7PZS::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qfq; else goto c7Qff;
       u7Qfq: // global
           call _c7Qfe(R1) args: 0, res: 0, upd: 0;
       c7Qff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qfe() //  [R1]
         { info_tbl: [(c7Qfe,
                       label: block_c7Qfe_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qfe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Qfp; else goto c7Qfo;
       c7Qfp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Qfo: // global
           _s7PZV::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = _s7PZV::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.197647105 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer5_bytes" {
     GHC.IO.Buffer.summaryBuffer5_bytes:
         I8[] [98,117,102]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.199798455 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer4_bytes" {
     GHC.IO.Buffer.summaryBuffer4_bytes:
         I8[] [40]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.201471389 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer3_bytes" {
     GHC.IO.Buffer.summaryBuffer3_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.20323231 UTC

[section ""cstring" . GHC.IO.Buffer.summaryBuffer2_bytes" {
     GHC.IO.Buffer.summaryBuffer2_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.205391962 UTC

[section ""data" . GHC.IO.Buffer.summaryBuffer1_closure" {
     GHC.IO.Buffer.summaryBuffer1_closure:
         const GHC.IO.Buffer.summaryBuffer1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Buffer.summaryBuffer1_entry() //  [R1]
         { info_tbl: [(c7QfW,
                       label: GHC.IO.Buffer.summaryBuffer1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QfW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7QfX; else goto c7QfY;
       c7QfX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7QfY: // global
           (_c7QfT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7QfT::I64 == 0) goto c7QfV; else goto c7QfU;
       c7QfV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7QfU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7QfT::I64;
           R2 = GHC.IO.Buffer.summaryBuffer2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.212061634 UTC

[section ""data" . GHC.IO.Buffer.$wsummaryBuffer_closure" {
     GHC.IO.Buffer.$wsummaryBuffer_closure:
         const GHC.IO.Buffer.$wsummaryBuffer_info;
         const 0;
 },
 sat_s7Q0b_entry() //  [R1]
         { info_tbl: [(c7QgC,
                       label: sat_s7Q0b_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QgC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7QgD; else goto c7QgE;
       c7QgD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7QgE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c7Qgz_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Qgz() //  [R1, R2]
         { info_tbl: [(c7Qgz,
                       label: block_c7Qgz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qgz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7QgH; else goto c7QgG;
       c7QgH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7QgG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.IO.Buffer.summaryBuffer1_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Q0c_entry() //  [R1]
         { info_tbl: [(c7QgI,
                       label: sat_s7Q0c_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QgI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7QgM; else goto c7QgL;
       c7QgM: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7QgL: // global
           _s7PZY::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_s7Q0b_info;
           I64[Hp] = _s7PZY::I64;
           R3 = Hp - 16;
           R2 = GHC.IO.Buffer.summaryBuffer3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Q0d_entry() //  [R1]
         { info_tbl: [(c7QgO,
                       label: sat_s7Q0d_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QgO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7QgP; else goto c7QgQ;
       c7QgP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7QgQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c7Qgp_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Qgp() //  [R1, R2]
         { info_tbl: [(c7Qgp,
                       label: block_c7Qgp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qgp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7QgT; else goto c7QgS;
       c7QgT: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7QgS: // global
           I64[Hp - 40] = sat_s7Q0c_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7Q0e_entry() //  [R1]
         { info_tbl: [(c7QgU,
                       label: sat_s7Q0e_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QgU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7QgY; else goto c7QgX;
       c7QgY: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7QgX: // global
           _s7PZX::I64 = I64[R1 + 16];
           _s7PZY::I64 = I64[R1 + 24];
           I64[Hp - 24] = sat_s7Q0d_info;
           I64[Hp - 8] = _s7PZX::I64;
           I64[Hp] = _s7PZY::I64;
           R3 = Hp - 24;
           R2 = GHC.IO.Buffer.summaryBuffer4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7Q0f_entry() //  [R1]
         { info_tbl: [(c7Qh0,
                       label: sat_s7Q0f_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qh0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Qh1; else goto c7Qh2;
       c7Qh1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Qh2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c7Qgf_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           I64[Sp - 32] = I64[R1 + 24];
           I64[Sp - 24] = I64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c7Qgf() //  [R1, R2]
         { info_tbl: [(c7Qgf,
                       label: block_c7Qgf_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qgf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Qh5; else goto c7Qh4;
       c7Qh5: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c7Qh4: // global
           I64[Hp - 48] = sat_s7Q0e_info;
           I64[Hp - 32] = I64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.$wsummaryBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Qh6,
                       label: GHC.IO.Buffer.$wsummaryBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qh6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Qha; else goto c7Qh9;
       c7Qha: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.$wsummaryBuffer_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qh9: // global
           I64[Hp - 32] = sat_s7Q0f_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = R3;
           I64[Hp] = R4;
           R3 = Hp - 32;
           R2 = GHC.IO.Buffer.summaryBuffer5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.234993742 UTC

[section ""data" . GHC.IO.Buffer.summaryBuffer_closure" {
     GHC.IO.Buffer.summaryBuffer_closure:
         const GHC.IO.Buffer.summaryBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.summaryBuffer_entry() //  [R2]
         { info_tbl: [(c7Qib,
                       label: GHC.IO.Buffer.summaryBuffer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qib: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Qic; else goto c7Qid;
       c7Qic: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.summaryBuffer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Qid: // global
           I64[Sp - 8] = block_c7Qi8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qih; else goto c7Qi9;
       u7Qih: // global
           call _c7Qi8(R1) args: 0, res: 0, upd: 0;
       c7Qi9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qi8() //  [R1]
         { info_tbl: [(c7Qi8,
                       label: block_c7Qi8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qi8: // global
           R4 = I64[R1 + 47];
           R3 = I64[R1 + 39];
           R2 = I64[R1 + 31];
           Sp = Sp + 8;
           call GHC.IO.Buffer.$wsummaryBuffer_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.241107116 UTC

[section ""cstring" . GHC.IO.Buffer.$trModule4_bytes" {
     GHC.IO.Buffer.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.243099746 UTC

[section ""data" . GHC.IO.Buffer.$trModule3_closure" {
     GHC.IO.Buffer.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.244857728 UTC

[section ""cstring" . GHC.IO.Buffer.$trModule2_bytes" {
     GHC.IO.Buffer.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.246653936 UTC

[section ""data" . GHC.IO.Buffer.$trModule1_closure" {
     GHC.IO.Buffer.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.248722475 UTC

[section ""data" . GHC.IO.Buffer.$trModule_closure" {
     GHC.IO.Buffer.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Buffer.$trModule3_closure+1;
         const GHC.IO.Buffer.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.250437597 UTC

[section ""data" . $krep_r7OJJ_closure" {
     $krep_r7OJJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.252125138 UTC

[section ""data" . $krep1_r7OJK_closure" {
     $krep1_r7OJK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.253902203 UTC

[section ""data" . $krep2_r7OJL_closure" {
     $krep2_r7OJL_closure:
         const :_con_info;
         const $krep1_r7OJK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.255738494 UTC

[section ""data" . $krep3_r7OJM_closure" {
     $krep3_r7OJM_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ForeignPtr.$tcForeignPtr_closure;
         const $krep2_r7OJL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.25820997 UTC

[section ""cstring" . GHC.IO.Buffer.$tcBufferState2_bytes" {
     GHC.IO.Buffer.$tcBufferState2_bytes:
         I8[] [66,117,102,102,101,114,83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.259914423 UTC

[section ""data" . GHC.IO.Buffer.$tcBufferState1_closure" {
     GHC.IO.Buffer.$tcBufferState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tcBufferState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.261666061 UTC

[section ""data" . GHC.IO.Buffer.$tcBufferState_closure" {
     GHC.IO.Buffer.$tcBufferState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tcBufferState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 15354245406219544442;
         const 3075510984364124805;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.263624174 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer1_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBufferState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.265509349 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'ReadBuffer3_bytes" {
     GHC.IO.Buffer.$tc'ReadBuffer3_bytes:
         I8[] [39,82,101,97,100,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.267587068 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer2_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'ReadBuffer3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.269912955 UTC

[section ""data" . GHC.IO.Buffer.$tc'ReadBuffer_closure" {
     GHC.IO.Buffer.$tc'ReadBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer2_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const 18127629064171759490;
         const 12249378994783130540;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.271794556 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'WriteBuffer2_bytes" {
     GHC.IO.Buffer.$tc'WriteBuffer2_bytes:
         I8[] [39,87,114,105,116,101,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.273586632 UTC

[section ""data" . GHC.IO.Buffer.$tc'WriteBuffer1_closure" {
     GHC.IO.Buffer.$tc'WriteBuffer1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'WriteBuffer2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.275691816 UTC

[section ""data" . GHC.IO.Buffer.$tc'WriteBuffer_closure" {
     GHC.IO.Buffer.$tc'WriteBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'WriteBuffer1_closure+1;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const 17535537923682101798;
         const 5353421715631386637;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.277591354 UTC

[section ""cstring" . GHC.IO.Buffer.$tcBuffer2_bytes" {
     GHC.IO.Buffer.$tcBuffer2_bytes:
         I8[] [66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.279234246 UTC

[section ""data" . GHC.IO.Buffer.$tcBuffer1_closure" {
     GHC.IO.Buffer.$tcBuffer1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tcBuffer2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.280993354 UTC

[section ""data" . GHC.IO.Buffer.$tcBuffer_closure" {
     GHC.IO.Buffer.$tcBuffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tcBuffer1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 18372445388029251215;
         const 8106905342043791875;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.283361491 UTC

[section ""data" . $krep4_r7OJN_closure" {
     $krep4_r7OJN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Buffer.$tcBuffer_closure+1;
         const $krep2_r7OJL_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.285535042 UTC

[section ""data" . $krep5_r7OJO_closure" {
     $krep5_r7OJO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep4_r7OJN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.287193429 UTC

[section ""data" . $krep6_r7OJP_closure" {
     $krep6_r7OJP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep5_r7OJO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.288967907 UTC

[section ""data" . $krep7_r7OJQ_closure" {
     $krep7_r7OJQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7OJJ_closure+1;
         const $krep6_r7OJP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.290874078 UTC

[section ""data" . $krep8_r7OJR_closure" {
     $krep8_r7OJR_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.IO.Buffer.$tc'ReadBuffer1_closure+1;
         const $krep7_r7OJQ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.293098599 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer1_closure" {
     GHC.IO.Buffer.$tc'Buffer1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r7OJM_closure+1;
         const $krep8_r7OJR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.295189363 UTC

[section ""cstring" . GHC.IO.Buffer.$tc'Buffer3_bytes" {
     GHC.IO.Buffer.$tc'Buffer3_bytes:
         I8[] [39,66,117,102,102,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.29684347 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer2_closure" {
     GHC.IO.Buffer.$tc'Buffer2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Buffer.$tc'Buffer3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.298698916 UTC

[section ""data" . GHC.IO.Buffer.$tc'Buffer_closure" {
     GHC.IO.Buffer.$tc'Buffer_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Buffer.$trModule_closure+1;
         const GHC.IO.Buffer.$tc'Buffer2_closure+1;
         const GHC.IO.Buffer.$tc'Buffer1_closure+4;
         const 6953290879310668230;
         const 8839152842293094522;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.301377163 UTC

[section ""data" . GHC.IO.Buffer.writeWord8Buf1_closure" {
     GHC.IO.Buffer.writeWord8Buf1_closure:
         const GHC.IO.Buffer.writeWord8Buf1_info;
 },
 GHC.IO.Buffer.writeWord8Buf1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Qj4,
                       label: GHC.IO.Buffer.writeWord8Buf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qj4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Qjd; else goto c7Qje;
       c7Qjd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.writeWord8Buf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qje: // global
           I64[Sp - 24] = block_c7Qj1_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Qjr; else goto c7Qj2;
       u7Qjr: // global
           call _c7Qj1(R1) args: 0, res: 0, upd: 0;
       c7Qj2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qj1() //  [R1]
         { info_tbl: [(c7Qj1,
                       label: block_c7Qj1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qj1: // global
           I64[Sp - 8] = block_c7Qj7_info;
           _s7Q0u::P64 = P64[R1 + 7];
           _s7Q0t::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7Q0u::P64;
           I64[Sp + 8] = _s7Q0t::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qjq; else goto c7Qj8;
       u7Qjq: // global
           call _c7Qj7(R1) args: 0, res: 0, upd: 0;
       c7Qj8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qj7() //  [R1]
         { info_tbl: [(c7Qj7,
                       label: block_c7Qj7_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qj7: // global
           I64[Sp] = block_c7Qjc_info;
           _s7Q0w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7Q0w::I64;
           if (R1 & 7 != 0) goto u7Qjs; else goto c7Qjh;
       u7Qjs: // global
           call _c7Qjc(R1) args: 0, res: 0, upd: 0;
       c7Qjh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qjc() //  [R1]
         { info_tbl: [(c7Qjc,
                       label: block_c7Qjc_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qjc: // global
           _s7Q0u::P64 = P64[Sp + 8];
           I8[I64[Sp + 16] + I64[Sp + 24]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           call MO_Touch(_s7Q0u::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.311778151 UTC

[section ""data" . GHC.IO.Buffer.writeWord8Buf_closure" {
     GHC.IO.Buffer.writeWord8Buf_closure:
         const GHC.IO.Buffer.writeWord8Buf_info;
 },
 GHC.IO.Buffer.writeWord8Buf_entry() //  [R2, R3, R4]
         { info_tbl: [(c7QjW,
                       label: GHC.IO.Buffer.writeWord8Buf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QjW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.writeWord8Buf1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.316035982 UTC

[section ""data" . GHC.IO.Buffer.readWord8Buf1_closure" {
     GHC.IO.Buffer.readWord8Buf1_closure:
         const GHC.IO.Buffer.readWord8Buf1_info;
 },
 GHC.IO.Buffer.readWord8Buf1_entry() //  [R2, R3]
         { info_tbl: [(c7Qka,
                       label: GHC.IO.Buffer.readWord8Buf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qka: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Qkn; else goto c7Qko;
       c7Qkn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.readWord8Buf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qko: // global
           I64[Sp - 16] = block_c7Qk7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Qku; else goto c7Qk8;
       u7Qku: // global
           call _c7Qk7(R1) args: 0, res: 0, upd: 0;
       c7Qk8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qk7() //  [R1]
         { info_tbl: [(c7Qk7,
                       label: block_c7Qk7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qk7: // global
           I64[Sp - 8] = block_c7Qkd_info;
           _s7Q0H::P64 = P64[R1 + 7];
           _s7Q0G::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7Q0H::P64;
           I64[Sp + 8] = _s7Q0G::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qkt; else goto c7Qke;
       u7Qkt: // global
           call _c7Qkd(R1) args: 0, res: 0, upd: 0;
       c7Qke: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qkd() //  [R1]
         { info_tbl: [(c7Qkd,
                       label: block_c7Qkd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qkd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Qks; else goto c7Qkr;
       c7Qks: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Qkr: // global
           _s7Q0N::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 16] + I64[R1 + 7]]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s7Q0N::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.324667839 UTC

[section ""data" . GHC.IO.Buffer.readWord8Buf_closure" {
     GHC.IO.Buffer.readWord8Buf_closure:
         const GHC.IO.Buffer.readWord8Buf_info;
 },
 GHC.IO.Buffer.readWord8Buf_entry() //  [R2, R3]
         { info_tbl: [(c7QkS,
                       label: GHC.IO.Buffer.readWord8Buf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QkS: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.readWord8Buf1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.329015651 UTC

[section ""data" . GHC.IO.Buffer.bufferAdd_closure" {
     GHC.IO.Buffer.bufferAdd_closure:
         const GHC.IO.Buffer.bufferAdd_info;
 },
 GHC.IO.Buffer.bufferAdd_entry() //  [R2, R3]
         { info_tbl: [(c7Ql6,
                       label: GHC.IO.Buffer.bufferAdd_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ql6: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c7Qli; else goto c7Qlj;
       c7Qli: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAdd_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qlj: // global
           I64[Sp - 16] = block_c7Ql3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Qlp; else goto c7Ql4;
       u7Qlp: // global
           call _c7Ql3(R1) args: 0, res: 0, upd: 0;
       c7Ql4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ql3() //  [R1]
         { info_tbl: [(c7Ql3,
                       label: block_c7Ql3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ql3: // global
           I64[Sp - 40] = block_c7Ql9_info;
           _s7Q0U::P64 = P64[R1 + 7];
           _s7Q0V::P64 = P64[R1 + 15];
           _s7Q0T::I64 = I64[R1 + 23];
           _s7Q0W::I64 = I64[R1 + 31];
           _s7Q0X::I64 = I64[R1 + 39];
           _s7Q0Y::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s7Q0V::P64;
           I64[Sp - 24] = _s7Q0W::I64;
           I64[Sp - 16] = _s7Q0X::I64;
           I64[Sp - 8] = _s7Q0Y::I64;
           P64[Sp] = _s7Q0U::P64;
           I64[Sp + 8] = _s7Q0T::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Qlo; else goto c7Qla;
       u7Qlo: // global
           call _c7Ql9(R1) args: 0, res: 0, upd: 0;
       c7Qla: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ql9() //  [R1]
         { info_tbl: [(c7Ql9,
                       label: block_c7Ql9_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ql9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Qln; else goto c7Qlm;
       c7Qln: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Qlm: // global
           _s7Q11::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 48];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = _s7Q11::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.338922803 UTC

[section ""data" . GHC.IO.Buffer.bufferRemove_closure" {
     GHC.IO.Buffer.bufferRemove_closure:
         const GHC.IO.Buffer.bufferRemove_info;
 },
 GHC.IO.Buffer.bufferRemove_entry() //  [R2, R3]
         { info_tbl: [(c7QlV,
                       label: GHC.IO.Buffer.bufferRemove_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QlV: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c7QlZ; else goto c7Qm0;
       c7QlZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferRemove_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qm0: // global
           I64[Sp - 16] = block_c7QlS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Qmm; else goto c7QlT;
       u7Qmm: // global
           call _c7QlS(R1) args: 0, res: 0, upd: 0;
       c7QlT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QlS() //  [R1]
         { info_tbl: [(c7QlS,
                       label: block_c7QlS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QlS: // global
           I64[Sp - 40] = block_c7QlY_info;
           _s7Q16::P64 = P64[R1 + 7];
           _s7Q17::P64 = P64[R1 + 15];
           _s7Q15::I64 = I64[R1 + 23];
           _s7Q18::I64 = I64[R1 + 31];
           _s7Q19::I64 = I64[R1 + 39];
           _s7Q1a::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           P64[Sp - 32] = _s7Q17::P64;
           I64[Sp - 24] = _s7Q18::I64;
           I64[Sp - 16] = _s7Q19::I64;
           I64[Sp - 8] = _s7Q1a::I64;
           P64[Sp] = _s7Q16::P64;
           I64[Sp + 8] = _s7Q15::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u7Qml; else goto c7Qm2;
       u7Qml: // global
           call _c7QlY(R1) args: 0, res: 0, upd: 0;
       c7Qm2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QlY() //  [R1]
         { info_tbl: [(c7QlY,
                       label: block_c7QlY_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QlY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Qm8; else goto c7Qm7;
       c7Qm8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Qm7: // global
           _s7Q15::I64 = I64[Sp + 48];
           _s7Q16::P64 = P64[Sp + 40];
           _s7Q17::P64 = P64[Sp + 8];
           _s7Q18::I64 = I64[Sp + 16];
           _s7Q1a::I64 = I64[Sp + 32];
           _s7Q1d::I64 = I64[Sp + 24] + I64[R1 + 7];
           if (_s7Q1d::I64 == _s7Q1a::I64) goto c7Qmk; else goto c7Qmh;
       c7Qmk: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7Q16::P64;
           P64[Hp - 32] = _s7Q17::P64;
           I64[Hp - 24] = _s7Q15::I64;
           I64[Hp - 16] = _s7Q18::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Qmh: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7Q16::P64;
           P64[Hp - 32] = _s7Q17::P64;
           I64[Hp - 24] = _s7Q15::I64;
           I64[Hp - 16] = _s7Q18::I64;
           I64[Hp - 8] = _s7Q1d::I64;
           I64[Hp] = _s7Q1a::I64;
           R1 = Hp - 47;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.348737343 UTC

[section ""data" . GHC.IO.Buffer.bufferAvailable_closure" {
     GHC.IO.Buffer.bufferAvailable_closure:
         const GHC.IO.Buffer.bufferAvailable_info;
 },
 GHC.IO.Buffer.bufferAvailable_entry() //  [R2]
         { info_tbl: [(c7QmP,
                       label: GHC.IO.Buffer.bufferAvailable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QmP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7QmW; else goto c7QmX;
       c7QmW: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferAvailable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7QmX: // global
           I64[Sp - 8] = block_c7QmM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qn1; else goto c7QmN;
       u7Qn1: // global
           call _c7QmM(R1) args: 0, res: 0, upd: 0;
       c7QmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QmM() //  [R1]
         { info_tbl: [(c7QmM,
                       label: block_c7QmM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QmM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Qn0; else goto c7QmZ;
       c7Qn0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7QmZ: // global
           _s7Q1n::I64 = I64[R1 + 31] - I64[R1 + 47];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Q1n::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.356481163 UTC

[section ""data" . GHC.IO.Buffer.bufferElems_closure" {
     GHC.IO.Buffer.bufferElems_closure:
         const GHC.IO.Buffer.bufferElems_info;
 },
 GHC.IO.Buffer.bufferElems_entry() //  [R2]
         { info_tbl: [(c7Qnn,
                       label: GHC.IO.Buffer.bufferElems_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qnn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Qnu; else goto c7Qnv;
       c7Qnu: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.bufferElems_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Qnv: // global
           I64[Sp - 8] = block_c7Qnk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qnz; else goto c7Qnl;
       u7Qnz: // global
           call _c7Qnk(R1) args: 0, res: 0, upd: 0;
       c7Qnl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qnk() //  [R1]
         { info_tbl: [(c7Qnk,
                       label: block_c7Qnk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qnk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Qny; else goto c7Qnx;
       c7Qny: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Qnx: // global
           _s7Q1w::I64 = I64[R1 + 47] - I64[R1 + 39];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Q1w::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.365663566 UTC

[section ""cstring" . lvl_r7OJS_bytes" {
     lvl_r7OJS_bytes:
         I8[] [98,117,102,102,101,114,32,105,110,118,97,114,105,97,110,116,32,118,105,111,108,97,116,105,111,110,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.368688341 UTC

[section ""data" . GHC.IO.Buffer.$wlvl_closure" {
     GHC.IO.Buffer.$wlvl_closure:
         const GHC.IO.Buffer.$wlvl_info;
         const 0;
 },
 sat_s7Q1A_entry() //  [R1]
         { info_tbl: [(c7QnX,
                       label: sat_s7Q1A_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QnX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7QnY; else goto c7QnZ;
       c7QnY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7QnZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = I64[R1 + 32];
           R3 = I64[R1 + 24];
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.IO.Buffer.$wsummaryBuffer_entry(R4,
                                                    R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.$wlvl_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Qo2,
                       label: GHC.IO.Buffer.$wlvl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qo2: // global
           _s7Q1z::I64 = R4;
           _s7Q1y::I64 = R3;
           _s7Q1x::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c7Qo3; else goto c7Qo4;
       c7Qo4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Qo6; else goto c7Qo5;
       c7Qo6: // global
           HpAlloc = 40;
           goto c7Qo3;
       c7Qo3: // global
           R4 = _s7Q1z::I64;
           R3 = _s7Q1y::I64;
           R2 = _s7Q1x::I64;
           R1 = GHC.IO.Buffer.$wlvl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qo5: // global
           I64[Hp - 32] = sat_s7Q1A_info;
           I64[Hp - 16] = _s7Q1x::I64;
           I64[Hp - 8] = _s7Q1y::I64;
           I64[Hp] = _s7Q1z::I64;
           I64[Sp - 8] = block_c7Qo0_info;
           R3 = Hp - 32;
           R2 = lvl_r7OJS_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qo0() //  [R1]
         { info_tbl: [(c7Qo0,
                       label: block_c7Qo0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qo0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.380235736 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer2_closure" {
     GHC.IO.Buffer.checkBuffer2_closure:
         const GHC.IO.Buffer.checkBuffer2_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer2_entry() //  [R2, R3]
         { info_tbl: [(c7Qot,
                       label: GHC.IO.Buffer.checkBuffer2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qot: // global
           R4 = R3;
           R3 = 0;
           R2 = R2;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.386728083 UTC

[section ""data" . GHC.IO.Buffer.$wcheckBuffer_closure" {
     GHC.IO.Buffer.$wcheckBuffer_closure:
         const GHC.IO.Buffer.$wcheckBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.$wcheckBuffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QoB: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.IO.Buffer.$wcheckBuffer_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Buffer.$wcheckBuffer_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c7QoK,
                       label: GHC.IO.Buffer.$wcheckBuffer_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QoK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7QoL; else goto c7QoM;
       c7QoL: // global
           R1 = GHC.IO.Buffer.$wcheckBuffer_closure;
           P64[Sp - 32] = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       c7QoM: // global
           if (%MO_S_Le_W64(R3, 0)) goto u7QpU; else goto c7QoJ;
       u7QpU: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7Qq7;
       c7QoJ: // global
           if (%MO_S_Gt_W64(R4, R5)) goto u7QpV; else goto c7QpR;
       u7QpV: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7Qq7;
       c7QpR: // global
           if (%MO_S_Gt_W64(R5, R3)) goto u7QpW; else goto c7QpQ;
       u7QpW: // global
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 24;
           goto u7Qq7;
       u7Qq7: // global
           call _c7QpN() args: 0, res: 0, upd: 0;
       c7QpQ: // global
           if (R4 == R5) goto c7Qp6; else goto c7Qpz;
       c7Qp6: // global
           I64[Sp - 32] = block_c7Qp4_info;
           R1 = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Qq3; else goto c7Qp7;
       u7Qq3: // global
           call _c7Qp4(R1) args: 0, res: 0, upd: 0;
       c7Qp7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Qpz: // global
           I64[Sp - 32] = block_c7Qpy_info;
           R1 = R2;
           I64[Sp - 24] = R3;
           I64[Sp - 16] = R4;
           I64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u7Qq4; else goto c7QpA;
       u7Qq4: // global
           call _c7Qpy(R1) args: 0, res: 0, upd: 0;
       c7QpA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qp4() //  [R1]
         { info_tbl: [(c7Qp4,
                       label: block_c7Qp4_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qp4: // global
           _s7Q1F::I64 = I64[Sp + 8];
           _s7Q1H::I64 = I64[Sp + 24];
           if (R1 & 7 == 1) goto c7Qpn; else goto c7Qpw;
       c7Qpn: // global
           _s7Q1R::I64 = I64[Sp + 16];
           if (_s7Q1R::I64 != 0) goto c7Qpe; else goto c7Qpl;
       c7Qpe: // global
           R4 = _s7Q1H::I64;
           R3 = _s7Q1R::I64;
           R2 = _s7Q1F::I64;
           Sp = Sp + 32;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
       c7Qpl: // global
           if (_s7Q1H::I64 == 0) goto u7QpZ; else goto c7Qpj;
       u7QpZ: // global
           Sp = Sp + 32;
           goto u7Qqa;
       c7Qpj: // global
           R3 = _s7Q1H::I64;
           R2 = _s7Q1F::I64;
           Sp = Sp + 32;
           call GHC.IO.Buffer.checkBuffer2_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
       c7Qpw: // global
           if (%MO_S_Ge_W64(_s7Q1H::I64,
                            _s7Q1F::I64)) goto u7QpY; else goto u7QpX;
       u7QpY: // global
           Sp = Sp + 8;
           call _c7QpN() args: 0, res: 0, upd: 0;
       u7QpX: // global
           Sp = Sp + 32;
           goto u7Qqa;
       u7Qqa: // global
           call _c7QpO() args: 0, res: 0, upd: 0;
     }
 },
 _c7Qpy() //  [R1]
         { info_tbl: [(c7Qpy,
                       label: block_c7Qpy_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qpy: // global
           if (R1 & 7 == 1) goto u7Qq0; else goto c7QpP;
       u7Qq0: // global
           Sp = Sp + 32;
           goto u7Qqc;
       c7QpP: // global
           if (%MO_S_Ge_W64(I64[Sp + 24],
                            I64[Sp + 8])) goto u7Qq2; else goto u7Qq1;
       u7Qq2: // global
           Sp = Sp + 8;
           call _c7QpN() args: 0, res: 0, upd: 0;
       u7Qq1: // global
           Sp = Sp + 32;
           goto u7Qqc;
       u7Qqc: // global
           call _c7QpO() args: 0, res: 0, upd: 0;
     }
 },
 _c7QpN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QpN: // global
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           Sp = Sp + 24;
           call GHC.IO.Buffer.$wlvl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c7QpO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QpO: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.401086426 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer1_closure" {
     GHC.IO.Buffer.checkBuffer1_closure:
         const GHC.IO.Buffer.checkBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer1_entry() //  [R2]
         { info_tbl: [(c7QqN,
                       label: GHC.IO.Buffer.checkBuffer1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QqN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7QqO; else goto c7QqP;
       c7QqO: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.checkBuffer1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7QqP: // global
           I64[Sp - 8] = block_c7QqK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7QqT; else goto c7QqL;
       u7QqT: // global
           call _c7QqK(R1) args: 0, res: 0, upd: 0;
       c7QqL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QqK() //  [R1]
         { info_tbl: [(c7QqK,
                       label: block_c7QqK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QqK: // global
           R5 = I64[R1 + 47];
           R4 = I64[R1 + 39];
           R3 = I64[R1 + 31];
           R2 = P64[R1 + 15];
           Sp = Sp + 8;
           call GHC.IO.Buffer.$wcheckBuffer_entry(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.40731149 UTC

[section ""data" . GHC.IO.Buffer.checkBuffer_closure" {
     GHC.IO.Buffer.checkBuffer_closure:
         const GHC.IO.Buffer.checkBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.checkBuffer_entry() //  [R2]
         { info_tbl: [(c7Qr8,
                       label: GHC.IO.Buffer.checkBuffer_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qr8: // global
           R2 = R2;
           call GHC.IO.Buffer.checkBuffer1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.412007196 UTC

[section ""data" . GHC.IO.Buffer.newBuffer1_closure" {
     GHC.IO.Buffer.newBuffer1_closure:
         const GHC.IO.Buffer.newBuffer1_info;
         const 0;
 },
 sat_s7Q2q_entry() //  [R1]
         { info_tbl: [(c7QrC,
                       label: sat_s7Q2q_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QrC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c7QrK; else goto c7QrL;
       c7QrK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7QrL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_c7Qrz_info;
           _s7Q2b::P64 = P64[R1 + 24];
           _s7Q2i::P64 = P64[R1 + 32];
           _s7Q2l::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _s7Q2b::P64;
           P64[Sp - 32] = _s7Q2i::P64;
           P64[Sp - 24] = _s7Q2l::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto u7QrP; else goto c7QrA;
       u7QrP: // global
           call _c7Qrz(R1) args: 0, res: 0, upd: 0;
       c7QrA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c7Qrz() //  [R1]
         { info_tbl: [(c7Qrz,
                       label: block_c7Qrz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qrz: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c7QrO; else goto c7QrN;
       c7QrO: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c7QrN: // global
           _s7Q2n::I64 = I64[R1 + 7];
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           _s7Q2l::P64 = P64[Sp + 24];
           P64[Hp - 64] = _s7Q2l::P64;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s7Q2l::P64 + 16;
           I64[Hp - 16] = _s7Q2n::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Buffer.newBuffer1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7QrQ,
                       label: GHC.IO.Buffer.newBuffer1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QrQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7QrR; else goto c7QrS;
       c7QrR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.newBuffer1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7QrS: // global
           I64[Sp - 24] = block_c7Qrj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Qs1; else goto c7Qrk;
       u7Qs1: // global
           call _c7Qrj(R1) args: 0, res: 0, upd: 0;
       c7Qrk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qrj() //  [R1]
         { info_tbl: [(c7Qrj,
                       label: block_c7Qrj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qrj: // global
           _s7Q2e::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7Q2e::I64, 0)) goto c7QrV; else goto c7Qs0;
       c7QrV: // global
           I64[Sp - 8] = block_c7Qrr_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s7Q2e::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7Qs0: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Qrr() //  [R1]
         { info_tbl: [(c7Qrr,
                       label: block_c7Qrr_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qrr: // global
           I64[Sp] = block_c7Qrt_info;
           _s7Q2i::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7Q2i::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qrt() //  [R1]
         { info_tbl: [(c7Qrt,
                       label: block_c7Qrt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qrt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7QrZ; else goto c7QrY;
       c7QrZ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7QrY: // global
           I64[Hp - 40] = sat_s7Q2q_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.427070196 UTC

[section ""data" . GHC.IO.Buffer.newBuffer_closure" {
     GHC.IO.Buffer.newBuffer_closure:
         const GHC.IO.Buffer.newBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newBuffer_entry() //  [R2, R3, R4]
         { info_tbl: [(c7QsL,
                       label: GHC.IO.Buffer.newBuffer_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QsL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newBuffer1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.431313943 UTC

[section ""data" . GHC.IO.Buffer.newByteBuffer1_closure" {
     GHC.IO.Buffer.newByteBuffer1_closure:
         const GHC.IO.Buffer.newByteBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.newByteBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7QsW,
                       label: GHC.IO.Buffer.newByteBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QsW: // global
           R4 = R3;
           R3 = R2;
           R2 = R2;
           call GHC.IO.Buffer.newBuffer1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.434822301 UTC

[section ""data" . GHC.IO.Buffer.newByteBuffer_closure" {
     GHC.IO.Buffer.newByteBuffer_closure:
         const GHC.IO.Buffer.newByteBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newByteBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7Qt7,
                       label: GHC.IO.Buffer.newByteBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qt7: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newByteBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.438849249 UTC

[section ""data" . GHC.IO.Buffer.newCharBuffer1_closure" {
     GHC.IO.Buffer.newCharBuffer1_closure:
         const GHC.IO.Buffer.newCharBuffer1_info;
         const 0;
 },
 GHC.IO.Buffer.newCharBuffer1_entry() //  [R2, R3]
         { info_tbl: [(c7Qtl,
                       label: GHC.IO.Buffer.newCharBuffer1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qtl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Qtm; else goto c7Qtn;
       c7Qtm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.newCharBuffer1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qtn: // global
           I64[Sp - 16] = block_c7Qti_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7QtN; else goto c7Qtj;
       u7QtN: // global
           call _c7Qti(R1) args: 0, res: 0, upd: 0;
       c7Qtj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qti() //  [R1]
         { info_tbl: [(c7Qti,
                       label: block_c7Qti_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qti: // global
           _s7Q2y::I64 = I64[R1 + 7];
           _s7Q2z::I64 = _s7Q2y::I64 << 2;
           if (%MO_S_Ge_W64(_s7Q2z::I64, 0)) goto c7QtH; else goto c7QtM;
       c7QtH: // global
           I64[Sp - 16] = block_c7Qtx_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 8] = _s7Q2z::I64;
           I64[Sp] = _s7Q2y::I64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7QtM: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Qtx() //  [R1]
         { info_tbl: [(c7Qtx,
                       label: block_c7Qtx_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qtx: // global
           I64[Sp] = block_c7Qtz_info;
           _s7Q2D::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7Q2D::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qtz() //  [R1]
         { info_tbl: [(c7Qtz,
                       label: block_c7Qtz_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qtz: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c7QtL; else goto c7QtK;
       c7QtL: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7QtK: // global
           I64[Hp - 72] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 70;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = R1 + 16;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.453519424 UTC

[section ""data" . GHC.IO.Buffer.newCharBuffer_closure" {
     GHC.IO.Buffer.newCharBuffer_closure:
         const GHC.IO.Buffer.newCharBuffer_info;
         const 0;
 },
 GHC.IO.Buffer.newCharBuffer_entry() //  [R2, R3]
         { info_tbl: [(c7Quj,
                       label: GHC.IO.Buffer.newCharBuffer_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Quj: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.newCharBuffer1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.45852969 UTC

[section ""data" . GHC.IO.Buffer.slideContents1_closure" {
     GHC.IO.Buffer.slideContents1_closure:
         const GHC.IO.Buffer.slideContents1_info;
 },
 GHC.IO.Buffer.slideContents1_entry() //  [R2]
         { info_tbl: [(c7Qux,
                       label: GHC.IO.Buffer.slideContents1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qux: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7QuP; else goto c7QuQ;
       c7QuP: // global
           R2 = R2;
           R1 = GHC.IO.Buffer.slideContents1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7QuQ: // global
           I64[Sp - 8] = block_c7Quu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7QuU; else goto c7Quv;
       u7QuU: // global
           call _c7Quu(R1) args: 0, res: 0, upd: 0;
       c7Quv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Quu() //  [R1]
         { info_tbl: [(c7Quu,
                       label: block_c7Quu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Quu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7QuT; else goto c7QuS;
       c7QuT: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7QuS: // global
           _s7Q2P::P64 = P64[R1 + 7];
           _s7Q2Q::P64 = P64[R1 + 15];
           _s7Q2O::I64 = I64[R1 + 23];
           _s7Q2R::I64 = I64[R1 + 31];
           _s7Q2S::I64 = I64[R1 + 39];
           _s7Q2U::I64 = I64[R1 + 47] - _s7Q2S::I64;
           (_s7Q30::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(_s7Q2O::I64, _s7Q2O::I64 + _s7Q2S::I64, _s7Q2U::I64);
           call MO_Touch(_s7Q2P::P64);
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _s7Q2P::P64;
           P64[Hp - 32] = _s7Q2Q::P64;
           I64[Hp - 24] = _s7Q2O::I64;
           I64[Hp - 16] = _s7Q2R::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s7Q2U::I64;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.467904366 UTC

[section ""data" . GHC.IO.Buffer.slideContents_closure" {
     GHC.IO.Buffer.slideContents_closure:
         const GHC.IO.Buffer.slideContents_info;
 },
 GHC.IO.Buffer.slideContents_entry() //  [R2]
         { info_tbl: [(c7Qvf,
                       label: GHC.IO.Buffer.slideContents_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qvf: // global
           R2 = R2;
           call GHC.IO.Buffer.slideContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.473021755 UTC

[section ""data" . writeCharBufPtr1_r7OJT_closure" {
     writeCharBufPtr1_r7OJT_closure:
         const writeCharBufPtr1_r7OJT_info;
 },
 writeCharBufPtr1_r7OJT_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Qvt,
                       label: writeCharBufPtr1_r7OJT_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qvt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7QvK; else goto c7QvL;
       c7QvK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = writeCharBufPtr1_r7OJT_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7QvL: // global
           I64[Sp - 24] = block_c7Qvq_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7QvS; else goto c7Qvr;
       u7QvS: // global
           call _c7Qvq(R1) args: 0, res: 0, upd: 0;
       c7Qvr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qvq() //  [R1]
         { info_tbl: [(c7Qvq,
                       label: block_c7Qvq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qvq: // global
           I64[Sp] = block_c7Qvw_info;
           _s7Q38::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Q38::I64;
           if (R1 & 7 != 0) goto u7QvR; else goto c7Qvx;
       u7QvR: // global
           call _c7Qvw(R1) args: 0, res: 0, upd: 0;
       c7Qvx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qvw() //  [R1]
         { info_tbl: [(c7Qvw,
                       label: block_c7Qvw_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qvw: // global
           I64[Sp] = block_c7QvB_info;
           _s7Q3a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7Q3a::I64;
           if (R1 & 7 != 0) goto u7QvT; else goto c7QvC;
       u7QvT: // global
           call _c7QvB(R1) args: 0, res: 0, upd: 0;
       c7QvC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QvB() //  [R1]
         { info_tbl: [(c7QvB,
                       label: block_c7QvB_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QvB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7QvQ; else goto c7QvP;
       c7QvQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7QvP: // global
           _s7Q3a::I64 = I64[Sp + 16];
           I32[I64[Sp + 8] + (_s7Q3a::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Q3a::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.48696496 UTC

[section ""data" . GHC.IO.Buffer.writeCharBufPtr_closure" {
     GHC.IO.Buffer.writeCharBufPtr_closure:
         const GHC.IO.Buffer.writeCharBufPtr_info;
 },
 GHC.IO.Buffer.writeCharBufPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Qwn,
                       label: GHC.IO.Buffer.writeCharBufPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qwn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call writeCharBufPtr1_r7OJT_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.492345534 UTC

[section ""data" . writeCharBuf1_r7OJU_closure" {
     writeCharBuf1_r7OJU_closure:
         const writeCharBuf1_r7OJU_info;
 },
 writeCharBuf1_r7OJU_entry() //  [R2, R3, R4]
         { info_tbl: [(c7QwB,
                       label: writeCharBuf1_r7OJU_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QwB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7QwT; else goto c7QwU;
       c7QwT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = writeCharBuf1_r7OJU_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7QwU: // global
           I64[Sp - 24] = block_c7Qwy_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Qx1; else goto c7Qwz;
       u7Qx1: // global
           call _c7Qwy(R1) args: 0, res: 0, upd: 0;
       c7Qwz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Qwy() //  [R1]
         { info_tbl: [(c7Qwy,
                       label: block_c7Qwy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qwy: // global
           I64[Sp - 8] = block_c7QwE_info;
           _s7Q3m::P64 = P64[R1 + 7];
           _s7Q3l::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7Q3m::P64;
           I64[Sp + 8] = _s7Q3l::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qx0; else goto c7QwF;
       u7Qx0: // global
           call _c7QwE(R1) args: 0, res: 0, upd: 0;
       c7QwF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QwE() //  [R1]
         { info_tbl: [(c7QwE,
                       label: block_c7QwE_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QwE: // global
           I64[Sp] = block_c7QwJ_info;
           _s7Q3o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7Q3o::I64;
           if (R1 & 7 != 0) goto u7Qx2; else goto c7QwK;
       u7Qx2: // global
           call _c7QwJ(R1) args: 0, res: 0, upd: 0;
       c7QwK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QwJ() //  [R1]
         { info_tbl: [(c7QwJ,
                       label: block_c7QwJ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QwJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7QwZ; else goto c7QwY;
       c7QwZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7QwY: // global
           _s7Q3m::P64 = P64[Sp + 8];
           _s7Q3o::I64 = I64[Sp + 24];
           I32[I64[Sp + 16] + (_s7Q3o::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           call MO_Touch(_s7Q3m::P64);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Q3o::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.502630699 UTC

[section ""data" . GHC.IO.Buffer.writeCharBuf_closure" {
     GHC.IO.Buffer.writeCharBuf_closure:
         const GHC.IO.Buffer.writeCharBuf_info;
 },
 GHC.IO.Buffer.writeCharBuf_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Qxw,
                       label: GHC.IO.Buffer.writeCharBuf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qxw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call writeCharBuf1_r7OJU_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.50651533 UTC

[section ""data" . readCharBufPtr1_r7OJV_closure" {
     readCharBufPtr1_r7OJV_closure:
         const readCharBufPtr1_r7OJV_info;
 },
 readCharBufPtr1_r7OJV_entry() //  [R2, R3]
         { info_tbl: [(c7QxK,
                       label: readCharBufPtr1_r7OJV_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QxK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7QxY; else goto c7QxZ;
       c7QxY: // global
           R3 = R3;
           R2 = R2;
           R1 = readCharBufPtr1_r7OJV_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7QxZ: // global
           I64[Sp - 16] = block_c7QxH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Qy5; else goto c7QxI;
       u7Qy5: // global
           call _c7QxH(R1) args: 0, res: 0, upd: 0;
       c7QxI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QxH() //  [R1]
         { info_tbl: [(c7QxH,
                       label: block_c7QxH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QxH: // global
           I64[Sp] = block_c7QxN_info;
           _s7Q3z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Q3z::I64;
           if (R1 & 7 != 0) goto u7Qy4; else goto c7QxO;
       u7Qy4: // global
           call _c7QxN(R1) args: 0, res: 0, upd: 0;
       c7QxO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QxN() //  [R1]
         { info_tbl: [(c7QxN,
                       label: block_c7QxN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QxN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Qy3; else goto c7Qy2;
       c7Qy3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Qy2: // global
           _s7Q3B::I64 = I64[R1 + 7];
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7Q3B::I64 + 1;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (_s7Q3B::I64 << 2)]);
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.514677309 UTC

[section ""data" . GHC.IO.Buffer.readCharBufPtr_closure" {
     GHC.IO.Buffer.readCharBufPtr_closure:
         const GHC.IO.Buffer.readCharBufPtr_info;
 },
 GHC.IO.Buffer.readCharBufPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Qyy,
                       label: GHC.IO.Buffer.readCharBufPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Qyy: // global
           R3 = R3;
           R2 = R2;
           call readCharBufPtr1_r7OJV_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.518459961 UTC

[section ""data" . readCharBuf1_r7OJW_closure" {
     readCharBuf1_r7OJW_closure:
         const readCharBuf1_r7OJW_info;
 },
 readCharBuf1_r7OJW_entry() //  [R2, R3]
         { info_tbl: [(c7QyM,
                       label: readCharBuf1_r7OJW_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QyM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Qz1; else goto c7Qz2;
       c7Qz1: // global
           R3 = R3;
           R2 = R2;
           R1 = readCharBuf1_r7OJW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Qz2: // global
           I64[Sp - 16] = block_c7QyJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Qz8; else goto c7QyK;
       u7Qz8: // global
           call _c7QyJ(R1) args: 0, res: 0, upd: 0;
       c7QyK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QyJ() //  [R1]
         { info_tbl: [(c7QyJ,
                       label: block_c7QyJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QyJ: // global
           I64[Sp - 8] = block_c7QyP_info;
           _s7Q3O::P64 = P64[R1 + 7];
           _s7Q3N::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7Q3O::P64;
           I64[Sp + 8] = _s7Q3N::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Qz7; else goto c7QyQ;
       u7Qz7: // global
           call _c7QyP(R1) args: 0, res: 0, upd: 0;
       c7QyQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QyP() //  [R1]
         { info_tbl: [(c7QyP,
                       label: block_c7QyP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QyP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7Qz6; else goto c7Qz5;
       c7Qz6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Qz5: // global
           _s7Q3Q::I64 = I64[R1 + 7];
           _s7Q3T::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 16] + (_s7Q3Q::I64 << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7Q3Q::I64 + 1;
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s7Q3T::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.527461563 UTC

[section ""data" . GHC.IO.Buffer.readCharBuf_closure" {
     GHC.IO.Buffer.readCharBuf_closure:
         const GHC.IO.Buffer.readCharBuf_info;
 },
 GHC.IO.Buffer.readCharBuf_entry() //  [R2, R3]
         { info_tbl: [(c7QzA,
                       label: GHC.IO.Buffer.readCharBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QzA: // global
           R3 = R3;
           R2 = R2;
           call readCharBuf1_r7OJW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.531597684 UTC

[section ""data" . GHC.IO.Buffer.peekCharBuf1_closure" {
     GHC.IO.Buffer.peekCharBuf1_closure:
         const GHC.IO.Buffer.peekCharBuf1_info;
 },
 GHC.IO.Buffer.peekCharBuf1_entry() //  [R2, R3]
         { info_tbl: [(c7QzO,
                       label: GHC.IO.Buffer.peekCharBuf1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QzO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7QzY; else goto c7QzZ;
       c7QzY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Buffer.peekCharBuf1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7QzZ: // global
           I64[Sp - 16] = block_c7QzL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7QA5; else goto c7QzM;
       u7QA5: // global
           call _c7QzL(R1) args: 0, res: 0, upd: 0;
       c7QzM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QzL() //  [R1]
         { info_tbl: [(c7QzL,
                       label: block_c7QzL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QzL: // global
           I64[Sp - 8] = block_c7QzR_info;
           _s7Q44::P64 = P64[R1 + 7];
           _s7Q43::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _s7Q44::P64;
           I64[Sp + 8] = _s7Q43::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7QA4; else goto c7QzS;
       u7QA4: // global
           call _c7QzR(R1) args: 0, res: 0, upd: 0;
       c7QzS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7QzR() //  [R1]
         { info_tbl: [(c7QzR,
                       label: block_c7QzR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QzR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7QA3; else goto c7QA2;
       c7QA3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7QA2: // global
           _s7Q49::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 16] + (I64[R1 + 7] << 2)]);
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s7Q49::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.539751925 UTC

[section ""data" . GHC.IO.Buffer.peekCharBuf_closure" {
     GHC.IO.Buffer.peekCharBuf_closure:
         const GHC.IO.Buffer.peekCharBuf_info;
 },
 GHC.IO.Buffer.peekCharBuf_entry() //  [R2, R3]
         { info_tbl: [(c7QAt,
                       label: GHC.IO.Buffer.peekCharBuf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QAt: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Buffer.peekCharBuf1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.543387208 UTC

[section ""data" . GHC.IO.Buffer.ReadBuffer_closure" {
     GHC.IO.Buffer.ReadBuffer_closure:
         const GHC.IO.Buffer.ReadBuffer_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.545026548 UTC

[section ""data" . GHC.IO.Buffer.WriteBuffer_closure" {
     GHC.IO.Buffer.WriteBuffer_closure:
         const GHC.IO.Buffer.WriteBuffer_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.547160369 UTC

[section ""data" . GHC.IO.Buffer.Buffer_closure" {
     GHC.IO.Buffer.Buffer_closure:
         const GHC.IO.Buffer.Buffer_info;
 },
 GHC.IO.Buffer.Buffer_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QAD: // global
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.IO.Buffer.Buffer_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2,
                                           R1) args: 16, res: 0, upd: 8;
     }
 },
 GHC.IO.Buffer.Buffer_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c7QAI,
                       label: GHC.IO.Buffer.Buffer_info
                       rep:HeapRep static {
                             Fun {arity: 6
                                  fun_type: ArgGen [True, False, False, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QAI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c7QAM; else goto c7QAL;
       c7QAM: // global
           HpAlloc = 56;
           R1 = GHC.IO.Buffer.Buffer_closure;
           I64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       c7QAL: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = R5;
           I64[Hp - 8] = R6;
           I64[Hp] = I64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.553101656 UTC

[section ""relreadonly" . GHC.IO.Buffer.BufferState_closure_tbl" {
     GHC.IO.Buffer.BufferState_closure_tbl:
         const GHC.IO.Buffer.ReadBuffer_closure+1;
         const GHC.IO.Buffer.WriteBuffer_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.554832566 UTC

[GHC.IO.Buffer.ReadBuffer_con_entry() //  [R1]
         { info_tbl: [(c7QAX,
                       label: GHC.IO.Buffer.ReadBuffer_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,82,101,97,100,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QAX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.559272771 UTC

[GHC.IO.Buffer.WriteBuffer_con_entry() //  [R1]
         { info_tbl: [(c7QB4,
                       label: GHC.IO.Buffer.WriteBuffer_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,87,114,105,116,101,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QB4: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.564146334 UTC

[GHC.IO.Buffer.Buffer_con_entry() //  [R1]
         { info_tbl: [(c7QBb,
                       label: GHC.IO.Buffer.Buffer_con_info
                       rep:HeapRep 2 ptrs 4 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,66,117,102,102,101,114,46,66,117,102,102,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7QBb: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:57.568786514 UTC

[section ""relreadonly" . S7Qhb_srt" {
     S7Qhb_srt:
         const GHC.IO.Buffer.summaryBuffer1_closure;
         const GHC.IO.Buffer.$wsummaryBuffer_closure;
         const GHC.IO.Buffer.summaryBuffer_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Buffer.$wlvl_closure;
         const GHC.IO.Buffer.$wcheckBuffer_closure;
         const GHC.IO.Buffer.checkBuffer2_closure;
         const GHC.IO.Buffer.checkBuffer1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const GHC.IO.Buffer.newBuffer1_closure;
         const GHC.IO.Buffer.newByteBuffer1_closure;
         const GHC.IO.Buffer.newCharBuffer1_closure;
 }]

