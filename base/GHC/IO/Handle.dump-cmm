
==================== Output Cmm ====================
2018-03-16 16:06:16.481696909 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:16.482847907 UTC

[section ""data" . GHC.IO.Handle.$w$c==_closure" {
     GHC.IO.Handle.$w$c==_closure:
         const GHC.IO.Handle.$w$c==_info;
 },
 GHC.IO.Handle.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cboyG,
                       label: GHC.IO.Handle.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboyG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboyH; else goto cboyI;
       cboyH: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cboyI: // global
           I64[Sp - 24] = block_cboyB_info;
           _sbnXw::P64 = R3;
           R3 = R5;
           _sbnXv::P64 = R2;
           R2 = _sbnXw::P64;
           P64[Sp - 16] = _sbnXv::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboyB() //  [R1]
         { info_tbl: [(cboyB,
                       label: block_cboyB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboyB: // global
           if (R1 == 1) goto cboyF; else goto cboyE;
       cboyF: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fEqHandle_$c==_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cboyE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.484286079 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_$c==_closure" {
     GHC.IO.Handle.$fEqHandlePosn_$c==_closure:
         const GHC.IO.Handle.$fEqHandlePosn_$c==_info;
 },
 GHC.IO.Handle.$fEqHandlePosn_$c==_entry() //  [R2, R3]
         { info_tbl: [(cboyW,
                       label: GHC.IO.Handle.$fEqHandlePosn_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboyW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboz0; else goto cboz1;
       cboz0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fEqHandlePosn_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cboz1: // global
           I64[Sp - 16] = block_cboyT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uboz9; else goto cboyU;
       uboz9: // global
           call _cboyT(R1) args: 0, res: 0, upd: 0;
       cboyU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboyT() //  [R1]
         { info_tbl: [(cboyT,
                       label: block_cboyT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboyT: // global
           I64[Sp - 8] = block_cboyZ_info;
           _sbnXD::P64 = P64[R1 + 7];
           _sbnXE::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbnXE::P64;
           P64[Sp + 8] = _sbnXD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboz8; else goto cboz3;
       uboz8: // global
           call _cboyZ(R1) args: 0, res: 0, upd: 0;
       cboz3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboyZ() //  [R1]
         { info_tbl: [(cboyZ,
                       label: block_cboyZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboyZ: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.$w$c==_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.486643955 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_$c/=_closure" {
     GHC.IO.Handle.$fEqHandlePosn_$c/=_closure:
         const GHC.IO.Handle.$fEqHandlePosn_$c/=_info;
 },
 GHC.IO.Handle.$fEqHandlePosn_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cbozh,
                       label: GHC.IO.Handle.$fEqHandlePosn_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbozh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbozl; else goto cbozm;
       cbozl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fEqHandlePosn_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbozm: // global
           I64[Sp - 16] = block_cboze_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uboAT; else goto cbozf;
       uboAT: // global
           call _cboze(R1) args: 0, res: 0, upd: 0;
       cbozf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboze() //  [R1]
         { info_tbl: [(cboze,
                       label: block_cboze_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboze: // global
           I64[Sp - 8] = block_cbozk_info;
           _sbnXL::P64 = P64[R1 + 7];
           _sbnXM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbnXM::P64;
           P64[Sp + 8] = _sbnXL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboAS; else goto cbozo;
       uboAS: // global
           call _cbozk(R1) args: 0, res: 0, upd: 0;
       cbozo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbozk() //  [R1]
         { info_tbl: [(cbozk,
                       label: block_cbozk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbozk: // global
           I64[Sp] = block_cbozs_info;
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbozs() //  [R1]
         { info_tbl: [(cbozs,
                       label: block_cbozs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbozs: // global
           if (R1 == 1) goto cbozE; else goto uboAL;
       cbozE: // global
           I64[Sp] = block_cbozC_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto uboAU; else goto cbozF;
       uboAU: // global
           call _cbozC(R1) args: 0, res: 0, upd: 0;
       cbozF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uboAL: // global
           Sp = Sp + 24;
           call _cboAx() args: 0, res: 0, upd: 0;
     }
 },
 _cbozC() //  [R1]
         { info_tbl: [(cbozC,
                       label: block_cbozC_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbozC: // global
           _sbnXO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbozM; else goto cboAh;
       cbozM: // global
           I64[Sp + 8] = block_cbozJ_info;
           _sbnXT::P64 = P64[R1 + 15];
           R1 = _sbnXO::P64;
           P64[Sp + 16] = _sbnXT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uboAW; else goto cbozN;
       uboAW: // global
           call _cbozJ(R1) args: 0, res: 0, upd: 0;
       cbozN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cboAh: // global
           I64[Sp + 8] = block_cboAf_info;
           _sbnY2::P64 = P64[R1 + 14];
           R1 = _sbnXO::P64;
           P64[Sp + 16] = _sbnY2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uboAX; else goto cboAi;
       uboAX: // global
           call _cboAf(R1) args: 0, res: 0, upd: 0;
       cboAi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbozJ() //  [R1]
         { info_tbl: [(cbozJ,
                       label: block_cbozJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbozJ: // global
           if (R1 & 7 == 1) goto cboA8; else goto uboAP;
       cboA8: // global
           if (P64[Sp + 8] == P64[R1 + 15]) goto uboAQ; else goto uboAR;
       uboAQ: // global
           Sp = Sp + 16;
           call _cboAD() args: 0, res: 0, upd: 0;
       uboAR: // global
           Sp = Sp + 16;
           goto uboB0;
       uboAP: // global
           Sp = Sp + 16;
           goto uboB0;
       uboB0: // global
           call _cboAx() args: 0, res: 0, upd: 0;
     }
 },
 _cboAf() //  [R1]
         { info_tbl: [(cboAf,
                       label: block_cboAf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboAf: // global
           if (R1 & 7 == 1) goto uboAM; else goto cboAH;
       uboAM: // global
           Sp = Sp + 16;
           goto uboB3;
       cboAH: // global
           if (P64[Sp + 8] == P64[R1 + 14]) goto uboAN; else goto uboAO;
       uboAN: // global
           Sp = Sp + 16;
           call _cboAD() args: 0, res: 0, upd: 0;
       uboAO: // global
           Sp = Sp + 16;
           goto uboB3;
       uboB3: // global
           call _cboAx() args: 0, res: 0, upd: 0;
     }
 },
 _cboAD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboAD: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboAx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboAx: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.488956253 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_closure" {
     GHC.IO.Handle.$fEqHandlePosn_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.$fEqHandlePosn_$c==_closure+2;
         const GHC.IO.Handle.$fEqHandlePosn_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.489538029 UTC

[section ""cstring" . GHC.IO.Handle.$fShowHandlePosn2_bytes" {
     GHC.IO.Handle.$fShowHandlePosn2_bytes:
         I8[] [32,97,116,32,112,111,115,105,116,105,111,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.491944597 UTC

[section ""data" . GHC.IO.Handle.$w$cshowsPrec_closure" {
     GHC.IO.Handle.$w$cshowsPrec_closure:
         const GHC.IO.Handle.$w$cshowsPrec_info;
         const 0;
 },
 sat_sbnYk_entry() //  [R1]
         { info_tbl: [(cboBw,
                       label: sat_sbnYk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboBw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboBx; else goto cboBy;
       cboBx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboBy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cboBt_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cboBt() //  [R1, R2]
         { info_tbl: [(cboBt,
                       label: block_cboBt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboBt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboBB; else goto cboBA;
       cboBB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cboBA: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYl_entry() //  [R1]
         { info_tbl: [(cboBC,
                       label: sat_sbnYl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboBC: // global
           _sbnYl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cboBD; else goto cboBE;
       cboBE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cboBG; else goto cboBF;
       cboBG: // global
           HpAlloc = 32;
           goto cboBD;
       cboBD: // global
           R1 = _sbnYl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboBF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYl::P64;
           _sbnYc::P64 = P64[_sbnYl::P64 + 16];
           _sbnYd::P64 = P64[_sbnYl::P64 + 24];
           I64[Hp - 24] = sat_sbnYk_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.$fShowHandlePosn2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYm_entry() //  [R1]
         { info_tbl: [(cboBH,
                       label: sat_sbnYm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboBH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cboBL; else goto cboBK;
       cboBL: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboBK: // global
           _sbnYc::P64 = P64[R1 + 16];
           _sbnYd::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbnYl_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbnYn_entry() //  [R1]
         { info_tbl: [(cboBM,
                       label: sat_sbnYn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboBM: // global
           _sbnYn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cboBN; else goto cboBO;
       cboBO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cboBQ; else goto cboBP;
       cboBQ: // global
           HpAlloc = 32;
           goto cboBN;
       cboBN: // global
           R1 = _sbnYn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboBP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYn::P64;
           _sbnYc::P64 = P64[_sbnYn::P64 + 16];
           _sbnYd::P64 = P64[_sbnYn::P64 + 24];
           _sbnYf::P64 = P64[_sbnYn::P64 + 32];
           I64[Hp - 24] = sat_sbnYm_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = _sbnYf::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYu_entry() //  [R1]
         { info_tbl: [(cboCc,
                       label: sat_sbnYu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboCc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboCd; else goto cboCe;
       cboCd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboCe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cboC9_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cboC9() //  [R1, R2]
         { info_tbl: [(cboC9,
                       label: block_cboC9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboC9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboCh; else goto cboCg;
       cboCh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cboCg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYv_entry() //  [R1]
         { info_tbl: [(cboCi,
                       label: sat_sbnYv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboCi: // global
           _sbnYv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cboCj; else goto cboCk;
       cboCk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cboCm; else goto cboCl;
       cboCm: // global
           HpAlloc = 32;
           goto cboCj;
       cboCj: // global
           R1 = _sbnYv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboCl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYv::P64;
           _sbnYc::P64 = P64[_sbnYv::P64 + 16];
           _sbnYd::P64 = P64[_sbnYv::P64 + 24];
           I64[Hp - 24] = sat_sbnYu_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.$fShowHandlePosn2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYw_entry() //  [R1]
         { info_tbl: [(cboCn,
                       label: sat_sbnYw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboCn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cboCr; else goto cboCq;
       cboCr: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboCq: // global
           _sbnYc::P64 = P64[R1 + 16];
           _sbnYd::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbnYv_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbnYx_entry() //  [R1]
         { info_tbl: [(cboCs,
                       label: sat_sbnYx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboCs: // global
           _sbnYx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cboCt; else goto cboCu;
       cboCu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cboCw; else goto cboCv;
       cboCw: // global
           HpAlloc = 32;
           goto cboCt;
       cboCt: // global
           R1 = _sbnYx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboCv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYx::P64;
           _sbnYc::P64 = P64[_sbnYx::P64 + 16];
           _sbnYd::P64 = P64[_sbnYx::P64 + 24];
           _sbnYo::P64 = P64[_sbnYx::P64 + 32];
           I64[Hp - 24] = sat_sbnYw_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = _sbnYo::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cboCB,
                       label: GHC.IO.Handle.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboCB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboCC; else goto cboCD;
       cboCC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cboCD: // global
           I64[Sp - 24] = block_cboB8_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uboCK; else goto cboB9;
       uboCK: // global
           call _cboB8(R1) args: 0, res: 0, upd: 0;
       cboB9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboB8() //  [R1]
         { info_tbl: [(cboB8,
                       label: block_cboB8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboB8: // global
           _sbnYc::P64 = P64[Sp + 8];
           _sbnYd::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cboCy; else goto cboCz;
       cboCy: // global
           Hp = Hp + 40;
           _sbnYe::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cboCJ; else goto cboCF;
       cboCF: // global
           _sbnYf::P64 = P64[_sbnYe::P64 + 7];
           I64[Hp - 32] = sat_sbnYn_info;
           P64[Hp - 16] = _sbnYc::P64;
           P64[Hp - 8] = _sbnYd::P64;
           P64[Hp] = _sbnYf::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cboCz: // global
           Hp = Hp + 40;
           _sbnYe::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cboCJ; else goto cboCI;
       cboCJ: // global
           HpAlloc = 40;
           R1 = _sbnYe::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboCI: // global
           _sbnYo::P64 = P64[_sbnYe::P64 + 6];
           I64[Hp - 32] = sat_sbnYx_info;
           P64[Hp - 16] = _sbnYc::P64;
           P64[Hp - 8] = _sbnYd::P64;
           P64[Hp] = _sbnYo::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.49657224 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cboCT,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboCT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboCU; else goto cboCV;
       cboCU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cboCV: // global
           I64[Sp - 16] = block_cboCQ_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uboCZ; else goto cboCR;
       uboCZ: // global
           call _cboCQ(R1) args: 0, res: 0, upd: 0;
       cboCR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboCQ() //  [R1]
         { info_tbl: [(cboCQ,
                       label: block_cboCQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboCQ: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.497725892 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn3_closure" {
     GHC.IO.Handle.$fShowHandlePosn3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.498472621 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshow_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshow_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshow_entry() //  [R2]
         { info_tbl: [(cboD7,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboD7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cboD8; else goto cboD9;
       cboD8: // global
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboD9: // global
           I64[Sp - 8] = block_cboD4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboDd; else goto cboD5;
       uboDd: // global
           call _cboD4(R1) args: 0, res: 0, upd: 0;
       cboD5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboD4() //  [R1]
         { info_tbl: [(cboD4,
                       label: block_cboD4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboD4: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.499720756 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn1_closure" {
     GHC.IO.Handle.$fShowHandlePosn1_closure:
         const GHC.IO.Handle.$fShowHandlePosn1_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn1_entry() //  [R2, R3]
         { info_tbl: [(cboDl,
                       label: GHC.IO.Handle.$fShowHandlePosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboDl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboDm; else goto cboDn;
       cboDm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cboDn: // global
           I64[Sp - 16] = block_cboDi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uboDr; else goto cboDj;
       uboDr: // global
           call _cboDi(R1) args: 0, res: 0, upd: 0;
       cboDj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboDi() //  [R1]
         { info_tbl: [(cboDi,
                       label: block_cboDi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboDi: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.500814774 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cboDw,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboDw: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.$fShowHandlePosn1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.501548561 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_closure" {
     GHC.IO.Handle.$fShowHandlePosn_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure+3;
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_closure+1;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.50213211 UTC

[section ""cstring" . GHC.IO.Handle.hLookAhead3_bytes" {
     GHC.IO.Handle.hLookAhead3_bytes:
         I8[] [104,76,111,111,107,65,104,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.502879014 UTC

[section ""data" . GHC.IO.Handle.hLookAhead2_closure" {
     GHC.IO.Handle.hLookAhead2_closure:
         const GHC.IO.Handle.hLookAhead2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hLookAhead2_entry() //  [R1]
         { info_tbl: [(cboDF,
                       label: GHC.IO.Handle.hLookAhead2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboDF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboDG; else goto cboDH;
       cboDG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboDH: // global
           (_cboDC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboDC::I64 == 0) goto cboDE; else goto cboDD;
       cboDE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboDD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboDC::I64;
           R2 = GHC.IO.Handle.hLookAhead3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.503891775 UTC

[section ""data" . GHC.IO.Handle.hLookAhead1_closure" {
     GHC.IO.Handle.hLookAhead1_closure:
         const GHC.IO.Handle.hLookAhead1_info;
         const 0;
 },
 GHC.IO.Handle.hLookAhead1_entry() //  [R2]
         { info_tbl: [(cboDM,
                       label: GHC.IO.Handle.hLookAhead1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboDM: // global
           R4 = GHC.IO.Handle.Internals.hLookAhead_1_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hLookAhead2_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.504712967 UTC

[section ""data" . GHC.IO.Handle.hLookAhead_closure" {
     GHC.IO.Handle.hLookAhead_closure:
         const GHC.IO.Handle.hLookAhead_info;
         const 0;
 },
 GHC.IO.Handle.hLookAhead_entry() //  [R2]
         { info_tbl: [(cboDT,
                       label: GHC.IO.Handle.hLookAhead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboDT: // global
           R2 = R2;
           call GHC.IO.Handle.hLookAhead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.505447486 UTC

[section ""cstring" . GHC.IO.Handle.hFlush3_bytes" {
     GHC.IO.Handle.hFlush3_bytes:
         I8[] [104,70,108,117,115,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.50616045 UTC

[section ""data" . GHC.IO.Handle.hFlush2_closure" {
     GHC.IO.Handle.hFlush2_closure:
         const GHC.IO.Handle.hFlush2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFlush2_entry() //  [R1]
         { info_tbl: [(cboE2,
                       label: GHC.IO.Handle.hFlush2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboE2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboE3; else goto cboE4;
       cboE3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboE4: // global
           (_cboDZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboDZ::I64 == 0) goto cboE1; else goto cboE0;
       cboE1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboE0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboDZ::I64;
           R2 = GHC.IO.Handle.hFlush3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.507161337 UTC

[section ""data" . GHC.IO.Handle.hFlush1_closure" {
     GHC.IO.Handle.hFlush1_closure:
         const GHC.IO.Handle.hFlush1_info;
         const 0;
 },
 GHC.IO.Handle.hFlush1_entry() //  [R2]
         { info_tbl: [(cboE9,
                       label: GHC.IO.Handle.hFlush1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboE9: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.508050482 UTC

[section ""data" . GHC.IO.Handle.hFlush_closure" {
     GHC.IO.Handle.hFlush_closure:
         const GHC.IO.Handle.hFlush_info;
         const 0;
 },
 GHC.IO.Handle.hFlush_entry() //  [R2]
         { info_tbl: [(cboEg,
                       label: GHC.IO.Handle.hFlush_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboEg: // global
           R2 = R2;
           call GHC.IO.Handle.hFlush1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.508774938 UTC

[section ""cstring" . GHC.IO.Handle.hFlushAll4_bytes" {
     GHC.IO.Handle.hFlushAll4_bytes:
         I8[] [104,70,108,117,115,104,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.50964219 UTC

[section ""data" . GHC.IO.Handle.hFlushAll3_closure" {
     GHC.IO.Handle.hFlushAll3_closure:
         const GHC.IO.Handle.hFlushAll3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFlushAll3_entry() //  [R1]
         { info_tbl: [(cboEp,
                       label: GHC.IO.Handle.hFlushAll3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboEp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboEq; else goto cboEr;
       cboEq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboEr: // global
           (_cboEm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboEm::I64 == 0) goto cboEo; else goto cboEn;
       cboEo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboEn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboEm::I64;
           R2 = GHC.IO.Handle.hFlushAll4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.510747813 UTC

[section ""data" . GHC.IO.Handle.hFlushAll2_closure" {
     GHC.IO.Handle.hFlushAll2_closure:
         const GHC.IO.Handle.hFlushAll2_info;
         const 0;
 },
 GHC.IO.Handle.hFlushAll2_entry() //  [R2]
         { info_tbl: [(cboEz,
                       label: GHC.IO.Handle.hFlushAll2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboEz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboEA; else goto cboEB;
       cboEA: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFlushAll2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboEB: // global
           I64[Sp - 16] = block_cboEw_info;
           _sbnYR::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbnYR::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboEw() //  [R1]
         { info_tbl: [(cboEw,
                       label: block_cboEw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboEw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboEE; else goto cboED;
       cboEE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboED: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.512960235 UTC

[section ""data" . GHC.IO.Handle.hFlushAll1_closure" {
     GHC.IO.Handle.hFlushAll1_closure:
         const GHC.IO.Handle.hFlushAll1_info;
         const 0;
 },
 io_sbnZ5_entry() //  [R1]
         { info_tbl: [(cboF0,
                       label: io_sbnZ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboF0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboF4; else goto cboF5;
       cboF4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cboF5: // global
           I64[Sp - 16] = block_cboEV_info;
           _sbnZ1::P64 = P64[R1 + 15];
           R5 = _sbnZ1::P64;
           R4 = GHC.IO.Handle.hFlushAll2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFlushAll3_closure;
           P64[Sp - 8] = _sbnZ1::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboEV() //  [R1]
         { info_tbl: [(cboEV,
                       label: block_cboEV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboEV: // global
           I64[Sp] = block_cboEX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uboFa; else goto cboEY;
       uboFa: // global
           call _cboEX(R1) args: 0, res: 0, upd: 0;
       cboEY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboEX() //  [R1]
         { info_tbl: [(cboEX,
                       label: block_cboEX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboEX: // global
           I64[Sp] = block_cboF3_info;
           R2 = P64[R1 + 7];
           _sbnZc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbnZc::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboF3() //  []
         { info_tbl: [(cboF3,
                       label: block_cboF3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboF3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbnZl_entry() //  [R1]
         { info_tbl: [(cboFp,
                       label: io_sbnZl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboFp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboFt; else goto cboFu;
       cboFt: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cboFu: // global
           I64[Sp - 16] = block_cboFk_info;
           _sbnZg::P64 = P64[R1 + 15];
           R5 = _sbnZg::P64;
           R4 = GHC.IO.Handle.hFlushAll2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFlushAll3_closure;
           P64[Sp - 8] = _sbnZg::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboFk() //  [R1]
         { info_tbl: [(cboFk,
                       label: block_cboFk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboFk: // global
           I64[Sp] = block_cboFm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uboFz; else goto cboFn;
       uboFz: // global
           call _cboFm(R1) args: 0, res: 0, upd: 0;
       cboFn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboFm() //  [R1]
         { info_tbl: [(cboFm,
                       label: block_cboFm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboFm: // global
           I64[Sp] = block_cboFs_info;
           R2 = P64[R1 + 7];
           _sbnZs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbnZs::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboFs() //  []
         { info_tbl: [(cboFs,
                       label: block_cboFs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboFs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hFlushAll1_entry() //  [R2]
         { info_tbl: [(cboFE,
                       label: GHC.IO.Handle.hFlushAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboFE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboFF; else goto cboFG;
       cboFF: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFlushAll1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboFG: // global
           I64[Sp - 8] = block_cboEJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboFX; else goto cboEK;
       uboFX: // global
           call _cboEJ(R1) args: 0, res: 0, upd: 0;
       cboEK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboEJ() //  [R1]
         { info_tbl: [(cboEJ,
                       label: block_cboEJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboEJ: // global
           if (R1 & 7 == 1) goto cboFB; else goto cboFC;
       cboFB: // global
           I64[Sp - 16] = block_cboEO_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cboFC: // global
           I64[Sp - 16] = block_cboFd_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cboEO() //  [R1]
         { info_tbl: [(cboEO,
                       label: block_cboEO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboEO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboFK; else goto cboFJ;
       cboFK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cboFJ: // global
           I64[Hp - 16] = io_sbnZ5_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cboEQ::P64 = Hp - 15;
           if (R1 == 0) goto cboFO; else goto cboFN;
       cboFO: // global
           R1 = _cboEQ::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cboFN: // global
           R1 = _cboEQ::P64;
           Sp = Sp + 24;
           call io_sbnZ5_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboFd() //  [R1]
         { info_tbl: [(cboFd,
                       label: block_cboFd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboFd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboFS; else goto cboFR;
       cboFS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cboFR: // global
           I64[Hp - 16] = io_sbnZl_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cboFf::P64 = Hp - 15;
           if (R1 == 0) goto cboFW; else goto cboFV;
       cboFW: // global
           R1 = _cboFf::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cboFV: // global
           R1 = _cboFf::P64;
           Sp = Sp + 24;
           call io_sbnZl_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.516194251 UTC

[section ""data" . GHC.IO.Handle.hFlushAll_closure" {
     GHC.IO.Handle.hFlushAll_closure:
         const GHC.IO.Handle.hFlushAll_info;
         const 0;
 },
 GHC.IO.Handle.hFlushAll_entry() //  [R2]
         { info_tbl: [(cboG2,
                       label: GHC.IO.Handle.hFlushAll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboG2: // global
           R2 = R2;
           call GHC.IO.Handle.hFlushAll1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.516918582 UTC

[section ""cstring" . GHC.IO.Handle.hGetEcho7_bytes" {
     GHC.IO.Handle.hGetEcho7_bytes:
         I8[] [104,73,115,84,101,114,109,105,110,97,108,68,101,118,105,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.517731547 UTC

[section ""data" . GHC.IO.Handle.hGetEcho_fun_closure" {
     GHC.IO.Handle.hGetEcho_fun_closure:
         const GHC.IO.Handle.hGetEcho_fun_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEcho_fun_entry() //  [R1]
         { info_tbl: [(cboGb,
                       label: GHC.IO.Handle.hGetEcho_fun_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboGb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboGc; else goto cboGd;
       cboGc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboGd: // global
           (_cboG8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboG8::I64 == 0) goto cboGa; else goto cboG9;
       cboGa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboG9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboG8::I64;
           R2 = GHC.IO.Handle.hGetEcho7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.51916807 UTC

[section ""data" . GHC.IO.Handle.hGetEcho6_closure" {
     GHC.IO.Handle.hGetEcho6_closure:
         const GHC.IO.Handle.hGetEcho6_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho6_entry() //  [R2]
         { info_tbl: [(cboGl,
                       label: GHC.IO.Handle.hGetEcho6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboGl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cboGm; else goto cboGn;
       cboGm: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboGn: // global
           I64[Sp - 8] = block_cboGi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboGL; else goto cboGj;
       uboGL: // global
           call _cboGi(R1) args: 0, res: 0, upd: 0;
       cboGj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboGi() //  [R1]
         { info_tbl: [(cboGi,
                       label: block_cboGi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboGi: // global
           I64[Sp - 24] = block_cboGq_info;
           _sbnZx::P64 = R1;
           _sbnZy::P64 = P64[R1 + 7];
           _sbnZB::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbnZy::P64;
           P64[Sp - 8] = _sbnZB::P64;
           P64[Sp] = _sbnZx::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uboGK; else goto cboGs;
       uboGK: // global
           call _cboGq(R1) args: 0, res: 0, upd: 0;
       cboGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboGq() //  [R1]
         { info_tbl: [(cboGq,
                       label: block_cboGq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboGq: // global
           if (R1 & 7 == 1) goto cboGI; else goto cboGB;
       cboGI: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cboGB: // global
           _sbnZB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cboGw_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbnZB::P64;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cboGw() //  [R1]
         { info_tbl: [(cboGw,
                       label: block_cboGw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboGw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboGE; else goto cboGD;
       cboGE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboGD: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.522214773 UTC

[section ""data" . GHC.IO.Handle.hGetEcho5_closure" {
     GHC.IO.Handle.hGetEcho5_closure:
         const GHC.IO.Handle.hGetEcho5_info;
         const 0;
 },
 io_sbo02_entry() //  [R1]
         { info_tbl: [(cboH7,
                       label: io_sbo02_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboH7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboHb; else goto cboHc;
       cboHb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cboHc: // global
           I64[Sp - 16] = block_cboH2_info;
           _sbnZY::P64 = P64[R1 + 15];
           R5 = _sbnZY::P64;
           R4 = GHC.IO.Handle.hGetEcho6_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho_fun_closure;
           P64[Sp - 8] = _sbnZY::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboH2() //  [R1]
         { info_tbl: [(cboH2,
                       label: block_cboH2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboH2: // global
           I64[Sp] = block_cboH4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uboHh; else goto cboH5;
       uboHh: // global
           call _cboH4(R1) args: 0, res: 0, upd: 0;
       cboH5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboH4() //  [R1]
         { info_tbl: [(cboH4,
                       label: block_cboH4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboH4: // global
           I64[Sp] = block_cboHa_info;
           R2 = P64[R1 + 7];
           _sbo09::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo09::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboHa() //  []
         { info_tbl: [(cboHa,
                       label: block_cboHa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboHa: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbo0i_entry() //  [R1]
         { info_tbl: [(cboHw,
                       label: io_sbo0i_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboHw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboHA; else goto cboHB;
       cboHA: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cboHB: // global
           I64[Sp - 16] = block_cboHr_info;
           _sbo0d::P64 = P64[R1 + 15];
           R5 = _sbo0d::P64;
           R4 = GHC.IO.Handle.hGetEcho6_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho_fun_closure;
           P64[Sp - 8] = _sbo0d::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboHr() //  [R1]
         { info_tbl: [(cboHr,
                       label: block_cboHr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboHr: // global
           I64[Sp] = block_cboHt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uboHG; else goto cboHu;
       uboHG: // global
           call _cboHt(R1) args: 0, res: 0, upd: 0;
       cboHu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboHt() //  [R1]
         { info_tbl: [(cboHt,
                       label: block_cboHt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboHt: // global
           I64[Sp] = block_cboHz_info;
           R2 = P64[R1 + 7];
           _sbo0p::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo0p::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboHz() //  []
         { info_tbl: [(cboHz,
                       label: block_cboHz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboHz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hGetEcho5_entry() //  [R2]
         { info_tbl: [(cboHL,
                       label: GHC.IO.Handle.hGetEcho5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboHL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboHM; else goto cboHN;
       cboHM: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho5_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboHN: // global
           I64[Sp - 8] = block_cboGQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboI4; else goto cboGR;
       uboI4: // global
           call _cboGQ(R1) args: 0, res: 0, upd: 0;
       cboGR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboGQ() //  [R1]
         { info_tbl: [(cboGQ,
                       label: block_cboGQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboGQ: // global
           if (R1 & 7 == 1) goto cboHI; else goto cboHJ;
       cboHI: // global
           I64[Sp - 16] = block_cboGV_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cboHJ: // global
           I64[Sp - 16] = block_cboHk_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cboGV() //  [R1]
         { info_tbl: [(cboGV,
                       label: block_cboGV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboGV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboHR; else goto cboHQ;
       cboHR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cboHQ: // global
           I64[Hp - 16] = io_sbo02_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cboGX::P64 = Hp - 15;
           if (R1 == 0) goto cboHV; else goto cboHU;
       cboHV: // global
           R1 = _cboGX::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cboHU: // global
           R1 = _cboGX::P64;
           Sp = Sp + 24;
           call io_sbo02_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboHk() //  [R1]
         { info_tbl: [(cboHk,
                       label: block_cboHk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboHk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboHZ; else goto cboHY;
       cboHZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cboHY: // global
           I64[Hp - 16] = io_sbo0i_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cboHm::P64 = Hp - 15;
           if (R1 == 0) goto cboI3; else goto cboI2;
       cboI3: // global
           R1 = _cboHm::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cboI2: // global
           R1 = _cboHm::P64;
           Sp = Sp + 24;
           call io_sbo0i_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.525463232 UTC

[section ""data" . GHC.IO.Handle.hIsTerminalDevice_closure" {
     GHC.IO.Handle.hIsTerminalDevice_closure:
         const GHC.IO.Handle.hIsTerminalDevice_info;
         const 0;
 },
 GHC.IO.Handle.hIsTerminalDevice_entry() //  [R2]
         { info_tbl: [(cboI9,
                       label: GHC.IO.Handle.hIsTerminalDevice_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboI9: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.526163305 UTC

[section ""cstring" . lvl_rbnWB_bytes" {
     lvl_rbnWB_bytes:
         I8[] [104,68,117,112,108,105,99,97,116,101,84,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.526891831 UTC

[section ""data" . lvl1_rbnWC_closure" {
     lvl1_rbnWC_closure:
         const lvl1_rbnWC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbnWC_entry() //  [R1]
         { info_tbl: [(cboIi,
                       label: lvl1_rbnWC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboIi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboIj; else goto cboIk;
       cboIj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboIk: // global
           (_cboIf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboIf::I64 == 0) goto cboIh; else goto cboIg;
       cboIh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboIg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboIf::I64;
           R2 = lvl_rbnWB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.527776856 UTC

[section ""cstring" . lvl2_rbnWD_bytes" {
     lvl2_rbnWD_bytes:
         I8[] [104,97,110,100,108,101,115,32,97,114,101,32,105,110,99,111,109,112,97,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.528470566 UTC

[section ""data" . lvl3_rbnWE_closure" {
     lvl3_rbnWE_closure:
         const lvl3_rbnWE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbnWE_entry() //  [R1]
         { info_tbl: [(cboIr,
                       label: lvl3_rbnWE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboIr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboIs; else goto cboIt;
       cboIs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboIt: // global
           (_cboIo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboIo::I64 == 0) goto cboIq; else goto cboIp;
       cboIq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboIp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboIo::I64;
           R2 = lvl2_rbnWD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.529765331 UTC

[section ""data" . ioe_dupHandlesNotCompatible_rbnWF_closure" {
     ioe_dupHandlesNotCompatible_rbnWF_closure:
         const ioe_dupHandlesNotCompatible_rbnWF_info;
         const 0;
 },
 sat_sbo0w_entry() //  [R1]
         { info_tbl: [(cboIE,
                       label: sat_sbo0w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboIE: // global
           _sbo0w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cboIF; else goto cboIG;
       cboIG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cboII; else goto cboIH;
       cboII: // global
           HpAlloc = 72;
           goto cboIF;
       cboIF: // global
           R1 = _sbo0w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboIH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbo0w::P64;
           _sbo0s::P64 = P64[_sbo0w::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbo0s::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = lvl1_rbnWC_closure;
           P64[Hp - 16] = lvl3_rbnWE_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ioe_dupHandlesNotCompatible_rbnWF_entry() //  [R2]
         { info_tbl: [(cboIJ,
                       label: ioe_dupHandlesNotCompatible_rbnWF_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboIJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboIN; else goto cboIM;
       cboIN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = ioe_dupHandlesNotCompatible_rbnWF_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboIM: // global
           I64[Hp - 16] = sat_sbo0w_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.531076297 UTC

[section ""cstring" . GHC.IO.Handle.$trModule4_bytes" {
     GHC.IO.Handle.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.53160511 UTC

[section ""data" . GHC.IO.Handle.$trModule3_closure" {
     GHC.IO.Handle.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.532151054 UTC

[section ""cstring" . GHC.IO.Handle.$trModule2_bytes" {
     GHC.IO.Handle.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.532712626 UTC

[section ""data" . GHC.IO.Handle.$trModule1_closure" {
     GHC.IO.Handle.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.533467404 UTC

[section ""data" . GHC.IO.Handle.$trModule_closure" {
     GHC.IO.Handle.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.$trModule3_closure+1;
         const GHC.IO.Handle.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.53407828 UTC

[section ""data" . $krep_rbnWG_closure" {
     $krep_rbnWG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.545654557 UTC

[section ""data" . $krep1_rbnWH_closure" {
     $krep1_rbnWH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.546472598 UTC

[section ""cstring" . GHC.IO.Handle.$tcHandlePosn2_bytes" {
     GHC.IO.Handle.$tcHandlePosn2_bytes:
         I8[] [72,97,110,100,108,101,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.547071295 UTC

[section ""data" . GHC.IO.Handle.$tcHandlePosn1_closure" {
     GHC.IO.Handle.$tcHandlePosn1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$tcHandlePosn2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.547851701 UTC

[section ""data" . GHC.IO.Handle.$tcHandlePosn_closure" {
     GHC.IO.Handle.$tcHandlePosn_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.$trModule_closure+1;
         const GHC.IO.Handle.$tcHandlePosn1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14603627022044816180;
         const 6047646306417636971;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.548593988 UTC

[section ""data" . $krep2_rbnWI_closure" {
     $krep2_rbnWI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.$tcHandlePosn_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.549183678 UTC

[section ""data" . $krep3_rbnWJ_closure" {
     $krep3_rbnWJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbnWG_closure+1;
         const $krep2_rbnWI_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.549805091 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn1_closure" {
     GHC.IO.Handle.$tc'HandlePosn1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rbnWH_closure+1;
         const $krep3_rbnWJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.55041495 UTC

[section ""cstring" . GHC.IO.Handle.$tc'HandlePosn3_bytes" {
     GHC.IO.Handle.$tc'HandlePosn3_bytes:
         I8[] [39,72,97,110,100,108,101,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.550946633 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn2_closure" {
     GHC.IO.Handle.$tc'HandlePosn2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$tc'HandlePosn3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.551542522 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn_closure" {
     GHC.IO.Handle.$tc'HandlePosn_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.$trModule_closure+1;
         const GHC.IO.Handle.$tc'HandlePosn2_closure+1;
         const GHC.IO.Handle.$tc'HandlePosn1_closure+4;
         const 2346493220596692855;
         const 1604707260447826943;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.553317087 UTC

[section ""data" . dupHandle__rbnWK_closure" {
     dupHandle__rbnWK_closure:
         const dupHandle__rbnWK_info;
         const 0;
 },
 dupHandle__rbnWK_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboIP: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 dupHandle__rbnWK_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cboIW,
                       label: dupHandle__rbnWK_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboIW: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cboIX; else goto cboIY;
       cboIX: // global
           R1 = dupHandle__rbnWK_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cboIY: // global
           I64[Sp - 40] = block_cboIT_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uboJE; else goto cboIU;
       uboJE: // global
           call _cboIT(R1) args: 0, res: 0, upd: 0;
       cboIU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboIT() //  [R1]
         { info_tbl: [(cboIT,
                       label: block_cboIT_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboIT: // global
           I64[Sp - 24] = block_cboJ3_info;
           _sbo0L::P64 = P64[R1 + 39];
           _sbo0U::P64 = P64[R1 + 111];
           _sbo0V::P64 = P64[R1 + 119];
           R1 = P64[R1 + 87];
           P64[Sp - 16] = _sbo0U::P64;
           P64[Sp - 8] = _sbo0V::P64;
           P64[Sp] = _sbo0L::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uboJD; else goto cboJb;
       uboJD: // global
           call _cboJ3(R1) args: 0, res: 0, upd: 0;
       cboJb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboJ3() //  [R1]
         { info_tbl: [(cboJ3,
                       label: block_cboJ3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboJ3: // global
           if (R1 & 7 == 1) goto cboJh; else goto cboJm;
       cboJh: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _cboJ6() args: 0, res: 0, upd: 0;
       cboJm: // global
           I64[Sp] = block_cboJk_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto uboJF; else goto cboJn;
       uboJF: // global
           call _cboJk(R1) args: 0, res: 0, upd: 0;
       cboJn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboJk() //  [R1]
         { info_tbl: [(cboJk,
                       label: block_cboJk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboJk: // global
           I64[Sp] = block_cboJr_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboJr() //  [R1]
         { info_tbl: [(cboJr,
                       label: block_cboJr_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboJr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cboJw; else goto cboJv;
       cboJw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboJv: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 6;
           call _cboJ6() args: 0, res: 0, upd: 0;
     }
 },
 _cboJ6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboJ6: // global
           Hp = Hp + 24;
           _sbo0Z::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cboJa; else goto cboJ9;
       cboJa: // global
           HpAlloc = 24;
           I64[Sp] = block_cboJ5_info;
           R1 = _sbo0Z::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboJ9: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 72];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = GHC.Types.True_closure+2;
           P64[Sp + 56] = _sbo0Z::P64;
           _sbo0C::P64 = P64[Sp + 64];
           P64[Sp + 64] = Hp - 15;
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sbo0C::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 },
 _cboJ5() //  [R1]
         { info_tbl: [(cboJ5,
                       label: block_cboJ5_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboJ5: // global
           P64[Sp] = R1;
           call _cboJ6() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.555904036 UTC

[section ""cstring" . lvl4_rbnWL_bytes" {
     lvl4_rbnWL_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,55,49,51,58,55,45,50,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.556663081 UTC

[section ""data" . lvl5_rbnWM_closure" {
     lvl5_rbnWM_closure:
         const lvl5_rbnWM_info;
         const 0;
 },
 lvl5_rbnWM_entry() //  []
         { info_tbl: [(cboJP,
                       label: lvl5_rbnWM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboJP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cboJQ; else goto cboJR;
       cboJQ: // global
           R1 = lvl5_rbnWM_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cboJR: // global
           I64[Sp - 8] = block_cboJN_info;
           R2 = lvl4_rbnWL_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboJN() //  [R1]
         { info_tbl: [(cboJN,
                       label: block_cboJN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboJN: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.558419254 UTC

[section ""data" . dupHandleTo_rbnWN_closure" {
     dupHandleTo_rbnWN_closure:
         const dupHandleTo_rbnWN_info;
         const 0;
 },
 dupHandleTo_rbnWN_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cboK2,
                       label: dupHandleTo_rbnWN_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboK2: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cboK6; else goto cboK7;
       cboK6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = dupHandleTo_rbnWN_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cboK7: // global
           I64[Sp - 40] = block_cboJZ_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uboKN; else goto cboK0;
       uboKN: // global
           call _cboJZ(R1) args: 0, res: 0, upd: 0;
       cboK0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboJZ() //  [R1]
         { info_tbl: [(cboJZ,
                       label: block_cboJZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboJZ: // global
           I64[Sp - 8] = block_cboK5_info;
           _sbo1m::P64 = P64[R1 + 23];
           _sbo1n::P64 = P64[R1 + 31];
           R1 = P64[Sp + 32];
           P64[Sp] = _sbo1n::P64;
           P64[Sp + 32] = _sbo1m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboKM; else goto cboK9;
       uboKM: // global
           call _cboK5(R1) args: 0, res: 0, upd: 0;
       cboK9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboK5() //  [R1]
         { info_tbl: [(cboK5,
                       label: block_cboK5_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboK5: // global
           I64[Sp - 40] = block_cboKd_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboKd() //  []
         { info_tbl: [(cboKd,
                       label: block_cboKd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboKd: // global
           I64[Sp] = block_cboKf_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 80];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboKf() //  [R1]
         { info_tbl: [(cboKf,
                       label: block_cboKf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboKf: // global
           if (R1 & 7 == 1) goto cboKn; else goto cboKw;
       cboKn: // global
           R2 = P64[Sp + 64];
           Sp = Sp + 96;
           call ioe_dupHandlesNotCompatible_rbnWF_entry(R2) args: 8, res: 0, upd: 8;
       cboKw: // global
           I64[Sp] = block_cboKq_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 48];
           Sp = Sp - 24;
           call GHC.IO.Device.dup2_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cboKq() //  []
         { info_tbl: [(cboKq,
                       label: block_cboKq_info
                       rep:StackRep [False, False, False, True, False, False, False, True,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboKq: // global
           _sbo1h::P64 = P64[Sp + 88];
           I64[Sp + 88] = block_cboKs_info;
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 64] = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 40];
           P64[Sp + 80] = _sbo1h::P64;
           Sp = Sp + 64;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cboKs() //  [R1]
         { info_tbl: [(cboKs,
                       label: block_cboKs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboKs: // global
           I64[Sp] = block_cboKu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uboKO; else goto cboKz;
       uboKO: // global
           call _cboKu(R1) args: 0, res: 0, upd: 0;
       cboKz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboKu() //  [R1]
         { info_tbl: [(cboKu,
                       label: block_cboKu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboKu: // global
           if (R1 & 7 == 1) goto cboKF; else goto cboKJ;
       cboKF: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
       cboKJ: // global
           Sp = Sp + 8;
           call lvl5_rbnWM_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.560722524 UTC

[section ""cstring" . lvl6_rbnWO_bytes" {
     lvl6_rbnWO_bytes:
         I8[] [100,117,112,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.561490248 UTC

[section ""data" . lvl7_rbnWP_closure" {
     lvl7_rbnWP_closure:
         const lvl7_rbnWP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rbnWP_entry() //  [R1]
         { info_tbl: [(cboKV,
                       label: lvl7_rbnWP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboKV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboKW; else goto cboKX;
       cboKW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboKX: // global
           (_cboKS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboKS::I64 == 0) goto cboKU; else goto cboKT;
       cboKU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboKT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboKS::I64;
           R2 = lvl6_rbnWO_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.56235934 UTC

[section ""cstring" . GHC.IO.Handle.hSetNewlineMode3_bytes" {
     GHC.IO.Handle.hSetNewlineMode3_bytes:
         I8[] [104,83,101,116,78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.563070854 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode2_closure" {
     GHC.IO.Handle.hSetNewlineMode2_closure:
         const GHC.IO.Handle.hSetNewlineMode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode2_entry() //  [R1]
         { info_tbl: [(cboL4,
                       label: GHC.IO.Handle.hSetNewlineMode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboL4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboL5; else goto cboL6;
       cboL5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboL6: // global
           (_cboL1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboL1::I64 == 0) goto cboL3; else goto cboL2;
       cboL3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboL2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboL1::I64;
           R2 = GHC.IO.Handle.hSetNewlineMode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.564781302 UTC

[section ""data" . GHC.IO.Handle.$whSetNewlineMode_closure" {
     GHC.IO.Handle.$whSetNewlineMode_closure:
         const GHC.IO.Handle.$whSetNewlineMode_info;
         const 0;
 },
 sat_sbo2y_entry() //  [R1, R2]
         { info_tbl: [(cboLj,
                       label: sat_sbo2y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboLj: // global
           if ((Sp + -136) < SpLim) (likely: False) goto cboLp; else goto cboLq;
       cboLp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboLq: // global
           I64[Sp - 24] = block_cboLg_info;
           _sbo28::P64 = P64[R1 + 6];
           _sbo29::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbo28::P64;
           P64[Sp - 8] = _sbo29::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uboLv; else goto cboLh;
       uboLv: // global
           call _cboLg(R1) args: 0, res: 0, upd: 0;
       cboLh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboLg() //  [R1]
         { info_tbl: [(cboLg,
                       label: block_cboLg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboLg: // global
           I64[Sp - 112] = block_cboLm_info;
           R2 = R1;
           P64[Sp - 104] = P64[R1 + 15];
           P64[Sp - 96] = P64[R1 + 23];
           P64[Sp - 88] = P64[R1 + 31];
           P64[Sp - 80] = P64[R1 + 39];
           P64[Sp - 72] = P64[R1 + 47];
           P64[Sp - 64] = P64[R1 + 55];
           P64[Sp - 56] = P64[R1 + 63];
           P64[Sp - 48] = P64[R1 + 71];
           P64[Sp - 40] = P64[R1 + 79];
           P64[Sp - 32] = P64[R1 + 87];
           P64[Sp - 24] = P64[R1 + 95];
           P64[Sp - 16] = P64[R1 + 103];
           P64[Sp - 8] = P64[R1 + 127];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 112;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboLm() //  [R1]
         { info_tbl: [(cboLm,
                       label: block_cboLm_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboLm: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cboLu; else goto cboLt;
       cboLu: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboLt: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 112];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 56];
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = P64[Sp + 104];
           R1 = Hp - 127;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.$whSetNewlineMode_entry() //  [R2, R3, R4]
         { info_tbl: [(cboLw,
                       label: GHC.IO.Handle.$whSetNewlineMode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboLw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboLA; else goto cboLz;
       cboLA: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$whSetNewlineMode_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cboLz: // global
           I64[Hp - 16] = sat_sbo2y_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.hSetNewlineMode2_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.567070534 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode1_closure" {
     GHC.IO.Handle.hSetNewlineMode1_closure:
         const GHC.IO.Handle.hSetNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(cboLI,
                       label: GHC.IO.Handle.hSetNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboLI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboLJ; else goto cboLK;
       cboLJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetNewlineMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cboLK: // global
           I64[Sp - 16] = block_cboLF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uboLO; else goto cboLG;
       uboLO: // global
           call _cboLF(R1) args: 0, res: 0, upd: 0;
       cboLG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboLF() //  [R1]
         { info_tbl: [(cboLF,
                       label: block_cboLF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboLF: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$whSetNewlineMode_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.568198825 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode_closure" {
     GHC.IO.Handle.hSetNewlineMode_closure:
         const GHC.IO.Handle.hSetNewlineMode_info;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode_entry() //  [R2, R3]
         { info_tbl: [(cboLT,
                       label: GHC.IO.Handle.hSetNewlineMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboLT: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetNewlineMode1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.568935347 UTC

[section ""cstring" . lvl8_rbnWQ_bytes" {
     lvl8_rbnWQ_bytes:
         I8[] [104,83,101,116,66,105,110,97,114,121,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.569996216 UTC

[section ""data" . lvl9_rbnWR_closure" {
     lvl9_rbnWR_closure:
         const lvl9_rbnWR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rbnWR_entry() //  [R1]
         { info_tbl: [(cboM2,
                       label: lvl9_rbnWR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboM2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboM3; else goto cboM4;
       cboM3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboM4: // global
           (_cboLZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboLZ::I64 == 0) goto cboM1; else goto cboM0;
       cboM1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboM0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboLZ::I64;
           R2 = lvl8_rbnWQ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.57083431 UTC

[section ""cstring" . lvl10_rbnWS_bytes" {
     lvl10_rbnWS_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.57159395 UTC

[section ""data" . lvl11_rbnWT_closure" {
     lvl11_rbnWT_closure:
         const lvl11_rbnWT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rbnWT_entry() //  [R1]
         { info_tbl: [(cboMd,
                       label: lvl11_rbnWT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboMd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboMe; else goto cboMf;
       cboMe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboMf: // global
           (_cboM8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboM8::I64 == 0) goto cboMa; else goto cboM9;
       cboMa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboM9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboM8::I64;
           I64[Sp - 24] = block_cboMb_info;
           R2 = lvl10_rbnWS_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cboMb() //  [R1]
         { info_tbl: [(cboMb,
                       label: block_cboMb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboMb: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.58005884 UTC

[section ""data" . GHC.IO.Handle.hSetBinaryMode1_closure" {
     GHC.IO.Handle.hSetBinaryMode1_closure:
         const GHC.IO.Handle.hSetBinaryMode1_info;
         const 0;
 },
 lvl48_sbo2J_entry() //  [R1]
         { info_tbl: [(cboMu,
                       label: lvl48_sbo2J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboMu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboMv; else goto cboMw;
       cboMv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboMw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cboMr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uboMA; else goto cboMs;
       uboMA: // global
           call _cboMr() args: 0, res: 0, upd: 0;
       cboMs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cboMr() //  []
         { info_tbl: [(cboMr,
                       label: block_cboMr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboMr: // global
           R1 = GHC.IO.Handle.Types.LF_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo5C_entry() //  [R1]
         { info_tbl: [(cboNm,
                       label: sat_sbo5C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboNm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboNq; else goto cboNr;
       cboNq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboNr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cboNj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uboNv; else goto cboNk;
       uboNv: // global
           call _cboNj(R1) args: 0, res: 0, upd: 0;
       cboNk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cboNj() //  [R1]
         { info_tbl: [(cboNj,
                       label: block_cboNj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboNj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cboNu; else goto cboNt;
       cboNu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cboNt: // global
           _sbo5x::P64 = P64[R1 + 7];
           _sbo5y::P64 = P64[R1 + 15];
           _sbo5w::I64 = I64[R1 + 23];
           _sbo5z::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo5x::P64;
           P64[Hp - 32] = _sbo5y::P64;
           I64[Hp - 24] = _sbo5w::I64;
           I64[Hp - 16] = _sbo5z::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo5V_entry() //  [R1]
         { info_tbl: [(cboNS,
                       label: sat_sbo5V_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboNS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cboNZ; else goto cboO0;
       cboNZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboO0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cboNP_info;
           _sbo5L::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbo5L::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uboO4; else goto cboNQ;
       uboO4: // global
           call _cboNP(R1) args: 0, res: 0, upd: 0;
       cboNQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cboNP() //  [R1]
         { info_tbl: [(cboNP,
                       label: block_cboNP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboNP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cboO3; else goto cboO2;
       cboO3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cboO2: // global
           _sbo5P::P64 = P64[R1 + 7];
           _sbo5Q::P64 = P64[R1 + 15];
           _sbo5O::I64 = I64[R1 + 23];
           _sbo5R::I64 = I64[R1 + 31];
           _sbo5T::I64 = I64[R1 + 47];
           _sbo5U::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo5P::P64;
           P64[Hp - 32] = _sbo5Q::P64;
           I64[Hp - 24] = _sbo5O::I64;
           I64[Hp - 16] = _sbo5R::I64;
           I64[Hp - 8] = _sbo5U::I64;
           I64[Hp] = _sbo5T::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo6i_entry() //  [R1, R2]
         { info_tbl: [(cboO5,
                       label: sat_sbo6i_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboO5: // global
           if ((Sp + -176) < SpLim) (likely: False) goto cboO6; else goto cboO7;
       cboO6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboO7: // global
           I64[Sp - 24] = block_cboMG_info;
           _sbo2H::P64 = P64[R1 + 6];
           _sbo2J::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbo2H::P64;
           P64[Sp - 8] = _sbo2J::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uboTH; else goto cboMH;
       uboTH: // global
           call _cboMG(R1) args: 0, res: 0, upd: 0;
       cboMH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboMG() //  [R1]
         { info_tbl: [(cboMG,
                       label: block_cboMG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboMG: // global
           I64[Sp - 104] = block_cboML_info;
           _sbo2O::P64 = P64[R1 + 7];
           _sbo2P::P64 = P64[R1 + 15];
           _sbo2Q::P64 = P64[R1 + 23];
           _sbo2R::P64 = P64[R1 + 31];
           _sbo2S::P64 = P64[R1 + 39];
           _sbo2T::P64 = P64[R1 + 47];
           _sbo2U::P64 = P64[R1 + 55];
           _sbo2V::P64 = P64[R1 + 63];
           _sbo2W::P64 = P64[R1 + 71];
           _sbo2X::P64 = P64[R1 + 79];
           _sbo2Y::P64 = P64[R1 + 87];
           _sbo2Z::P64 = P64[R1 + 95];
           _sbo33::P64 = P64[R1 + 127];
           R1 = P64[_sbo2W::P64 + 8];
           P64[Sp - 96] = _sbo2P::P64;
           P64[Sp - 88] = _sbo2Q::P64;
           P64[Sp - 80] = _sbo2R::P64;
           P64[Sp - 72] = _sbo2S::P64;
           P64[Sp - 64] = _sbo2T::P64;
           P64[Sp - 56] = _sbo2U::P64;
           P64[Sp - 48] = _sbo2V::P64;
           P64[Sp - 40] = _sbo2W::P64;
           P64[Sp - 32] = _sbo2X::P64;
           P64[Sp - 24] = _sbo2Y::P64;
           P64[Sp - 16] = _sbo2Z::P64;
           P64[Sp - 8] = _sbo33::P64;
           P64[Sp] = _sbo2O::P64;
           Sp = Sp - 104;
           if (R1 & 7 != 0) goto uboTu; else goto cboMM;
       uboTu: // global
           call _cboML(R1) args: 0, res: 0, upd: 0;
       cboMM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboML() //  [R1]
         { info_tbl: [(cboML,
                       label: block_cboML_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboML: // global
           I64[Sp - 16] = block_cboMS_info;
           _sbo3c::I64 = I64[R1 + 39];
           _sbo3d::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo3d::I64;
           I64[Sp] = _sbo3c::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uboTv; else goto cboMT;
       uboTv: // global
           call _cboMS(R1) args: 0, res: 0, upd: 0;
       cboMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboMS() //  [R1]
         { info_tbl: [(cboMS,
                       label: block_cboMS_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboMS: // global
           if (R1 & 7 == 1) goto cboRT; else goto cboSO;
       cboRT: // global
           _sbo5c::P64 = P64[P64[Sp + 80] + 8];
           I64[Sp + 16] = block_cboMX_info;
           R1 = _sbo5c::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uboTw; else goto cboMY;
       uboTw: // global
           call _cboMX(R1) args: 0, res: 0, upd: 0;
       cboMY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cboSO: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto uboTf; else goto cboSM;
       uboTf: // global
           Sp = Sp + 24;
           call _sbo3e() args: 0, res: 0, upd: 0;
       cboSM: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 144;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboMX() //  [R1]
         { info_tbl: [(cboMX,
                       label: block_cboMX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboMX: // global
           I64[Sp - 16] = block_cboN2_info;
           _sbo5i::I64 = I64[R1 + 39];
           _sbo5j::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo5j::I64;
           I64[Sp] = _sbo5i::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uboTy; else goto cboN3;
       uboTy: // global
           call _cboN2(R1) args: 0, res: 0, upd: 0;
       cboN3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboN2() //  [R1]
         { info_tbl: [(cboN2,
                       label: block_cboN2_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboN2: // global
           if (R1 & 7 == 1) goto cboSB; else goto uboTg;
       cboSB: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto uboTh; else goto cboRX;
       uboTh: // global
           Sp = Sp + 24;
           goto uboTB;
       cboRX: // global
           _sbo5o::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cboNa_info;
           R1 = _sbo5o::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uboTz; else goto cboNb;
       uboTz: // global
           call _cboNa(R1) args: 0, res: 0, upd: 0;
       cboNb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       uboTg: // global
           Sp = Sp + 24;
           goto uboTB;
       uboTB: // global
           call _sbo3e() args: 0, res: 0, upd: 0;
     }
 },
 _cboNa() //  [R1]
         { info_tbl: [(cboNa,
                       label: block_cboNa_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboNa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboS0; else goto cboRZ;
       cboS0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboRZ: // global
           _sbo2W::P64 = P64[Sp + 64];
           _sbo5q::P64 = P64[R1 + 7];
           _sbo5r::P64 = P64[R1 + 15];
           _sbo5u::P64 = P64[_sbo2W::P64 + 8];
           I64[Hp - 16] = sat_sbo5C_info;
           P64[Hp] = _sbo5u::P64;
           call MO_WriteBarrier();
           P64[_sbo2W::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2W::P64);
           I64[Sp - 8] = block_cboNz_info;
           R1 = _sbo5u::P64;
           P64[Sp] = _sbo5r::P64;
           P64[Sp + 56] = _sbo5q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboTC; else goto cboNA;
       uboTC: // global
           call _cboNz(R1) args: 0, res: 0, upd: 0;
       cboNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboNz() //  [R1]
         { info_tbl: [(cboNz,
                       label: block_cboNz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboNz: // global
           _sbo5L::I64 = I64[R1 + 39];
           if (_sbo5L::I64 != 0) goto cboS3; else goto cboSy;
       cboS3: // global
           I64[Sp - 32] = block_cboNG_info;
           _sbo5G::P64 = P64[R1 + 7];
           _sbo5H::P64 = P64[R1 + 15];
           _sbo5F::I64 = I64[R1 + 23];
           R1 = P64[Sp + 96];
           P64[Sp - 24] = _sbo5G::P64;
           P64[Sp - 16] = _sbo5H::P64;
           I64[Sp - 8] = _sbo5L::I64;
           I64[Sp] = _sbo5F::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uboTD; else goto cboNH;
       uboTD: // global
           call _cboNG(R1) args: 0, res: 0, upd: 0;
       cboNH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cboSy: // global
           _sbo2T::P64 = P64[Sp + 48];
           _sbo5r::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbo2T::P64 + 8] = _sbo5r::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2T::P64);
           Sp = Sp + 16;
           call _sbo3e() args: 0, res: 0, upd: 0;
     }
 },
 _cboNG() //  [R1]
         { info_tbl: [(cboNG,
                       label: block_cboNG_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboNG: // global
           if (R1 & 7 == 1) goto cboS5; else goto cboSn;
       cboS5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cboS8; else goto cboS7;
       cboS8: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboS7: // global
           I64[Hp - 24] = sat_sbo5V_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 24];
           _sbo2T::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sbo2T::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2T::P64);
           Sp = Sp + 48;
           call _sbo3e() args: 0, res: 0, upd: 0;
       cboSn: // global
           I64[Sp] = block_cboSb_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uboTF; else goto cboSc;
       uboTF: // global
           call _cboSb(R1) args: 0, res: 0, upd: 0;
       cboSc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboSb() //  [R1]
         { info_tbl: [(cboSb,
                       label: block_cboSb_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboSb: // global
           I64[Sp - 8] = block_cboSg_info;
           R2 = P64[Sp + 96];
           _sbo5Z::P64 = P64[R1 + 7];
           _sbo60::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbo60::P64;
           P64[Sp + 96] = _sbo5Z::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboSg() //  [R1]
         { info_tbl: [(cboSg,
                       label: block_cboSg_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboSg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cboSr; else goto cboSq;
       cboSr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboSq: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbo5r::P64 = P64[Sp + 48];
           I64[Sp + 48] = block_cboSj_info;
           R5 = Hp - 47;
           R4 = _sbo5r::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 104];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboSj() //  [R1]
         { info_tbl: [(cboSj,
                       label: block_cboSj_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboSj: // global
           I64[Sp] = block_cboSl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uboTZ; else goto cboSt;
       uboTZ: // global
           call _cboSl(R1) args: 0, res: 0, upd: 0;
       cboSt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboSl() //  [R1]
         { info_tbl: [(cboSl,
                       label: block_cboSl_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboSl: // global
           _sbo2T::P64 = P64[Sp + 40];
           _sbo6c::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbo2T::P64 + 8] = _sbo6c::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2T::P64);
           Sp = Sp + 8;
           call _sbo3e() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3e() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3e: // global
           I64[Sp - 8] = block_cboOf_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboU1; else goto cboQR;
       uboU1: // global
           call _cboOf(R1) args: 0, res: 0, upd: 0;
       cboQR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboOf() //  [R1]
         { info_tbl: [(cboOf,
                       label: block_cboOf_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboOf: // global
           if (R1 & 7 == 1) goto cboQY; else goto cboRn;
       cboQY: // global
           I64[Sp] = block_cboQV_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto uboTI; else goto cboQZ;
       uboTI: // global
           call _cboQV(R1) args: 0, res: 0, upd: 0;
       cboQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cboRn: // global
           I64[Sp] = block_cboRl_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uboTJ; else goto cboRo;
       uboTJ: // global
           call _cboRl(R1) args: 0, res: 0, upd: 0;
       cboRo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboQV() //  [R1]
         { info_tbl: [(cboQV,
                       label: block_cboQV_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboQV: // global
           if (R1 & 7 == 1) goto uboTn; else goto cboRf;
       uboTn: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
       cboRf: // global
           I64[Sp] = block_cboR8_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uboTS; else goto cboR9;
       uboTS: // global
           call _cboR8(R1) args: 0, res: 0, upd: 0;
       cboR9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboR8() //  [R1]
         { info_tbl: [(cboR8,
                       label: block_cboR8_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboR8: // global
           I64[Sp] = block_cboRd_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboRd() //  []
         { info_tbl: [(cboRd,
                       label: block_cboRd_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboRd: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
     }
 },
 _cboRl() //  [R1]
         { info_tbl: [(cboRl,
                       label: block_cboRl_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboRl: // global
           I64[Sp] = block_cboRs_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboRs() //  []
         { info_tbl: [(cboRs,
                       label: block_cboRs_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboRs: // global
           I64[Sp] = block_cboRu_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto uboTV; else goto cboRx;
       uboTV: // global
           call _cboRu(R1) args: 0, res: 0, upd: 0;
       cboRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboRu() //  [R1]
         { info_tbl: [(cboRu,
                       label: block_cboRu_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboRu: // global
           if (R1 & 7 == 1) goto uboTl; else goto cboRN;
       uboTl: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
       cboRN: // global
           I64[Sp] = block_cboRG_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uboTW; else goto cboRH;
       uboTW: // global
           call _cboRG(R1) args: 0, res: 0, upd: 0;
       cboRH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboRG() //  [R1]
         { info_tbl: [(cboRG,
                       label: block_cboRG_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboRG: // global
           I64[Sp] = block_cboRL_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboRL() //  []
         { info_tbl: [(cboRL,
                       label: block_cboRL_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboRL: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3g: // global
           I64[Sp - 8] = block_cboOm_info;
           R1 = P64[Sp + 104];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboU2; else goto cboQv;
       uboU2: // global
           call _cboOm(R1) args: 0, res: 0, upd: 0;
       cboQv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboOm() //  [R1]
         { info_tbl: [(cboOm,
                       label: block_cboOm_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboOm: // global
           if (R1 & 7 == 1) goto cboQC; else goto cboQQ;
       cboQC: // global
           I64[Sp] = block_cboQz_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto uboTK; else goto cboQD;
       uboTK: // global
           call _cboQz(R1) args: 0, res: 0, upd: 0;
       cboQD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cboQQ: // global
           P64[Sp + 112] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbo3i() args: 0, res: 0, upd: 0;
     }
 },
 _cboQz() //  [R1]
         { info_tbl: [(cboQz,
                       label: block_cboQz_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboQz: // global
           I64[Sp] = block_cboQH_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboQH() //  [R1]
         { info_tbl: [(cboQH,
                       label: block_cboQH_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboQH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cboQM; else goto cboQL;
       cboQM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboQL: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 112] = Hp - 6;
           Sp = Sp + 8;
           call _sbo3i() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3i() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3i: // global
           I64[Sp - 8] = block_cboOr_info;
           R1 = P64[Sp + 104];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboU3; else goto cboOt;
       uboU3: // global
           call _cboOr(R1) args: 0, res: 0, upd: 0;
       cboOt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboOr() //  [R1]
         { info_tbl: [(cboOr,
                       label: block_cboOr_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboOr: // global
           if (R1 & 7 == 1) goto cboOC; else goto cboON;
       cboOC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboOF; else goto cboOE;
       cboOF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboOE: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cboOy_info;
           R1 = Hp - 15;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cboON: // global
           I64[Sp] = block_cboOL_info;
           _sbo3l::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 112] = _sbo3l::P64;
           if (R1 & 7 != 0) goto uboTM; else goto cboOO;
       uboTM: // global
           call _cboOL(R1) args: 0, res: 0, upd: 0;
       cboOO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboOy() //  [R1]
         { info_tbl: [(cboOy,
                       label: block_cboOy_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboOy: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cboOI; else goto cboOH;
       cboOI: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboOH: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboOL() //  [R1]
         { info_tbl: [(cboOL,
                       label: block_cboOL_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboOL: // global
           I64[Sp] = block_cboOU_info;
           _sbo3x::P64 = P64[R1 + 15];
           _sbo3y::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp + 80] = _sbo3y::P64;
           P64[Sp + 88] = _sbo3x::P64;
           if (R1 & 7 != 0) goto uboTN; else goto cboQ6;
       uboTN: // global
           call _cboOU(R1) args: 0, res: 0, upd: 0;
       cboQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboOU() //  [R1]
         { info_tbl: [(cboOU,
                       label: block_cboOU_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboOU: // global
           _sbo3x::P64 = P64[Sp + 88];
           _cboT8::P64 = R1 & 7;
           if (_cboT8::P64 != 3) goto uboTc; else goto cboQh;
       uboTc: // global
           if (_cboT8::P64 != 6) goto cboQc; else goto cboQq;
       cboQc: // global
           P64[Sp + 88] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbo3z() args: 0, res: 0, upd: 0;
       cboQq: // global
           I64[Sp] = block_cboQo_info;
           R1 = _sbo3x::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cboQh: // global
           I64[Sp] = block_cboQf_info;
           R1 = _sbo3x::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboQo() //  [R1]
         { info_tbl: [(cboQo,
                       label: block_cboQo_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboQo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cboQu; else goto cboQt;
       cboQu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboQt: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 88] = Hp - 6;
           Sp = Sp + 8;
           call _sbo3z() args: 0, res: 0, upd: 0;
     }
 },
 _cboQf() //  [R1]
         { info_tbl: [(cboQf,
                       label: block_cboQf_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboQf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cboQl; else goto cboQk;
       cboQl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboQk: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 88] = Hp - 6;
           Sp = Sp + 8;
           call _sbo3z() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3z: // global
           I64[Sp - 8] = block_cboOZ_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboU4; else goto cboP1;
       uboU4: // global
           call _cboOZ(R1) args: 0, res: 0, upd: 0;
       cboP1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboOZ() //  [R1]
         { info_tbl: [(cboOZ,
                       label: block_cboOZ_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboOZ: // global
           _sbo3y::P64 = P64[Sp + 80];
           _cboTb::P64 = R1 & 7;
           if (_cboTb::P64 < 5) goto uboTd; else goto uboTe;
       uboTd: // global
           if (_cboTb::P64 < 4) goto cboPa; else goto cboPr;
       cboPa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboPd; else goto cboPc;
       cboPd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboPc: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cboP6_info;
           _sbo3C::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo3C::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cboPr: // global
           I64[Sp] = block_cboPj_info;
           R1 = _sbo3y::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       uboTe: // global
           if (_cboTb::P64 < 6) goto cboPI; else goto cboPZ;
       cboPI: // global
           I64[Sp] = block_cboPA_info;
           R1 = _sbo3y::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cboPZ: // global
           I64[Sp] = block_cboPR_info;
           R1 = _sbo3y::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboP6() //  [R1]
         { info_tbl: [(cboP6,
                       label: block_cboP6_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboP6: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cboPg; else goto cboPf;
       cboPg: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboPf: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboPj() //  [R1]
         { info_tbl: [(cboPj,
                       label: block_cboPj_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboPj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboPu; else goto cboPt;
       cboPu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboPt: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cboPm_info;
           _sbo3N::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo3N::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboPm() //  [R1]
         { info_tbl: [(cboPm,
                       label: block_cboPm_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboPm: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cboPx; else goto cboPw;
       cboPx: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboPw: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboPA() //  [R1]
         { info_tbl: [(cboPA,
                       label: block_cboPA_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboPA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboPL; else goto cboPK;
       cboPL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboPK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cboPD_info;
           _sbo3Z::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo3Z::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboPD() //  [R1]
         { info_tbl: [(cboPD,
                       label: block_cboPD_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboPD: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cboPO; else goto cboPN;
       cboPO: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboPN: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.AppendHandle_closure+5;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboPR() //  [R1]
         { info_tbl: [(cboPR,
                       label: block_cboPR_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboPR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboQ2; else goto cboQ1;
       cboQ2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboQ1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cboPU_info;
           _sbo4b::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo4b::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboPU() //  [R1]
         { info_tbl: [(cboPU,
                       label: block_cboPU_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboPU: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cboQ5; else goto cboQ4;
       cboQ5: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboQ4: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetBinaryMode1_entry() //  [R2, R3]
         { info_tbl: [(cboU5,
                       label: GHC.IO.Handle.hSetBinaryMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboU5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cboU9; else goto cboU8;
       cboU9: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetBinaryMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cboU8: // global
           I64[Hp - 40] = lvl48_sbo2J_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbo6i_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = R2;
           R2 = lvl9_rbnWR_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.595942705 UTC

[section ""data" . GHC.IO.Handle.hSetBinaryMode_closure" {
     GHC.IO.Handle.hSetBinaryMode_closure:
         const GHC.IO.Handle.hSetBinaryMode_info;
         const 0;
 },
 GHC.IO.Handle.hSetBinaryMode_entry() //  [R2, R3]
         { info_tbl: [(cboUe,
                       label: GHC.IO.Handle.hSetBinaryMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboUe: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetBinaryMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.596742786 UTC

[section ""cstring" . GHC.IO.Handle.hIsSeekable4_bytes" {
     GHC.IO.Handle.hIsSeekable4_bytes:
         I8[] [104,73,115,83,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.597596835 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable3_closure" {
     GHC.IO.Handle.hIsSeekable3_closure:
         const GHC.IO.Handle.hIsSeekable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable3_entry() //  [R1]
         { info_tbl: [(cboUn,
                       label: GHC.IO.Handle.hIsSeekable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboUn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboUo; else goto cboUp;
       cboUo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboUp: // global
           (_cboUk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboUk::I64 == 0) goto cboUm; else goto cboUl;
       cboUm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboUl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboUk::I64;
           R2 = GHC.IO.Handle.hIsSeekable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.599196853 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable2_closure" {
     GHC.IO.Handle.hIsSeekable2_closure:
         const GHC.IO.Handle.hIsSeekable2_info;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable2_entry() //  [R2]
         { info_tbl: [(cboUx,
                       label: GHC.IO.Handle.hIsSeekable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboUx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cboUy; else goto cboUz;
       cboUy: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsSeekable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboUz: // global
           I64[Sp - 8] = block_cboUu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboVa; else goto cboUv;
       uboVa: // global
           call _cboUu(R1) args: 0, res: 0, upd: 0;
       cboUv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboUu() //  [R1]
         { info_tbl: [(cboUu,
                       label: block_cboUu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboUu: // global
           I64[Sp - 24] = block_cboUC_info;
           _sbo6l::P64 = R1;
           _sbo6m::P64 = P64[R1 + 7];
           _sbo6p::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbo6m::P64;
           P64[Sp - 8] = _sbo6p::P64;
           P64[Sp] = _sbo6l::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uboV9; else goto cboUE;
       uboV9: // global
           call _cboUC(R1) args: 0, res: 0, upd: 0;
       cboUE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboUC() //  [R1]
         { info_tbl: [(cboUC,
                       label: block_cboUC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboUC: // global
           _cboV6::P64 = R1 & 7;
           if (_cboV6::P64 < 3) goto uboV7; else goto uboV8;
       uboV7: // global
           if (_cboV6::P64 < 2) goto cboUU; else goto cboUY;
       cboUU: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cboUY: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       uboV8: // global
           if (_cboV6::P64 == 5) goto cboV2; else goto cboUN;
       cboV2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboV5; else goto cboV4;
       cboV5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboV4: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cboUN: // global
           _sbo6p::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cboUI_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbo6p::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cboUI() //  [R1]
         { info_tbl: [(cboUI,
                       label: block_cboUI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboUI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboUQ; else goto cboUP;
       cboUQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboUP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.602190137 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable1_closure" {
     GHC.IO.Handle.hIsSeekable1_closure:
         const GHC.IO.Handle.hIsSeekable1_info;
         const 0;
 },
 io_sbo6S_entry() //  [R1]
         { info_tbl: [(cboVw,
                       label: io_sbo6S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboVA; else goto cboVB;
       cboVA: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cboVB: // global
           I64[Sp - 16] = block_cboVr_info;
           _sbo6O::P64 = P64[R1 + 15];
           R5 = _sbo6O::P64;
           R4 = GHC.IO.Handle.hIsSeekable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsSeekable3_closure;
           P64[Sp - 8] = _sbo6O::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboVr() //  [R1]
         { info_tbl: [(cboVr,
                       label: block_cboVr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVr: // global
           I64[Sp] = block_cboVt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uboVG; else goto cboVu;
       uboVG: // global
           call _cboVt(R1) args: 0, res: 0, upd: 0;
       cboVu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboVt() //  [R1]
         { info_tbl: [(cboVt,
                       label: block_cboVt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVt: // global
           I64[Sp] = block_cboVz_info;
           R2 = P64[R1 + 7];
           _sbo6Z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo6Z::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboVz() //  []
         { info_tbl: [(cboVz,
                       label: block_cboVz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbo78_entry() //  [R1]
         { info_tbl: [(cboVV,
                       label: io_sbo78_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboVZ; else goto cboW0;
       cboVZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cboW0: // global
           I64[Sp - 16] = block_cboVQ_info;
           _sbo73::P64 = P64[R1 + 15];
           R5 = _sbo73::P64;
           R4 = GHC.IO.Handle.hIsSeekable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsSeekable3_closure;
           P64[Sp - 8] = _sbo73::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboVQ() //  [R1]
         { info_tbl: [(cboVQ,
                       label: block_cboVQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVQ: // global
           I64[Sp] = block_cboVS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uboW5; else goto cboVT;
       uboW5: // global
           call _cboVS(R1) args: 0, res: 0, upd: 0;
       cboVT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboVS() //  [R1]
         { info_tbl: [(cboVS,
                       label: block_cboVS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVS: // global
           I64[Sp] = block_cboVY_info;
           R2 = P64[R1 + 7];
           _sbo7f::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo7f::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboVY() //  []
         { info_tbl: [(cboVY,
                       label: block_cboVY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsSeekable1_entry() //  [R2]
         { info_tbl: [(cboWa,
                       label: GHC.IO.Handle.hIsSeekable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboWa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboWb; else goto cboWc;
       cboWb: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsSeekable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboWc: // global
           I64[Sp - 8] = block_cboVf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uboWt; else goto cboVg;
       uboWt: // global
           call _cboVf(R1) args: 0, res: 0, upd: 0;
       cboVg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboVf() //  [R1]
         { info_tbl: [(cboVf,
                       label: block_cboVf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVf: // global
           if (R1 & 7 == 1) goto cboW7; else goto cboW8;
       cboW7: // global
           I64[Sp - 16] = block_cboVk_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cboW8: // global
           I64[Sp - 16] = block_cboVJ_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cboVk() //  [R1]
         { info_tbl: [(cboVk,
                       label: block_cboVk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboWg; else goto cboWf;
       cboWg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cboWf: // global
           I64[Hp - 16] = io_sbo6S_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cboVm::P64 = Hp - 15;
           if (R1 == 0) goto cboWk; else goto cboWj;
       cboWk: // global
           R1 = _cboVm::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cboWj: // global
           R1 = _cboVm::P64;
           Sp = Sp + 24;
           call io_sbo6S_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboVJ() //  [R1]
         { info_tbl: [(cboVJ,
                       label: block_cboVJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboVJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboWo; else goto cboWn;
       cboWo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cboWn: // global
           I64[Hp - 16] = io_sbo78_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cboVL::P64 = Hp - 15;
           if (R1 == 0) goto cboWs; else goto cboWr;
       cboWs: // global
           R1 = _cboVL::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cboWr: // global
           R1 = _cboVL::P64;
           Sp = Sp + 24;
           call io_sbo78_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.605452141 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable_closure" {
     GHC.IO.Handle.hIsSeekable_closure:
         const GHC.IO.Handle.hIsSeekable_info;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable_entry() //  [R2]
         { info_tbl: [(cboWy,
                       label: GHC.IO.Handle.hIsSeekable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboWy: // global
           R2 = R2;
           call GHC.IO.Handle.hIsSeekable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.606232298 UTC

[section ""cstring" . GHC.IO.Handle.hGetPosn4_bytes" {
     GHC.IO.Handle.hGetPosn4_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.606946454 UTC

[section ""data" . GHC.IO.Handle.hGetPosn3_closure" {
     GHC.IO.Handle.hGetPosn3_closure:
         const GHC.IO.Handle.hGetPosn3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetPosn3_entry() //  [R1]
         { info_tbl: [(cboWH,
                       label: GHC.IO.Handle.hGetPosn3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboWH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cboWI; else goto cboWJ;
       cboWI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboWJ: // global
           (_cboWE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cboWE::I64 == 0) goto cboWG; else goto cboWF;
       cboWG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cboWF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cboWE::I64;
           R2 = GHC.IO.Handle.hGetPosn4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.611052816 UTC

[section ""data" . GHC.IO.Handle.hGetPosn2_closure" {
     GHC.IO.Handle.hGetPosn2_closure:
         const GHC.IO.Handle.hGetPosn2_info;
         const 0;
 },
 sat_sbo88_entry() //  [R1]
         { info_tbl: [(cboXc,
                       label: sat_sbo88_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboXc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cboXd; else goto cboXe;
       cboXd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboXe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cboX9_info;
           _sbo7D::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbo7D::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uboXM; else goto cboXa;
       uboXM: // global
           call _cboX9(R1) args: 0, res: 0, upd: 0;
       cboXa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cboX9() //  [R1]
         { info_tbl: [(cboX9,
                       label: block_cboX9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboX9: // global
           I64[Sp - 16] = block_cboXh_info;
           _sbo81::I64 = I64[R1 + 39];
           _sbo82::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo82::I64;
           I64[Sp] = _sbo81::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uboXL; else goto cboXj;
       uboXL: // global
           call _cboXh(R1) args: 0, res: 0, upd: 0;
       cboXj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cboXh() //  [R1]
         { info_tbl: [(cboXh,
                       label: block_cboXh_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboXh: // global
           _sbo81::I64 = I64[Sp + 16];
           _sbo82::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cboXt; else goto cboXF;
       cboXt: // global
           I64[Sp + 16] = block_cboXq_info;
           R2 = _sbo82::I64 - _sbo81::I64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
       cboXF: // global
           I64[Sp + 16] = block_cboXD_info;
           R2 = _sbo82::I64 - _sbo81::I64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cboXq() //  [R1]
         { info_tbl: [(cboXq,
                       label: block_cboXq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboXq: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 _cboXD() //  [R1]
         { info_tbl: [(cboXD,
                       label: block_cboXD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboXD: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo8C_entry() //  [R1]
         { info_tbl: [(cboYh,
                       label: sat_sbo8C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboYh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cboYl; else goto cboYm;
       cboYl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboYm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cboYe_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uboYq; else goto cboYf;
       uboYq: // global
           call _cboYe(R1) args: 0, res: 0, upd: 0;
       cboYf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cboYe() //  [R1]
         { info_tbl: [(cboYe,
                       label: block_cboYe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboYe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cboYp; else goto cboYo;
       cboYp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cboYo: // global
           _sbo8x::P64 = P64[R1 + 7];
           _sbo8y::P64 = P64[R1 + 15];
           _sbo8w::I64 = I64[R1 + 23];
           _sbo8z::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo8x::P64;
           P64[Hp - 32] = _sbo8y::P64;
           I64[Hp - 24] = _sbo8w::I64;
           I64[Hp - 16] = _sbo8z::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo8V_entry() //  [R1]
         { info_tbl: [(cboYN,
                       label: sat_sbo8V_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboYN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cboYU; else goto cboYV;
       cboYU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cboYV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cboYK_info;
           _sbo8L::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbo8L::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uboYZ; else goto cboYL;
       uboYZ: // global
           call _cboYK(R1) args: 0, res: 0, upd: 0;
       cboYL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cboYK() //  [R1]
         { info_tbl: [(cboYK,
                       label: block_cboYK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboYK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cboYY; else goto cboYX;
       cboYY: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cboYX: // global
           _sbo8P::P64 = P64[R1 + 7];
           _sbo8Q::P64 = P64[R1 + 15];
           _sbo8O::I64 = I64[R1 + 23];
           _sbo8R::I64 = I64[R1 + 31];
           _sbo8T::I64 = I64[R1 + 47];
           _sbo8U::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo8P::P64;
           P64[Hp - 32] = _sbo8Q::P64;
           I64[Hp - 24] = _sbo8O::I64;
           I64[Hp - 16] = _sbo8R::I64;
           I64[Hp - 8] = _sbo8U::I64;
           I64[Hp] = _sbo8T::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.hGetPosn2_entry() //  [R2]
         { info_tbl: [(cboZ0,
                       label: GHC.IO.Handle.hGetPosn2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboZ0: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cboZ1; else goto cboZ2;
       cboZ1: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetPosn2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cboZ2: // global
           I64[Sp - 8] = block_cboWO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubp0C; else goto cboWP;
       ubp0C: // global
           call _cboWO(R1) args: 0, res: 0, upd: 0;
       cboWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboWO() //  [R1]
         { info_tbl: [(cboWO,
                       label: block_cboWO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboWO: // global
           I64[Sp - 32] = block_cboWT_info;
           R2 = P64[R1 + 7];
           I64[Sp - 48] = stg_ap_pv_info;
           P64[Sp - 40] = P64[R1 + 31];
           P64[Sp - 24] = P64[R1 + 63];
           P64[Sp - 16] = P64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 95];
           P64[Sp] = P64[R1 + 47];
           Sp = Sp - 48;
           call GHC.IO.Device.tell_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cboWT() //  [R1]
         { info_tbl: [(cboWT,
                       label: block_cboWT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboWT: // global
           _sbo7G::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp - 8] = block_cboWV_info;
           _sbo7D::P64 = R1;
           R1 = _sbo7G::P64;
           P64[Sp] = _sbo7D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubp0p; else goto cboWW;
       ubp0p: // global
           call _cboWV(R1) args: 0, res: 0, upd: 0;
       cboWW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboWV() //  [R1]
         { info_tbl: [(cboWV,
                       label: block_cboWV_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboWV: // global
           I64[Sp - 16] = block_cboXN_info;
           _sbo7M::I64 = I64[R1 + 39];
           _sbo7N::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo7N::I64;
           I64[Sp] = _sbo7M::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubp0q; else goto cboXO;
       ubp0q: // global
           call _cboXN(R1) args: 0, res: 0, upd: 0;
       cboXO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboXN() //  [R1]
         { info_tbl: [(cboXN,
                       label: block_cboXN_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboXN: // global
           if (R1 & 7 == 1) goto cboZb; else goto cbp06;
       cboZb: // global
           _sbo8c::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_cboXS_info;
           R1 = _sbo8c::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubp0r; else goto cboXT;
       ubp0r: // global
           call _cboXS(R1) args: 0, res: 0, upd: 0;
       cboXT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbp06: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubp0k; else goto cbp04;
       ubp0k: // global
           Sp = Sp + 16;
           call _cboX3() args: 0, res: 0, upd: 0;
       cbp04: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cboXS() //  [R1]
         { info_tbl: [(cboXS,
                       label: block_cboXS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboXS: // global
           I64[Sp - 16] = block_cboXX_info;
           _sbo8i::I64 = I64[R1 + 39];
           _sbo8j::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo8j::I64;
           I64[Sp] = _sbo8i::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubp0t; else goto cboXY;
       ubp0t: // global
           call _cboXX(R1) args: 0, res: 0, upd: 0;
       cboXY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboXX() //  [R1]
         { info_tbl: [(cboXX,
                       label: block_cboXX_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboXX: // global
           if (R1 & 7 == 1) goto cboZT; else goto ubp0l;
       cboZT: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubp0m; else goto cboZf;
       ubp0m: // global
           Sp = Sp + 16;
           goto ubp0w;
       cboZf: // global
           _sbo8o::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cboY5_info;
           R1 = _sbo8o::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubp0u; else goto cboY6;
       ubp0u: // global
           call _cboY5(R1) args: 0, res: 0, upd: 0;
       cboY6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubp0l: // global
           Sp = Sp + 16;
           goto ubp0w;
       ubp0w: // global
           call _cboX3() args: 0, res: 0, upd: 0;
     }
 },
 _cboY5() //  [R1]
         { info_tbl: [(cboY5,
                       label: block_cboY5_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboY5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cboZi; else goto cboZh;
       cboZi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboZh: // global
           _sbo7t::P64 = P64[Sp + 24];
           _sbo8q::P64 = P64[R1 + 7];
           _sbo8r::P64 = P64[R1 + 15];
           _sbo8u::P64 = P64[_sbo7t::P64 + 8];
           I64[Hp - 16] = sat_sbo8C_info;
           P64[Hp] = _sbo8u::P64;
           call MO_WriteBarrier();
           P64[_sbo7t::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7t::P64);
           I64[Sp - 8] = block_cboYu_info;
           R1 = _sbo8u::P64;
           P64[Sp] = _sbo8r::P64;
           P64[Sp + 16] = _sbo8q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubp0x; else goto cboYv;
       ubp0x: // global
           call _cboYu(R1) args: 0, res: 0, upd: 0;
       cboYv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboYu() //  [R1]
         { info_tbl: [(cboYu,
                       label: block_cboYu_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboYu: // global
           _sbo8L::I64 = I64[R1 + 39];
           if (_sbo8L::I64 != 0) goto cboZl; else goto cboZQ;
       cboZl: // global
           I64[Sp - 24] = block_cboYB_info;
           _sbo8G::P64 = P64[R1 + 7];
           _sbo8H::P64 = P64[R1 + 15];
           _sbo8F::I64 = I64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _sbo8H::P64;
           I64[Sp - 8] = _sbo8L::I64;
           P64[Sp] = _sbo8G::P64;
           I64[Sp + 40] = _sbo8F::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubp0y; else goto cboYC;
       ubp0y: // global
           call _cboYB(R1) args: 0, res: 0, upd: 0;
       cboYC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cboZQ: // global
           _sbo7q::P64 = P64[Sp + 48];
           _sbo8r::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbo7q::P64 + 8] = _sbo8r::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7q::P64);
           Sp = Sp + 8;
           call _cboX3() args: 0, res: 0, upd: 0;
     }
 },
 _cboYB() //  [R1]
         { info_tbl: [(cboYB,
                       label: block_cboYB_info
                       rep:StackRep [False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboYB: // global
           if (R1 & 7 == 1) goto cboZn; else goto cboZF;
       cboZn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cboZq; else goto cboZp;
       cboZq: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboZp: // global
           I64[Hp - 24] = sat_sbo8V_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sbo7q::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sbo7q::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7q::P64);
           Sp = Sp + 32;
           call _cboX3() args: 0, res: 0, upd: 0;
       cboZF: // global
           I64[Sp] = block_cboZt_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubp0A; else goto cboZu;
       ubp0A: // global
           call _cboZt(R1) args: 0, res: 0, upd: 0;
       cboZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboZt() //  [R1]
         { info_tbl: [(cboZt,
                       label: block_cboZt_info
                       rep:StackRep [False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboZt: // global
           I64[Sp - 8] = block_cboZy_info;
           R2 = P64[Sp + 48];
           _sbo8Z::P64 = P64[R1 + 7];
           _sbo90::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbo90::P64;
           P64[Sp + 48] = _sbo8Z::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboZy() //  [R1]
         { info_tbl: [(cboZy,
                       label: block_cboZy_info
                       rep:StackRep [False, False, True, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboZy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cboZJ; else goto cboZI;
       cboZJ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cboZI: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbo8r::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cboZB_info;
           R5 = Hp - 47;
           R4 = _sbo8r::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cboZB() //  [R1]
         { info_tbl: [(cboZB,
                       label: block_cboZB_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboZB: // global
           I64[Sp] = block_cboZD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubp0D; else goto cboZL;
       ubp0D: // global
           call _cboZD(R1) args: 0, res: 0, upd: 0;
       cboZL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cboZD() //  [R1]
         { info_tbl: [(cboZD,
                       label: block_cboZD_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboZD: // global
           _sbo7q::P64 = P64[Sp + 40];
           _sbo9c::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbo7q::P64 + 8] = _sbo9c::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7q::P64);
           call _cboX3() args: 0, res: 0, upd: 0;
     }
 },
 _cboX3() //  []
         { info_tbl: [(cboX3,
                       label: block_cboX3_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cboX3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cboZ8; else goto cboZ7;
       cboZ8: // global
           HpAlloc = 32;
           I64[Sp] = block_cboX3_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cboZ7: // global
           I64[Hp - 24] = sat_sbo88_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[P64[Sp + 40] + 8];
           R1 = Hp - 24;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.618627894 UTC

[section ""data" . GHC.IO.Handle.hTell1_closure" {
     GHC.IO.Handle.hTell1_closure:
         const GHC.IO.Handle.hTell1_info;
         const 0;
 },
 GHC.IO.Handle.hTell1_entry() //  [R2]
         { info_tbl: [(cbp0J,
                       label: GHC.IO.Handle.hTell1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp0J: // global
           R4 = GHC.IO.Handle.hGetPosn2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hGetPosn3_closure;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.619600489 UTC

[section ""data" . GHC.IO.Handle.hTell_closure" {
     GHC.IO.Handle.hTell_closure:
         const GHC.IO.Handle.hTell_info;
         const 0;
 },
 GHC.IO.Handle.hTell_entry() //  [R2]
         { info_tbl: [(cbp0Q,
                       label: GHC.IO.Handle.hTell_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp0Q: // global
           R2 = R2;
           call GHC.IO.Handle.hTell1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.620395062 UTC

[section ""cstring" . lvl12_rbnWU_bytes" {
     lvl12_rbnWU_bytes:
         I8[] [104,83,101,101,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.621195974 UTC

[section ""data" . lvl13_rbnWV_closure" {
     lvl13_rbnWV_closure:
         const lvl13_rbnWV_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rbnWV_entry() //  [R1]
         { info_tbl: [(cbp0Z,
                       label: lvl13_rbnWV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp0Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbp10; else goto cbp11;
       cbp10: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp11: // global
           (_cbp0W::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbp0W::I64 == 0) goto cbp0Y; else goto cbp0X;
       cbp0Y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbp0X: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbp0W::I64;
           R2 = lvl12_rbnWU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.622497969 UTC

[section ""data" . lvl14_rbnWW_closure" {
     lvl14_rbnWW_closure:
         const lvl14_rbnWW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_rbnWW_entry() //  [R1]
         { info_tbl: [(cbp18,
                       label: lvl14_rbnWW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp18: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbp19; else goto cbp1a;
       cbp19: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp1a: // global
           (_cbp15::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbp15::I64 == 0) goto cbp17; else goto cbp16;
       cbp17: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbp16: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbp15::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.628708639 UTC

[section ""data" . GHC.IO.Handle.hSeek1_closure" {
     GHC.IO.Handle.hSeek1_closure:
         const GHC.IO.Handle.hSeek1_info;
         const 0;
 },
 lvl48_sbo9n_entry() //  [R1]
         { info_tbl: [(cbp1l,
                       label: lvl48_sbo9n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp1l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbp1p; else goto cbp1q;
       cbp1p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp1q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbp1j_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbp1j() //  [R1]
         { info_tbl: [(cbp1j,
                       label: block_cbp1j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp1j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbp1t; else goto cbp1s;
       cbp1t: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cbp1s: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl49_sbo9p_entry() //  [R1]
         { info_tbl: [(cbp1A,
                       label: lvl49_sbo9p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp1A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbp1E; else goto cbp1F;
       cbp1E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp1F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbp1y_info;
           R3 = lvl14_rbnWW_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbp1y() //  [R1]
         { info_tbl: [(cbp1y,
                       label: block_cbp1y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp1y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbp1I; else goto cbp1H;
       cbp1I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cbp1H: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboao_entry() //  [R1]
         { info_tbl: [(cbp2x,
                       label: sat_sboao_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp2x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbp2B; else goto cbp2C;
       cbp2B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp2C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbp2u_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubp2G; else goto cbp2v;
       ubp2G: // global
           call _cbp2u(R1) args: 0, res: 0, upd: 0;
       cbp2v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbp2u() //  [R1]
         { info_tbl: [(cbp2u,
                       label: block_cbp2u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp2u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbp2F; else goto cbp2E;
       cbp2F: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbp2E: // global
           _sboaj::P64 = P64[R1 + 7];
           _sboak::P64 = P64[R1 + 15];
           _sboai::I64 = I64[R1 + 23];
           _sboal::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sboaj::P64;
           P64[Hp - 32] = _sboak::P64;
           I64[Hp - 24] = _sboai::I64;
           I64[Hp - 16] = _sboal::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboaH_entry() //  [R1]
         { info_tbl: [(cbp33,
                       label: sat_sboaH_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp33: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbp3a; else goto cbp3b;
       cbp3a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp3b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbp30_info;
           _sboax::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sboax::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubp3f; else goto cbp31;
       ubp3f: // global
           call _cbp30(R1) args: 0, res: 0, upd: 0;
       cbp31: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbp30() //  [R1]
         { info_tbl: [(cbp30,
                       label: block_cbp30_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp30: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbp3e; else goto cbp3d;
       cbp3e: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbp3d: // global
           _sboaB::P64 = P64[R1 + 7];
           _sboaC::P64 = P64[R1 + 15];
           _sboaA::I64 = I64[R1 + 23];
           _sboaD::I64 = I64[R1 + 31];
           _sboaF::I64 = I64[R1 + 47];
           _sboaG::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sboaB::P64;
           P64[Hp - 32] = _sboaC::P64;
           I64[Hp - 24] = _sboaA::I64;
           I64[Hp - 16] = _sboaD::I64;
           I64[Hp - 8] = _sboaG::I64;
           I64[Hp] = _sboaF::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbobs_entry() //  [R1]
         { info_tbl: [(cbp3S,
                       label: sat_sbobs_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp3S: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbp3Z; else goto cbp40;
       cbp3Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp40: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cbp3P_info;
           _sbo9P::P64 = P64[R1 + 24];
           _sbo9O::I64 = I64[R1 + 32];
           _sbo9R::I64 = I64[R1 + 40];
           _sbo9S::I64 = I64[R1 + 48];
           _sbo9T::I64 = I64[R1 + 56];
           R1 = P64[R1 + 16];
           I64[Sp - 56] = _sbo9O::I64;
           P64[Sp - 48] = _sbo9P::P64;
           I64[Sp - 40] = _sbo9R::I64;
           I64[Sp - 32] = _sbo9S::I64;
           I64[Sp - 24] = _sbo9T::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubp44; else goto cbp3Q;
       ubp44: // global
           call _cbp3P(R1) args: 0, res: 0, upd: 0;
       cbp3Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbp3P() //  [R1]
         { info_tbl: [(cbp3P,
                       label: block_cbp3P_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp3P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbp43; else goto cbp42;
       cbp43: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbp42: // global
           _sbobr::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = _sbobr::I64;
           I64[Hp] = I64[Sp + 40];
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbobV_entry() //  [R1, R2]
         { info_tbl: [(cbp45,
                       label: sat_sbobV_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp45: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cbp46; else goto cbp47;
       cbp46: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbp47: // global
           I64[Sp - 40] = block_cbp1O_info;
           _sbo9k::P64 = P64[R1 + 6];
           _sbo9l::P64 = P64[R1 + 14];
           _sbo9n::P64 = P64[R1 + 22];
           _sbo9p::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 32] = _sbo9k::P64;
           P64[Sp - 24] = _sbo9l::P64;
           P64[Sp - 16] = _sbo9n::P64;
           P64[Sp - 8] = _sbo9p::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubp6Y; else goto cbp1P;
       ubp6Y: // global
           call _cbp1O(R1) args: 0, res: 0, upd: 0;
       cbp1P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp1O() //  [R1]
         { info_tbl: [(cbp1O,
                       label: block_cbp1O_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp1O: // global
           I64[Sp - 64] = block_cbp1T_info;
           _sbo9t::P64 = R1;
           _sbo9u::P64 = P64[R1 + 7];
           _sbo9v::P64 = P64[R1 + 15];
           _sbo9x::P64 = P64[R1 + 31];
           _sbo9z::P64 = P64[R1 + 47];
           _sbo9B::P64 = P64[R1 + 63];
           _sbo9C::P64 = P64[R1 + 71];
           _sbo9F::P64 = P64[R1 + 95];
           R1 = P64[_sbo9C::P64 + 8];
           P64[Sp - 56] = _sbo9u::P64;
           P64[Sp - 48] = _sbo9v::P64;
           P64[Sp - 40] = _sbo9x::P64;
           P64[Sp - 32] = _sbo9z::P64;
           P64[Sp - 24] = _sbo9B::P64;
           P64[Sp - 16] = _sbo9C::P64;
           P64[Sp - 8] = _sbo9F::P64;
           P64[Sp] = _sbo9t::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubp6J; else goto cbp1U;
       ubp6J: // global
           call _cbp1T(R1) args: 0, res: 0, upd: 0;
       cbp1U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp1T() //  [R1]
         { info_tbl: [(cbp1T,
                       label: block_cbp1T_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp1T: // global
           I64[Sp - 40] = block_cbp1Y_info;
           _sbo9P::P64 = P64[R1 + 7];
           _sbo9O::I64 = I64[R1 + 23];
           _sbo9R::I64 = I64[R1 + 31];
           _sbo9S::I64 = I64[R1 + 39];
           _sbo9T::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _sbo9P::P64;
           I64[Sp - 24] = _sbo9R::I64;
           I64[Sp - 16] = _sbo9S::I64;
           I64[Sp - 8] = _sbo9T::I64;
           I64[Sp] = _sbo9O::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubp6K; else goto cbp1Z;
       ubp6K: // global
           call _cbp1Y(R1) args: 0, res: 0, upd: 0;
       cbp1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp1Y() //  [R1]
         { info_tbl: [(cbp1Y,
                       label: block_cbp1Y_info
                       rep:StackRep [False, True, True, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp1Y: // global
           if (R1 & 7 == 1) goto cbp5p; else goto cbp5U;
       cbp5p: // global
           I64[Sp] = block_cbp3g_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto ubp6L; else goto cbp3h;
       ubp6L: // global
           call _cbp3g(R1) args: 0, res: 0, upd: 0;
       cbp3h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbp5U: // global
           _sbobx::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 40] = block_cbp5S_info;
           R1 = _sbobx::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ubp6M; else goto cbp5V;
       ubp6M: // global
           call _cbp5S(R1) args: 0, res: 0, upd: 0;
       cbp5V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp3g() //  [R1]
         { info_tbl: [(cbp3g,
                       label: block_cbp3g_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp3g: // global
           if (R1 & 7 == 2) goto cbp5v; else goto ubp6F;
       cbp5v: // global
           I64[Sp] = block_cbp3m_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto ubp6S; else goto cbp3n;
       ubp6S: // global
           call _cbp3m(R1) args: 0, res: 0, upd: 0;
       cbp3n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubp6F: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _cbp3m() //  [R1]
         { info_tbl: [(cbp3m,
                       label: block_cbp3m_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp3m: // global
           if (R1 & 7 == 1) goto cbp5y; else goto ubp6G;
       cbp5y: // global
           I64[Sp] = block_cbp3r_info;
           R1 = P64[Sp + 136];
           if (R1 & 7 != 0) goto ubp6U; else goto cbp3s;
       ubp6U: // global
           call _cbp3r(R1) args: 0, res: 0, upd: 0;
       cbp3s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubp6G: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _cbp3r() //  [R1]
         { info_tbl: [(cbp3r,
                       label: block_cbp3r_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp3r: // global
           if (I64[R1 + 7] == 1) goto cbp5C; else goto ubp6H;
       cbp5C: // global
           _sbobm::I64 = I64[Sp + 32] - I64[Sp + 24];
           I64[Sp] = block_cbp3C_info;
           R2 = _sbobm::I64;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       ubp6H: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _cbp3C() //  [R1]
         { info_tbl: [(cbp3C,
                       label: block_cbp3C_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp3C: // global
           I64[Sp] = block_cbp3G_info;
           R3 = R1;
           R2 = P64[Sp + 120];
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbp3G() //  [R1]
         { info_tbl: [(cbp3G,
                       label: block_cbp3G_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp3G: // global
           if (R1 == 1) goto cbp5I; else goto ubp6I;
       cbp5I: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbp5L; else goto cbp5K;
       cbp5L: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbp5K: // global
           I64[Hp - 56] = sat_sbobs_info;
           P64[Hp - 40] = P64[Sp + 128];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 32];
           _sbo9C::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sbo9C::P64 + 8] = Hp - 56;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9C::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ubp6I: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _sbo9V() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo9V: // global
           _sbo9Y::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 8] = block_cbp28_info;
           R1 = _sbo9Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubp74; else goto cbp29;
       ubp74: // global
           call _cbp28(R1) args: 0, res: 0, upd: 0;
       cbp29: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp28() //  [R1]
         { info_tbl: [(cbp28,
                       label: block_cbp28_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp28: // global
           I64[Sp] = block_cbp2d_info;
           _sboa4::I64 = I64[R1 + 39];
           _sboa5::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp + 88] = _sboa5::I64;
           I64[Sp + 96] = _sboa4::I64;
           if (R1 & 7 != 0) goto ubp6N; else goto cbp2e;
       ubp6N: // global
           call _cbp2d(R1) args: 0, res: 0, upd: 0;
       cbp2e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp2d() //  [R1]
         { info_tbl: [(cbp2d,
                       label: block_cbp2d_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp2d: // global
           _sbo9t::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto cbp5g; else goto cbp5l;
       cbp5g: // global
           if (I64[Sp + 96] == I64[Sp + 88]) goto cbp5c; else goto cbp4f;
       cbp5c: // global
           I64[Sp] = block_cbp5b_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
       cbp4f: // global
           _sboaa::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbp2l_info;
           R1 = _sboaa::P64;
           if (R1 & 7 != 0) goto ubp6O; else goto cbp2m;
       ubp6O: // global
           call _cbp2l(R1) args: 0, res: 0, upd: 0;
       cbp2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbp5l: // global
           I64[Sp] = block_cbp5j_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbp5b() //  []
         { info_tbl: [(cbp5b,
                       label: block_cbp5b_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp5b: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbp2l() //  [R1]
         { info_tbl: [(cbp2l,
                       label: block_cbp2l_info
                       rep:StackRep [False, True, False, False, True, False, False, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp2l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbp4i; else goto cbp4h;
       cbp4i: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbp4h: // global
           _sbo9C::P64 = P64[Sp + 48];
           _sboac::P64 = P64[R1 + 7];
           _sboad::P64 = P64[R1 + 15];
           _sboag::P64 = P64[_sbo9C::P64 + 8];
           I64[Hp - 16] = sat_sboao_info;
           P64[Hp] = _sboag::P64;
           call MO_WriteBarrier();
           P64[_sbo9C::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9C::P64);
           I64[Sp] = block_cbp2K_info;
           R1 = _sboag::P64;
           P64[Sp + 88] = _sboad::P64;
           P64[Sp + 96] = _sboac::P64;
           if (R1 & 7 != 0) goto ubp6P; else goto cbp2L;
       ubp6P: // global
           call _cbp2K(R1) args: 0, res: 0, upd: 0;
       cbp2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp2K() //  [R1]
         { info_tbl: [(cbp2K,
                       label: block_cbp2K_info
                       rep:StackRep [False, True, False, False, True, True, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp2K: // global
           _sboax::I64 = I64[R1 + 39];
           if (_sboax::I64 != 0) goto cbp4l; else goto cbp57;
       cbp4l: // global
           I64[Sp] = block_cbp2R_info;
           _sboas::P64 = P64[R1 + 7];
           _sboat::P64 = P64[R1 + 15];
           _sboar::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           I64[Sp + 16] = _sboax::I64;
           P64[Sp + 40] = _sboat::P64;
           P64[Sp + 48] = _sboas::P64;
           I64[Sp + 56] = _sboar::I64;
           if (R1 & 7 != 0) goto ubp6Q; else goto cbp2S;
       ubp6Q: // global
           call _cbp2R(R1) args: 0, res: 0, upd: 0;
       cbp2S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbp57: // global
           _sbo9t::P64 = P64[Sp + 64];
           _sbo9z::P64 = P64[Sp + 32];
           _sboad::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = _sboad::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           I64[Sp] = block_cbp56_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbp2R() //  [R1]
         { info_tbl: [(cbp2R,
                       label: block_cbp2R_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp2R: // global
           if (R1 & 7 == 1) goto cbp4r; else goto cbp4T;
       cbp4r: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbp4u; else goto cbp4t;
       cbp4u: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbp4t: // global
           I64[Hp - 24] = sat_sboaH_info;
           P64[Hp - 8] = P64[Sp + 88];
           I64[Hp] = I64[Sp + 16];
           _sbo9t::P64 = P64[Sp + 64];
           _sbo9z::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           I64[Sp] = block_cbp4p_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
       cbp4T: // global
           I64[Sp] = block_cbp4z_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubp6R; else goto cbp4A;
       ubp6R: // global
           call _cbp4z(R1) args: 0, res: 0, upd: 0;
       cbp4A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp4p() //  []
         { info_tbl: [(cbp4p,
                       label: block_cbp4p_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp4p: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbp4z() //  [R1]
         { info_tbl: [(cbp4z,
                       label: block_cbp4z_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp4z: // global
           I64[Sp - 8] = block_cbp4E_info;
           R2 = P64[Sp + 96];
           _sboaO::P64 = P64[R1 + 7];
           _sboaP::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sboaP::P64;
           P64[Sp + 96] = _sboaO::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp4E() //  [R1]
         { info_tbl: [(cbp4E,
                       label: block_cbp4E_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp4E: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbp4X; else goto cbp4W;
       cbp4X: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbp4W: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 48];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sboaP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbp4H_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 96];
           R3 = _sboaP::P64;
           R2 = P64[Sp + 104];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbp4H() //  [R1]
         { info_tbl: [(cbp4H,
                       label: block_cbp4H_info
                       rep:StackRep [False, True, False, False, True, True, True, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp4H: // global
           I64[Sp] = block_cbp4J_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubp6Z; else goto cbp4K;
       ubp6Z: // global
           call _cbp4J(R1) args: 0, res: 0, upd: 0;
       cbp4K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp4J() //  [R1]
         { info_tbl: [(cbp4J,
                       label: block_cbp4J_info
                       rep:StackRep [False, True, False, False, True, True, True, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp4J: // global
           _sbo9t::P64 = P64[Sp + 64];
           _sbo9z::P64 = P64[Sp + 32];
           _sbob1::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = _sbob1::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           I64[Sp] = block_cbp4R_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbp4R() //  []
         { info_tbl: [(cbp4R,
                       label: block_cbp4R_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp4R: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbp56() //  []
         { info_tbl: [(cbp56,
                       label: block_cbp56_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp56: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbp5j() //  []
         { info_tbl: [(cbp5j,
                       label: block_cbp5j_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp5j: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbp5S() //  [R1]
         { info_tbl: [(cbp5S,
                       label: block_cbp5S_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp5S: // global
           I64[Sp] = block_cbp5Z_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubp70; else goto cbp61;
       ubp70: // global
           call _cbp5Z(R1) args: 0, res: 0, upd: 0;
       cbp61: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp5Z() //  [R1]
         { info_tbl: [(cbp5Z,
                       label: block_cbp5Z_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp5Z: // global
           if (R1 & 7 == 1) goto ubp6D; else goto cbp6c;
       ubp6D: // global
           Sp = Sp + 8;
           call _cbp6q() args: 0, res: 0, upd: 0;
       cbp6c: // global
           _sbobI::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp] = block_cbp6a_info;
           R1 = _sbobI::P64;
           if (R1 & 7 != 0) goto ubp71; else goto cbp6d;
       ubp71: // global
           call _cbp6a(R1) args: 0, res: 0, upd: 0;
       cbp6d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp6a() //  [R1]
         { info_tbl: [(cbp6a,
                       label: block_cbp6a_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp6a: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubp6E; else goto cbp6n;
       ubp6E: // global
           Sp = Sp + 8;
           call _cbp6q() args: 0, res: 0, upd: 0;
       cbp6n: // global
           I64[Sp] = block_cbp6l_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbp6q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp6q: // global
           R2 = P64[Sp];
           _sbo9k::P64 = P64[Sp + 64];
           I64[Sp + 64] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 16];
           P64[Sp + 80] = _sbo9k::P64;
           P64[Sp + 88] = _sbo9l::P64;
           Sp = Sp + 64;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbp6l() //  [R1]
         { info_tbl: [(cbp6l,
                       label: block_cbp6l_info
                       rep:StackRep [False, True, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp6l: // global
           _sbo9k::P64 = P64[Sp + 72];
           _sbo9l::P64 = P64[Sp + 80];
           _sbo9u::P64 = P64[Sp + 8];
           _sbo9x::P64 = P64[Sp + 24];
           _sbo9z::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           R2 = _sbo9u::P64;
           I64[Sp + 72] = stg_ap_pppv_info;
           P64[Sp + 80] = _sbo9x::P64;
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSeek1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbp75,
                       label: GHC.IO.Handle.hSeek1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp75: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbp79; else goto cbp78;
       cbp79: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSeek1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbp78: // global
           I64[Hp - 80] = lvl48_sbo9n_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl49_sbo9p_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sbobV_info;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = Hp - 30;
           R3 = R2;
           R2 = lvl13_rbnWV_closure;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.644428138 UTC

[section ""data" . GHC.IO.Handle.hSeek_closure" {
     GHC.IO.Handle.hSeek_closure:
         const GHC.IO.Handle.hSeek_info;
         const 0;
 },
 GHC.IO.Handle.hSeek_entry() //  [R2, R3, R4]
         { info_tbl: [(cbp7e,
                       label: GHC.IO.Handle.hSeek_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp7e: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSeek1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.645531413 UTC

[section ""data" . GHC.IO.Handle.hSetPosn1_closure" {
     GHC.IO.Handle.hSetPosn1_closure:
         const GHC.IO.Handle.hSetPosn1_info;
         const 0;
 },
 GHC.IO.Handle.hSetPosn1_entry() //  [R2]
         { info_tbl: [(cbp7o,
                       label: GHC.IO.Handle.hSetPosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp7o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbp7p; else goto cbp7q;
       cbp7p: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hSetPosn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbp7q: // global
           I64[Sp - 8] = block_cbp7l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubp7u; else goto cbp7m;
       ubp7u: // global
           call _cbp7l(R1) args: 0, res: 0, upd: 0;
       cbp7m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp7l() //  [R1]
         { info_tbl: [(cbp7l,
                       label: block_cbp7l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp7l: // global
           R4 = P64[R1 + 15];
           R3 = GHC.IO.Device.AbsoluteSeek_closure+1;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.hSeek1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.646627724 UTC

[section ""data" . GHC.IO.Handle.hSetPosn_closure" {
     GHC.IO.Handle.hSetPosn_closure:
         const GHC.IO.Handle.hSetPosn_info;
         const 0;
 },
 GHC.IO.Handle.hSetPosn_entry() //  [R2]
         { info_tbl: [(cbp7z,
                       label: GHC.IO.Handle.hSetPosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp7z: // global
           R2 = R2;
           call GHC.IO.Handle.hSetPosn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.647314426 UTC

[section ""cstring" . GHC.IO.Handle.hGetEncoding4_bytes" {
     GHC.IO.Handle.hGetEncoding4_bytes:
         I8[] [104,71,101,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.648049738 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding3_closure" {
     GHC.IO.Handle.hGetEncoding3_closure:
         const GHC.IO.Handle.hGetEncoding3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEncoding3_entry() //  [R1]
         { info_tbl: [(cbp7I,
                       label: GHC.IO.Handle.hGetEncoding3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp7I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbp7J; else goto cbp7K;
       cbp7J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp7K: // global
           (_cbp7F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbp7F::I64 == 0) goto cbp7H; else goto cbp7G;
       cbp7H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbp7G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbp7F::I64;
           R2 = GHC.IO.Handle.hGetEncoding4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.649222178 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding2_closure" {
     GHC.IO.Handle.hGetEncoding2_closure:
         const GHC.IO.Handle.hGetEncoding2_info;
 },
 GHC.IO.Handle.hGetEncoding2_entry() //  [R2]
         { info_tbl: [(cbp7S,
                       label: GHC.IO.Handle.hGetEncoding2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp7S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbp7W; else goto cbp7X;
       cbp7W: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEncoding2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbp7X: // global
           I64[Sp - 8] = block_cbp7P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubp81; else goto cbp7Q;
       ubp81: // global
           call _cbp7P(R1) args: 0, res: 0, upd: 0;
       cbp7Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp7P() //  [R1]
         { info_tbl: [(cbp7P,
                       label: block_cbp7P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp7P: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbp80; else goto cbp7Z;
       cbp80: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbp7Z: // global
           _sbocg::P64 = P64[R1 + 103];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sbocg::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.651413724 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding1_closure" {
     GHC.IO.Handle.hGetEncoding1_closure:
         const GHC.IO.Handle.hGetEncoding1_info;
         const 0;
 },
 io_sboct_entry() //  [R1]
         { info_tbl: [(cbp8n,
                       label: io_sboct_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbp8r; else goto cbp8s;
       cbp8r: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbp8s: // global
           I64[Sp - 16] = block_cbp8i_info;
           _sbocp::P64 = P64[R1 + 15];
           R5 = _sbocp::P64;
           R4 = GHC.IO.Handle.hGetEncoding2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEncoding3_closure;
           P64[Sp - 8] = _sbocp::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbp8i() //  [R1]
         { info_tbl: [(cbp8i,
                       label: block_cbp8i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8i: // global
           I64[Sp] = block_cbp8k_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubp8x; else goto cbp8l;
       ubp8x: // global
           call _cbp8k(R1) args: 0, res: 0, upd: 0;
       cbp8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp8k() //  [R1]
         { info_tbl: [(cbp8k,
                       label: block_cbp8k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8k: // global
           I64[Sp] = block_cbp8q_info;
           R2 = P64[R1 + 7];
           _sbocA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbocA::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp8q() //  []
         { info_tbl: [(cbp8q,
                       label: block_cbp8q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbocJ_entry() //  [R1]
         { info_tbl: [(cbp8M,
                       label: io_sbocJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbp8Q; else goto cbp8R;
       cbp8Q: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbp8R: // global
           I64[Sp - 16] = block_cbp8H_info;
           _sbocE::P64 = P64[R1 + 15];
           R5 = _sbocE::P64;
           R4 = GHC.IO.Handle.hGetEncoding2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEncoding3_closure;
           P64[Sp - 8] = _sbocE::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbp8H() //  [R1]
         { info_tbl: [(cbp8H,
                       label: block_cbp8H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8H: // global
           I64[Sp] = block_cbp8J_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubp8W; else goto cbp8K;
       ubp8W: // global
           call _cbp8J(R1) args: 0, res: 0, upd: 0;
       cbp8K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp8J() //  [R1]
         { info_tbl: [(cbp8J,
                       label: block_cbp8J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8J: // global
           I64[Sp] = block_cbp8P_info;
           R2 = P64[R1 + 7];
           _sbocQ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbocQ::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp8P() //  []
         { info_tbl: [(cbp8P,
                       label: block_cbp8P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8P: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hGetEncoding1_entry() //  [R2]
         { info_tbl: [(cbp91,
                       label: GHC.IO.Handle.hGetEncoding1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp91: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbp92; else goto cbp93;
       cbp92: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEncoding1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbp93: // global
           I64[Sp - 8] = block_cbp86_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubp9k; else goto cbp87;
       ubp9k: // global
           call _cbp86(R1) args: 0, res: 0, upd: 0;
       cbp87: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp86() //  [R1]
         { info_tbl: [(cbp86,
                       label: block_cbp86_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp86: // global
           if (R1 & 7 == 1) goto cbp8Y; else goto cbp8Z;
       cbp8Y: // global
           I64[Sp - 16] = block_cbp8b_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbp8Z: // global
           I64[Sp - 16] = block_cbp8A_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbp8b() //  [R1]
         { info_tbl: [(cbp8b,
                       label: block_cbp8b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbp97; else goto cbp96;
       cbp97: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbp96: // global
           I64[Hp - 16] = io_sboct_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbp8d::P64 = Hp - 15;
           if (R1 == 0) goto cbp9b; else goto cbp9a;
       cbp9b: // global
           R1 = _cbp8d::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbp9a: // global
           R1 = _cbp8d::P64;
           Sp = Sp + 24;
           call io_sboct_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbp8A() //  [R1]
         { info_tbl: [(cbp8A,
                       label: block_cbp8A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp8A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbp9f; else goto cbp9e;
       cbp9f: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbp9e: // global
           I64[Hp - 16] = io_sbocJ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbp8C::P64 = Hp - 15;
           if (R1 == 0) goto cbp9j; else goto cbp9i;
       cbp9j: // global
           R1 = _cbp8C::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbp9i: // global
           R1 = _cbp8C::P64;
           Sp = Sp + 24;
           call io_sbocJ_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.654586818 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding_closure" {
     GHC.IO.Handle.hGetEncoding_closure:
         const GHC.IO.Handle.hGetEncoding_info;
         const 0;
 },
 GHC.IO.Handle.hGetEncoding_entry() //  [R2]
         { info_tbl: [(cbp9p,
                       label: GHC.IO.Handle.hGetEncoding_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp9p: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.6553111 UTC

[section ""cstring" . lvl15_rbnWX_bytes" {
     lvl15_rbnWX_bytes:
         I8[] [104,83,101,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.65600869 UTC

[section ""data" . lvl16_rbnWY_closure" {
     lvl16_rbnWY_closure:
         const lvl16_rbnWY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_rbnWY_entry() //  [R1]
         { info_tbl: [(cbp9y,
                       label: lvl16_rbnWY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp9y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbp9z; else goto cbp9A;
       cbp9z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp9A: // global
           (_cbp9v::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbp9v::I64 == 0) goto cbp9x; else goto cbp9w;
       cbp9x: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbp9w: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbp9v::I64;
           R2 = lvl15_rbnWX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.656839547 UTC

[section ""cstring" . lvl17_rbnWZ_bytes" {
     lvl17_rbnWZ_bytes:
         I8[] [108,97,115,116,95,100,101,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.657650932 UTC

[section ""data" . lvl18_rbnX0_closure" {
     lvl18_rbnX0_closure:
         const lvl18_rbnX0_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rbnX0_entry() //  [R1]
         { info_tbl: [(cbp9J,
                       label: lvl18_rbnX0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp9J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbp9K; else goto cbp9L;
       cbp9K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbp9L: // global
           (_cbp9E::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbp9E::I64 == 0) goto cbp9G; else goto cbp9F;
       cbp9G: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbp9F: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbp9E::I64;
           I64[Sp - 24] = block_cbp9H_info;
           R2 = lvl17_rbnWZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbp9H() //  [R1]
         { info_tbl: [(cbp9H,
                       label: block_cbp9H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp9H: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.66432283 UTC

[section ""data" . GHC.IO.Handle.hSetEncoding1_closure" {
     GHC.IO.Handle.hSetEncoding1_closure:
         const GHC.IO.Handle.hSetEncoding1_info;
         const 0;
 },
 sat_sbofq_entry() //  [R1]
         { info_tbl: [(cbpaF,
                       label: sat_sbofq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpaF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpaJ; else goto cbpaK;
       cbpaJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpaK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbpaC_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpaO; else goto cbpaD;
       ubpaO: // global
           call _cbpaC(R1) args: 0, res: 0, upd: 0;
       cbpaD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpaC() //  [R1]
         { info_tbl: [(cbpaC,
                       label: block_cbpaC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpaC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbpaN; else goto cbpaM;
       cbpaN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbpaM: // global
           _sbofl::P64 = P64[R1 + 7];
           _sbofm::P64 = P64[R1 + 15];
           _sbofk::I64 = I64[R1 + 23];
           _sbofn::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbofl::P64;
           P64[Hp - 32] = _sbofm::P64;
           I64[Hp - 24] = _sbofk::I64;
           I64[Hp - 16] = _sbofn::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbofJ_entry() //  [R1]
         { info_tbl: [(cbpbb,
                       label: sat_sbofJ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpbb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbpbi; else goto cbpbj;
       cbpbi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpbj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbpb8_info;
           _sbofz::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbofz::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubpbn; else goto cbpb9;
       ubpbn: // global
           call _cbpb8(R1) args: 0, res: 0, upd: 0;
       cbpb9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpb8() //  [R1]
         { info_tbl: [(cbpb8,
                       label: block_cbpb8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpb8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbpbm; else goto cbpbl;
       cbpbm: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbpbl: // global
           _sbofD::P64 = P64[R1 + 7];
           _sbofE::P64 = P64[R1 + 15];
           _sbofC::I64 = I64[R1 + 23];
           _sbofF::I64 = I64[R1 + 31];
           _sbofH::I64 = I64[R1 + 47];
           _sbofI::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbofD::P64;
           P64[Hp - 32] = _sbofE::P64;
           I64[Hp - 24] = _sbofC::I64;
           I64[Hp - 16] = _sbofF::I64;
           I64[Hp - 8] = _sbofI::I64;
           I64[Hp] = _sbofH::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbog6_entry() //  [R1, R2]
         { info_tbl: [(cbpbo,
                       label: sat_sbog6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpbo: // global
           if ((Sp + -192) < SpLim) (likely: False) goto cbpbp; else goto cbpbq;
       cbpbp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpbq: // global
           I64[Sp - 24] = block_cbp9Z_info;
           _sbocV::P64 = P64[R1 + 6];
           _sbocX::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbocV::P64;
           P64[Sp - 8] = _sbocX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpfV; else goto cbpa0;
       ubpfV: // global
           call _cbp9Z(R1) args: 0, res: 0, upd: 0;
       cbpa0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbp9Z() //  [R1]
         { info_tbl: [(cbp9Z,
                       label: block_cbp9Z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbp9Z: // global
           I64[Sp - 120] = block_cbpa4_info;
           _sbod1::P64 = P64[R1 + 7];
           _sbod2::P64 = P64[R1 + 15];
           _sbod3::P64 = P64[R1 + 23];
           _sbod4::P64 = P64[R1 + 31];
           _sbod5::P64 = P64[R1 + 39];
           _sbod6::P64 = P64[R1 + 47];
           _sbod7::P64 = P64[R1 + 55];
           _sbod8::P64 = P64[R1 + 63];
           _sbod9::P64 = P64[R1 + 71];
           _sboda::P64 = P64[R1 + 79];
           _sbodb::P64 = P64[R1 + 87];
           _sbodc::P64 = P64[R1 + 95];
           _sbode::P64 = P64[R1 + 111];
           _sbodf::P64 = P64[R1 + 119];
           _sbodg::P64 = P64[R1 + 127];
           R1 = P64[_sbod9::P64 + 8];
           P64[Sp - 112] = _sbod2::P64;
           P64[Sp - 104] = _sbod3::P64;
           P64[Sp - 96] = _sbod4::P64;
           P64[Sp - 88] = _sbod5::P64;
           P64[Sp - 80] = _sbod6::P64;
           P64[Sp - 72] = _sbod7::P64;
           P64[Sp - 64] = _sbod8::P64;
           P64[Sp - 56] = _sbod9::P64;
           P64[Sp - 48] = _sboda::P64;
           P64[Sp - 40] = _sbodb::P64;
           P64[Sp - 32] = _sbodc::P64;
           P64[Sp - 24] = _sbode::P64;
           P64[Sp - 16] = _sbodf::P64;
           P64[Sp - 8] = _sbodg::P64;
           P64[Sp] = _sbod1::P64;
           Sp = Sp - 120;
           if (R1 & 7 != 0) goto ubpfI; else goto cbpa5;
       ubpfI: // global
           call _cbpa4(R1) args: 0, res: 0, upd: 0;
       cbpa5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpa4() //  [R1]
         { info_tbl: [(cbpa4,
                       label: block_cbpa4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpa4: // global
           I64[Sp - 16] = block_cbpab_info;
           _sbodp::I64 = I64[R1 + 39];
           _sbodq::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbodq::I64;
           I64[Sp] = _sbodp::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpfJ; else goto cbpac;
       ubpfJ: // global
           call _cbpab(R1) args: 0, res: 0, upd: 0;
       cbpac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpab() //  [R1]
         { info_tbl: [(cbpab,
                       label: block_cbpab_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpab: // global
           if (R1 & 7 == 1) goto cbpec; else goto cbpf7;
       cbpec: // global
           _sbof0::P64 = P64[P64[Sp + 80] + 8];
           I64[Sp + 16] = block_cbpag_info;
           R1 = _sbof0::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubpfK; else goto cbpah;
       ubpfK: // global
           call _cbpag(R1) args: 0, res: 0, upd: 0;
       cbpah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpf7: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubpfv; else goto cbpf5;
       ubpfv: // global
           Sp = Sp + 24;
           call _sbodr() args: 0, res: 0, upd: 0;
       cbpf5: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 160;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpag() //  [R1]
         { info_tbl: [(cbpag,
                       label: block_cbpag_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpag: // global
           I64[Sp - 16] = block_cbpal_info;
           _sbof6::I64 = I64[R1 + 39];
           _sbof7::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbof7::I64;
           I64[Sp] = _sbof6::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpfM; else goto cbpam;
       ubpfM: // global
           call _cbpal(R1) args: 0, res: 0, upd: 0;
       cbpam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpal() //  [R1]
         { info_tbl: [(cbpal,
                       label: block_cbpal_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpal: // global
           if (R1 & 7 == 1) goto cbpeU; else goto ubpfw;
       cbpeU: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubpfx; else goto cbpeg;
       ubpfx: // global
           Sp = Sp + 24;
           goto ubpfP;
       cbpeg: // global
           _sbofc::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cbpat_info;
           R1 = _sbofc::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubpfN; else goto cbpau;
       ubpfN: // global
           call _cbpat(R1) args: 0, res: 0, upd: 0;
       cbpau: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubpfw: // global
           Sp = Sp + 24;
           goto ubpfP;
       ubpfP: // global
           call _sbodr() args: 0, res: 0, upd: 0;
     }
 },
 _cbpat() //  [R1]
         { info_tbl: [(cbpat,
                       label: block_cbpat_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpat: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpej; else goto cbpei;
       cbpej: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpei: // global
           _sbod9::P64 = P64[Sp + 64];
           _sbofe::P64 = P64[R1 + 7];
           _sboff::P64 = P64[R1 + 15];
           _sbofi::P64 = P64[_sbod9::P64 + 8];
           I64[Hp - 16] = sat_sbofq_info;
           P64[Hp] = _sbofi::P64;
           call MO_WriteBarrier();
           P64[_sbod9::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod9::P64);
           I64[Sp - 8] = block_cbpaS_info;
           R1 = _sbofi::P64;
           P64[Sp] = _sboff::P64;
           P64[Sp + 56] = _sbofe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpfQ; else goto cbpaT;
       ubpfQ: // global
           call _cbpaS(R1) args: 0, res: 0, upd: 0;
       cbpaT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpaS() //  [R1]
         { info_tbl: [(cbpaS,
                       label: block_cbpaS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpaS: // global
           _sbofz::I64 = I64[R1 + 39];
           if (_sbofz::I64 != 0) goto cbpem; else goto cbpeR;
       cbpem: // global
           I64[Sp - 32] = block_cbpaZ_info;
           _sbofu::P64 = P64[R1 + 7];
           _sbofv::P64 = P64[R1 + 15];
           _sboft::I64 = I64[R1 + 23];
           R1 = P64[Sp + 96];
           P64[Sp - 24] = _sbofu::P64;
           P64[Sp - 16] = _sbofv::P64;
           I64[Sp - 8] = _sbofz::I64;
           I64[Sp] = _sboft::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubpfR; else goto cbpb0;
       ubpfR: // global
           call _cbpaZ(R1) args: 0, res: 0, upd: 0;
       cbpb0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpeR: // global
           _sbod6::P64 = P64[Sp + 48];
           _sboff::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbod6::P64 + 8] = _sboff::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod6::P64);
           Sp = Sp + 16;
           call _sbodr() args: 0, res: 0, upd: 0;
     }
 },
 _cbpaZ() //  [R1]
         { info_tbl: [(cbpaZ,
                       label: block_cbpaZ_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpaZ: // global
           if (R1 & 7 == 1) goto cbpeo; else goto cbpeG;
       cbpeo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbper; else goto cbpeq;
       cbper: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpeq: // global
           I64[Hp - 24] = sat_sbofJ_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 24];
           _sbod6::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sbod6::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod6::P64);
           Sp = Sp + 48;
           call _sbodr() args: 0, res: 0, upd: 0;
       cbpeG: // global
           I64[Sp] = block_cbpeu_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubpfT; else goto cbpev;
       ubpfT: // global
           call _cbpeu(R1) args: 0, res: 0, upd: 0;
       cbpev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpeu() //  [R1]
         { info_tbl: [(cbpeu,
                       label: block_cbpeu_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpeu: // global
           I64[Sp - 8] = block_cbpez_info;
           R2 = P64[Sp + 96];
           _sbofN::P64 = P64[R1 + 7];
           _sbofO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbofO::P64;
           P64[Sp + 96] = _sbofN::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpez() //  [R1]
         { info_tbl: [(cbpez,
                       label: block_cbpez_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpez: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbpeK; else goto cbpeJ;
       cbpeK: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpeJ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sboff::P64 = P64[Sp + 48];
           I64[Sp + 48] = block_cbpeC_info;
           R5 = Hp - 47;
           R4 = _sboff::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 104];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpeC() //  [R1]
         { info_tbl: [(cbpeC,
                       label: block_cbpeC_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpeC: // global
           I64[Sp] = block_cbpeE_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpg9; else goto cbpeM;
       ubpg9: // global
           call _cbpeE(R1) args: 0, res: 0, upd: 0;
       cbpeM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpeE() //  [R1]
         { info_tbl: [(cbpeE,
                       label: block_cbpeE_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpeE: // global
           _sbod6::P64 = P64[Sp + 40];
           _sbog0::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbod6::P64 + 8] = _sbog0::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod6::P64);
           Sp = Sp + 8;
           call _sbodr() args: 0, res: 0, upd: 0;
     }
 },
 _sbodr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbodr: // global
           I64[Sp - 8] = block_cbpby_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpgb; else goto cbpda;
       ubpgb: // global
           call _cbpby(R1) args: 0, res: 0, upd: 0;
       cbpda: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpby() //  [R1]
         { info_tbl: [(cbpby,
                       label: block_cbpby_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpby: // global
           if (R1 & 7 == 1) goto cbpdh; else goto cbpdG;
       cbpdh: // global
           I64[Sp] = block_cbpde_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubpfW; else goto cbpdi;
       ubpfW: // global
           call _cbpde(R1) args: 0, res: 0, upd: 0;
       cbpdi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpdG: // global
           I64[Sp] = block_cbpdE_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubpfX; else goto cbpdH;
       ubpfX: // global
           call _cbpdE(R1) args: 0, res: 0, upd: 0;
       cbpdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpde() //  [R1]
         { info_tbl: [(cbpde,
                       label: block_cbpde_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpde: // global
           if (R1 & 7 == 1) goto ubpfD; else goto cbpdy;
       ubpfD: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
       cbpdy: // global
           I64[Sp] = block_cbpdr_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubpg2; else goto cbpds;
       ubpg2: // global
           call _cbpdr(R1) args: 0, res: 0, upd: 0;
       cbpds: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpdr() //  [R1]
         { info_tbl: [(cbpdr,
                       label: block_cbpdr_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpdr: // global
           I64[Sp] = block_cbpdw_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpdw() //  []
         { info_tbl: [(cbpdw,
                       label: block_cbpdw_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpdw: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
     }
 },
 _cbpdE() //  [R1]
         { info_tbl: [(cbpdE,
                       label: block_cbpdE_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpdE: // global
           I64[Sp] = block_cbpdL_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpdL() //  []
         { info_tbl: [(cbpdL,
                       label: block_cbpdL_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpdL: // global
           I64[Sp] = block_cbpdN_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubpg5; else goto cbpdQ;
       ubpg5: // global
           call _cbpdN(R1) args: 0, res: 0, upd: 0;
       cbpdQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpdN() //  [R1]
         { info_tbl: [(cbpdN,
                       label: block_cbpdN_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpdN: // global
           if (R1 & 7 == 1) goto ubpfB; else goto cbpe6;
       ubpfB: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
       cbpe6: // global
           I64[Sp] = block_cbpdZ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubpg6; else goto cbpe0;
       ubpg6: // global
           call _cbpdZ(R1) args: 0, res: 0, upd: 0;
       cbpe0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpdZ() //  [R1]
         { info_tbl: [(cbpdZ,
                       label: block_cbpdZ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpdZ: // global
           I64[Sp] = block_cbpe4_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpe4() //  []
         { info_tbl: [(cbpe4,
                       label: block_cbpe4_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpe4: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
     }
 },
 _sbodt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbodt: // global
           I64[Sp - 8] = block_cbpbD_info;
           R1 = P64[Sp + 120];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpgc; else goto cbpbF;
       ubpgc: // global
           call _cbpbD(R1) args: 0, res: 0, upd: 0;
       cbpbF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpbD() //  [R1]
         { info_tbl: [(cbpbD,
                       label: block_cbpbD_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpbD: // global
           I64[Sp] = block_cbpbL_info;
           _sbodx::P64 = P64[R1 + 15];
           _sbody::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp + 88] = _sbody::P64;
           P64[Sp + 128] = _sbodx::P64;
           if (R1 & 7 != 0) goto ubpfY; else goto cbpcL;
       ubpfY: // global
           call _cbpbL(R1) args: 0, res: 0, upd: 0;
       cbpcL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpbL() //  [R1]
         { info_tbl: [(cbpbL,
                       label: block_cbpbL_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpbL: // global
           _sbodx::P64 = P64[Sp + 128];
           _cbpfo::P64 = R1 & 7;
           if (_cbpfo::P64 != 3) goto ubpfs; else goto cbpcW;
       ubpfs: // global
           if (_cbpfo::P64 != 6) goto cbpcR; else goto cbpd5;
       cbpcR: // global
           P64[Sp + 128] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbodz() args: 0, res: 0, upd: 0;
       cbpd5: // global
           I64[Sp] = block_cbpd3_info;
           R1 = _sbodx::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbpcW: // global
           I64[Sp] = block_cbpcU_info;
           R1 = _sbodx::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpd3() //  [R1]
         { info_tbl: [(cbpd3,
                       label: block_cbpd3_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpd3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbpd9; else goto cbpd8;
       cbpd9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpd8: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 128] = Hp - 6;
           Sp = Sp + 8;
           call _sbodz() args: 0, res: 0, upd: 0;
     }
 },
 _cbpcU() //  [R1]
         { info_tbl: [(cbpcU,
                       label: block_cbpcU_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpcU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbpd0; else goto cbpcZ;
       cbpd0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpcZ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 128] = Hp - 6;
           Sp = Sp + 8;
           call _sbodz() args: 0, res: 0, upd: 0;
     }
 },
 _sbodz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbodz: // global
           I64[Sp - 8] = block_cbpbQ_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpgd; else goto cbpbS;
       ubpgd: // global
           call _cbpbQ(R1) args: 0, res: 0, upd: 0;
       cbpbS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpbQ() //  [R1]
         { info_tbl: [(cbpbQ,
                       label: block_cbpbQ_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpbQ: // global
           _sbody::P64 = P64[Sp + 88];
           _cbpfr::P64 = R1 & 7;
           if (_cbpfr::P64 < 5) goto ubpft; else goto ubpfu;
       ubpft: // global
           if (_cbpfr::P64 < 4) goto cbpc1; else goto cbpce;
       cbpc1: // global
           I64[Sp] = block_cbpbW_info;
           _sbodC::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbodC::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbpce: // global
           I64[Sp] = block_cbpc7_info;
           R1 = _sbody::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ubpfu: // global
           if (_cbpfr::P64 < 6) goto cbpcs; else goto cbpcG;
       cbpcs: // global
           I64[Sp] = block_cbpcl_info;
           R1 = _sbody::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbpcG: // global
           I64[Sp] = block_cbpcz_info;
           R1 = _sbody::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpbW() //  [R1]
         { info_tbl: [(cbpbW,
                       label: block_cbpbW_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpbW: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbpc4; else goto cbpc3;
       cbpc4: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpc3: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 88];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpc7() //  [R1]
         { info_tbl: [(cbpc7,
                       label: block_cbpc7_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpc7: // global
           I64[Sp] = block_cbpc9_info;
           _sbodM::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbodM::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpc9() //  [R1]
         { info_tbl: [(cbpc9,
                       label: block_cbpc9_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpc9: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbpci; else goto cbpch;
       cbpci: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpch: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpcl() //  [R1]
         { info_tbl: [(cbpcl,
                       label: block_cbpcl_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpcl: // global
           I64[Sp] = block_cbpcn_info;
           _sbodX::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbodX::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpcn() //  [R1]
         { info_tbl: [(cbpcn,
                       label: block_cbpcn_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpcn: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbpcw; else goto cbpcv;
       cbpcw: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpcv: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.AppendHandle_closure+5;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpcz() //  [R1]
         { info_tbl: [(cbpcz,
                       label: block_cbpcz_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpcz: // global
           I64[Sp] = block_cbpcB_info;
           _sboe8::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sboe8::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpcB() //  [R1]
         { info_tbl: [(cbpcB,
                       label: block_cbpcB_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpcB: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbpcK; else goto cbpcJ;
       cbpcK: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpcJ: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetEncoding1_entry() //  [R2, R3]
         { info_tbl: [(cbpge,
                       label: GHC.IO.Handle.hSetEncoding1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpge: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbpgi; else goto cbpgh;
       cbpgi: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetEncoding1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbpgh: // global
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbog6_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 30;
           R4 = Hp - 14;
           R3 = R2;
           R2 = lvl16_rbnWY_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.677443676 UTC

[section ""data" . GHC.IO.Handle.hSetEncoding_closure" {
     GHC.IO.Handle.hSetEncoding_closure:
         const GHC.IO.Handle.hSetEncoding_info;
         const 0;
 },
 GHC.IO.Handle.hSetEncoding_entry() //  [R2, R3]
         { info_tbl: [(cbpgn,
                       label: GHC.IO.Handle.hSetEncoding_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpgn: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetEncoding1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.678189509 UTC

[section ""cstring" . GHC.IO.Handle.hSetBuffering3_bytes" {
     GHC.IO.Handle.hSetBuffering3_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.678934705 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering2_closure" {
     GHC.IO.Handle.hSetBuffering2_closure:
         const GHC.IO.Handle.hSetBuffering2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetBuffering2_entry() //  [R1]
         { info_tbl: [(cbpgw,
                       label: GHC.IO.Handle.hSetBuffering2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpgw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpgx; else goto cbpgy;
       cbpgx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpgy: // global
           (_cbpgt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpgt::I64 == 0) goto cbpgv; else goto cbpgu;
       cbpgv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpgu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpgt::I64;
           R2 = GHC.IO.Handle.hSetBuffering3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.684017749 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering1_closure" {
     GHC.IO.Handle.hSetBuffering1_closure:
         const GHC.IO.Handle.hSetBuffering1_info;
         const 0;
 },
 sat_sbohh_entry() //  [R1, R2]
         { info_tbl: [(cbpgL,
                       label: sat_sbohh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpgL: // global
           if ((Sp + -176) < SpLim) (likely: False) goto cbpgM; else goto cbpgN;
       cbpgM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpgN: // global
           I64[Sp - 16] = block_cbpgI_info;
           _sbog8::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbog8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubplf; else goto cbpgJ;
       ubplf: // global
           call _cbpgI(R1) args: 0, res: 0, upd: 0;
       cbpgJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpgI() //  [R1]
         { info_tbl: [(cbpgI,
                       label: block_cbpgI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpgI: // global
           I64[Sp - 128] = block_cbpgQ_info;
           _sbogc::P64 = R1;
           _sbogd::P64 = P64[R1 + 7];
           _sboge::P64 = P64[R1 + 15];
           _sbogf::P64 = P64[R1 + 23];
           _sbogg::P64 = P64[R1 + 31];
           _sbogi::P64 = P64[R1 + 47];
           _sbogj::P64 = P64[R1 + 55];
           _sbogk::P64 = P64[R1 + 63];
           _sbogl::P64 = P64[R1 + 71];
           _sbogm::P64 = P64[R1 + 79];
           _sbogn::P64 = P64[R1 + 87];
           _sbogo::P64 = P64[R1 + 95];
           _sbogp::P64 = P64[R1 + 103];
           _sbogq::P64 = P64[R1 + 111];
           _sbogr::P64 = P64[R1 + 119];
           _sbogs::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sbogd::P64;
           P64[Sp - 112] = _sboge::P64;
           P64[Sp - 104] = _sbogf::P64;
           P64[Sp - 96] = _sbogg::P64;
           P64[Sp - 88] = _sbogi::P64;
           P64[Sp - 80] = _sbogj::P64;
           P64[Sp - 72] = _sbogk::P64;
           P64[Sp - 64] = _sbogl::P64;
           P64[Sp - 56] = _sbogm::P64;
           P64[Sp - 48] = _sbogn::P64;
           P64[Sp - 40] = _sbogo::P64;
           P64[Sp - 32] = _sbogp::P64;
           P64[Sp - 24] = _sbogq::P64;
           P64[Sp - 16] = _sbogr::P64;
           P64[Sp - 8] = _sbogs::P64;
           P64[Sp] = _sbogc::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto ubple; else goto cbpgS;
       ubple: // global
           call _cbpgQ(R1) args: 0, res: 0, upd: 0;
       cbpgS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpgQ() //  [R1]
         { info_tbl: [(cbpgQ,
                       label: block_cbpgQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpgQ: // global
           if (R1 & 7 == 1) goto cbpkL; else goto cbpj1;
       cbpkL: // global
           Sp = Sp + 144;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbpj1: // global
           I64[Sp - 8] = block_cbpgY_info;
           _sbogt::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp] = _sbogt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubplg; else goto cbpj2;
       ubplg: // global
           call _cbpgY(R1) args: 0, res: 0, upd: 0;
       cbpj2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpgY() //  [R1]
         { info_tbl: [(cbpgY,
                       label: block_cbpgY_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpgY: // global
           _sbogj::P64 = P64[Sp + 56];
           _cbpkN::P64 = R1 & 7;
           if (_cbpkN::P64 < 3) goto ubpkZ; else goto cbpjF;
       ubpkZ: // global
           if (_cbpkN::P64 < 2) goto cbpj9; else goto cbpjp;
       cbpj9: // global
           I64[Sp] = block_cbpj6_info;
           R1 = _sbogj::P64;
           if (R1 & 7 != 0) goto ubplh; else goto cbpja;
       ubplh: // global
           call _cbpj6(R1) args: 0, res: 0, upd: 0;
       cbpja: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpjp: // global
           I64[Sp] = block_cbpjn_info;
           R1 = _sbogj::P64;
           if (R1 & 7 != 0) goto ubpli; else goto cbpjq;
       ubpli: // global
           call _cbpjn(R1) args: 0, res: 0, upd: 0;
       cbpjq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpjF: // global
           I64[Sp] = block_cbpjD_info;
           _sboh3::P64 = P64[R1 + 5];
           R1 = _sbogj::P64;
           P64[Sp + 56] = _sboh3::P64;
           if (R1 & 7 != 0) goto ubplj; else goto cbpjG;
       ubplj: // global
           call _cbpjD(R1) args: 0, res: 0, upd: 0;
       cbpjG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpj6() //  [R1]
         { info_tbl: [(cbpj6,
                       label: block_cbpj6_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpj6: // global
           if (R1 & 7 == 1) goto ubpl1; else goto ubpl2;
       ubpl1: // global
           Sp = Sp + 136;
           call _cbpkH() args: 0, res: 0, upd: 0;
       ubpl2: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbpjn() //  [R1]
         { info_tbl: [(cbpjn,
                       label: block_cbpjn_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpjn: // global
           if (R1 & 7 == 2) goto ubpl3; else goto ubpl4;
       ubpl3: // global
           Sp = Sp + 136;
           call _cbpkH() args: 0, res: 0, upd: 0;
       ubpl4: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbpjD() //  [R1]
         { info_tbl: [(cbpjD,
                       label: block_cbpjD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpjD: // global
           if (R1 & 7 == 3) goto cbpjR; else goto ubpl5;
       cbpjR: // global
           I64[Sp] = block_cbpjP_info;
           _sboh5::P64 = P64[R1 + 5];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _sboh5::P64;
           if (R1 & 7 != 0) goto ubplw; else goto cbpjS;
       ubplw: // global
           call _cbpjP(R1) args: 0, res: 0, upd: 0;
       cbpjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubpl5: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbpjP() //  [R1]
         { info_tbl: [(cbpjP,
                       label: block_cbpjP_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpjP: // global
           _sboh5::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cbpjZ; else goto cbpkf;
       cbpjZ: // global
           I64[Sp] = block_cbpjW_info;
           R1 = _sboh5::P64;
           if (R1 & 7 != 0) goto ubply; else goto cbpk0;
       ubply: // global
           call _cbpjW(R1) args: 0, res: 0, upd: 0;
       cbpk0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpkf: // global
           I64[Sp] = block_cbpkd_info;
           _sboh9::P64 = P64[R1 + 6];
           R1 = _sboh5::P64;
           P64[Sp + 56] = _sboh9::P64;
           if (R1 & 7 != 0) goto ubplz; else goto cbpkg;
       ubplz: // global
           call _cbpkd(R1) args: 0, res: 0, upd: 0;
       cbpkg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpjW() //  [R1]
         { info_tbl: [(cbpjW,
                       label: block_cbpjW_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpjW: // global
           if (R1 & 7 == 1) goto ubpl9; else goto ubpla;
       ubpl9: // global
           Sp = Sp + 136;
           call _cbpkH() args: 0, res: 0, upd: 0;
       ubpla: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbpkd() //  [R1]
         { info_tbl: [(cbpkd,
                       label: block_cbpkd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpkd: // global
           if (R1 & 7 == 1) goto ubpl6; else goto cbpkw;
       ubpl6: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
       cbpkw: // global
           I64[Sp] = block_cbpkp_info;
           _sbohb::P64 = P64[R1 + 6];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _sbohb::P64;
           if (R1 & 7 != 0) goto ubplC; else goto cbpkq;
       ubplC: // global
           call _cbpkp(R1) args: 0, res: 0, upd: 0;
       cbpkq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpkp() //  [R1]
         { info_tbl: [(cbpkp,
                       label: block_cbpkp_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpkp: // global
           I64[Sp] = block_cbpku_info;
           _sbohd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp + 56] = _sbohd::I64;
           if (R1 & 7 != 0) goto ubplE; else goto cbpky;
       ubplE: // global
           call _cbpku(R1) args: 0, res: 0, upd: 0;
       cbpky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpku() //  [R1]
         { info_tbl: [(cbpku,
                       label: block_cbpku_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpku: // global
           if (I64[Sp + 56] == I64[R1 + 7]) goto ubpl7; else goto ubpl8;
       ubpl7: // global
           Sp = Sp + 136;
           call _cbpkH() args: 0, res: 0, upd: 0;
       ubpl8: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbpkH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpkH: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _sbogu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbogu: // global
           I64[Sp - 8] = block_cbph5_info;
           R1 = P64[Sp + 136];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubplH; else goto cbpis;
       ubplH: // global
           call _cbph5(R1) args: 0, res: 0, upd: 0;
       cbpis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbph5() //  [R1]
         { info_tbl: [(cbph5,
                       label: block_cbph5_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbph5: // global
           if (R1 & 7 == 3) goto cbpiD; else goto ubplb;
       cbpiD: // global
           I64[Sp] = block_cbpiB_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto ubplk; else goto cbpiE;
       ubplk: // global
           call _cbpiB(R1) args: 0, res: 0, upd: 0;
       cbpiE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubplb: // global
           Sp = Sp + 8;
           call _sbogv() args: 0, res: 0, upd: 0;
     }
 },
 _cbpiB() //  [R1]
         { info_tbl: [(cbpiB,
                       label: block_cbpiB_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpiB: // global
           if (R1 & 7 == 1) goto ubplc; else goto cbpiP;
       ubplc: // global
           Sp = Sp + 8;
           call _sbogv() args: 0, res: 0, upd: 0;
       cbpiP: // global
           I64[Sp] = block_cbpiN_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubplp; else goto cbpiQ;
       ubplp: // global
           call _cbpiN(R1) args: 0, res: 0, upd: 0;
       cbpiQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpiN() //  [R1]
         { info_tbl: [(cbpiN,
                       label: block_cbpiN_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpiN: // global
           _sbogX::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sbogX::I64, 0)) goto ubpld; else goto cbpiZ;
       ubpld: // global
           Sp = Sp + 8;
           call _sbogv() args: 0, res: 0, upd: 0;
       cbpiZ: // global
           R2 = _sbogX::I64;
           Sp = Sp + 152;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _sbogv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbogv: // global
           I64[Sp - 8] = block_cbpha_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbpha() //  [R1]
         { info_tbl: [(cbpha,
                       label: block_cbpha_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpha: // global
           I64[Sp] = block_cbphc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubplm; else goto cbphf;
       ubplm: // global
           call _cbphc(R1) args: 0, res: 0, upd: 0;
       cbphf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbphc() //  [R1]
         { info_tbl: [(cbphc,
                       label: block_cbphc_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbphc: // global
           _sbogt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbpho; else goto cbpi6;
       cbpho: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbphr; else goto cbphq;
       cbphr: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbphq: // global
           _sbog8::P64 = P64[Sp + 144];
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = _sbogt::P64;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = _sbog8::P64;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpi6: // global
           I64[Sp] = block_cbphw_info;
           R1 = _sbogt::P64;
           if (R1 & 7 != 0) goto ubpln; else goto cbpi7;
       ubpln: // global
           call _cbphw(R1) args: 0, res: 0, upd: 0;
       cbpi7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbphw() //  [R1]
         { info_tbl: [(cbphw,
                       label: block_cbphw_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbphw: // global
           _sbog8::P64 = P64[Sp + 144];
           _cbpkX::P64 = R1 & 7;
           if (_cbpkX::P64 == 3) goto sbogD; else goto ubpl0;
       ubpl0: // global
           if (_cbpkX::P64 == 6) goto sbogD; else goto cbpig;
       sbogD: // global
           I64[Sp] = block_cbphB_info;
           R1 = _sbog8::P64;
           if (R1 & 7 != 0) goto ubplo; else goto cbphD;
       ubplo: // global
           call _cbphB(R1) args: 0, res: 0, upd: 0;
       cbphD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpig: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbpij; else goto cbpii;
       cbpij: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpii: // global
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = R1;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = _sbog8::P64;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbphB() //  [R1]
         { info_tbl: [(cbphB,
                       label: block_cbphB_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbphB: // global
           _sbogd::P64 = P64[Sp + 16];
           _sbogg::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbpi2; else goto cbphP;
       cbpi2: // global
           I64[Sp] = block_cbphV_info;
           R2 = _sbogd::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sbogg::P64;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 24;
           call GHC.IO.Device.setRaw_entry(R2) args: 32, res: 8, upd: 8;
       cbphP: // global
           I64[Sp] = block_cbphH_info;
           R2 = _sbogd::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sbogg::P64;
           P64[Sp - 8] = GHC.Types.False_closure+1;
           P64[Sp + 144] = R1;
           Sp = Sp - 24;
           call GHC.IO.Device.setRaw_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbphV() //  [R1]
         { info_tbl: [(cbphV,
                       label: block_cbphV_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbphV: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbpi5; else goto cbpi4;
       cbpi5: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpi4: // global
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           _sbogt::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = _sbogt::P64;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbphH() //  [R1]
         { info_tbl: [(cbphH,
                       label: block_cbphH_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbphH: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbphS; else goto cbphR;
       cbphS: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbphR: // global
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           _sbogt::P64 = P64[Sp + 8];
           _sbogE::P64 = P64[Sp + 144];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = _sbogt::P64;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = _sbogE::P64;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubplN_srtd" {
     ubplN_srtd:
         const SboCL_srt+256;
         const 34;
         const 16106127361;
 },
 GHC.IO.Handle.hSetBuffering1_entry() //  [R2, R3]
         { info_tbl: [(cbplI,
                       label: GHC.IO.Handle.hSetBuffering1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbplI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbplM; else goto cbplL;
       cbplM: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetBuffering1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbplL: // global
           I64[Hp - 8] = sat_sbohh_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = R2;
           R2 = GHC.IO.Handle.hSetBuffering2_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.693121479 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering_closure" {
     GHC.IO.Handle.hSetBuffering_closure:
         const GHC.IO.Handle.hSetBuffering_info;
         const 0;
 },
 GHC.IO.Handle.hSetBuffering_entry() //  [R2, R3]
         { info_tbl: [(cbplS,
                       label: GHC.IO.Handle.hSetBuffering_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbplS: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetBuffering1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.693888667 UTC

[section ""cstring" . GHC.IO.Handle.hIsEOF4_bytes" {
     GHC.IO.Handle.hIsEOF4_bytes:
         I8[] [104,73,115,69,79,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.694618657 UTC

[section ""data" . GHC.IO.Handle.hIsEOF3_closure" {
     GHC.IO.Handle.hIsEOF3_closure:
         const GHC.IO.Handle.hIsEOF3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsEOF3_entry() //  [R1]
         { info_tbl: [(cbpm1,
                       label: GHC.IO.Handle.hIsEOF3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpm1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpm2; else goto cbpm3;
       cbpm2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpm3: // global
           (_cbplY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbplY::I64 == 0) goto cbpm0; else goto cbplZ;
       cbpm0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbplZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbplY::I64;
           R2 = GHC.IO.Handle.hIsEOF4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.696467174 UTC

[section ""data" . GHC.IO.Handle.hIsEOF2_closure" {
     GHC.IO.Handle.hIsEOF2_closure:
         const GHC.IO.Handle.hIsEOF2_info;
 },
 GHC.IO.Handle.hIsEOF2_entry() //  [R2]
         { info_tbl: [(cbpmb,
                       label: GHC.IO.Handle.hIsEOF2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpmb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbpmf; else goto cbpmg;
       cbpmf: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsEOF2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpmg: // global
           I64[Sp - 8] = block_cbpm8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpn7; else goto cbpm9;
       ubpn7: // global
           call _cbpm8(R1) args: 0, res: 0, upd: 0;
       cbpm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpm8() //  [R1]
         { info_tbl: [(cbpm8,
                       label: block_cbpm8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpm8: // global
           _sbohD::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 24] = block_cbpme_info;
           _sbohm::P64 = P64[R1 + 15];
           _sboho::P64 = P64[R1 + 31];
           _sbohq::P64 = P64[R1 + 47];
           R1 = _sbohD::P64;
           P64[Sp - 16] = _sboho::P64;
           P64[Sp - 8] = _sbohq::P64;
           P64[Sp] = _sbohm::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpn6; else goto cbpmi;
       ubpn6: // global
           call _cbpme(R1) args: 0, res: 0, upd: 0;
       cbpmi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpme() //  [R1]
         { info_tbl: [(cbpme,
                       label: block_cbpme_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpme: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbpmu; else goto ubpn4;
       cbpmu: // global
           _sbohO::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbpmt_info;
           R1 = _sbohO::P64;
           if (R1 & 7 != 0) goto ubpn8; else goto cbpmv;
       ubpn8: // global
           call _cbpmt(R1) args: 0, res: 0, upd: 0;
       cbpmv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubpn4: // global
           Sp = Sp + 32;
           call _cbpmD() args: 0, res: 0, upd: 0;
     }
 },
 _cbpmt() //  [R1]
         { info_tbl: [(cbpmt,
                       label: block_cbpmt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpmt: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbpmO; else goto ubpn5;
       cbpmO: // global
           _sboho::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbpmG_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sboho::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       ubpn5: // global
           Sp = Sp + 32;
           call _cbpmD() args: 0, res: 0, upd: 0;
     }
 },
 _cbpmG() //  [R1]
         { info_tbl: [(cbpmG,
                       label: block_cbpmG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpmG: // global
           I64[Sp] = block_cbpmI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpnb; else goto cbpmJ;
       ubpnb: // global
           call _cbpmI(R1) args: 0, res: 0, upd: 0;
       cbpmJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpmI() //  [R1]
         { info_tbl: [(cbpmI,
                       label: block_cbpmI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpmI: // global
           I64[Sp] = block_cbpmN_info;
           _sboi2::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 16] = _sboi2::P64;
           if (R1 & 7 != 0) goto ubpnc; else goto cbpmR;
       ubpnc: // global
           call _cbpmN(R1) args: 0, res: 0, upd: 0;
       cbpmR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpmN() //  [R1]
         { info_tbl: [(cbpmN,
                       label: block_cbpmN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpmN: // global
           if (I64[R1 + 7] == 0) goto cbpmZ; else goto cbpmY;
       cbpmZ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpmY: // global
           _sbohq::P64 = P64[Sp + 8];
           _sboi2::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbohq::P64 + 8] = _sboi2::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbohq::P64);
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpmD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpmD: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.698903582 UTC

[section ""data" . GHC.IO.Handle.hIsEOF1_closure" {
     GHC.IO.Handle.hIsEOF1_closure:
         const GHC.IO.Handle.hIsEOF1_info;
         const 0;
 },
 GHC.IO.Handle.hIsEOF1_entry() //  [R2]
         { info_tbl: [(cbpnh,
                       label: GHC.IO.Handle.hIsEOF1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpnh: // global
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.699790015 UTC

[section ""data" . GHC.IO.Handle.hIsEOF_closure" {
     GHC.IO.Handle.hIsEOF_closure:
         const GHC.IO.Handle.hIsEOF_info;
         const 0;
 },
 GHC.IO.Handle.hIsEOF_entry() //  [R2]
         { info_tbl: [(cbpno,
                       label: GHC.IO.Handle.hIsEOF_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpno: // global
           R2 = R2;
           call GHC.IO.Handle.hIsEOF1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.700576159 UTC

[section ""data" . GHC.IO.Handle.isEOF1_closure" {
     GHC.IO.Handle.isEOF1_closure:
         const GHC.IO.Handle.isEOF1_info;
         const 0;
 },
 GHC.IO.Handle.isEOF1_entry() //  []
         { info_tbl: [(cbpnv,
                       label: GHC.IO.Handle.isEOF1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpnv: // global
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.701521982 UTC

[section ""data" . GHC.IO.Handle.isEOF_closure" {
     GHC.IO.Handle.isEOF_closure:
         const GHC.IO.Handle.isEOF_info;
         const 0;
 },
 GHC.IO.Handle.isEOF_entry() //  []
         { info_tbl: [(cbpnC,
                       label: GHC.IO.Handle.isEOF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpnC: // global
           call GHC.IO.Handle.isEOF1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.702207968 UTC

[section ""cstring" . lvl19_rbnX1_bytes" {
     lvl19_rbnX1_bytes:
         I8[] [104,83,101,116,70,105,108,101,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.702926196 UTC

[section ""data" . lvl20_rbnX2_closure" {
     lvl20_rbnX2_closure:
         const lvl20_rbnX2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_rbnX2_entry() //  [R1]
         { info_tbl: [(cbpnL,
                       label: lvl20_rbnX2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpnL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpnM; else goto cbpnN;
       cbpnM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpnN: // global
           (_cbpnI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpnI::I64 == 0) goto cbpnK; else goto cbpnJ;
       cbpnK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpnJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpnI::I64;
           R2 = lvl19_rbnX1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.706555311 UTC

[section ""data" . GHC.IO.Handle.hSetFileSize1_closure" {
     GHC.IO.Handle.hSetFileSize1_closure:
         const GHC.IO.Handle.hSetFileSize1_info;
         const 0;
 },
 act_sboib_entry() //  [R1, R2]
         { info_tbl: [(cbpo0,
                       label: act_sboib_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpo0: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbpo1; else goto cbpo2;
       cbpo1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpo2: // global
           I64[Sp - 16] = block_cbpnX_info;
           _sboi9::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sboi9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubppa; else goto cbpnY;
       ubppa: // global
           call _cbpnX(R1) args: 0, res: 0, upd: 0;
       cbpnY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpnX() //  [R1]
         { info_tbl: [(cbpnX,
                       label: block_cbpnX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpnX: // global
           I64[Sp - 32] = block_cbpo5_info;
           _sboif::P64 = P64[R1 + 7];
           _sboig::P64 = P64[R1 + 15];
           _sboii::P64 = P64[R1 + 31];
           _sboik::P64 = P64[R1 + 47];
           R1 = P64[R1 + 39];
           P64[Sp - 24] = _sboig::P64;
           P64[Sp - 16] = _sboii::P64;
           P64[Sp - 8] = _sboik::P64;
           P64[Sp] = _sboif::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubpp9; else goto cbpo7;
       ubpp9: // global
           call _cbpo5(R1) args: 0, res: 0, upd: 0;
       cbpo7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpo5() //  [R1]
         { info_tbl: [(cbpo5,
                       label: block_cbpo5_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpo5: // global
           _cbpp6::P64 = R1 & 7;
           if (_cbpp6::P64 != 1) goto ubpp8; else goto cbpp1;
       ubpp8: // global
           if (_cbpp6::P64 != 2) goto cbpoe; else goto cbpp5;
       cbpoe: // global
           _sboiy::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbpob_info;
           R1 = _sboiy::P64;
           if (R1 & 7 != 0) goto ubppb; else goto cbpof;
       ubppb: // global
           call _cbpob(R1) args: 0, res: 0, upd: 0;
       cbpof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpp5: // global
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbpp1: // global
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbpob() //  [R1]
         { info_tbl: [(cbpob,
                       label: block_cbpob_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpob: // global
           I64[Sp] = block_cbpoj_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubppc; else goto cbpol;
       ubppc: // global
           call _cbpoj(R1) args: 0, res: 0, upd: 0;
       cbpol: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpoj() //  [R1]
         { info_tbl: [(cbpoj,
                       label: block_cbpoj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpoj: // global
           if (R1 & 7 == 1) goto cbpos; else goto cbpoz;
       cbpos: // global
           _sboi9::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbpop_info;
           R2 = P64[Sp + 32];
           _sboii::P64 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_ppv_info;
           P64[Sp + 24] = _sboii::P64;
           P64[Sp + 32] = _sboi9::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
       cbpoz: // global
           _sboiM::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbpox_info;
           R1 = _sboiM::P64;
           if (R1 & 7 != 0) goto ubppd; else goto cbpoA;
       ubppd: // global
           call _cbpox(R1) args: 0, res: 0, upd: 0;
       cbpoA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpop() //  []
         { info_tbl: [(cbpop,
                       label: block_cbpop_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpop: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpox() //  [R1]
         { info_tbl: [(cbpox,
                       label: block_cbpox_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpox: // global
           _sboii::P64 = P64[Sp + 16];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbpoV; else goto cbpoP;
       cbpoV: // global
           _sboi9::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbpoU_info;
           R2 = P64[Sp + 32];
           I64[Sp + 16] = stg_ap_ppv_info;
           P64[Sp + 24] = _sboii::P64;
           P64[Sp + 32] = _sboi9::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
       cbpoP: // global
           _sboig::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbpoI_info;
           R2 = _sboig::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sboii::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbpoU() //  []
         { info_tbl: [(cbpoU,
                       label: block_cbpoU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpoU: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpoI() //  [R1]
         { info_tbl: [(cbpoI,
                       label: block_cbpoI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpoI: // global
           _sboi9::P64 = P64[Sp + 32];
           _sboif::P64 = P64[Sp + 24];
           _sboii::P64 = P64[Sp + 8];
           _sboik::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sboik::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sboik::P64);
           I64[Sp + 32] = block_cbpoN_info;
           R2 = _sboif::P64;
           I64[Sp + 8] = stg_ap_ppv_info;
           P64[Sp + 16] = _sboii::P64;
           P64[Sp + 24] = _sboi9::P64;
           Sp = Sp + 8;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbpoN() //  []
         { info_tbl: [(cbpoN,
                       label: block_cbpoN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpoN: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbojj_entry() //  [R1, R2]
         { info_tbl: [(cbppy,
                       label: sat_sbojj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbppy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbppz; else goto cbppA;
       cbppz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbppA: // global
           I64[Sp - 16] = block_cbppv_info;
           _sbojd::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbojd::P64;
           Sp = Sp - 16;
           call act_sboib_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbppv() //  [R1]
         { info_tbl: [(cbppv,
                       label: block_cbppv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbppv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbppD; else goto cbppC;
       cbppD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbppC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbojb_entry() //  [R1]
         { info_tbl: [(cbppJ,
                       label: io_sbojb_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbppJ: // global
           _sbojb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbppN; else goto cbppO;
       cbppO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbppQ; else goto cbppP;
       cbppQ: // global
           HpAlloc = 16;
           goto cbppN;
       cbppN: // global
           R1 = _sbojb::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbppP: // global
           _sboib::P64 = P64[_sbojb::P64 + 7];
           _sboj5::P64 = P64[_sbojb::P64 + 15];
           _sboj7::P64 = P64[_sbojb::P64 + 23];
           I64[Hp - 8] = sat_sbojj_info;
           P64[Hp] = _sboib::P64;
           I64[Sp - 16] = block_cbppE_info;
           R5 = _sboj7::P64;
           R4 = Hp - 6;
           R3 = _sboj5::P64;
           R2 = lvl20_rbnX2_closure;
           P64[Sp - 8] = _sboj7::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbppE() //  [R1]
         { info_tbl: [(cbppE,
                       label: block_cbppE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbppE: // global
           I64[Sp] = block_cbppG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubppV; else goto cbppH;
       ubppV: // global
           call _cbppG(R1) args: 0, res: 0, upd: 0;
       cbppH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbppG() //  [R1]
         { info_tbl: [(cbppG,
                       label: block_cbppG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbppG: // global
           I64[Sp] = block_cbppM_info;
           R2 = P64[R1 + 7];
           _sbojp::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbojp::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbppM() //  []
         { info_tbl: [(cbppM,
                       label: block_cbppM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbppM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbojG_entry() //  [R1, R2]
         { info_tbl: [(cbpqd,
                       label: sat_sbojG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpqd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpqe; else goto cbpqf;
       cbpqe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpqf: // global
           I64[Sp - 16] = block_cbpqa_info;
           _sbojA::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbojA::P64;
           Sp = Sp - 16;
           call act_sboib_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpqa() //  [R1]
         { info_tbl: [(cbpqa,
                       label: block_cbpqa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpqa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpqi; else goto cbpqh;
       cbpqi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpqh: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbojy_entry() //  [R1]
         { info_tbl: [(cbpqo,
                       label: io_sbojy_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpqo: // global
           _sbojy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbpqs; else goto cbpqt;
       cbpqt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbpqv; else goto cbpqu;
       cbpqv: // global
           HpAlloc = 16;
           goto cbpqs;
       cbpqs: // global
           R1 = _sbojy::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpqu: // global
           _sboib::P64 = P64[_sbojy::P64 + 7];
           _sboj5::P64 = P64[_sbojy::P64 + 15];
           _sbojt::P64 = P64[_sbojy::P64 + 23];
           I64[Hp - 8] = sat_sbojG_info;
           P64[Hp] = _sboib::P64;
           I64[Sp - 16] = block_cbpqj_info;
           R5 = _sbojt::P64;
           R4 = Hp - 6;
           R3 = _sboj5::P64;
           R2 = lvl20_rbnX2_closure;
           P64[Sp - 8] = _sbojt::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpqj() //  [R1]
         { info_tbl: [(cbpqj,
                       label: block_cbpqj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpqj: // global
           I64[Sp] = block_cbpql_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpqA; else goto cbpqm;
       ubpqA: // global
           call _cbpql(R1) args: 0, res: 0, upd: 0;
       cbpqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpql() //  [R1]
         { info_tbl: [(cbpql,
                       label: block_cbpql_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpql: // global
           I64[Sp] = block_cbpqr_info;
           R2 = P64[R1 + 7];
           _sbojM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbojM::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpqr() //  []
         { info_tbl: [(cbpqr,
                       label: block_cbpqr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpqr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetFileSize1_entry() //  [R2, R3]
         { info_tbl: [(cbpqF,
                       label: GHC.IO.Handle.hSetFileSize1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpqF: // global
           _sboi9::P64 = R3;
           _sboi8::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbpqG; else goto cbpqH;
       cbpqH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbpqJ; else goto cbpqI;
       cbpqJ: // global
           HpAlloc = 16;
           goto cbpqG;
       cbpqG: // global
           R3 = _sboi9::P64;
           R2 = _sboi8::P64;
           R1 = GHC.IO.Handle.hSetFileSize1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbpqI: // global
           I64[Hp - 8] = act_sboib_info;
           P64[Hp] = _sboi9::P64;
           I64[Sp - 16] = block_cbppe_info;
           R1 = _sboi8::P64;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpr0; else goto cbppf;
       ubpr0: // global
           call _cbppe(R1) args: 0, res: 0, upd: 0;
       cbppf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbppe() //  [R1]
         { info_tbl: [(cbppe,
                       label: block_cbppe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbppe: // global
           if (R1 & 7 == 1) goto cbpqC; else goto cbpqD;
       cbpqC: // global
           I64[Sp - 16] = block_cbppj_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbpqD: // global
           I64[Sp - 16] = block_cbppY_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbppj() //  [R1]
         { info_tbl: [(cbppj,
                       label: block_cbppj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbppj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpqN; else goto cbpqM;
       cbpqN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpqM: // global
           I64[Hp - 24] = io_sbojb_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbppl::P64 = Hp - 23;
           if (R1 == 0) goto cbpqR; else goto cbpqQ;
       cbpqR: // global
           R1 = _cbppl::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpqQ: // global
           R1 = _cbppl::P64;
           Sp = Sp + 32;
           call io_sbojb_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbppY() //  [R1]
         { info_tbl: [(cbppY,
                       label: block_cbppY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbppY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpqV; else goto cbpqU;
       cbpqV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpqU: // global
           I64[Hp - 24] = io_sbojy_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpq0::P64 = Hp - 23;
           if (R1 == 0) goto cbpqZ; else goto cbpqY;
       cbpqZ: // global
           R1 = _cbpq0::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpqY: // global
           R1 = _cbpq0::P64;
           Sp = Sp + 32;
           call io_sbojy_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.713513796 UTC

[section ""data" . GHC.IO.Handle.hSetFileSize_closure" {
     GHC.IO.Handle.hSetFileSize_closure:
         const GHC.IO.Handle.hSetFileSize_info;
         const 0;
 },
 GHC.IO.Handle.hSetFileSize_entry() //  [R2, R3]
         { info_tbl: [(cbpr5,
                       label: GHC.IO.Handle.hSetFileSize_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpr5: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetFileSize1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.714260933 UTC

[section ""cstring" . GHC.IO.Handle.hFileSize9_bytes" {
     GHC.IO.Handle.hFileSize9_bytes:
         I8[] [104,70,105,108,101,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.714975976 UTC

[section ""data" . GHC.IO.Handle.hFileSize8_closure" {
     GHC.IO.Handle.hFileSize8_closure:
         const GHC.IO.Handle.hFileSize8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize8_entry() //  [R1]
         { info_tbl: [(cbpre,
                       label: GHC.IO.Handle.hFileSize8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpre: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbprf; else goto cbprg;
       cbprf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbprg: // global
           (_cbprb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbprb::I64 == 0) goto cbprd; else goto cbprc;
       cbprd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbprc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbprb::I64;
           R2 = GHC.IO.Handle.hFileSize9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.715836403 UTC

[section ""cstring" . GHC.IO.Handle.hFileSize7_bytes" {
     GHC.IO.Handle.hFileSize7_bytes:
         I8[] [110,111,116,32,97,32,114,101,103,117,108,97,114,32,102,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.716556897 UTC

[section ""data" . GHC.IO.Handle.hFileSize6_closure" {
     GHC.IO.Handle.hFileSize6_closure:
         const GHC.IO.Handle.hFileSize6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize6_entry() //  [R1]
         { info_tbl: [(cbprn,
                       label: GHC.IO.Handle.hFileSize6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbprn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpro; else goto cbprp;
       cbpro: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbprp: // global
           (_cbprk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbprk::I64 == 0) goto cbprm; else goto cbprl;
       cbprm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbprl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbprk::I64;
           R2 = GHC.IO.Handle.hFileSize7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.717494349 UTC

[section ""data" . GHC.IO.Handle.hFileSize5_closure" {
     GHC.IO.Handle.hFileSize5_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Handle.hFileSize8_closure;
         const GHC.IO.Handle.hFileSize6_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.718336383 UTC

[section ""data" . GHC.IO.Handle.hFileSize4_closure" {
     GHC.IO.Handle.hFileSize4_closure:
         const GHC.IO.Handle.hFileSize4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize4_entry() //  [R1]
         { info_tbl: [(cbprw,
                       label: GHC.IO.Handle.hFileSize4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbprw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbprx; else goto cbpry;
       cbprx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpry: // global
           (_cbprt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbprt::I64 == 0) goto cbprv; else goto cbpru;
       cbprv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpru: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbprt::I64;
           R2 = GHC.IO.Handle.hFileSize5_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.719263897 UTC

[section ""data" . sat_sbojP_closure" {
     sat_sbojP_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.719908364 UTC

[section ""data" . sat_sbojQ_closure" {
     sat_sbojQ_closure:
         const :_con_info;
         const sat_sbojP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.720675016 UTC

[section ""data" . GHC.IO.Handle.hFileSize10_closure" {
     GHC.IO.Handle.hFileSize10_closure:
         const GHC.IO.Handle.hFileSize10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize10_entry() //  [R1]
         { info_tbl: [(cbprF,
                       label: GHC.IO.Handle.hFileSize10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbprF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbprG; else goto cbprH;
       cbprG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbprH: // global
           (_cbprC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbprC::I64 == 0) goto cbprE; else goto cbprD;
       cbprE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbprD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbprC::I64;
           R3 = sat_sbojQ_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.72268113 UTC

[section ""data" . GHC.IO.Handle.hFileSize3_closure" {
     GHC.IO.Handle.hFileSize3_closure:
         const GHC.IO.Handle.hFileSize3_info;
         const 0;
 },
 section ""relreadonly" . ubptj_srtd" {
     ubptj_srtd:
         const SboCL_srt+328;
         const 38;
         const 240522362881;
 },
 GHC.IO.Handle.hFileSize3_entry() //  [R2]
         { info_tbl: [(cbprP,
                       label: GHC.IO.Handle.hFileSize3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbprP: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbprQ; else goto cbprR;
       cbprQ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbprR: // global
           I64[Sp - 8] = block_cbprM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubptc; else goto cbprN;
       ubptc: // global
           call _cbprM(R1) args: 0, res: 0, upd: 0;
       cbprN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubptk_srtd" {
     ubptk_srtd:
         const SboCL_srt+328;
         const 38;
         const 206162624513;
 },
 _cbprM() //  [R1]
         { info_tbl: [(cbprM,
                       label: block_cbprM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbprM: // global
           I64[Sp - 32] = block_cbprU_info;
           _sbojU::P64 = P64[R1 + 7];
           _sbojV::P64 = P64[R1 + 15];
           _sbojX::P64 = P64[R1 + 31];
           _sbojZ::P64 = P64[R1 + 47];
           R1 = P64[R1 + 39];
           P64[Sp - 24] = _sbojV::P64;
           P64[Sp - 16] = _sbojX::P64;
           P64[Sp - 8] = _sbojZ::P64;
           P64[Sp] = _sbojU::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubptb; else goto cbprW;
       ubptb: // global
           call _cbprU(R1) args: 0, res: 0, upd: 0;
       cbprW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubptl_srtd" {
     ubptl_srtd:
         const SboCL_srt+328;
         const 38;
         const 206162624513;
 },
 _cbprU() //  [R1]
         { info_tbl: [(cbprU,
                       label: block_cbprU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbprU: // global
           _cbpt2::P64 = R1 & 7;
           if (_cbpt2::P64 != 1) goto ubpt7; else goto cbpsX;
       ubpt7: // global
           if (_cbpt2::P64 != 2) goto cbps3; else goto cbpt1;
       cbps3: // global
           _sbokd::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbps0_info;
           R1 = _sbokd::P64;
           if (R1 & 7 != 0) goto ubptd; else goto cbps4;
       ubptd: // global
           call _cbps0(R1) args: 0, res: 0, upd: 0;
       cbps4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpt1: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbpsX: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbps0() //  [R1]
         { info_tbl: [(cbps0,
                       label: block_cbps0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbps0: // global
           I64[Sp] = block_cbpsa_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubpte; else goto cbpsu;
       ubpte: // global
           call _cbpsa(R1) args: 0, res: 0, upd: 0;
       cbpsu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpsa() //  [R1]
         { info_tbl: [(cbpsa,
                       label: block_cbpsa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpsa: // global
           if (R1 & 7 == 1) goto ubpt8; else goto cbpsF;
       ubpt8: // global
           Sp = Sp + 16;
           call _sbokl() args: 0, res: 0, upd: 0;
       cbpsF: // global
           _sboku::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbpsD_info;
           R1 = _sboku::P64;
           if (R1 & 7 != 0) goto ubptf; else goto cbpsG;
       ubptf: // global
           call _cbpsD(R1) args: 0, res: 0, upd: 0;
       cbpsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpsD() //  [R1]
         { info_tbl: [(cbpsD,
                       label: block_cbpsD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpsD: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubpt9; else goto cbpsQ;
       ubpt9: // global
           Sp = Sp + 16;
           call _sbokl() args: 0, res: 0, upd: 0;
       cbpsQ: // global
           _sbojV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbpsO_info;
           R2 = _sbojV::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbpsO() //  [R1]
         { info_tbl: [(cbpsO,
                       label: block_cbpsO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpsO: // global
           _sbojZ::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbojZ::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbojZ::P64);
           Sp = Sp + 8;
           call _sbokl() args: 0, res: 0, upd: 0;
     }
 },
 _sbokl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbokl: // global
           _sbojU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbpsf_info;
           R2 = _sbojU::P64;
           _sbojX::P64 = P64[Sp];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbojX::P64;
           call GHC.IO.Device.getSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbpsf() //  [R1]
         { info_tbl: [(cbpsf,
                       label: block_cbpsf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpsf: // global
           I64[Sp - 8] = block_cbpsh_info;
           R3 = GHC.IO.Handle.hFileSize10_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpsh() //  [R1]
         { info_tbl: [(cbpsh,
                       label: block_cbpsh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpsh: // global
           if (R1 == 1) goto cbpst; else goto cbpsp;
       cbpst: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpsp: // global
           R1 = GHC.IO.Handle.hFileSize4_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.726052899 UTC

[section ""data" . GHC.IO.Handle.hFileSize2_closure" {
     GHC.IO.Handle.hFileSize2_closure:
         const GHC.IO.Handle.hFileSize2_info;
         const 0;
 },
 GHC.IO.Handle.hFileSize2_entry() //  [R2]
         { info_tbl: [(cbptt,
                       label: GHC.IO.Handle.hFileSize2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbptt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbptu; else goto cbptv;
       cbptu: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbptv: // global
           I64[Sp - 16] = block_cbptq_info;
           _sbokH::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbokH::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hFileSize3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbptq() //  [R1]
         { info_tbl: [(cbptq,
                       label: block_cbptq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbptq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpty; else goto cbptx;
       cbpty: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbptx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.728323781 UTC

[section ""data" . GHC.IO.Handle.hFileSize1_closure" {
     GHC.IO.Handle.hFileSize1_closure:
         const GHC.IO.Handle.hFileSize1_info;
         const 0;
 },
 io_sbokV_entry() //  [R1]
         { info_tbl: [(cbptU,
                       label: io_sbokV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbptU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbptY; else goto cbptZ;
       cbptY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbptZ: // global
           I64[Sp - 16] = block_cbptP_info;
           _sbokR::P64 = P64[R1 + 15];
           R5 = _sbokR::P64;
           R4 = GHC.IO.Handle.hFileSize2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFileSize8_closure;
           P64[Sp - 8] = _sbokR::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbptP() //  [R1]
         { info_tbl: [(cbptP,
                       label: block_cbptP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbptP: // global
           I64[Sp] = block_cbptR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpu4; else goto cbptS;
       ubpu4: // global
           call _cbptR(R1) args: 0, res: 0, upd: 0;
       cbptS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbptR() //  [R1]
         { info_tbl: [(cbptR,
                       label: block_cbptR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbptR: // global
           I64[Sp] = block_cbptX_info;
           R2 = P64[R1 + 7];
           _sbol2::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbol2::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbptX() //  []
         { info_tbl: [(cbptX,
                       label: block_cbptX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbptX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbolb_entry() //  [R1]
         { info_tbl: [(cbpuj,
                       label: io_sbolb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpuj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpun; else goto cbpuo;
       cbpun: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpuo: // global
           I64[Sp - 16] = block_cbpue_info;
           _sbol6::P64 = P64[R1 + 15];
           R5 = _sbol6::P64;
           R4 = GHC.IO.Handle.hFileSize2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFileSize8_closure;
           P64[Sp - 8] = _sbol6::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpue() //  [R1]
         { info_tbl: [(cbpue,
                       label: block_cbpue_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpue: // global
           I64[Sp] = block_cbpug_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubput; else goto cbpuh;
       ubput: // global
           call _cbpug(R1) args: 0, res: 0, upd: 0;
       cbpuh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpug() //  [R1]
         { info_tbl: [(cbpug,
                       label: block_cbpug_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpug: // global
           I64[Sp] = block_cbpum_info;
           R2 = P64[R1 + 7];
           _sboli::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboli::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpum() //  []
         { info_tbl: [(cbpum,
                       label: block_cbpum_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpum: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hFileSize1_entry() //  [R2]
         { info_tbl: [(cbpuy,
                       label: GHC.IO.Handle.hFileSize1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpuy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpuz; else goto cbpuA;
       cbpuz: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpuA: // global
           I64[Sp - 8] = block_cbptD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpuR; else goto cbptE;
       ubpuR: // global
           call _cbptD(R1) args: 0, res: 0, upd: 0;
       cbptE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbptD() //  [R1]
         { info_tbl: [(cbptD,
                       label: block_cbptD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbptD: // global
           if (R1 & 7 == 1) goto cbpuv; else goto cbpuw;
       cbpuv: // global
           I64[Sp - 16] = block_cbptI_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbpuw: // global
           I64[Sp - 16] = block_cbpu7_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbptI() //  [R1]
         { info_tbl: [(cbptI,
                       label: block_cbptI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbptI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpuE; else goto cbpuD;
       cbpuE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpuD: // global
           I64[Hp - 16] = io_sbokV_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbptK::P64 = Hp - 15;
           if (R1 == 0) goto cbpuI; else goto cbpuH;
       cbpuI: // global
           R1 = _cbptK::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpuH: // global
           R1 = _cbptK::P64;
           Sp = Sp + 24;
           call io_sbokV_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpu7() //  [R1]
         { info_tbl: [(cbpu7,
                       label: block_cbpu7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpu7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpuM; else goto cbpuL;
       cbpuM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpuL: // global
           I64[Hp - 16] = io_sbolb_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpu9::P64 = Hp - 15;
           if (R1 == 0) goto cbpuQ; else goto cbpuP;
       cbpuQ: // global
           R1 = _cbpu9::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpuP: // global
           R1 = _cbpu9::P64;
           Sp = Sp + 24;
           call io_sbolb_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.735018462 UTC

[section ""data" . GHC.IO.Handle.hFileSize_closure" {
     GHC.IO.Handle.hFileSize_closure:
         const GHC.IO.Handle.hFileSize_info;
         const 0;
 },
 GHC.IO.Handle.hFileSize_entry() //  [R2]
         { info_tbl: [(cbpuW,
                       label: GHC.IO.Handle.hFileSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpuW: // global
           R2 = R2;
           call GHC.IO.Handle.hFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.735745009 UTC

[section ""data" . lvl21_rbnX3_closure" {
     lvl21_rbnX3_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.73920091 UTC

[section ""data" . GHC.IO.Handle.hDuplicateTo1_closure" {
     GHC.IO.Handle.hDuplicateTo1_closure:
         const GHC.IO.Handle.hDuplicateTo1_info;
         const 0;
 },
 sat_sbolF_entry() //  [R1, R2]
         { info_tbl: [(cbpvs,
                       label: sat_sbolF_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpvs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpvt; else goto cbpvu;
       cbpvt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpvu: // global
           I64[Sp - 16] = block_cbpvp_info;
           R6 = R2;
           R5 = P64[R1 + 22];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 6];
           _sbolz::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = lvl21_rbnX3_closure+2;
           P64[Sp - 8] = _sbolz::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbpvp() //  [R1]
         { info_tbl: [(cbpvp,
                       label: block_cbpvp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpvp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpvx; else goto cbpvw;
       cbpvx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpvw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpxk_srtd" {
     ubpxk_srtd:
         const SboCL_srt+176;
         const 64;
         const 17293822569102704641;
 },
 sat_sbolG_entry() //  [R1, R2]
         { info_tbl: [(cbpvy,
                       label: sat_sbolG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpvy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbpvz; else goto cbpvA;
       cbpvz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpvA: // global
           I64[Sp - 40] = block_cbpvi_info;
           _sbolu::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 14];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _sbolu::P64;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpxl_srtd" {
     ubpxl_srtd:
         const SboCL_srt+176;
         const 64;
         const 12682136550675316737;
 },
 _cbpvi() //  [R1]
         { info_tbl: [(cbpvi,
                       label: block_cbpvi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpvi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpvD; else goto cbpvC;
       cbpvD: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpvC: // global
           I64[Hp - 24] = sat_sbolF_info;
           _sbolo::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sbolo::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 32];
           R5 = Hp - 22;
           R4 = P64[Sp + 24];
           R3 = _sbolo::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbom4_entry() //  [R1, R2]
         { info_tbl: [(cbpw1,
                       label: sat_sbom4_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpw1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpw2; else goto cbpw3;
       cbpw2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpw3: // global
           I64[Sp - 16] = block_cbpvY_info;
           R6 = R2;
           R5 = P64[R1 + 22];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 6];
           _sbolY::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = lvl21_rbnX3_closure+2;
           P64[Sp - 8] = _sbolY::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbpvY() //  [R1]
         { info_tbl: [(cbpvY,
                       label: block_cbpvY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpvY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpw6; else goto cbpw5;
       cbpw6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpw5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpxm_srtd" {
     ubpxm_srtd:
         const SboCL_srt+176;
         const 64;
         const 17293822569102704641;
 },
 sat_sbom5_entry() //  [R1, R2]
         { info_tbl: [(cbpw7,
                       label: sat_sbom5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpw7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbpw8; else goto cbpw9;
       cbpw8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpw9: // global
           I64[Sp - 40] = block_cbpvR_info;
           _sbolT::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 14];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _sbolT::P64;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpxn_srtd" {
     ubpxn_srtd:
         const SboCL_srt+176;
         const 64;
         const 12682136550675316737;
 },
 _cbpvR() //  [R1]
         { info_tbl: [(cbpvR,
                       label: block_cbpvR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpvR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpwc; else goto cbpwb;
       cbpwc: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpwb: // global
           I64[Hp - 24] = sat_sbom4_info;
           _sbolo::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sbolo::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 32];
           R5 = Hp - 22;
           R4 = P64[Sp + 24];
           R3 = _sbolo::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbomm_entry() //  [R1, R2]
         { info_tbl: [(cbpww,
                       label: sat_sbomm_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpww: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpwx; else goto cbpwy;
       cbpwx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpwy: // global
           I64[Sp - 16] = block_cbpwt_info;
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 6];
           _sbomg::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _sbomg::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbpwt() //  [R1]
         { info_tbl: [(cbpwt,
                       label: block_cbpwt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpwt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpwB; else goto cbpwA;
       cbpwB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpwA: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpxo_srtd" {
     ubpxo_srtd:
         const SboCL_srt+176;
         const 64;
         const 16140901064495857665;
 },
 sat_sbomn_entry() //  [R1, R2]
         { info_tbl: [(cbpwC,
                       label: sat_sbomn_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpwC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbpwD; else goto cbpwE;
       cbpwD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpwE: // global
           I64[Sp - 48] = block_cbpwm_info;
           _sbomb::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = P64[R1 + 6];
           P64[Sp - 32] = P64[R1 + 14];
           P64[Sp - 24] = P64[R1 + 22];
           P64[Sp - 16] = P64[R1 + 30];
           P64[Sp - 8] = _sbomb::P64;
           Sp = Sp - 48;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpxp_srtd" {
     ubpxp_srtd:
         const SboCL_srt+176;
         const 64;
         const 11529215046068469761;
 },
 _cbpwm() //  [R1]
         { info_tbl: [(cbpwm,
                       label: block_cbpwm_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpwm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbpwH; else goto cbpwG;
       cbpwH: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpwG: // global
           I64[Hp - 32] = sat_sbomm_info;
           _sbolo::P64 = P64[Sp + 8];
           P64[Hp - 24] = _sbolo::P64;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R5 = Hp - 30;
           R4 = P64[Sp + 24];
           R3 = _sbolo::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpxq_srtd" {
     ubpxq_srtd:
         const SboCL_srt+176;
         const 66;
         const 17293822569102704645;
         const 3;
 },
 GHC.IO.Handle.hDuplicateTo1_entry() //  [R2, R3]
         { info_tbl: [(cbpwM,
                       label: GHC.IO.Handle.hDuplicateTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpwM: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbpwN; else goto cbpwO;
       cbpwN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hDuplicateTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbpwO: // global
           I64[Sp - 16] = block_cbpv3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpxj; else goto cbpv4;
       ubpxj: // global
           call _cbpv3(R1) args: 0, res: 0, upd: 0;
       cbpv4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpxr_srtd" {
     ubpxr_srtd:
         const SboCL_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbpv3() //  [R1]
         { info_tbl: [(cbpv3,
                       label: block_cbpv3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpv3: // global
           _sbolm::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbpwJ; else goto cbpwK;
       cbpwJ: // global
           I64[Sp - 16] = block_cbpv8_info;
           _sbolo::P64 = R1;
           _sbolp::P64 = P64[R1 + 7];
           _sbolq::P64 = P64[R1 + 15];
           R1 = _sbolm::P64;
           P64[Sp - 8] = _sbolq::P64;
           P64[Sp] = _sbolp::P64;
           P64[Sp + 8] = _sbolo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpxf; else goto cbpv9;
       ubpxf: // global
           call _cbpv8(R1) args: 0, res: 0, upd: 0;
       cbpv9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbpwK: // global
           I64[Sp - 24] = block_cbpvG_info;
           _sbolo::P64 = R1;
           _sbolK::P64 = P64[R1 + 6];
           _sbolL::P64 = P64[R1 + 14];
           _sbolM::P64 = P64[R1 + 22];
           R1 = _sbolm::P64;
           P64[Sp - 16] = _sbolL::P64;
           P64[Sp - 8] = _sbolM::P64;
           P64[Sp] = _sbolK::P64;
           P64[Sp + 8] = _sbolo::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpxg; else goto cbpvH;
       ubpxg: // global
           call _cbpvG(R1) args: 0, res: 0, upd: 0;
       cbpvH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpxs_srtd" {
     ubpxs_srtd:
         const SboCL_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbpv8() //  [R1]
         { info_tbl: [(cbpv8,
                       label: block_cbpv8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpv8: // global
           if (R1 & 7 == 1) goto cbpwR; else goto ubpxe;
       cbpwR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpwU; else goto cbpwT;
       cbpwU: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpwT: // global
           _sbolt::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sbolG_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R5 = Hp - 22;
           R4 = _sbolt::P64;
           R3 = R1;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       ubpxe: // global
           Sp = Sp + 24;
           call _cbpx3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubpxt_srtd" {
     ubpxt_srtd:
         const SboCL_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbpvG() //  [R1]
         { info_tbl: [(cbpvG,
                       label: block_cbpvG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpvG: // global
           if (R1 & 7 == 1) goto ubpxd; else goto cbpx4;
       ubpxd: // global
           Sp = Sp + 32;
           call _cbpx3() args: 0, res: 0, upd: 0;
       cbpx4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpx7; else goto cbpx6;
       cbpx7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpx6: // global
           _sbolR::P64 = P64[R1 + 14];
           _sbolS::P64 = P64[R1 + 22];
           I64[Hp - 24] = sat_sbom5_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 16] = block_cbpwd_info;
           R5 = Hp - 22;
           R4 = _sbolS::P64;
           R3 = R1;
           R2 = lvl1_rbnWC_closure;
           P64[Sp - 8] = _sbolR::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpx3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpx3: // global
           R2 = P64[Sp];
           Sp = Sp + 8;
           call ioe_dupHandlesNotCompatible_rbnWF_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpxu_srtd" {
     ubpxu_srtd:
         const SboCL_srt+176;
         const 65;
         const 16140901064495857665;
         const 1;
 },
 _cbpwd() //  [R1]
         { info_tbl: [(cbpwd,
                       label: block_cbpwd_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpwd: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbpxa; else goto cbpx9;
       cbpxa: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpx9: // global
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = P64[Sp + 32];
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = sat_sbomn_info;
           P64[Hp - 24] = P64[Sp + 48];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           R5 = Hp - 30;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.745658052 UTC

[section ""data" . GHC.IO.Handle.hDuplicateTo_closure" {
     GHC.IO.Handle.hDuplicateTo_closure:
         const GHC.IO.Handle.hDuplicateTo_info;
         const 0;
 },
 GHC.IO.Handle.hDuplicateTo_entry() //  [R2, R3]
         { info_tbl: [(cbpxz,
                       label: GHC.IO.Handle.hDuplicateTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpxz: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hDuplicateTo1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.746376479 UTC

[section ""cstring" . lvl22_rbnX4_bytes" {
     lvl22_rbnX4_bytes:
         I8[] [104,68,117,112,108,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.747083639 UTC

[section ""data" . lvl23_rbnX5_closure" {
     lvl23_rbnX5_closure:
         const lvl23_rbnX5_info;
         const 0;
         const 0;
         const 0;
 },
 lvl23_rbnX5_entry() //  [R1]
         { info_tbl: [(cbpxI,
                       label: lvl23_rbnX5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpxI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpxJ; else goto cbpxK;
       cbpxJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpxK: // global
           (_cbpxF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpxF::I64 == 0) goto cbpxH; else goto cbpxG;
       cbpxH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpxG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpxF::I64;
           R2 = lvl22_rbnX4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.74799229 UTC

[section ""cstring" . lvl24_rbnX6_bytes" {
     lvl24_rbnX6_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,54,50,54,58,51,45,51,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.748696737 UTC

[section ""data" . lvl25_rbnX7_closure" {
     lvl25_rbnX7_closure:
         const lvl25_rbnX7_info;
         const 0;
 },
 lvl25_rbnX7_entry() //  []
         { info_tbl: [(cbpxR,
                       label: lvl25_rbnX7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpxR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbpxS; else goto cbpxT;
       cbpxS: // global
           R1 = lvl25_rbnX7_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpxT: // global
           I64[Sp - 8] = block_cbpxP_info;
           R2 = lvl24_rbnX6_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpxP() //  [R1]
         { info_tbl: [(cbpxP,
                       label: block_cbpxP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpxP: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.749739708 UTC

[section ""cstring" . lvl26_rbnX8_bytes" {
     lvl26_rbnX8_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,54,50,51,58,51,45,51,53]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.750441548 UTC

[section ""data" . lvl27_rbnX9_closure" {
     lvl27_rbnX9_closure:
         const lvl27_rbnX9_info;
         const 0;
 },
 lvl27_rbnX9_entry() //  []
         { info_tbl: [(cbpy3,
                       label: lvl27_rbnX9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpy3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbpy4; else goto cbpy5;
       cbpy4: // global
           R1 = lvl27_rbnX9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpy5: // global
           I64[Sp - 8] = block_cbpy1_info;
           R2 = lvl26_rbnX8_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpy1() //  [R1]
         { info_tbl: [(cbpy1,
                       label: block_cbpy1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpy1: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.754032214 UTC

[section ""data" . GHC.IO.Handle.hDuplicate1_closure" {
     GHC.IO.Handle.hDuplicate1_closure:
         const GHC.IO.Handle.hDuplicate1_info;
         const 0;
 },
 section ""relreadonly" . ubpAQ_srtd" {
     ubpAQ_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 sat_sbon0_entry() //  [R1, R2]
         { info_tbl: [(cbpyq,
                       label: sat_sbon0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyq: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbpyA; else goto cbpyB;
       cbpyA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpyB: // global
           I64[Sp - 16] = block_cbpyn_info;
           _sbomv::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbomv::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpyI; else goto cbpyo;
       ubpyI: // global
           call _cbpyn(R1) args: 0, res: 0, upd: 0;
       cbpyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpAR_srtd" {
     ubpAR_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 _cbpyn() //  [R1]
         { info_tbl: [(cbpyn,
                       label: block_cbpyn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyn: // global
           I64[Sp - 40] = block_cbpyt_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpAS_srtd" {
     ubpAS_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbpyt() //  []
         { info_tbl: [(cbpyt,
                       label: block_cbpyt_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyt: // global
           I64[Sp] = block_cbpyv_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 16;
           call GHC.IO.Device.dup_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpAT_srtd" {
     ubpAT_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbpyv() //  [R1]
         { info_tbl: [(cbpyv,
                       label: block_cbpyv_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyv: // global
           I64[Sp + 32] = block_cbpyx_info;
           R6 = P64[Sp + 48];
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = lvl21_rbnX3_closure+2;
           Sp = Sp + 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbpyx() //  [R1]
         { info_tbl: [(cbpyx,
                       label: block_cbpyx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpyH; else goto cbpyG;
       cbpyH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpyG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpAU_srtd" {
     ubpAU_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 sat_sbonx_entry() //  [R1, R2]
         { info_tbl: [(cbpyT,
                       label: sat_sbonx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyT: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbpz3; else goto cbpz4;
       cbpz3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpz4: // global
           I64[Sp - 16] = block_cbpyQ_info;
           _sbon1::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbon1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpzb; else goto cbpyR;
       ubpzb: // global
           call _cbpyQ(R1) args: 0, res: 0, upd: 0;
       cbpyR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpAV_srtd" {
     ubpAV_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 _cbpyQ() //  [R1]
         { info_tbl: [(cbpyQ,
                       label: block_cbpyQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyQ: // global
           I64[Sp - 40] = block_cbpyW_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpAW_srtd" {
     ubpAW_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbpyW() //  []
         { info_tbl: [(cbpyW,
                       label: block_cbpyW_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyW: // global
           I64[Sp] = block_cbpyY_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 16;
           call GHC.IO.Device.dup_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpAX_srtd" {
     ubpAX_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbpyY() //  [R1]
         { info_tbl: [(cbpyY,
                       label: block_cbpyY_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyY: // global
           I64[Sp + 32] = block_cbpz0_info;
           R6 = P64[Sp + 48];
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = lvl21_rbnX3_closure+2;
           Sp = Sp + 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbpz0() //  [R1]
         { info_tbl: [(cbpz0,
                       label: block_cbpz0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpz0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpza; else goto cbpz9;
       cbpza: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpz9: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sboop_entry() //  [R1, R2]
         { info_tbl: [(cbpzF,
                       label: sat_sboop_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpzF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbpzL; else goto cbpzM;
       cbpzL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpzM: // global
           I64[Sp - 32] = block_cbpzC_info;
           _sbon1::P64 = P64[R1 + 6];
           _sbonF::P64 = P64[R1 + 14];
           _sbonI::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sbon1::P64;
           P64[Sp - 16] = _sbonF::P64;
           P64[Sp - 8] = _sbonI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubpzR; else goto cbpzD;
       ubpzR: // global
           call _cbpzC(R1) args: 0, res: 0, upd: 0;
       cbpzD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpzC() //  [R1]
         { info_tbl: [(cbpzC,
                       label: block_cbpzC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpzC: // global
           _sbonF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbpzI_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sbonF::P64;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbpzI() //  [R1]
         { info_tbl: [(cbpzI,
                       label: block_cbpzI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpzI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpzQ; else goto cbpzP;
       cbpzQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpzP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpAY_srtd" {
     ubpAY_srtd:
         const SboCL_srt+96;
         const 81;
         const 1;
         const 98816;
 },
 sat_sboou_entry() //  [R1, R2]
         { info_tbl: [(cbpzS,
                       label: sat_sboou_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpzS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbpzW; else goto cbpzX;
       cbpzW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpzX: // global
           I64[Sp - 40] = block_cbpzq_info;
           _sbomu::P64 = P64[R1 + 6];
           _sbon1::P64 = P64[R1 + 14];
           _sbonD::P64 = P64[R1 + 22];
           _sbonF::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 32] = _sbomu::P64;
           P64[Sp - 24] = _sbon1::P64;
           P64[Sp - 16] = _sbonD::P64;
           P64[Sp - 8] = _sbonF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubpA5; else goto cbpzr;
       ubpA5: // global
           call _cbpzq(R1) args: 0, res: 0, upd: 0;
       cbpzr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpAZ_srtd" {
     ubpAZ_srtd:
         const SboCL_srt+96;
         const 81;
         const 1;
         const 98816;
 },
 _cbpzq() //  [R1]
         { info_tbl: [(cbpzq,
                       label: block_cbpzq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpzq: // global
           I64[Sp - 8] = block_cbpzv_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpzv() //  [R1]
         { info_tbl: [(cbpzv,
                       label: block_cbpzv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpzv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpA1; else goto cbpA0;
       cbpA1: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpA0: // global
           I64[Hp - 24] = sat_sboop_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cbpzT_info;
           R5 = Hp - 22;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = lvl7_rbnWP_closure;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpzT() //  [R1]
         { info_tbl: [(cbpzT,
                       label: block_cbpzT_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpzT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpA4; else goto cbpA3;
       cbpA4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpA3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpB0_srtd" {
     ubpB0_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 512576;
 },
 GHC.IO.Handle.hDuplicate1_entry() //  [R2]
         { info_tbl: [(cbpAa,
                       label: GHC.IO.Handle.hDuplicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpAa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbpAb; else goto cbpAc;
       cbpAb: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hDuplicate1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpAc: // global
           I64[Sp - 8] = block_cbpyd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpAO; else goto cbpye;
       ubpAO: // global
           call _cbpyd(R1) args: 0, res: 0, upd: 0;
       cbpye: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpB1_srtd" {
     ubpB1_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 381504;
 },
 _cbpyd() //  [R1]
         { info_tbl: [(cbpyd,
                       label: block_cbpyd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpyd: // global
           if (R1 & 7 == 1) goto cbpA7; else goto cbpA8;
       cbpA7: // global
           Hp = Hp + 16;
           _sbomu::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpAi; else goto cbpAe;
       cbpAe: // global
           _sbomv::P64 = P64[_sbomu::P64 + 7];
           _sbomw::P64 = P64[_sbomu::P64 + 15];
           I64[Hp - 8] = sat_sbon0_info;
           P64[Hp] = _sbomv::P64;
           R5 = Hp - 6;
           R4 = _sbomw::P64;
           R3 = _sbomu::P64;
           R2 = lvl23_rbnX5_closure;
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cbpA8: // global
           Hp = Hp + 16;
           _sbomu::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpAi; else goto cbpAh;
       cbpAi: // global
           HpAlloc = 16;
           R1 = _sbomu::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpAh: // global
           _sbon1::P64 = P64[_sbomu::P64 + 6];
           _sbon2::P64 = P64[_sbomu::P64 + 14];
           _sbon3::P64 = P64[_sbomu::P64 + 22];
           I64[Hp - 8] = sat_sbonx_info;
           P64[Hp] = _sbon1::P64;
           I64[Sp - 24] = block_cbpzc_info;
           R5 = Hp - 6;
           R4 = _sbon3::P64;
           R3 = _sbomu::P64;
           R2 = lvl23_rbnX5_closure;
           P64[Sp - 16] = _sbon1::P64;
           P64[Sp - 8] = _sbon2::P64;
           P64[Sp] = _sbomu::P64;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpB2_srtd" {
     ubpB2_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 381440;
 },
 _cbpzc() //  [R1]
         { info_tbl: [(cbpzc,
                       label: block_cbpzc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpzc: // global
           I64[Sp] = block_cbpze_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpAN; else goto cbpzf;
       ubpAN: // global
           call _cbpze(R1) args: 0, res: 0, upd: 0;
       cbpzf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpB3_srtd" {
     ubpB3_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 381440;
 },
 _cbpze() //  [R1]
         { info_tbl: [(cbpze,
                       label: block_cbpze_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpze: // global
           if (R1 & 7 == 1) goto cbpAo; else goto cbpAK;
       cbpAo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbpAr; else goto cbpAq;
       cbpAr: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpAq: // global
           _sbonD::P64 = P64[R1 + 15];
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = _sbonD::P64;
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = sat_sboou_info;
           _sbomu::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sbomu::P64;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sbonD::P64;
           P64[Hp] = Hp - 46;
           I64[Sp] = block_cbpAk_info;
           R5 = Hp - 30;
           R4 = P64[Sp + 16];
           R3 = _sbomu::P64;
           R2 = lvl23_rbnX5_closure;
           P64[Sp + 24] = _sbonD::P64;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
       cbpAK: // global
           Sp = Sp + 32;
           call lvl27_rbnX9_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbpAk() //  [R1]
         { info_tbl: [(cbpAk,
                       label: block_cbpAk_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpAk: // global
           I64[Sp] = block_cbpAm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpAP; else goto cbpAt;
       ubpAP: // global
           call _cbpAm(R1) args: 0, res: 0, upd: 0;
       cbpAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpAm() //  [R1]
         { info_tbl: [(cbpAm,
                       label: block_cbpAm_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpAm: // global
           if (R1 & 7 == 1) goto cbpAz; else goto cbpAG;
       cbpAz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpAC; else goto cbpAB;
       cbpAC: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpAB: // global
           _sbooA::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sbooA::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpAG: // global
           Sp = Sp + 32;
           call lvl25_rbnX7_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.761160799 UTC

[section ""data" . GHC.IO.Handle.hDuplicate_closure" {
     GHC.IO.Handle.hDuplicate_closure:
         const GHC.IO.Handle.hDuplicate_info;
         const 0;
 },
 GHC.IO.Handle.hDuplicate_entry() //  [R2]
         { info_tbl: [(cbpB8,
                       label: GHC.IO.Handle.hDuplicate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpB8: // global
           R2 = R2;
           call GHC.IO.Handle.hDuplicate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.762021819 UTC

[section ""cstring" . GHC.IO.Handle.hGetEcho4_bytes" {
     GHC.IO.Handle.hGetEcho4_bytes:
         I8[] [104,71,101,116,69,99,104,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.762759618 UTC

[section ""data" . GHC.IO.Handle.hGetEcho3_closure" {
     GHC.IO.Handle.hGetEcho3_closure:
         const GHC.IO.Handle.hGetEcho3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEcho3_entry() //  [R1]
         { info_tbl: [(cbpBh,
                       label: GHC.IO.Handle.hGetEcho3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpBh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpBi; else goto cbpBj;
       cbpBi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpBj: // global
           (_cbpBe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpBe::I64 == 0) goto cbpBg; else goto cbpBf;
       cbpBg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpBf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpBe::I64;
           R2 = GHC.IO.Handle.hGetEcho4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.764124601 UTC

[section ""data" . GHC.IO.Handle.hGetEcho2_closure" {
     GHC.IO.Handle.hGetEcho2_closure:
         const GHC.IO.Handle.hGetEcho2_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho2_entry() //  [R2]
         { info_tbl: [(cbpBr,
                       label: GHC.IO.Handle.hGetEcho2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpBr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbpBs; else goto cbpBt;
       cbpBs: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpBt: // global
           I64[Sp - 8] = block_cbpBo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpBR; else goto cbpBp;
       ubpBR: // global
           call _cbpBo(R1) args: 0, res: 0, upd: 0;
       cbpBp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpBo() //  [R1]
         { info_tbl: [(cbpBo,
                       label: block_cbpBo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpBo: // global
           I64[Sp - 24] = block_cbpBw_info;
           _sbooK::P64 = R1;
           _sbooL::P64 = P64[R1 + 7];
           _sbooO::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbooL::P64;
           P64[Sp - 8] = _sbooO::P64;
           P64[Sp] = _sbooK::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpBQ; else goto cbpBy;
       ubpBQ: // global
           call _cbpBw(R1) args: 0, res: 0, upd: 0;
       cbpBy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpBw() //  [R1]
         { info_tbl: [(cbpBw,
                       label: block_cbpBw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpBw: // global
           if (R1 & 7 == 1) goto cbpBO; else goto cbpBH;
       cbpBO: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbpBH: // global
           _sbooO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbpBC_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbooO::P64;
           call GHC.IO.Device.getEcho_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbpBC() //  [R1]
         { info_tbl: [(cbpBC,
                       label: block_cbpBC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpBC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpBK; else goto cbpBJ;
       cbpBK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpBJ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.76691018 UTC

[section ""data" . GHC.IO.Handle.hGetEcho1_closure" {
     GHC.IO.Handle.hGetEcho1_closure:
         const GHC.IO.Handle.hGetEcho1_info;
         const 0;
 },
 section ""relreadonly" . ubpDs_srtd" {
     ubpDs_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 io_sbopj_entry() //  [R1]
         { info_tbl: [(cbpCl,
                       label: io_sbopj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpCp; else goto cbpCq;
       cbpCp: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpCq: // global
           I64[Sp - 16] = block_cbpCg_info;
           _sbopf::P64 = P64[R1 + 15];
           R5 = _sbopf::P64;
           R4 = GHC.IO.Handle.hGetEcho2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho3_closure;
           P64[Sp - 8] = _sbopf::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpCg() //  [R1]
         { info_tbl: [(cbpCg,
                       label: block_cbpCg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCg: // global
           I64[Sp] = block_cbpCi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpCv; else goto cbpCj;
       ubpCv: // global
           call _cbpCi(R1) args: 0, res: 0, upd: 0;
       cbpCj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpCi() //  [R1]
         { info_tbl: [(cbpCi,
                       label: block_cbpCi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCi: // global
           I64[Sp] = block_cbpCo_info;
           R2 = P64[R1 + 7];
           _sbopq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbopq::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpCo() //  []
         { info_tbl: [(cbpCo,
                       label: block_cbpCo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCo: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpDt_srtd" {
     ubpDt_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 io_sbopz_entry() //  [R1]
         { info_tbl: [(cbpCK,
                       label: io_sbopz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpCO; else goto cbpCP;
       cbpCO: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpCP: // global
           I64[Sp - 16] = block_cbpCF_info;
           _sbopu::P64 = P64[R1 + 15];
           R5 = _sbopu::P64;
           R4 = GHC.IO.Handle.hGetEcho2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho3_closure;
           P64[Sp - 8] = _sbopu::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpCF() //  [R1]
         { info_tbl: [(cbpCF,
                       label: block_cbpCF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCF: // global
           I64[Sp] = block_cbpCH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpCU; else goto cbpCI;
       ubpCU: // global
           call _cbpCH(R1) args: 0, res: 0, upd: 0;
       cbpCI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpCH() //  [R1]
         { info_tbl: [(cbpCH,
                       label: block_cbpCH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCH: // global
           I64[Sp] = block_cbpCN_info;
           R2 = P64[R1 + 7];
           _sbopG::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbopG::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpCN() //  []
         { info_tbl: [(cbpCN,
                       label: block_cbpCN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpDu_srtd" {
     ubpDu_srtd:
         const SboCL_srt+160;
         const 79;
         const 137438953473;
         const 26624;
 },
 GHC.IO.Handle.hGetEcho1_entry() //  [R2]
         { info_tbl: [(cbpCZ,
                       label: GHC.IO.Handle.hGetEcho1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpD0; else goto cbpD1;
       cbpD0: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpD1: // global
           I64[Sp - 16] = block_cbpBW_info;
           _sbop7::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbop7::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpDv_srtd" {
     ubpDv_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbpBW() //  [R1]
         { info_tbl: [(cbpBW,
                       label: block_cbpBW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpBW: // global
           I64[Sp] = block_cbpBY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpDq; else goto cbpBZ;
       ubpDq: // global
           call _cbpBY(R1) args: 0, res: 0, upd: 0;
       cbpBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpDw_srtd" {
     ubpDw_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbpBY() //  [R1]
         { info_tbl: [(cbpBY,
                       label: block_cbpBY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpBY: // global
           if (R1 & 7 == 1) goto cbpCW; else goto cbpCX;
       cbpCW: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpCX: // global
           _sbop7::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbpC4_info;
           R1 = _sbop7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubpDr; else goto cbpC5;
       ubpDr: // global
           call _cbpC4(R1) args: 0, res: 0, upd: 0;
       cbpC5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpDx_srtd" {
     ubpDx_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbpC4() //  [R1]
         { info_tbl: [(cbpC4,
                       label: block_cbpC4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpC4: // global
           if (R1 & 7 == 1) goto cbpD8; else goto cbpDh;
       cbpD8: // global
           I64[Sp - 16] = block_cbpC9_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbpDh: // global
           I64[Sp - 16] = block_cbpCy_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpDy_srtd" {
     ubpDy_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbpC9() //  [R1]
         { info_tbl: [(cbpC9,
                       label: block_cbpC9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpC9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpDb; else goto cbpDa;
       cbpDb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpDa: // global
           I64[Hp - 16] = io_sbopj_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpCb::P64 = Hp - 15;
           if (R1 == 0) goto cbpDf; else goto cbpDe;
       cbpDf: // global
           R1 = _cbpCb::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpDe: // global
           R1 = _cbpCb::P64;
           Sp = Sp + 24;
           call io_sbopj_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpDz_srtd" {
     ubpDz_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbpCy() //  [R1]
         { info_tbl: [(cbpCy,
                       label: block_cbpCy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpCy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpDk; else goto cbpDj;
       cbpDk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpDj: // global
           I64[Hp - 16] = io_sbopz_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpCA::P64 = Hp - 15;
           if (R1 == 0) goto cbpDo; else goto cbpDn;
       cbpDo: // global
           R1 = _cbpCA::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpDn: // global
           R1 = _cbpCA::P64;
           Sp = Sp + 24;
           call io_sbopz_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.770750651 UTC

[section ""data" . GHC.IO.Handle.hGetEcho_closure" {
     GHC.IO.Handle.hGetEcho_closure:
         const GHC.IO.Handle.hGetEcho_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho_entry() //  [R2]
         { info_tbl: [(cbpDE,
                       label: GHC.IO.Handle.hGetEcho_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpDE: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEcho1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.77147036 UTC

[section ""cstring" . GHC.IO.Handle.hSetEcho3_bytes" {
     GHC.IO.Handle.hSetEcho3_bytes:
         I8[] [104,83,101,116,69,99,104,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.77220889 UTC

[section ""data" . GHC.IO.Handle.hSetEcho2_closure" {
     GHC.IO.Handle.hSetEcho2_closure:
         const GHC.IO.Handle.hSetEcho2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetEcho2_entry() //  [R1]
         { info_tbl: [(cbpDN,
                       label: GHC.IO.Handle.hSetEcho2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpDN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpDO; else goto cbpDP;
       cbpDO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpDP: // global
           (_cbpDK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpDK::I64 == 0) goto cbpDM; else goto cbpDL;
       cbpDM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpDL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpDK::I64;
           R2 = GHC.IO.Handle.hSetEcho3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.775504734 UTC

[section ""data" . GHC.IO.Handle.hSetEcho1_closure" {
     GHC.IO.Handle.hSetEcho1_closure:
         const GHC.IO.Handle.hSetEcho1_info;
         const 0;
 },
 sat_sboqn_entry() //  [R1, R2]
         { info_tbl: [(cbpEm,
                       label: sat_sboqn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpEm: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbpEn; else goto cbpEo;
       cbpEn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpEo: // global
           I64[Sp - 16] = block_cbpEj_info;
           _sbopK::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbopK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpEM; else goto cbpEk;
       ubpEM: // global
           call _cbpEj(R1) args: 0, res: 0, upd: 0;
       cbpEk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpEj() //  [R1]
         { info_tbl: [(cbpEj,
                       label: block_cbpEj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpEj: // global
           I64[Sp - 24] = block_cbpEr_info;
           _sboq0::P64 = R1;
           _sboq1::P64 = P64[R1 + 7];
           _sboq4::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sboq1::P64;
           P64[Sp - 8] = _sboq4::P64;
           P64[Sp] = _sboq0::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpEL; else goto cbpEt;
       ubpEL: // global
           call _cbpEr(R1) args: 0, res: 0, upd: 0;
       cbpEt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpEr() //  [R1]
         { info_tbl: [(cbpEr,
                       label: block_cbpEr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpEr: // global
           if (R1 & 7 == 1) goto cbpEJ; else goto cbpEC;
       cbpEJ: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbpEC: // global
           _sboq4::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbpEx_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sboq4::P64;
           P64[Sp + 8] = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.IO.Device.setEcho_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbpEx() //  [R1]
         { info_tbl: [(cbpEx,
                       label: block_cbpEx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpEx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpEF; else goto cbpEE;
       cbpEF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpEE: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpGC_srtd" {
     ubpGC_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 io_sbopW_entry() //  [R1]
         { info_tbl: [(cbpES,
                       label: io_sbopW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpES: // global
           _sbopW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbpEW; else goto cbpEX;
       cbpEX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbpEZ; else goto cbpEY;
       cbpEZ: // global
           HpAlloc = 16;
           goto cbpEW;
       cbpEW: // global
           R1 = _sbopW::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpEY: // global
           _sbopK::P64 = P64[_sbopW::P64 + 7];
           _sbopQ::P64 = P64[_sbopW::P64 + 15];
           _sbopS::P64 = P64[_sbopW::P64 + 23];
           I64[Hp - 8] = sat_sboqn_info;
           P64[Hp] = _sbopK::P64;
           I64[Sp - 16] = block_cbpEN_info;
           R5 = _sbopS::P64;
           R4 = Hp - 6;
           R3 = _sbopQ::P64;
           R2 = GHC.IO.Handle.hSetEcho2_closure;
           P64[Sp - 8] = _sbopS::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpEN() //  [R1]
         { info_tbl: [(cbpEN,
                       label: block_cbpEN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpEN: // global
           I64[Sp] = block_cbpEP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpF4; else goto cbpEQ;
       ubpF4: // global
           call _cbpEP(R1) args: 0, res: 0, upd: 0;
       cbpEQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpEP() //  [R1]
         { info_tbl: [(cbpEP,
                       label: block_cbpEP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpEP: // global
           I64[Sp] = block_cbpEV_info;
           R2 = P64[R1 + 7];
           _sboqt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboqt::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpEV() //  []
         { info_tbl: [(cbpEV,
                       label: block_cbpEV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpEV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbor3_entry() //  [R1, R2]
         { info_tbl: [(cbpFm,
                       label: sat_sbor3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpFm: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbpFn; else goto cbpFo;
       cbpFn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpFo: // global
           I64[Sp - 16] = block_cbpFj_info;
           _sbopK::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbopK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpFM; else goto cbpFk;
       ubpFM: // global
           call _cbpFj(R1) args: 0, res: 0, upd: 0;
       cbpFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpFj() //  [R1]
         { info_tbl: [(cbpFj,
                       label: block_cbpFj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpFj: // global
           I64[Sp - 24] = block_cbpFr_info;
           _sboqG::P64 = R1;
           _sboqH::P64 = P64[R1 + 7];
           _sboqK::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sboqH::P64;
           P64[Sp - 8] = _sboqK::P64;
           P64[Sp] = _sboqG::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpFL; else goto cbpFt;
       ubpFL: // global
           call _cbpFr(R1) args: 0, res: 0, upd: 0;
       cbpFt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpFr() //  [R1]
         { info_tbl: [(cbpFr,
                       label: block_cbpFr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpFr: // global
           if (R1 & 7 == 1) goto cbpFJ; else goto cbpFC;
       cbpFJ: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbpFC: // global
           _sboqK::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbpFx_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sboqK::P64;
           P64[Sp + 8] = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.IO.Device.setEcho_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbpFx() //  [R1]
         { info_tbl: [(cbpFx,
                       label: block_cbpFx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpFx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpFF; else goto cbpFE;
       cbpFF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpFE: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpGD_srtd" {
     ubpGD_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 io_sboqC_entry() //  [R1]
         { info_tbl: [(cbpFS,
                       label: io_sboqC_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpFS: // global
           _sboqC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbpFW; else goto cbpFX;
       cbpFX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbpFZ; else goto cbpFY;
       cbpFZ: // global
           HpAlloc = 16;
           goto cbpFW;
       cbpFW: // global
           R1 = _sboqC::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpFY: // global
           _sbopK::P64 = P64[_sboqC::P64 + 7];
           _sbopQ::P64 = P64[_sboqC::P64 + 15];
           _sboqx::P64 = P64[_sboqC::P64 + 23];
           I64[Hp - 8] = sat_sbor3_info;
           P64[Hp] = _sbopK::P64;
           I64[Sp - 16] = block_cbpFN_info;
           R5 = _sboqx::P64;
           R4 = Hp - 6;
           R3 = _sbopQ::P64;
           R2 = GHC.IO.Handle.hSetEcho2_closure;
           P64[Sp - 8] = _sboqx::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpFN() //  [R1]
         { info_tbl: [(cbpFN,
                       label: block_cbpFN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpFN: // global
           I64[Sp] = block_cbpFP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpG4; else goto cbpFQ;
       ubpG4: // global
           call _cbpFP(R1) args: 0, res: 0, upd: 0;
       cbpFQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpFP() //  [R1]
         { info_tbl: [(cbpFP,
                       label: block_cbpFP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpFP: // global
           I64[Sp] = block_cbpFV_info;
           R2 = P64[R1 + 7];
           _sbor9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbor9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpFV() //  []
         { info_tbl: [(cbpFV,
                       label: block_cbpFV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpFV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpGE_srtd" {
     ubpGE_srtd:
         const SboCL_srt+160;
         const 81;
         const 137438953473;
         const 102400;
 },
 GHC.IO.Handle.hSetEcho1_entry() //  [R2, R3]
         { info_tbl: [(cbpG9,
                       label: GHC.IO.Handle.hSetEcho1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpG9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbpGa; else goto cbpGb;
       cbpGa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetEcho1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbpGb: // global
           I64[Sp - 24] = block_cbpDU_info;
           _sbopJ::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbopJ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpGF_srtd" {
     ubpGF_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbpDU() //  [R1]
         { info_tbl: [(cbpDU,
                       label: block_cbpDU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpDU: // global
           I64[Sp] = block_cbpDW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpGA; else goto cbpDX;
       ubpGA: // global
           call _cbpDW(R1) args: 0, res: 0, upd: 0;
       cbpDX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpGG_srtd" {
     ubpGG_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbpDW() //  [R1]
         { info_tbl: [(cbpDW,
                       label: block_cbpDW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpDW: // global
           if (R1 & 7 == 1) goto cbpG6; else goto cbpG7;
       cbpG6: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpG7: // global
           _sbopJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbpE2_info;
           R1 = _sbopJ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubpGB; else goto cbpE3;
       ubpGB: // global
           call _cbpE2(R1) args: 0, res: 0, upd: 0;
       cbpE3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpGH_srtd" {
     ubpGH_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbpE2() //  [R1]
         { info_tbl: [(cbpE2,
                       label: block_cbpE2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpE2: // global
           if (R1 & 7 == 1) goto cbpGi; else goto cbpGr;
       cbpGi: // global
           I64[Sp - 16] = block_cbpE7_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbpGr: // global
           I64[Sp - 16] = block_cbpF7_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpGI_srtd" {
     ubpGI_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbpE7() //  [R1]
         { info_tbl: [(cbpE7,
                       label: block_cbpE7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpE7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpGl; else goto cbpGk;
       cbpGl: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpGk: // global
           I64[Hp - 24] = io_sbopW_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpE9::P64 = Hp - 23;
           if (R1 == 0) goto cbpGp; else goto cbpGo;
       cbpGp: // global
           R1 = _cbpE9::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpGo: // global
           R1 = _cbpE9::P64;
           Sp = Sp + 32;
           call io_sbopW_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpGJ_srtd" {
     ubpGJ_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbpF7() //  [R1]
         { info_tbl: [(cbpF7,
                       label: block_cbpF7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpF7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpGu; else goto cbpGt;
       cbpGu: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpGt: // global
           I64[Hp - 24] = io_sboqC_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpF9::P64 = Hp - 23;
           if (R1 == 0) goto cbpGy; else goto cbpGx;
       cbpGy: // global
           R1 = _cbpF9::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpGx: // global
           R1 = _cbpF9::P64;
           Sp = Sp + 32;
           call io_sboqC_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.781536187 UTC

[section ""data" . GHC.IO.Handle.hSetEcho_closure" {
     GHC.IO.Handle.hSetEcho_closure:
         const GHC.IO.Handle.hSetEcho_info;
         const 0;
 },
 GHC.IO.Handle.hSetEcho_entry() //  [R2, R3]
         { info_tbl: [(cbpGO,
                       label: GHC.IO.Handle.hSetEcho_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpGO: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetEcho1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.782275807 UTC

[section ""cstring" . GHC.IO.Handle.hGetBuffering3_bytes" {
     GHC.IO.Handle.hGetBuffering3_bytes:
         I8[] [104,71,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.783035648 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering_fun_closure" {
     GHC.IO.Handle.hGetBuffering_fun_closure:
         const GHC.IO.Handle.hGetBuffering_fun_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering_fun_entry() //  [R1]
         { info_tbl: [(cbpGX,
                       label: GHC.IO.Handle.hGetBuffering_fun_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpGX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpGY; else goto cbpGZ;
       cbpGY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpGZ: // global
           (_cbpGU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpGU::I64 == 0) goto cbpGW; else goto cbpGV;
       cbpGW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpGV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpGU::I64;
           R2 = GHC.IO.Handle.hGetBuffering3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.784337641 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering2_closure" {
     GHC.IO.Handle.hGetBuffering2_closure:
         const GHC.IO.Handle.hGetBuffering2_info;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering2_entry() //  [R2]
         { info_tbl: [(cbpH7,
                       label: GHC.IO.Handle.hGetBuffering2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpH7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpH8; else goto cbpH9;
       cbpH8: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetBuffering2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpH9: // global
           I64[Sp - 8] = block_cbpH4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpHu; else goto cbpH5;
       ubpHu: // global
           call _cbpH4(R1) args: 0, res: 0, upd: 0;
       cbpH5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpH4() //  [R1]
         { info_tbl: [(cbpH4,
                       label: block_cbpH4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpH4: // global
           I64[Sp - 16] = block_cbpHc_info;
           _sbore::P64 = R1;
           _sborl::P64 = P64[R1 + 55];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _sborl::P64;
           P64[Sp] = _sbore::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubpHt; else goto cbpHe;
       ubpHt: // global
           call _cbpHc(R1) args: 0, res: 0, upd: 0;
       cbpHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpHc() //  [R1]
         { info_tbl: [(cbpHc,
                       label: block_cbpHc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpHc: // global
           if (R1 & 7 == 1) goto cbpHr; else goto cbpHk;
       cbpHr: // global
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbpHk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpHn; else goto cbpHm;
       cbpHn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpHm: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.787011443 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering1_closure" {
     GHC.IO.Handle.hGetBuffering1_closure:
         const GHC.IO.Handle.hGetBuffering1_info;
         const 0;
 },
 section ""relreadonly" . ubpIO_srtd" {
     ubpIO_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 io_sborG_entry() //  [R1]
         { info_tbl: [(cbpHQ,
                       label: io_sborG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpHQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpHU; else goto cbpHV;
       cbpHU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpHV: // global
           I64[Sp - 16] = block_cbpHL_info;
           _sborC::P64 = P64[R1 + 15];
           R5 = _sborC::P64;
           R4 = GHC.IO.Handle.hGetBuffering2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetBuffering_fun_closure;
           P64[Sp - 8] = _sborC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpHL() //  [R1]
         { info_tbl: [(cbpHL,
                       label: block_cbpHL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpHL: // global
           I64[Sp] = block_cbpHN_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpI0; else goto cbpHO;
       ubpI0: // global
           call _cbpHN(R1) args: 0, res: 0, upd: 0;
       cbpHO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpHN() //  [R1]
         { info_tbl: [(cbpHN,
                       label: block_cbpHN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpHN: // global
           I64[Sp] = block_cbpHT_info;
           R2 = P64[R1 + 7];
           _sborN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sborN::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpHT() //  []
         { info_tbl: [(cbpHT,
                       label: block_cbpHT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpHT: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpIP_srtd" {
     ubpIP_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 io_sborW_entry() //  [R1]
         { info_tbl: [(cbpIf,
                       label: io_sborW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpIf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpIj; else goto cbpIk;
       cbpIj: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpIk: // global
           I64[Sp - 16] = block_cbpIa_info;
           _sborR::P64 = P64[R1 + 15];
           R5 = _sborR::P64;
           R4 = GHC.IO.Handle.hGetBuffering2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetBuffering_fun_closure;
           P64[Sp - 8] = _sborR::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpIa() //  [R1]
         { info_tbl: [(cbpIa,
                       label: block_cbpIa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpIa: // global
           I64[Sp] = block_cbpIc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpIp; else goto cbpId;
       ubpIp: // global
           call _cbpIc(R1) args: 0, res: 0, upd: 0;
       cbpId: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpIc() //  [R1]
         { info_tbl: [(cbpIc,
                       label: block_cbpIc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpIc: // global
           I64[Sp] = block_cbpIi_info;
           R2 = P64[R1 + 7];
           _sbos3::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbos3::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpIi() //  []
         { info_tbl: [(cbpIi,
                       label: block_cbpIi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpIi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpIQ_srtd" {
     ubpIQ_srtd:
         const SboCL_srt+456;
         const 47;
         const 123145302310913;
 },
 GHC.IO.Handle.hGetBuffering1_entry() //  [R2]
         { info_tbl: [(cbpIu,
                       label: GHC.IO.Handle.hGetBuffering1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpIu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpIv; else goto cbpIw;
       cbpIv: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetBuffering1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpIw: // global
           I64[Sp - 8] = block_cbpHz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpIN; else goto cbpHA;
       ubpIN: // global
           call _cbpHz(R1) args: 0, res: 0, upd: 0;
       cbpHA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpIR_srtd" {
     ubpIR_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbpHz() //  [R1]
         { info_tbl: [(cbpHz,
                       label: block_cbpHz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpHz: // global
           if (R1 & 7 == 1) goto cbpIr; else goto cbpIs;
       cbpIr: // global
           I64[Sp - 16] = block_cbpHE_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbpIs: // global
           I64[Sp - 16] = block_cbpI3_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpIS_srtd" {
     ubpIS_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbpHE() //  [R1]
         { info_tbl: [(cbpHE,
                       label: block_cbpHE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpHE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpIA; else goto cbpIz;
       cbpIA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpIz: // global
           I64[Hp - 16] = io_sborG_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpHG::P64 = Hp - 15;
           if (R1 == 0) goto cbpIE; else goto cbpID;
       cbpIE: // global
           R1 = _cbpHG::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpID: // global
           R1 = _cbpHG::P64;
           Sp = Sp + 24;
           call io_sborG_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpIT_srtd" {
     ubpIT_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbpI3() //  [R1]
         { info_tbl: [(cbpI3,
                       label: block_cbpI3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpI3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpII; else goto cbpIH;
       cbpII: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpIH: // global
           I64[Hp - 16] = io_sborW_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpI5::P64 = Hp - 15;
           if (R1 == 0) goto cbpIM; else goto cbpIL;
       cbpIM: // global
           R1 = _cbpI5::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpIL: // global
           R1 = _cbpI5::P64;
           Sp = Sp + 24;
           call io_sborW_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.790447777 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering_closure" {
     GHC.IO.Handle.hGetBuffering_closure:
         const GHC.IO.Handle.hGetBuffering_info;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering_entry() //  [R2]
         { info_tbl: [(cbpIY,
                       label: GHC.IO.Handle.hGetBuffering_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpIY: // global
           R2 = R2;
           call GHC.IO.Handle.hGetBuffering1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.791138159 UTC

[section ""cstring" . GHC.IO.Handle.hIsWritable4_bytes" {
     GHC.IO.Handle.hIsWritable4_bytes:
         I8[] [104,73,115,87,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.791850504 UTC

[section ""data" . GHC.IO.Handle.hIsWritable3_closure" {
     GHC.IO.Handle.hIsWritable3_closure:
         const GHC.IO.Handle.hIsWritable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsWritable3_entry() //  [R1]
         { info_tbl: [(cbpJ7,
                       label: GHC.IO.Handle.hIsWritable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpJ7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpJ8; else goto cbpJ9;
       cbpJ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpJ9: // global
           (_cbpJ4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpJ4::I64 == 0) goto cbpJ6; else goto cbpJ5;
       cbpJ6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpJ5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpJ4::I64;
           R2 = GHC.IO.Handle.hIsWritable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.793490008 UTC

[section ""data" . GHC.IO.Handle.hIsWritable2_closure" {
     GHC.IO.Handle.hIsWritable2_closure:
         const GHC.IO.Handle.hIsWritable2_info;
         const 0;
 },
 sat_sbosr_entry() //  [R1]
         { info_tbl: [(cbpJB,
                       label: sat_sbosr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpJB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpJC; else goto cbpJD;
       cbpJC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpJD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbpJs_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpJR; else goto cbpJt;
       ubpJR: // global
           call _cbpJs(R1) args: 0, res: 0, upd: 0;
       cbpJt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpJs() //  [R1]
         { info_tbl: [(cbpJs,
                       label: block_cbpJs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpJs: // global
           _cbpJA::P64 = R1 & 7;
           if (_cbpJA::P64 < 4) goto cbpJw; else goto ubpJQ;
       cbpJw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ubpJQ: // global
           if (_cbpJA::P64 != 5) goto cbpJz; else goto cbpJz;
       cbpJz: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubpKe_srtd" {
     ubpKe_srtd:
         const SboCL_srt+328;
         const 64;
         const 9259400833873739777;
 },
 GHC.IO.Handle.hIsWritable2_entry() //  [R2]
         { info_tbl: [(cbpJS,
                       label: GHC.IO.Handle.hIsWritable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpJS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpJT; else goto cbpJU;
       cbpJT: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsWritable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpJU: // global
           I64[Sp - 8] = block_cbpJe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpKd; else goto cbpJf;
       ubpKd: // global
           call _cbpJe(R1) args: 0, res: 0, upd: 0;
       cbpJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpKf_srtd" {
     ubpKf_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbpJe() //  [R1]
         { info_tbl: [(cbpJe,
                       label: block_cbpJe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpJe: // global
           I64[Sp - 8] = block_cbpJj_info;
           _sbos8::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbos8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpKc; else goto cbpJk;
       ubpKc: // global
           call _cbpJj(R1) args: 0, res: 0, upd: 0;
       cbpJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpKg_srtd" {
     ubpKg_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbpJj() //  [R1]
         { info_tbl: [(cbpJj,
                       label: block_cbpJj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpJj: // global
           _cbpKa::P64 = R1 & 7;
           if (_cbpKa::P64 == 1) goto cbpK5; else goto ubpKb;
       cbpK5: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       ubpKb: // global
           if (_cbpKa::P64 == 2) goto cbpK9; else goto cbpJY;
       cbpK9: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbpJY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbpK1; else goto cbpK0;
       cbpK1: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpK0: // global
           I64[Hp - 40] = sat_sbosr_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.796239789 UTC

[section ""data" . GHC.IO.Handle.hIsWritable1_closure" {
     GHC.IO.Handle.hIsWritable1_closure:
         const GHC.IO.Handle.hIsWritable1_info;
         const 0;
 },
 section ""relreadonly" . ubpL6_srtd" {
     ubpL6_srtd:
         const SboCL_srt+456;
         const 49;
         const 422212465065985;
 },
 io_sbosD_entry() //  [R1]
         { info_tbl: [(cbpKC,
                       label: io_sbosD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpKC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpKG; else goto cbpKH;
       cbpKG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpKH: // global
           I64[Sp - 16] = block_cbpKx_info;
           _sbosz::P64 = P64[R1 + 15];
           R5 = _sbosz::P64;
           R4 = GHC.IO.Handle.hIsWritable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsWritable3_closure;
           P64[Sp - 8] = _sbosz::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpKx() //  [R1]
         { info_tbl: [(cbpKx,
                       label: block_cbpKx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpKx: // global
           I64[Sp] = block_cbpKz_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpKM; else goto cbpKA;
       ubpKM: // global
           call _cbpKz(R1) args: 0, res: 0, upd: 0;
       cbpKA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpKz() //  [R1]
         { info_tbl: [(cbpKz,
                       label: block_cbpKz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpKz: // global
           I64[Sp] = block_cbpKF_info;
           R2 = P64[R1 + 7];
           _sbosK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbosK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpKF() //  []
         { info_tbl: [(cbpKF,
                       label: block_cbpKF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpKF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpL7_srtd" {
     ubpL7_srtd:
         const SboCL_srt+456;
         const 50;
         const 985162418487297;
 },
 GHC.IO.Handle.hIsWritable1_entry() //  [R2]
         { info_tbl: [(cbpKR,
                       label: GHC.IO.Handle.hIsWritable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpKR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpKS; else goto cbpKT;
       cbpKS: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsWritable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpKT: // global
           I64[Sp - 8] = block_cbpKl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpL5; else goto cbpKm;
       ubpL5: // global
           call _cbpKl(R1) args: 0, res: 0, upd: 0;
       cbpKm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpL8_srtd" {
     ubpL8_srtd:
         const SboCL_srt+456;
         const 49;
         const 422212465065985;
 },
 _cbpKl() //  [R1]
         { info_tbl: [(cbpKl,
                       label: block_cbpKl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpKl: // global
           if (R1 & 7 == 1) goto cbpKO; else goto cbpKP;
       cbpKO: // global
           I64[Sp - 16] = block_cbpKq_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbpKP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpL9_srtd" {
     ubpL9_srtd:
         const SboCL_srt+456;
         const 49;
         const 422212465065985;
 },
 _cbpKq() //  [R1]
         { info_tbl: [(cbpKq,
                       label: block_cbpKq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpKq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpKX; else goto cbpKW;
       cbpKX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpKW: // global
           I64[Hp - 16] = io_sbosD_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpKs::P64 = Hp - 15;
           if (R1 == 0) goto cbpL1; else goto cbpL0;
       cbpL1: // global
           R1 = _cbpKs::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpL0: // global
           R1 = _cbpKs::P64;
           Sp = Sp + 24;
           call io_sbosD_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.798713321 UTC

[section ""data" . GHC.IO.Handle.hIsWritable_closure" {
     GHC.IO.Handle.hIsWritable_closure:
         const GHC.IO.Handle.hIsWritable_info;
         const 0;
 },
 GHC.IO.Handle.hIsWritable_entry() //  [R2]
         { info_tbl: [(cbpLe,
                       label: GHC.IO.Handle.hIsWritable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpLe: // global
           R2 = R2;
           call GHC.IO.Handle.hIsWritable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.799407902 UTC

[section ""cstring" . GHC.IO.Handle.hIsReadable4_bytes" {
     GHC.IO.Handle.hIsReadable4_bytes:
         I8[] [104,73,115,82,101,97,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.800115618 UTC

[section ""data" . GHC.IO.Handle.hIsReadable3_closure" {
     GHC.IO.Handle.hIsReadable3_closure:
         const GHC.IO.Handle.hIsReadable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsReadable3_entry() //  [R1]
         { info_tbl: [(cbpLn,
                       label: GHC.IO.Handle.hIsReadable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpLn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpLo; else goto cbpLp;
       cbpLo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpLp: // global
           (_cbpLk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpLk::I64 == 0) goto cbpLm; else goto cbpLl;
       cbpLm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpLl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpLk::I64;
           R2 = GHC.IO.Handle.hIsReadable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.801692701 UTC

[section ""data" . GHC.IO.Handle.hIsReadable2_closure" {
     GHC.IO.Handle.hIsReadable2_closure:
         const GHC.IO.Handle.hIsReadable2_info;
         const 0;
 },
 sat_sbotb_entry() //  [R1]
         { info_tbl: [(cbpLQ,
                       label: sat_sbotb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpLQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpLR; else goto cbpLS;
       cbpLR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpLS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbpLI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpM3; else goto cbpLJ;
       ubpM3: // global
           call _cbpLI(R1) args: 0, res: 0, upd: 0;
       cbpLJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpLI() //  [R1]
         { info_tbl: [(cbpLI,
                       label: block_cbpLI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpLI: // global
           _cbpLP::P64 = R1 & 7;
           if (_cbpLP::P64 == 3) goto cbpLO; else goto ubpM2;
       ubpM2: // global
           if (_cbpLP::P64 == 6) goto cbpLO; else goto cbpLM;
       cbpLO: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbpLM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubpMq_srtd" {
     ubpMq_srtd:
         const SboCL_srt+328;
         const 67;
         const 36028797018963969;
         const 4;
 },
 GHC.IO.Handle.hIsReadable2_entry() //  [R2]
         { info_tbl: [(cbpM4,
                       label: GHC.IO.Handle.hIsReadable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpM4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpM5; else goto cbpM6;
       cbpM5: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsReadable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpM6: // global
           I64[Sp - 8] = block_cbpLu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpMp; else goto cbpLv;
       ubpMp: // global
           call _cbpLu(R1) args: 0, res: 0, upd: 0;
       cbpLv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpMr_srtd" {
     ubpMr_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbpLu() //  [R1]
         { info_tbl: [(cbpLu,
                       label: block_cbpLu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpLu: // global
           I64[Sp - 8] = block_cbpLz_info;
           _sbosS::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbosS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpMo; else goto cbpLA;
       ubpMo: // global
           call _cbpLz(R1) args: 0, res: 0, upd: 0;
       cbpLA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpMs_srtd" {
     ubpMs_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbpLz() //  [R1]
         { info_tbl: [(cbpLz,
                       label: block_cbpLz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpLz: // global
           _cbpMm::P64 = R1 & 7;
           if (_cbpMm::P64 == 1) goto cbpMh; else goto ubpMn;
       cbpMh: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       ubpMn: // global
           if (_cbpMm::P64 == 2) goto cbpMl; else goto cbpMa;
       cbpMl: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbpMa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbpMd; else goto cbpMc;
       cbpMd: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpMc: // global
           I64[Hp - 40] = sat_sbotb_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.804443883 UTC

[section ""data" . GHC.IO.Handle.hIsReadable1_closure" {
     GHC.IO.Handle.hIsReadable1_closure:
         const GHC.IO.Handle.hIsReadable1_info;
         const 0;
 },
 section ""relreadonly" . ubpNi_srtd" {
     ubpNi_srtd:
         const SboCL_srt+456;
         const 52;
         const 3377699720527873;
 },
 io_sbotn_entry() //  [R1]
         { info_tbl: [(cbpMO,
                       label: io_sbotn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpMO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpMS; else goto cbpMT;
       cbpMS: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpMT: // global
           I64[Sp - 16] = block_cbpMJ_info;
           _sbotj::P64 = P64[R1 + 15];
           R5 = _sbotj::P64;
           R4 = GHC.IO.Handle.hIsReadable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsReadable3_closure;
           P64[Sp - 8] = _sbotj::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpMJ() //  [R1]
         { info_tbl: [(cbpMJ,
                       label: block_cbpMJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpMJ: // global
           I64[Sp] = block_cbpML_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpMY; else goto cbpMM;
       ubpMY: // global
           call _cbpML(R1) args: 0, res: 0, upd: 0;
       cbpMM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpML() //  [R1]
         { info_tbl: [(cbpML,
                       label: block_cbpML_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpML: // global
           I64[Sp] = block_cbpMR_info;
           R2 = P64[R1 + 7];
           _sbotu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbotu::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpMR() //  []
         { info_tbl: [(cbpMR,
                       label: block_cbpMR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpMR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpNj_srtd" {
     ubpNj_srtd:
         const SboCL_srt+456;
         const 53;
         const 7881299347898369;
 },
 GHC.IO.Handle.hIsReadable1_entry() //  [R2]
         { info_tbl: [(cbpN3,
                       label: GHC.IO.Handle.hIsReadable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpN3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpN4; else goto cbpN5;
       cbpN4: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsReadable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpN5: // global
           I64[Sp - 8] = block_cbpMx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpNh; else goto cbpMy;
       ubpNh: // global
           call _cbpMx(R1) args: 0, res: 0, upd: 0;
       cbpMy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpNk_srtd" {
     ubpNk_srtd:
         const SboCL_srt+456;
         const 52;
         const 3377699720527873;
 },
 _cbpMx() //  [R1]
         { info_tbl: [(cbpMx,
                       label: block_cbpMx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpMx: // global
           if (R1 & 7 == 1) goto cbpN0; else goto cbpN1;
       cbpN0: // global
           I64[Sp - 16] = block_cbpMC_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbpN1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpNl_srtd" {
     ubpNl_srtd:
         const SboCL_srt+456;
         const 52;
         const 3377699720527873;
 },
 _cbpMC() //  [R1]
         { info_tbl: [(cbpMC,
                       label: block_cbpMC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpMC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpN9; else goto cbpN8;
       cbpN9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpN8: // global
           I64[Hp - 16] = io_sbotn_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpME::P64 = Hp - 15;
           if (R1 == 0) goto cbpNd; else goto cbpNc;
       cbpNd: // global
           R1 = _cbpME::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpNc: // global
           R1 = _cbpME::P64;
           Sp = Sp + 24;
           call io_sbotn_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.806762716 UTC

[section ""data" . GHC.IO.Handle.hIsReadable_closure" {
     GHC.IO.Handle.hIsReadable_closure:
         const GHC.IO.Handle.hIsReadable_info;
         const 0;
 },
 GHC.IO.Handle.hIsReadable_entry() //  [R2]
         { info_tbl: [(cbpNq,
                       label: GHC.IO.Handle.hIsReadable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpNq: // global
           R2 = R2;
           call GHC.IO.Handle.hIsReadable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.807485322 UTC

[section ""cstring" . GHC.IO.Handle.hIsClosed4_bytes" {
     GHC.IO.Handle.hIsClosed4_bytes:
         I8[] [104,73,115,67,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.808205962 UTC

[section ""data" . GHC.IO.Handle.hIsClosed3_closure" {
     GHC.IO.Handle.hIsClosed3_closure:
         const GHC.IO.Handle.hIsClosed3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsClosed3_entry() //  [R1]
         { info_tbl: [(cbpNz,
                       label: GHC.IO.Handle.hIsClosed3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpNz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpNA; else goto cbpNB;
       cbpNA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpNB: // global
           (_cbpNw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpNw::I64 == 0) goto cbpNy; else goto cbpNx;
       cbpNy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpNx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpNw::I64;
           R2 = GHC.IO.Handle.hIsClosed4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.809729639 UTC

[section ""data" . GHC.IO.Handle.hIsClosed2_closure" {
     GHC.IO.Handle.hIsClosed2_closure:
         const GHC.IO.Handle.hIsClosed2_info;
 },
 GHC.IO.Handle.hIsClosed2_entry() //  [R2]
         { info_tbl: [(cbpNJ,
                       label: GHC.IO.Handle.hIsClosed2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpNJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpNK; else goto cbpNL;
       cbpNK: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsClosed2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpNL: // global
           I64[Sp - 8] = block_cbpNG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpO9; else goto cbpNH;
       ubpO9: // global
           call _cbpNG(R1) args: 0, res: 0, upd: 0;
       cbpNH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpNG() //  [R1]
         { info_tbl: [(cbpNG,
                       label: block_cbpNG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpNG: // global
           I64[Sp - 8] = block_cbpNO_info;
           _sbotC::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbotC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpO8; else goto cbpNQ;
       ubpO8: // global
           call _cbpNO(R1) args: 0, res: 0, upd: 0;
       cbpNQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpNO() //  [R1]
         { info_tbl: [(cbpNO,
                       label: block_cbpNO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpNO: // global
           _sbotC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbpO3; else goto cbpNW;
       cbpO3: // global
           Hp = Hp + 24;
           _sbotT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpO6; else goto cbpO5;
       cbpO5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbotC::P64;
           P64[Hp] = GHC.Types.True_closure+2;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpNW: // global
           Hp = Hp + 24;
           _sbotT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpO6; else goto cbpNY;
       cbpO6: // global
           HpAlloc = 24;
           R1 = _sbotT::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpNY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbotC::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.812285637 UTC

[section ""data" . GHC.IO.Handle.hIsClosed1_closure" {
     GHC.IO.Handle.hIsClosed1_closure:
         const GHC.IO.Handle.hIsClosed1_info;
         const 0;
 },
 io_sbou4_entry() //  [R1]
         { info_tbl: [(cbpOv,
                       label: io_sbou4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpOz; else goto cbpOA;
       cbpOz: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpOA: // global
           I64[Sp - 16] = block_cbpOq_info;
           _sbou0::P64 = P64[R1 + 15];
           R5 = _sbou0::P64;
           R4 = GHC.IO.Handle.hIsClosed2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsClosed3_closure;
           P64[Sp - 8] = _sbou0::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpOq() //  [R1]
         { info_tbl: [(cbpOq,
                       label: block_cbpOq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOq: // global
           I64[Sp] = block_cbpOs_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpOF; else goto cbpOt;
       ubpOF: // global
           call _cbpOs(R1) args: 0, res: 0, upd: 0;
       cbpOt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpOs() //  [R1]
         { info_tbl: [(cbpOs,
                       label: block_cbpOs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOs: // global
           I64[Sp] = block_cbpOy_info;
           R2 = P64[R1 + 7];
           _sboub::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboub::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpOy() //  []
         { info_tbl: [(cbpOy,
                       label: block_cbpOy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbouk_entry() //  [R1]
         { info_tbl: [(cbpOU,
                       label: io_sbouk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpOY; else goto cbpOZ;
       cbpOY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpOZ: // global
           I64[Sp - 16] = block_cbpOP_info;
           _sbouf::P64 = P64[R1 + 15];
           R5 = _sbouf::P64;
           R4 = GHC.IO.Handle.hIsClosed2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsClosed3_closure;
           P64[Sp - 8] = _sbouf::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpOP() //  [R1]
         { info_tbl: [(cbpOP,
                       label: block_cbpOP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOP: // global
           I64[Sp] = block_cbpOR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpP4; else goto cbpOS;
       ubpP4: // global
           call _cbpOR(R1) args: 0, res: 0, upd: 0;
       cbpOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpOR() //  [R1]
         { info_tbl: [(cbpOR,
                       label: block_cbpOR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOR: // global
           I64[Sp] = block_cbpOX_info;
           R2 = P64[R1 + 7];
           _sbour::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbour::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpOX() //  []
         { info_tbl: [(cbpOX,
                       label: block_cbpOX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsClosed1_entry() //  [R2]
         { info_tbl: [(cbpP9,
                       label: GHC.IO.Handle.hIsClosed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpP9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpPa; else goto cbpPb;
       cbpPa: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsClosed1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpPb: // global
           I64[Sp - 8] = block_cbpOe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpPs; else goto cbpOf;
       ubpPs: // global
           call _cbpOe(R1) args: 0, res: 0, upd: 0;
       cbpOf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpOe() //  [R1]
         { info_tbl: [(cbpOe,
                       label: block_cbpOe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOe: // global
           if (R1 & 7 == 1) goto cbpP6; else goto cbpP7;
       cbpP6: // global
           I64[Sp - 16] = block_cbpOj_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbpP7: // global
           I64[Sp - 16] = block_cbpOI_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbpOj() //  [R1]
         { info_tbl: [(cbpOj,
                       label: block_cbpOj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpPf; else goto cbpPe;
       cbpPf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpPe: // global
           I64[Hp - 16] = io_sbou4_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpOl::P64 = Hp - 15;
           if (R1 == 0) goto cbpPj; else goto cbpPi;
       cbpPj: // global
           R1 = _cbpOl::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpPi: // global
           R1 = _cbpOl::P64;
           Sp = Sp + 24;
           call io_sbou4_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpOI() //  [R1]
         { info_tbl: [(cbpOI,
                       label: block_cbpOI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpOI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpPn; else goto cbpPm;
       cbpPn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpPm: // global
           I64[Hp - 16] = io_sbouk_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpOK::P64 = Hp - 15;
           if (R1 == 0) goto cbpPr; else goto cbpPq;
       cbpPr: // global
           R1 = _cbpOK::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpPq: // global
           R1 = _cbpOK::P64;
           Sp = Sp + 24;
           call io_sbouk_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.815503126 UTC

[section ""data" . GHC.IO.Handle.hIsClosed_closure" {
     GHC.IO.Handle.hIsClosed_closure:
         const GHC.IO.Handle.hIsClosed_info;
         const 0;
 },
 GHC.IO.Handle.hIsClosed_entry() //  [R2]
         { info_tbl: [(cbpPx,
                       label: GHC.IO.Handle.hIsClosed_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpPx: // global
           R2 = R2;
           call GHC.IO.Handle.hIsClosed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.816242171 UTC

[section ""cstring" . GHC.IO.Handle.hIsOpen4_bytes" {
     GHC.IO.Handle.hIsOpen4_bytes:
         I8[] [104,73,115,79,112,101,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.819941839 UTC

[section ""data" . GHC.IO.Handle.hIsOpen3_closure" {
     GHC.IO.Handle.hIsOpen3_closure:
         const GHC.IO.Handle.hIsOpen3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsOpen3_entry() //  [R1]
         { info_tbl: [(cbpPG,
                       label: GHC.IO.Handle.hIsOpen3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpPG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpPH; else goto cbpPI;
       cbpPH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpPI: // global
           (_cbpPD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpPD::I64 == 0) goto cbpPF; else goto cbpPE;
       cbpPF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpPE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpPD::I64;
           R2 = GHC.IO.Handle.hIsOpen4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.82161484 UTC

[section ""data" . GHC.IO.Handle.hIsOpen2_closure" {
     GHC.IO.Handle.hIsOpen2_closure:
         const GHC.IO.Handle.hIsOpen2_info;
 },
 GHC.IO.Handle.hIsOpen2_entry() //  [R2]
         { info_tbl: [(cbpPQ,
                       label: GHC.IO.Handle.hIsOpen2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpPQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpPR; else goto cbpPS;
       cbpPR: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsOpen2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpPS: // global
           I64[Sp - 8] = block_cbpPN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpQo; else goto cbpPO;
       ubpQo: // global
           call _cbpPN(R1) args: 0, res: 0, upd: 0;
       cbpPO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpPN() //  [R1]
         { info_tbl: [(cbpPN,
                       label: block_cbpPN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpPN: // global
           I64[Sp - 8] = block_cbpPV_info;
           _sbouw::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbouw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpQn; else goto cbpPX;
       ubpQn: // global
           call _cbpPV(R1) args: 0, res: 0, upd: 0;
       cbpPX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpPV() //  [R1]
         { info_tbl: [(cbpPV,
                       label: block_cbpPV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpPV: // global
           _sbouw::P64 = P64[Sp + 8];
           _cbpQl::P64 = R1 & 7;
           if (_cbpQl::P64 == 1) goto cbpQa; else goto ubpQm;
       cbpQa: // global
           Hp = Hp + 24;
           _sbouN::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpQk; else goto cbpQc;
       cbpQc: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbouw::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ubpQm: // global
           if (_cbpQl::P64 == 2) goto cbpQh; else goto cbpQ3;
       cbpQh: // global
           Hp = Hp + 24;
           _sbouN::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpQk; else goto cbpQj;
       cbpQj: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbouw::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbpQ3: // global
           Hp = Hp + 24;
           _sbouN::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpQk; else goto cbpQ5;
       cbpQk: // global
           HpAlloc = 24;
           R1 = _sbouN::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpQ5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbouw::P64;
           P64[Hp] = GHC.Types.True_closure+2;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.824239136 UTC

[section ""data" . GHC.IO.Handle.hIsOpen1_closure" {
     GHC.IO.Handle.hIsOpen1_closure:
         const GHC.IO.Handle.hIsOpen1_info;
         const 0;
 },
 io_sbouZ_entry() //  [R1]
         { info_tbl: [(cbpQK,
                       label: io_sbouZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpQK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpQO; else goto cbpQP;
       cbpQO: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpQP: // global
           I64[Sp - 16] = block_cbpQF_info;
           _sbouV::P64 = P64[R1 + 15];
           R5 = _sbouV::P64;
           R4 = GHC.IO.Handle.hIsOpen2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsOpen3_closure;
           P64[Sp - 8] = _sbouV::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpQF() //  [R1]
         { info_tbl: [(cbpQF,
                       label: block_cbpQF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpQF: // global
           I64[Sp] = block_cbpQH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpQU; else goto cbpQI;
       ubpQU: // global
           call _cbpQH(R1) args: 0, res: 0, upd: 0;
       cbpQI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpQH() //  [R1]
         { info_tbl: [(cbpQH,
                       label: block_cbpQH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpQH: // global
           I64[Sp] = block_cbpQN_info;
           R2 = P64[R1 + 7];
           _sbov6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbov6::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpQN() //  []
         { info_tbl: [(cbpQN,
                       label: block_cbpQN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpQN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbovf_entry() //  [R1]
         { info_tbl: [(cbpR9,
                       label: io_sbovf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpR9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpRd; else goto cbpRe;
       cbpRd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbpRe: // global
           I64[Sp - 16] = block_cbpR4_info;
           _sbova::P64 = P64[R1 + 15];
           R5 = _sbova::P64;
           R4 = GHC.IO.Handle.hIsOpen2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsOpen3_closure;
           P64[Sp - 8] = _sbova::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpR4() //  [R1]
         { info_tbl: [(cbpR4,
                       label: block_cbpR4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpR4: // global
           I64[Sp] = block_cbpR6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpRj; else goto cbpR7;
       ubpRj: // global
           call _cbpR6(R1) args: 0, res: 0, upd: 0;
       cbpR7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpR6() //  [R1]
         { info_tbl: [(cbpR6,
                       label: block_cbpR6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpR6: // global
           I64[Sp] = block_cbpRc_info;
           R2 = P64[R1 + 7];
           _sbovm::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbovm::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpRc() //  []
         { info_tbl: [(cbpRc,
                       label: block_cbpRc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpRc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsOpen1_entry() //  [R2]
         { info_tbl: [(cbpRo,
                       label: GHC.IO.Handle.hIsOpen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpRo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpRp; else goto cbpRq;
       cbpRp: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsOpen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpRq: // global
           I64[Sp - 8] = block_cbpQt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpRH; else goto cbpQu;
       ubpRH: // global
           call _cbpQt(R1) args: 0, res: 0, upd: 0;
       cbpQu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpQt() //  [R1]
         { info_tbl: [(cbpQt,
                       label: block_cbpQt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpQt: // global
           if (R1 & 7 == 1) goto cbpRl; else goto cbpRm;
       cbpRl: // global
           I64[Sp - 16] = block_cbpQy_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbpRm: // global
           I64[Sp - 16] = block_cbpQX_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbpQy() //  [R1]
         { info_tbl: [(cbpQy,
                       label: block_cbpQy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpQy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpRu; else goto cbpRt;
       cbpRu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpRt: // global
           I64[Hp - 16] = io_sbouZ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpQA::P64 = Hp - 15;
           if (R1 == 0) goto cbpRy; else goto cbpRx;
       cbpRy: // global
           R1 = _cbpQA::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpRx: // global
           R1 = _cbpQA::P64;
           Sp = Sp + 24;
           call io_sbouZ_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbpQX() //  [R1]
         { info_tbl: [(cbpQX,
                       label: block_cbpQX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpQX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpRC; else goto cbpRB;
       cbpRC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbpRB: // global
           I64[Hp - 16] = io_sbovf_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbpQZ::P64 = Hp - 15;
           if (R1 == 0) goto cbpRG; else goto cbpRF;
       cbpRG: // global
           R1 = _cbpQZ::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbpRF: // global
           R1 = _cbpQZ::P64;
           Sp = Sp + 24;
           call io_sbovf_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.827348741 UTC

[section ""data" . GHC.IO.Handle.hIsOpen_closure" {
     GHC.IO.Handle.hIsOpen_closure:
         const GHC.IO.Handle.hIsOpen_info;
         const 0;
 },
 GHC.IO.Handle.hIsOpen_entry() //  [R2]
         { info_tbl: [(cbpRM,
                       label: GHC.IO.Handle.hIsOpen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpRM: // global
           R2 = R2;
           call GHC.IO.Handle.hIsOpen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.828273668 UTC

[section ""data" . GHC.IO.Handle.hGetPosn1_closure" {
     GHC.IO.Handle.hGetPosn1_closure:
         const GHC.IO.Handle.hGetPosn1_info;
         const 0;
 },
 GHC.IO.Handle.hGetPosn1_entry() //  [R2]
         { info_tbl: [(cbpRW,
                       label: GHC.IO.Handle.hGetPosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpRW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpRX; else goto cbpRY;
       cbpRX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetPosn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpRY: // global
           I64[Sp - 16] = block_cbpRT_info;
           R4 = GHC.IO.Handle.hGetPosn2_closure+2;
           R3 = R2;
           _sbovp::P64 = R2;
           R2 = GHC.IO.Handle.hGetPosn3_closure;
           P64[Sp - 8] = _sbovp::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpRT() //  [R1]
         { info_tbl: [(cbpRT,
                       label: block_cbpRT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpRT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpS1; else goto cbpS0;
       cbpS1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpS0: // global
           I64[Hp - 16] = GHC.IO.Handle.HandlePosn_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.829475426 UTC

[section ""data" . GHC.IO.Handle.hGetPosn_closure" {
     GHC.IO.Handle.hGetPosn_closure:
         const GHC.IO.Handle.hGetPosn_info;
         const 0;
 },
 GHC.IO.Handle.hGetPosn_entry() //  [R2]
         { info_tbl: [(cbpS6,
                       label: GHC.IO.Handle.hGetPosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpS6: // global
           R2 = R2;
           call GHC.IO.Handle.hGetPosn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.830166327 UTC

[section ""cstring" . GHC.IO.Handle.hClose3_bytes" {
     GHC.IO.Handle.hClose3_bytes:
         I8[] [104,67,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.830846932 UTC

[section ""data" . GHC.IO.Handle.hClose2_closure" {
     GHC.IO.Handle.hClose2_closure:
         const GHC.IO.Handle.hClose2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hClose2_entry() //  [R1]
         { info_tbl: [(cbpSf,
                       label: GHC.IO.Handle.hClose2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpSf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpSg; else goto cbpSh;
       cbpSg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpSh: // global
           (_cbpSc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpSc::I64 == 0) goto cbpSe; else goto cbpSd;
       cbpSe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpSd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpSc::I64;
           R2 = GHC.IO.Handle.hClose3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.832583648 UTC

[section ""data" . GHC.IO.Handle.$wlvl_closure" {
     GHC.IO.Handle.$wlvl_closure:
         const GHC.IO.Handle.$wlvl_info;
         const 0;
 },
 sat_sbovK_entry() //  [R1]
         { info_tbl: [(cbpSB,
                       label: sat_sbovK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpSB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbpSC; else goto cbpSD;
       cbpSC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpSD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbpSu_info;
           _sbovv::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbovv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubpT4; else goto cbpSv;
       ubpT4: // global
           call _cbpSu(R1) args: 0, res: 0, upd: 0;
       cbpSv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpSu() //  [R1]
         { info_tbl: [(cbpSu,
                       label: block_cbpSu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpSu: // global
           if (R1 & 7 == 1) goto cbpSy; else goto cbpSz;
       cbpSy: // global
           _sbovv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbpSG_info;
           R1 = _sbovv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubpT3; else goto cbpSI;
       ubpT3: // global
           call _cbpSG(R1) args: 0, res: 0, upd: 0;
       cbpSI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbpSz: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cbpSG() //  [R1]
         { info_tbl: [(cbpSG,
                       label: block_cbpSG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpSG: // global
           if (R1 & 7 == 1) goto cbpSO; else goto cbpSV;
       cbpSO: // global
           Hp = Hp + 16;
           _sbovD::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpSY; else goto cbpSQ;
       cbpSQ: // global
           _sbovE::P64 = P64[_sbovD::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbovE::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbpSV: // global
           Hp = Hp + 16;
           _sbovD::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpSY; else goto cbpSX;
       cbpSY: // global
           HpAlloc = 16;
           R1 = _sbovD::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbpSX: // global
           _sbovG::P64 = P64[_sbovD::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbovG::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbovM_entry() //  [R1]
         { info_tbl: [(cbpT7,
                       label: sat_sbovM_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpT7: // global
           _sbovM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbpT8; else goto cbpT9;
       cbpT9: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbpTb; else goto cbpTa;
       cbpTb: // global
           HpAlloc = 104;
           goto cbpT8;
       cbpT8: // global
           R1 = _sbovM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpTa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbovM::P64;
           _sbovv::P64 = P64[_sbovM::P64 + 16];
           _sbovw::P64 = P64[_sbovM::P64 + 24];
           _sbovx::P64 = P64[_sbovM::P64 + 32];
           _sbovy::P64 = P64[_sbovM::P64 + 40];
           _sbovz::P64 = P64[_sbovM::P64 + 48];
           I64[Hp - 96] = sat_sbovK_info;
           P64[Hp - 80] = _sbovv::P64;
           P64[Hp - 72] = _sbovz::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbovv::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sbovw::P64;
           P64[Hp - 24] = GHC.IO.Handle.hClose2_closure;
           P64[Hp - 16] = _sbovx::P64;
           P64[Hp - 8] = _sbovy::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.$wlvl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbpTc,
                       label: GHC.IO.Handle.$wlvl_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpTc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbpTg; else goto cbpTf;
       cbpTg: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$wlvl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbpTf: // global
           I64[Hp - 48] = sat_sbovM_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.836317755 UTC

[section ""data" . GHC.IO.Handle.hClose1_closure" {
     GHC.IO.Handle.hClose1_closure:
         const GHC.IO.Handle.hClose1_info;
         const 0;
 },
 section ""relreadonly" . ubpVf_srtd" {
     ubpVf_srtd:
         const SboCL_srt+240;
         const 94;
         const 54043195528445953;
         const 973078528;
 },
 GHC.IO.Handle.hClose1_entry() //  [R2]
         { info_tbl: [(cbpTs,
                       label: GHC.IO.Handle.hClose1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpTs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbpTt; else goto cbpTu;
       cbpTt: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hClose1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbpTu: // global
           I64[Sp - 8] = block_cbpTl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubpV9; else goto cbpTm;
       ubpV9: // global
           call _cbpTl(R1) args: 0, res: 0, upd: 0;
       cbpTm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpVg_srtd" {
     ubpVg_srtd:
         const SboCL_srt+240;
         const 93;
         const 54043195528445953;
         const 436207616;
 },
 _cbpTl() //  [R1]
         { info_tbl: [(cbpTl,
                       label: block_cbpTl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpTl: // global
           if (R1 & 7 == 1) goto cbpTp; else goto cbpTq;
       cbpTp: // global
           I64[Sp - 8] = block_cbpTx_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
       cbpTq: // global
           I64[Sp - 16] = block_cbpUg_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[R1 + 14];
           R3 = R1;
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpVh_srtd" {
     ubpVh_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbpTx() //  [R1]
         { info_tbl: [(cbpTx,
                       label: block_cbpTx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpTx: // global
           I64[Sp] = block_cbpTz_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubpVa; else goto cbpTC;
       ubpVa: // global
           call _cbpTz(R1) args: 0, res: 0, upd: 0;
       cbpTC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpVi_srtd" {
     ubpVi_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbpTz() //  [R1]
         { info_tbl: [(cbpTz,
                       label: block_cbpTz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpTz: // global
           if (R1 & 7 == 1) goto ubpV8; else goto cbpTS;
       ubpV8: // global
           Sp = Sp + 16;
           call _cbpUx() args: 0, res: 0, upd: 0;
       cbpTS: // global
           I64[Sp] = block_cbpTL_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubpVb; else goto cbpTM;
       ubpVb: // global
           call _cbpTL(R1) args: 0, res: 0, upd: 0;
       cbpTM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpVj_srtd" {
     ubpVj_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbpTL() //  [R1]
         { info_tbl: [(cbpTL,
                       label: block_cbpTL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpTL: // global
           I64[Sp - 16] = block_cbpTQ_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpVk_srtd" {
     ubpVk_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbpTQ() //  [R1]
         { info_tbl: [(cbpTQ,
                       label: block_cbpTQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpTQ: // global
           I64[Sp] = block_cbpTX_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpTX() //  [R1]
         { info_tbl: [(cbpTX,
                       label: block_cbpTX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpTX: // global
           if (R1 & 7 == 1) goto cbpU4; else goto cbpU9;
       cbpU4: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbpU9: // global
           I64[Sp + 16] = block_cbpU7_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpU7() //  [R1]
         { info_tbl: [(cbpU7,
                       label: block_cbpU7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpU7: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 39];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$wlvl_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpVl_srtd" {
     ubpVl_srtd:
         const SboCL_srt+240;
         const 93;
         const 54043195528445953;
         const 436207616;
 },
 _cbpUg() //  [R1]
         { info_tbl: [(cbpUg,
                       label: block_cbpUg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpUg: // global
           I64[Sp] = block_cbpUi_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpVm_srtd" {
     ubpVm_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbpUi() //  [R1]
         { info_tbl: [(cbpUi,
                       label: block_cbpUi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpUi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbpUr; else goto cbpUq;
       cbpUr: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbpUq: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 38;
           I64[Sp + 8] = block_cbpUm_info;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call Data.Maybe.catMaybes1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpVn_srtd" {
     ubpVn_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbpUm() //  [R1]
         { info_tbl: [(cbpUm,
                       label: block_cbpUm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpUm: // global
           if (R1 & 7 == 1) goto ubpV7; else goto cbpUH;
       ubpV7: // global
           Sp = Sp + 16;
           call _cbpUx() args: 0, res: 0, upd: 0;
       cbpUH: // global
           I64[Sp] = block_cbpUA_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubpVd; else goto cbpUB;
       ubpVd: // global
           call _cbpUA(R1) args: 0, res: 0, upd: 0;
       cbpUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpUx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpUx: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubpVo_srtd" {
     ubpVo_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbpUA() //  [R1]
         { info_tbl: [(cbpUA,
                       label: block_cbpUA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpUA: // global
           I64[Sp - 16] = block_cbpUF_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubpVp_srtd" {
     ubpVp_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbpUF() //  [R1]
         { info_tbl: [(cbpUF,
                       label: block_cbpUF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpUF: // global
           I64[Sp] = block_cbpUM_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbpUM() //  [R1]
         { info_tbl: [(cbpUM,
                       label: block_cbpUM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpUM: // global
           if (R1 & 7 == 1) goto cbpUT; else goto cbpUY;
       cbpUT: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbpUY: // global
           I64[Sp + 16] = block_cbpUW_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbpUW() //  [R1]
         { info_tbl: [(cbpUW,
                       label: block_cbpUW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpUW: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 39];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$wlvl_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.840413585 UTC

[section ""data" . GHC.IO.Handle.hClose_closure" {
     GHC.IO.Handle.hClose_closure:
         const GHC.IO.Handle.hClose_info;
         const 0;
 },
 GHC.IO.Handle.hClose_entry() //  [R2]
         { info_tbl: [(cbpVu,
                       label: GHC.IO.Handle.hClose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpVu: // global
           R2 = R2;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.841099207 UTC

[section ""data" . lvl28_rbnXa_closure" {
     lvl28_rbnXa_closure:
         const GHC.Types.C#_con_info;
         const 123;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.841705945 UTC

[section ""data" . lvl29_rbnXb_closure" {
     lvl29_rbnXb_closure:
         const GHC.Types.C#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.842266356 UTC

[section ""cstring" . lvl30_rbnXc_bytes" {
     lvl30_rbnXc_bytes:
         I8[] [100,117,112,108,101,120,32,40,114,101,97,100,45,119,114,105,116,101,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.842944946 UTC

[section ""data" . lvl31_rbnXd_closure" {
     lvl31_rbnXd_closure:
         const lvl31_rbnXd_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_rbnXd_entry() //  [R1]
         { info_tbl: [(cbpVD,
                       label: lvl31_rbnXd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpVD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpVE; else goto cbpVF;
       cbpVE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpVF: // global
           (_cbpVA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpVA::I64 == 0) goto cbpVC; else goto cbpVB;
       cbpVC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpVB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpVA::I64;
           R2 = lvl30_rbnXc_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.843821868 UTC

[section ""cstring" . lvl32_rbnXe_bytes" {
     lvl32_rbnXe_bytes:
         I8[] [110,111,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.844544135 UTC

[section ""data" . lvl33_rbnXf_closure" {
     lvl33_rbnXf_closure:
         const lvl33_rbnXf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl33_rbnXf_entry() //  [R1]
         { info_tbl: [(cbpVM,
                       label: lvl33_rbnXf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpVM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpVN; else goto cbpVO;
       cbpVN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpVO: // global
           (_cbpVJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpVJ::I64 == 0) goto cbpVL; else goto cbpVK;
       cbpVL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpVK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpVJ::I64;
           R2 = lvl32_rbnXe_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.84557788 UTC

[section ""cstring" . lvl34_rbnXg_bytes" {
     lvl34_rbnXg_bytes:
         I8[] [108,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.846262064 UTC

[section ""data" . lvl35_rbnXh_closure" {
     lvl35_rbnXh_closure:
         const lvl35_rbnXh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_rbnXh_entry() //  [R1]
         { info_tbl: [(cbpVV,
                       label: lvl35_rbnXh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpVV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpVW; else goto cbpVX;
       cbpVW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpVX: // global
           (_cbpVS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpVS::I64 == 0) goto cbpVU; else goto cbpVT;
       cbpVU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpVT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpVS::I64;
           R2 = lvl34_rbnXg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.847099185 UTC

[section ""cstring" . lvl36_rbnXi_bytes" {
     lvl36_rbnXi_bytes:
         I8[] [115,104,111,119,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.847803895 UTC

[section ""data" . lvl37_rbnXj_closure" {
     lvl37_rbnXj_closure:
         const lvl37_rbnXj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_rbnXj_entry() //  [R1]
         { info_tbl: [(cbpW4,
                       label: lvl37_rbnXj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpW4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpW5; else goto cbpW6;
       cbpW5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpW6: // global
           (_cbpW1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpW1::I64 == 0) goto cbpW3; else goto cbpW2;
       cbpW3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpW2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpW1::I64;
           R2 = lvl36_rbnXi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.84867532 UTC

[section ""cstring" . lvl38_rbnXk_bytes" {
     lvl38_rbnXk_bytes:
         I8[] [108,111,99,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.849215464 UTC

[section ""cstring" . lvl39_rbnXl_bytes" {
     lvl39_rbnXl_bytes:
         I8[] [116,121,112,101,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.849756165 UTC

[section ""cstring" . lvl40_rbnXm_bytes" {
     lvl40_rbnXm_bytes:
         I8[] [98,117,102,102,101,114,105,110,103,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.850309052 UTC

[section ""cstring" . lvl41_rbnXn_bytes" {
     lvl41_rbnXn_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.851006443 UTC

[section ""data" . lvl42_rbnXo_closure" {
     lvl42_rbnXo_closure:
         const lvl42_rbnXo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rbnXo_entry() //  [R1]
         { info_tbl: [(cbpWd,
                       label: lvl42_rbnXo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpWd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpWe; else goto cbpWf;
       cbpWe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpWf: // global
           (_cbpWa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpWa::I64 == 0) goto cbpWc; else goto cbpWb;
       cbpWc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpWb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpWa::I64;
           R2 = lvl41_rbnXn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.852079936 UTC

[section ""data" . lvl43_rbnXp_closure" {
     lvl43_rbnXp_closure:
         const lvl43_rbnXp_info;
         const 0;
         const 0;
         const 0;
 },
 lvl43_rbnXp_entry() //  [R1]
         { info_tbl: [(cbpWm,
                       label: lvl43_rbnXp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpWm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpWn; else goto cbpWo;
       cbpWn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpWo: // global
           (_cbpWj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpWj::I64 == 0) goto cbpWl; else goto cbpWk;
       cbpWl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpWk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpWj::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = lvl33_rbnXf_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.85313334 UTC

[section ""data" . lvl44_rbnXq_closure" {
     lvl44_rbnXq_closure:
         const lvl44_rbnXq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rbnXq_entry() //  [R1]
         { info_tbl: [(cbpWv,
                       label: lvl44_rbnXq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpWv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpWw; else goto cbpWx;
       cbpWw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpWx: // global
           (_cbpWs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpWs::I64 == 0) goto cbpWu; else goto cbpWt;
       cbpWu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpWt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpWs::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = lvl35_rbnXh_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.854034756 UTC

[section ""cstring" . lvl45_rbnXr_bytes" {
     lvl45_rbnXr_bytes:
         I8[] [98,108,111,99,107,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.854605591 UTC

[section ""data" . lvl46_rbnXs_closure" {
     lvl46_rbnXs_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const lvl42_rbnXo_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.855364733 UTC

[section ""data" . lvl47_rbnXt_closure" {
     lvl47_rbnXt_closure:
         const lvl47_rbnXt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl47_rbnXt_entry() //  [R1]
         { info_tbl: [(cbpWE,
                       label: lvl47_rbnXt_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpWE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbpWF; else goto cbpWG;
       cbpWF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpWG: // global
           (_cbpWB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbpWB::I64 == 0) goto cbpWD; else goto cbpWC;
       cbpWD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbpWC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbpWB::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.861445355 UTC

[section ""data" . GHC.IO.Handle.hShow2_closure" {
     GHC.IO.Handle.hShow2_closure:
         const GHC.IO.Handle.hShow2_info;
         const 0;
 },
 sat_sboxg_entry() //  [R1]
         { info_tbl: [(cbpXM,
                       label: sat_sboxg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpXM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbpXS; else goto cbpXT;
       cbpXS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpXT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbpXE_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _cbpXE() //  []
         { info_tbl: [(cbpXE,
                       label: block_cbpXE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpXE: // global
           _sbox5::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cbpXJ_info;
           R1 = _sbox5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubpY0; else goto cbpXK;
       ubpY0: // global
           call _cbpXJ(R1) args: 0, res: 0, upd: 0;
       cbpXK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpXJ() //  [R1]
         { info_tbl: [(cbpXJ,
                       label: block_cbpXJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpXJ: // global
           I64[Sp] = block_cbpXP_info;
           R4 = lvl46_rbnXs_closure+2;
           R3 = I64[R1 + 31];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbpXP() //  [R1, R2]
         { info_tbl: [(cbpXP,
                       label: block_cbpXP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpXP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpXZ; else goto cbpXY;
       cbpXZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbpXY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxo_entry() //  [R1]
         { info_tbl: [(cbpYa,
                       label: sat_sboxo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpYa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbpYg; else goto cbpYh;
       cbpYg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpYh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbpY7_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubpYm; else goto cbpY8;
       ubpYm: // global
           call _cbpY7(R1) args: 0, res: 0, upd: 0;
       cbpY8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpY7() //  [R1]
         { info_tbl: [(cbpY7,
                       label: block_cbpY7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpY7: // global
           I64[Sp] = block_cbpYd_info;
           R4 = lvl46_rbnXs_closure+2;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbpYd() //  [R1, R2]
         { info_tbl: [(cbpYd,
                       label: block_cbpYd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpYd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpYl; else goto cbpYk;
       cbpYl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbpYk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxq_entry() //  [R1]
         { info_tbl: [(cbpYs,
                       label: sat_sboxq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpYs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbpYt; else goto cbpYu;
       cbpYt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpYu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbpXo_info;
           _sbowP::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbowP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubpYO; else goto cbpXp;
       ubpYO: // global
           call _cbpXo(R1) args: 0, res: 0, upd: 0;
       cbpXp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpXo() //  [R1]
         { info_tbl: [(cbpXo,
                       label: block_cbpXo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpXo: // global
           _cbpYr::P64 = R1 & 7;
           if (_cbpYr::P64 < 3) goto ubpYM; else goto cbpYq;
       ubpYM: // global
           if (_cbpYr::P64 < 2) goto cbpYo; else goto cbpYp;
       cbpYo: // global
           R1 = lvl43_rbnXp_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbpYp: // global
           R1 = lvl44_rbnXq_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbpYq: // global
           I64[Sp] = block_cbpXv_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto ubpYN; else goto cbpXw;
       ubpYN: // global
           call _cbpXv(R1) args: 0, res: 0, upd: 0;
       cbpXw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpXv() //  [R1]
         { info_tbl: [(cbpXv,
                       label: block_cbpXv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpXv: // global
           if (R1 & 7 == 1) goto cbpYC; else goto cbpYH;
       cbpYC: // global
           Hp = Hp + 48;
           _sbox1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpYK; else goto cbpYE;
       cbpYE: // global
           I64[Hp - 40] = sat_sboxg_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = lvl45_rbnXr_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cbpYH: // global
           Hp = Hp + 48;
           _sbox1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpYK; else goto cbpYJ;
       cbpYK: // global
           HpAlloc = 48;
           R1 = _sbox1::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbpYJ: // global
           _sboxi::P64 = P64[_sbox1::P64 + 6];
           I64[Hp - 40] = sat_sboxo_info;
           P64[Hp - 24] = _sboxi::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = lvl45_rbnXr_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 karg_sbowY_entry() //  [R1]
         { info_tbl: [(cbpYP,
                       label: karg_sbowY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpYP: // global
           _sbowY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbpYQ; else goto cbpYR;
       cbpYR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpYT; else goto cbpYS;
       cbpYT: // global
           HpAlloc = 32;
           goto cbpYQ;
       cbpYQ: // global
           R1 = _sbowY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpYS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbowY::P64;
           _sbowN::P64 = P64[_sbowY::P64 + 16];
           _sbowP::P64 = P64[_sbowY::P64 + 24];
           I64[Hp - 24] = sat_sboxq_info;
           P64[Hp - 8] = _sbowN::P64;
           P64[Hp] = _sbowP::P64;
           R3 = Hp - 24;
           R2 = lvl40_rbnXm_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxz_entry() //  [R1]
         { info_tbl: [(cbpZ1,
                       label: sat_sboxz_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpZ1: // global
           _sboxz::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbpZ2; else goto cbpZ3;
       cbpZ3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbpZ5; else goto cbpZ4;
       cbpZ5: // global
           HpAlloc = 32;
           goto cbpZ2;
       cbpZ2: // global
           R1 = _sboxz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbpZ4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sboxz::P64;
           _sbowA::P64 = P64[_sboxz::P64 + 16];
           _sbowN::P64 = P64[_sboxz::P64 + 24];
           _sbowP::P64 = P64[_sboxz::P64 + 32];
           _sbowX::P64 = P64[_sboxz::P64 + 40];
           I64[Hp - 24] = karg_sbowY_info;
           P64[Hp - 8] = _sbowN::P64;
           P64[Hp] = _sbowP::P64;
           I64[Sp - 40] = block_cbpYU_info;
           R1 = _sbowA::P64;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sbowX::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubpZX; else goto cbpYV;
       ubpZX: // global
           call _cbpYU(R1) args: 0, res: 0, upd: 0;
       cbpYV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpYU() //  [R1]
         { info_tbl: [(cbpYU,
                       label: block_cbpYU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpYU: // global
           if (R1 & 7 == 1) goto cbpYY; else goto cbpYZ;
       cbpYY: // global
           I64[Sp] = block_cbpZ8_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubpZW; else goto cbpZa;
       ubpZW: // global
           call _cbpZ8(R1) args: 0, res: 0, upd: 0;
       cbpZa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbpYZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbpZR; else goto cbpZQ;
       cbpZR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbpZQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 14;
           R2 = lvl31_rbnXd_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 _cbpZ8() //  [R1]
         { info_tbl: [(cbpZ8,
                       label: block_cbpZ8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpZ8: // global
           _cbpXg::P64 = P64[Sp + 8];
           _cbpZS::P64 = R1 & 7;
           if (_cbpZS::P64 < 5) goto ubpZT; else goto ubpZV;
       ubpZT: // global
           if (_cbpZS::P64 < 4) goto ubpZU; else goto cbpZu;
       ubpZU: // global
           if (_cbpZS::P64 < 3) goto cbpZg; else goto cbpZn;
       cbpZg: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpZL; else goto cbpZi;
       cbpZi: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbpXg::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbpZn: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpZL; else goto cbpZp;
       cbpZp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbpXg::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbpZu: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpZL; else goto cbpZw;
       cbpZw: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbpXg::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       ubpZV: // global
           if (_cbpZS::P64 < 6) goto cbpZB; else goto cbpZI;
       cbpZB: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpZL; else goto cbpZD;
       cbpZD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbpXg::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbpZI: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbpZL; else goto cbpZK;
       cbpZL: // global
           HpAlloc = 24;
           R1 = _sboxs::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbpZK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbpXg::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxA_entry() //  [R1]
         { info_tbl: [(cbpZY,
                       label: sat_sboxA_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpZY: // global
           _sboxA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbpZZ; else goto cbq00;
       cbq00: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbq02; else goto cbq01;
       cbq02: // global
           HpAlloc = 48;
           goto cbpZZ;
       cbpZZ: // global
           R1 = _sboxA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq01: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sboxA::P64;
           _sbowA::P64 = P64[_sboxA::P64 + 16];
           _sbowN::P64 = P64[_sboxA::P64 + 24];
           _sbowP::P64 = P64[_sboxA::P64 + 32];
           _sbowX::P64 = P64[_sboxA::P64 + 40];
           I64[Hp - 40] = sat_sboxz_info;
           P64[Hp - 24] = _sbowA::P64;
           P64[Hp - 16] = _sbowN::P64;
           P64[Hp - 8] = _sbowP::P64;
           P64[Hp] = _sbowX::P64;
           R3 = Hp - 40;
           R2 = lvl39_rbnXl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxC_entry() //  [R1]
         { info_tbl: [(cbq04,
                       label: sat_sboxC_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq04: // global
           _sboxC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbq05; else goto cbq06;
       cbq06: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbq08; else goto cbq07;
       cbq08: // global
           HpAlloc = 72;
           goto cbq05;
       cbq05: // global
           R1 = _sboxC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq07: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sboxC::P64;
           _sbowz::P64 = P64[_sboxC::P64 + 16];
           _sbowA::P64 = P64[_sboxC::P64 + 24];
           _sbowN::P64 = P64[_sboxC::P64 + 32];
           _sbowP::P64 = P64[_sboxC::P64 + 40];
           _sbowX::P64 = P64[_sboxC::P64 + 48];
           I64[Hp - 64] = sat_sboxA_info;
           P64[Hp - 48] = _sbowA::P64;
           P64[Hp - 40] = _sbowN::P64;
           P64[Hp - 32] = _sbowP::P64;
           P64[Hp - 24] = _sbowX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _sbowz::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxD_entry() //  [R1]
         { info_tbl: [(cbq09,
                       label: sat_sboxD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq09: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbq0a; else goto cbq0b;
       cbq0a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq0b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbpWU_info;
           _sbowz::P64 = P64[R1 + 16];
           _sbowA::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbowz::P64;
           P64[Sp - 24] = _sbowA::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubq0o; else goto cbpWV;
       ubq0o: // global
           call _cbpWU(R1) args: 0, res: 0, upd: 0;
       cbpWV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpWU() //  [R1]
         { info_tbl: [(cbpWU,
                       label: block_cbpWU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpWU: // global
           I64[Sp - 16] = block_cbpWZ_info;
           _sbowN::P64 = P64[R1 + 55];
           _sbowP::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _sbowP::P64;
           P64[Sp] = _sbowN::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubq0n; else goto cbpX0;
       ubq0n: // global
           call _cbpWZ(R1) args: 0, res: 0, upd: 0;
       cbpX0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbpWZ() //  [R1]
         { info_tbl: [(cbpWZ,
                       label: block_cbpWZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbpWZ: // global
           if (R1 & 7 == 1) goto cbq0l; else goto cbq0e;
       cbq0l: // global
           R1 = lvl47_rbnXt_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbq0e: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbq0h; else goto cbq0g;
       cbq0h: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbq0g: // global
           I64[Hp - 48] = sat_sboxC_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R3 = Hp - 48;
           R2 = lvl38_rbnXk_bytes;
           Sp = Sp + 40;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 act_sbowD_entry() //  [R1, R2]
         { info_tbl: [(cbq0q,
                       label: act_sbowD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq0q: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbq0u; else goto cbq0t;
       cbq0u: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbq0t: // global
           _sbowz::P64 = P64[R1 + 6];
           _sbowA::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sboxD_info;
           P64[Hp - 40] = _sbowz::P64;
           P64[Hp - 32] = _sbowA::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl28_rbnXa_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sboxT_entry() //  [R1, R2]
         { info_tbl: [(cbq0P,
                       label: sat_sboxT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq0P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq0Q; else goto cbq0R;
       cbq0Q: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbq0R: // global
           I64[Sp - 16] = block_cbq0M_info;
           _sboxN::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sboxN::P64;
           Sp = Sp - 16;
           call act_sbowD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq0M() //  [R1]
         { info_tbl: [(cbq0M,
                       label: block_cbq0M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq0M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbq0U; else goto cbq0T;
       cbq0U: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbq0T: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sboxL_entry() //  [R1]
         { info_tbl: [(cbq10,
                       label: io_sboxL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq10: // global
           _sboxL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbq14; else goto cbq15;
       cbq15: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbq17; else goto cbq16;
       cbq17: // global
           HpAlloc = 16;
           goto cbq14;
       cbq14: // global
           R1 = _sboxL::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbq16: // global
           _sbowD::P64 = P64[_sboxL::P64 + 7];
           _sboxF::P64 = P64[_sboxL::P64 + 15];
           _sboxH::P64 = P64[_sboxL::P64 + 23];
           I64[Hp - 8] = sat_sboxT_info;
           P64[Hp] = _sbowD::P64;
           I64[Sp - 16] = block_cbq0V_info;
           R5 = _sboxH::P64;
           R4 = Hp - 6;
           R3 = _sboxF::P64;
           R2 = lvl37_rbnXj_closure;
           P64[Sp - 8] = _sboxH::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbq0V() //  [R1]
         { info_tbl: [(cbq0V,
                       label: block_cbq0V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq0V: // global
           I64[Sp] = block_cbq0X_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubq1c; else goto cbq0Y;
       ubq1c: // global
           call _cbq0X(R1) args: 0, res: 0, upd: 0;
       cbq0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq0X() //  [R1]
         { info_tbl: [(cbq0X,
                       label: block_cbq0X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq0X: // global
           I64[Sp] = block_cbq13_info;
           R2 = P64[R1 + 7];
           _sboxZ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboxZ::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq13() //  []
         { info_tbl: [(cbq13,
                       label: block_cbq13_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq13: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sboyg_entry() //  [R1, R2]
         { info_tbl: [(cbq1u,
                       label: sat_sboyg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq1u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq1v; else goto cbq1w;
       cbq1v: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbq1w: // global
           I64[Sp - 16] = block_cbq1r_info;
           _sboya::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sboya::P64;
           Sp = Sp - 16;
           call act_sbowD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq1r() //  [R1]
         { info_tbl: [(cbq1r,
                       label: block_cbq1r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq1r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbq1z; else goto cbq1y;
       cbq1z: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbq1y: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sboy8_entry() //  [R1]
         { info_tbl: [(cbq1F,
                       label: io_sboy8_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq1F: // global
           _sboy8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbq1J; else goto cbq1K;
       cbq1K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbq1M; else goto cbq1L;
       cbq1M: // global
           HpAlloc = 16;
           goto cbq1J;
       cbq1J: // global
           R1 = _sboy8::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbq1L: // global
           _sbowD::P64 = P64[_sboy8::P64 + 7];
           _sboxF::P64 = P64[_sboy8::P64 + 15];
           _sboy3::P64 = P64[_sboy8::P64 + 23];
           I64[Hp - 8] = sat_sboyg_info;
           P64[Hp] = _sbowD::P64;
           I64[Sp - 16] = block_cbq1A_info;
           R5 = _sboy3::P64;
           R4 = Hp - 6;
           R3 = _sboxF::P64;
           R2 = lvl37_rbnXj_closure;
           P64[Sp - 8] = _sboy3::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbq1A() //  [R1]
         { info_tbl: [(cbq1A,
                       label: block_cbq1A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq1A: // global
           I64[Sp] = block_cbq1C_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubq1R; else goto cbq1D;
       ubq1R: // global
           call _cbq1C(R1) args: 0, res: 0, upd: 0;
       cbq1D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq1C() //  [R1]
         { info_tbl: [(cbq1C,
                       label: block_cbq1C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq1C: // global
           I64[Sp] = block_cbq1I_info;
           R2 = P64[R1 + 7];
           _sboym::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboym::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq1I() //  []
         { info_tbl: [(cbq1I,
                       label: block_cbq1I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq1I: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hShow2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbq1W,
                       label: GHC.IO.Handle.hShow2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq1W: // global
           _sbowB::P64 = R4;
           _sbowA::P64 = R3;
           _sbowz::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbq1X; else goto cbq1Y;
       cbq1Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbq20; else goto cbq1Z;
       cbq20: // global
           HpAlloc = 24;
           goto cbq1X;
       cbq1X: // global
           R4 = _sbowB::P64;
           R3 = _sbowA::P64;
           R2 = _sbowz::P64;
           R1 = GHC.IO.Handle.hShow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbq1Z: // global
           I64[Hp - 16] = act_sbowD_info;
           P64[Hp - 8] = _sbowz::P64;
           P64[Hp] = _sbowA::P64;
           I64[Sp - 16] = block_cbq0v_info;
           R1 = _sbowB::P64;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubq2h; else goto cbq0w;
       ubq2h: // global
           call _cbq0v(R1) args: 0, res: 0, upd: 0;
       cbq0w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq0v() //  [R1]
         { info_tbl: [(cbq0v,
                       label: block_cbq0v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq0v: // global
           if (R1 & 7 == 1) goto cbq1T; else goto cbq1U;
       cbq1T: // global
           I64[Sp - 16] = block_cbq0A_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbq1U: // global
           I64[Sp - 16] = block_cbq1f_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbq0A() //  [R1]
         { info_tbl: [(cbq0A,
                       label: block_cbq0A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq0A: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbq24; else goto cbq23;
       cbq24: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbq23: // global
           I64[Hp - 24] = io_sboxL_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbq0C::P64 = Hp - 23;
           if (R1 == 0) goto cbq28; else goto cbq27;
       cbq28: // global
           R1 = _cbq0C::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbq27: // global
           R1 = _cbq0C::P64;
           Sp = Sp + 32;
           call io_sboxL_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbq1f() //  [R1]
         { info_tbl: [(cbq1f,
                       label: block_cbq1f_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq1f: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbq2c; else goto cbq2b;
       cbq2c: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbq2b: // global
           I64[Hp - 24] = io_sboy8_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbq1h::P64 = Hp - 23;
           if (R1 == 0) goto cbq2g; else goto cbq2f;
       cbq2g: // global
           R1 = _cbq1h::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbq2f: // global
           R1 = _cbq1h::P64;
           Sp = Sp + 32;
           call io_sboy8_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.873182629 UTC

[section ""data" . GHC.IO.Handle.hShow1_closure" {
     GHC.IO.Handle.hShow1_closure:
         const GHC.IO.Handle.hShow1_info;
         const 0;
 },
 GHC.IO.Handle.hShow1_entry() //  [R2]
         { info_tbl: [(cbq2t,
                       label: GHC.IO.Handle.hShow1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq2t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbq2u; else goto cbq2v;
       cbq2u: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hShow1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbq2v: // global
           I64[Sp - 8] = block_cbq2m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubq2C; else goto cbq2n;
       ubq2C: // global
           call _cbq2m(R1) args: 0, res: 0, upd: 0;
       cbq2n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq2m() //  [R1]
         { info_tbl: [(cbq2m,
                       label: block_cbq2m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq2m: // global
           if (R1 & 7 == 1) goto cbq2q; else goto cbq2r;
       cbq2q: // global
           R4 = R1;
           R3 = GHC.Types.False_closure+1;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.hShow2_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cbq2r: // global
           R4 = R1;
           R3 = GHC.Types.True_closure+2;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.IO.Handle.hShow2_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.874477154 UTC

[section ""data" . GHC.IO.Handle.hShow_closure" {
     GHC.IO.Handle.hShow_closure:
         const GHC.IO.Handle.hShow_info;
         const 0;
 },
 GHC.IO.Handle.hShow_entry() //  [R2]
         { info_tbl: [(cbq2H,
                       label: GHC.IO.Handle.hShow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq2H: // global
           R2 = R2;
           call GHC.IO.Handle.hShow1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.875325933 UTC

[section ""data" . GHC.IO.Handle.HandlePosn_closure" {
     GHC.IO.Handle.HandlePosn_closure:
         const GHC.IO.Handle.HandlePosn_info;
 },
 GHC.IO.Handle.HandlePosn_entry() //  [R2, R3]
         { info_tbl: [(cbq2P,
                       label: GHC.IO.Handle.HandlePosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq2P: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbq2T; else goto cbq2S;
       cbq2T: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.HandlePosn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbq2S: // global
           I64[Hp - 16] = GHC.IO.Handle.HandlePosn_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.876178376 UTC

[GHC.IO.Handle.HandlePosn_con_entry() //  [R1]
         { info_tbl: [(cbq2U,
                       label: GHC.IO.Handle.HandlePosn_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,72,97,110,100,108,101,80,111,115,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq2U: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.876836511 UTC

[section ""relreadonly" . SboCL_srt" {
     SboCL_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.IO.Handle.$w$cshowsPrec_closure;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure;
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_closure;
         const GHC.IO.Handle.$fShowHandlePosn1_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.hLookAhead2_closure;
         const GHC.IO.Handle.hLookAhead1_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.hFlush2_closure;
         const GHC.IO.Handle.hFlush1_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const GHC.IO.Handle.hFlushAll2_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hFlushAll3_closure;
         const GHC.IO.Handle.hFlushAll1_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hGetEcho6_closure;
         const GHC.IO.Handle.hGetEcho_fun_closure;
         const GHC.IO.Handle.hGetEcho5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl1_rbnWC_closure;
         const lvl3_rbnWE_closure;
         const ioe_dupHandlesNotCompatible_rbnWF_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const dupHandle__rbnWK_closure;
         const GHC.IO.failIO1_closure;
         const lvl5_rbnWM_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const dupHandleTo_rbnWN_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.$whSetNewlineMode_closure;
         const GHC.IO.Handle.hSetNewlineMode2_closure;
         const GHC.IO.Handle.hSetNewlineMode1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const lvl11_rbnWT_closure;
         const GHC.IO.Handle.hSetBinaryMode1_closure;
         const lvl9_rbnWR_closure;
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure;
         const GHC.IO.Handle.hIsSeekable2_closure;
         const GHC.IO.Handle.hIsSeekable3_closure;
         const GHC.IO.Handle.hIsSeekable1_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.IO.Handle.hGetPosn2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.hGetPosn3_closure;
         const GHC.IO.Handle.hTell1_closure;
         const lvl14_rbnWW_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.hSeek1_closure;
         const lvl13_rbnWV_closure;
         const GHC.IO.Handle.hSetPosn1_closure;
         const GHC.IO.Handle.hGetEncoding3_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hGetEncoding1_closure;
         const lvl18_rbnX0_closure;
         const GHC.IO.Handle.hSetEncoding1_closure;
         const lvl16_rbnWY_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hSetBuffering1_closure;
         const GHC.IO.Handle.hSetBuffering2_closure;
         const GHC.IO.Handle.hIsEOF3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.hIsEOF1_closure;
         const GHC.IO.Handle.FD.stdin_closure;
         const GHC.IO.Handle.isEOF1_closure;
         const lvl20_rbnX2_closure;
         const GHC.IO.Handle.hSetFileSize1_closure;
         const GHC.IO.Handle.hFileSize5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const sat_sbojQ_closure;
         const GHC.IO.Handle.hFileSize3_closure;
         const GHC.IO.Handle.hFileSize4_closure;
         const GHC.IO.Handle.hFileSize10_closure;
         const GHC.IO.Handle.hFileSize2_closure;
         const GHC.IO.Handle.hFileSize8_closure;
         const GHC.IO.Handle.hFileSize1_closure;
         const lvl21_rbnX3_closure;
         const dupHandleTo_rbnWN_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.hDuplicateTo1_closure;
         const lvl25_rbnX7_closure;
         const GHC.IO.failIO1_closure;
         const lvl27_rbnX9_closure;
         const dupHandle__rbnWK_closure;
         const lvl7_rbnWP_closure;
         const GHC.IO.Handle.hDuplicate1_closure;
         const lvl23_rbnX5_closure;
         const GHC.IO.Handle.hGetEcho2_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hGetEcho3_closure;
         const GHC.IO.Handle.hGetEcho1_closure;
         const GHC.IO.Handle.hSetEcho2_closure;
         const GHC.IO.Handle.hSetEcho1_closure;
         const GHC.IO.Handle.hGetBuffering2_closure;
         const GHC.IO.Handle.hGetBuffering_fun_closure;
         const GHC.IO.Handle.hGetBuffering1_closure;
         const GHC.IO.Handle.hIsWritable2_closure;
         const GHC.IO.Handle.hIsWritable3_closure;
         const GHC.IO.Handle.hIsWritable1_closure;
         const GHC.IO.Handle.hIsReadable2_closure;
         const GHC.IO.Handle.hIsReadable3_closure;
         const GHC.IO.Handle.hIsReadable1_closure;
         const GHC.IO.Handle.hIsClosed3_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hIsClosed1_closure;
         const GHC.IO.Handle.hIsOpen3_closure;
         const GHC.IO.Handle.hIsOpen1_closure;
         const GHC.IO.Handle.hGetPosn1_closure;
         const GHC.IO.Handle.hGetPosn3_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.hGetPosn2_closure;
         const GHC.IO.Handle.hClose2_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.$wlvl_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.hClose1_closure;
         const lvl33_rbnXf_closure;
         const lvl42_rbnXo_closure;
         const lvl35_rbnXh_closure;
         const GHC.IO.Handle.Types.$fShowHandleType11_closure;
         const lvl46_rbnXs_closure;
         const lvl43_rbnXp_closure;
         const lvl44_rbnXq_closure;
         const GHC.IO.Handle.Types.$fShowHandleType1_closure;
         const GHC.IO.Handle.Types.$fShowHandleType3_closure;
         const GHC.IO.Handle.Types.$fShowHandleType5_closure;
         const GHC.IO.Handle.Types.$fShowHandleType7_closure;
         const GHC.IO.Handle.Types.$fShowHandleType9_closure;
         const lvl31_rbnXd_closure;
         const lvl47_rbnXt_closure;
         const lvl37_rbnXj_closure;
         const GHC.IO.Handle.hShow2_closure;
         const GHC.IO.Handle.hShow1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.878191339 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:16.8790103 UTC

[section ""data" . GHC.IO.Handle.$w$c==_closure" {
     GHC.IO.Handle.$w$c==_closure:
         const GHC.IO.Handle.$w$c==_info;
 },
 GHC.IO.Handle.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbq34,
                       label: GHC.IO.Handle.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq34: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbq35; else goto cbq36;
       cbq35: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbq36: // global
           I64[Sp - 24] = block_cbq2Z_info;
           _sbnXw::P64 = R3;
           R3 = R5;
           _sbnXv::P64 = R2;
           R2 = _sbnXw::P64;
           P64[Sp - 16] = _sbnXv::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbq2Z() //  [R1]
         { info_tbl: [(cbq2Z,
                       label: block_cbq2Z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq2Z: // global
           if (R1 == 1) goto cbq33; else goto cbq32;
       cbq33: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fEqHandle_$c==_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cbq32: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.880395161 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_$c==_closure" {
     GHC.IO.Handle.$fEqHandlePosn_$c==_closure:
         const GHC.IO.Handle.$fEqHandlePosn_$c==_info;
 },
 GHC.IO.Handle.$fEqHandlePosn_$c==_entry() //  [R2, R3]
         { info_tbl: [(cbq3k,
                       label: GHC.IO.Handle.$fEqHandlePosn_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq3k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbq3o; else goto cbq3p;
       cbq3o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fEqHandlePosn_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbq3p: // global
           I64[Sp - 16] = block_cbq3h_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubq3x; else goto cbq3i;
       ubq3x: // global
           call _cbq3h(R1) args: 0, res: 0, upd: 0;
       cbq3i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq3h() //  [R1]
         { info_tbl: [(cbq3h,
                       label: block_cbq3h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq3h: // global
           I64[Sp - 8] = block_cbq3n_info;
           _sbnXD::P64 = P64[R1 + 7];
           _sbnXE::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbnXE::P64;
           P64[Sp + 8] = _sbnXD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubq3w; else goto cbq3r;
       ubq3w: // global
           call _cbq3n(R1) args: 0, res: 0, upd: 0;
       cbq3r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq3n() //  [R1]
         { info_tbl: [(cbq3n,
                       label: block_cbq3n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq3n: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.$w$c==_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.882667732 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_$c/=_closure" {
     GHC.IO.Handle.$fEqHandlePosn_$c/=_closure:
         const GHC.IO.Handle.$fEqHandlePosn_$c/=_info;
 },
 GHC.IO.Handle.$fEqHandlePosn_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cbq3F,
                       label: GHC.IO.Handle.$fEqHandlePosn_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq3F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbq3J; else goto cbq3K;
       cbq3J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fEqHandlePosn_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbq3K: // global
           I64[Sp - 16] = block_cbq3C_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubq5h; else goto cbq3D;
       ubq5h: // global
           call _cbq3C(R1) args: 0, res: 0, upd: 0;
       cbq3D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq3C() //  [R1]
         { info_tbl: [(cbq3C,
                       label: block_cbq3C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq3C: // global
           I64[Sp - 8] = block_cbq3I_info;
           _sbnXL::P64 = P64[R1 + 7];
           _sbnXM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbnXM::P64;
           P64[Sp + 8] = _sbnXL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubq5g; else goto cbq3M;
       ubq5g: // global
           call _cbq3I(R1) args: 0, res: 0, upd: 0;
       cbq3M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq3I() //  [R1]
         { info_tbl: [(cbq3I,
                       label: block_cbq3I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq3I: // global
           I64[Sp] = block_cbq3Q_info;
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbq3Q() //  [R1]
         { info_tbl: [(cbq3Q,
                       label: block_cbq3Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq3Q: // global
           if (R1 == 1) goto cbq42; else goto ubq59;
       cbq42: // global
           I64[Sp] = block_cbq40_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubq5i; else goto cbq43;
       ubq5i: // global
           call _cbq40(R1) args: 0, res: 0, upd: 0;
       cbq43: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubq59: // global
           Sp = Sp + 24;
           call _cbq4V() args: 0, res: 0, upd: 0;
     }
 },
 _cbq40() //  [R1]
         { info_tbl: [(cbq40,
                       label: block_cbq40_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq40: // global
           _sbnXO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbq4a; else goto cbq4F;
       cbq4a: // global
           I64[Sp + 8] = block_cbq47_info;
           _sbnXT::P64 = P64[R1 + 15];
           R1 = _sbnXO::P64;
           P64[Sp + 16] = _sbnXT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubq5k; else goto cbq4b;
       ubq5k: // global
           call _cbq47(R1) args: 0, res: 0, upd: 0;
       cbq4b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbq4F: // global
           I64[Sp + 8] = block_cbq4D_info;
           _sbnY2::P64 = P64[R1 + 14];
           R1 = _sbnXO::P64;
           P64[Sp + 16] = _sbnY2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubq5l; else goto cbq4G;
       ubq5l: // global
           call _cbq4D(R1) args: 0, res: 0, upd: 0;
       cbq4G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq47() //  [R1]
         { info_tbl: [(cbq47,
                       label: block_cbq47_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq47: // global
           if (R1 & 7 == 1) goto cbq4w; else goto ubq5d;
       cbq4w: // global
           if (P64[Sp + 8] == P64[R1 + 15]) goto ubq5e; else goto ubq5f;
       ubq5e: // global
           Sp = Sp + 16;
           call _cbq51() args: 0, res: 0, upd: 0;
       ubq5f: // global
           Sp = Sp + 16;
           goto ubq5o;
       ubq5d: // global
           Sp = Sp + 16;
           goto ubq5o;
       ubq5o: // global
           call _cbq4V() args: 0, res: 0, upd: 0;
     }
 },
 _cbq4D() //  [R1]
         { info_tbl: [(cbq4D,
                       label: block_cbq4D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq4D: // global
           if (R1 & 7 == 1) goto ubq5a; else goto cbq55;
       ubq5a: // global
           Sp = Sp + 16;
           goto ubq5r;
       cbq55: // global
           if (P64[Sp + 8] == P64[R1 + 14]) goto ubq5b; else goto ubq5c;
       ubq5b: // global
           Sp = Sp + 16;
           call _cbq51() args: 0, res: 0, upd: 0;
       ubq5c: // global
           Sp = Sp + 16;
           goto ubq5r;
       ubq5r: // global
           call _cbq4V() args: 0, res: 0, upd: 0;
     }
 },
 _cbq51() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq51: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbq4V() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq4V: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.885015002 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_closure" {
     GHC.IO.Handle.$fEqHandlePosn_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.$fEqHandlePosn_$c==_closure+2;
         const GHC.IO.Handle.$fEqHandlePosn_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.885643247 UTC

[section ""cstring" . GHC.IO.Handle.$fShowHandlePosn2_bytes" {
     GHC.IO.Handle.$fShowHandlePosn2_bytes:
         I8[] [32,97,116,32,112,111,115,105,116,105,111,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.890725174 UTC

[section ""data" . GHC.IO.Handle.$w$cshowsPrec_closure" {
     GHC.IO.Handle.$w$cshowsPrec_closure:
         const GHC.IO.Handle.$w$cshowsPrec_info;
         const 0;
 },
 sat_sbnYk_entry() //  [R1]
         { info_tbl: [(cbq5U,
                       label: sat_sbnYk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq5U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbq5V; else goto cbq5W;
       cbq5V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq5W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbq5R_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbq5R() //  [R1, R2]
         { info_tbl: [(cbq5R,
                       label: block_cbq5R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq5R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbq5Z; else goto cbq5Y;
       cbq5Z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbq5Y: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYl_entry() //  [R1]
         { info_tbl: [(cbq60,
                       label: sat_sbnYl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq60: // global
           _sbnYl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbq61; else goto cbq62;
       cbq62: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbq64; else goto cbq63;
       cbq64: // global
           HpAlloc = 32;
           goto cbq61;
       cbq61: // global
           R1 = _sbnYl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq63: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYl::P64;
           _sbnYc::P64 = P64[_sbnYl::P64 + 16];
           _sbnYd::P64 = P64[_sbnYl::P64 + 24];
           I64[Hp - 24] = sat_sbnYk_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.$fShowHandlePosn2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYm_entry() //  [R1]
         { info_tbl: [(cbq65,
                       label: sat_sbnYm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq65: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbq69; else goto cbq68;
       cbq69: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq68: // global
           _sbnYc::P64 = P64[R1 + 16];
           _sbnYd::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbnYl_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbnYn_entry() //  [R1]
         { info_tbl: [(cbq6a,
                       label: sat_sbnYn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq6a: // global
           _sbnYn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbq6b; else goto cbq6c;
       cbq6c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbq6e; else goto cbq6d;
       cbq6e: // global
           HpAlloc = 32;
           goto cbq6b;
       cbq6b: // global
           R1 = _sbnYn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq6d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYn::P64;
           _sbnYc::P64 = P64[_sbnYn::P64 + 16];
           _sbnYd::P64 = P64[_sbnYn::P64 + 24];
           _sbnYf::P64 = P64[_sbnYn::P64 + 32];
           I64[Hp - 24] = sat_sbnYm_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = _sbnYf::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYu_entry() //  [R1]
         { info_tbl: [(cbq6A,
                       label: sat_sbnYu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq6A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbq6B; else goto cbq6C;
       cbq6B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq6C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbq6x_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbq6x() //  [R1, R2]
         { info_tbl: [(cbq6x,
                       label: block_cbq6x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq6x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbq6F; else goto cbq6E;
       cbq6F: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbq6E: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYv_entry() //  [R1]
         { info_tbl: [(cbq6G,
                       label: sat_sbnYv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq6G: // global
           _sbnYv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbq6H; else goto cbq6I;
       cbq6I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbq6K; else goto cbq6J;
       cbq6K: // global
           HpAlloc = 32;
           goto cbq6H;
       cbq6H: // global
           R1 = _sbnYv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq6J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYv::P64;
           _sbnYc::P64 = P64[_sbnYv::P64 + 16];
           _sbnYd::P64 = P64[_sbnYv::P64 + 24];
           I64[Hp - 24] = sat_sbnYu_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.$fShowHandlePosn2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYw_entry() //  [R1]
         { info_tbl: [(cbq6L,
                       label: sat_sbnYw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq6L: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbq6P; else goto cbq6O;
       cbq6P: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq6O: // global
           _sbnYc::P64 = P64[R1 + 16];
           _sbnYd::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbnYv_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbnYx_entry() //  [R1]
         { info_tbl: [(cbq6Q,
                       label: sat_sbnYx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq6Q: // global
           _sbnYx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbq6R; else goto cbq6S;
       cbq6S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbq6U; else goto cbq6T;
       cbq6U: // global
           HpAlloc = 32;
           goto cbq6R;
       cbq6R: // global
           R1 = _sbnYx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq6T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYx::P64;
           _sbnYc::P64 = P64[_sbnYx::P64 + 16];
           _sbnYd::P64 = P64[_sbnYx::P64 + 24];
           _sbnYo::P64 = P64[_sbnYx::P64 + 32];
           I64[Hp - 24] = sat_sbnYw_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = _sbnYo::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbq6Z,
                       label: GHC.IO.Handle.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq6Z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbq70; else goto cbq71;
       cbq70: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbq71: // global
           I64[Sp - 24] = block_cbq5w_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubq78; else goto cbq5x;
       ubq78: // global
           call _cbq5w(R1) args: 0, res: 0, upd: 0;
       cbq5x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq5w() //  [R1]
         { info_tbl: [(cbq5w,
                       label: block_cbq5w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq5w: // global
           _sbnYc::P64 = P64[Sp + 8];
           _sbnYd::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbq6W; else goto cbq6X;
       cbq6W: // global
           Hp = Hp + 40;
           _sbnYe::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbq77; else goto cbq73;
       cbq73: // global
           _sbnYf::P64 = P64[_sbnYe::P64 + 7];
           I64[Hp - 32] = sat_sbnYn_info;
           P64[Hp - 16] = _sbnYc::P64;
           P64[Hp - 8] = _sbnYd::P64;
           P64[Hp] = _sbnYf::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cbq6X: // global
           Hp = Hp + 40;
           _sbnYe::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbq77; else goto cbq76;
       cbq77: // global
           HpAlloc = 40;
           R1 = _sbnYe::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbq76: // global
           _sbnYo::P64 = P64[_sbnYe::P64 + 6];
           I64[Hp - 32] = sat_sbnYx_info;
           P64[Hp - 16] = _sbnYc::P64;
           P64[Hp - 8] = _sbnYd::P64;
           P64[Hp] = _sbnYo::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.89537948 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbq7g,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq7g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq7h; else goto cbq7i;
       cbq7h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbq7i: // global
           I64[Sp - 16] = block_cbq7d_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubq7m; else goto cbq7e;
       ubq7m: // global
           call _cbq7d(R1) args: 0, res: 0, upd: 0;
       cbq7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq7d() //  [R1]
         { info_tbl: [(cbq7d,
                       label: block_cbq7d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq7d: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.896397744 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn3_closure" {
     GHC.IO.Handle.$fShowHandlePosn3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.897151411 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshow_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshow_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshow_entry() //  [R2]
         { info_tbl: [(cbq7u,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq7u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbq7v; else goto cbq7w;
       cbq7v: // global
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbq7w: // global
           I64[Sp - 8] = block_cbq7r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubq7A; else goto cbq7s;
       ubq7A: // global
           call _cbq7r(R1) args: 0, res: 0, upd: 0;
       cbq7s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq7r() //  [R1]
         { info_tbl: [(cbq7r,
                       label: block_cbq7r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq7r: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.898405893 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn1_closure" {
     GHC.IO.Handle.$fShowHandlePosn1_closure:
         const GHC.IO.Handle.$fShowHandlePosn1_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn1_entry() //  [R2, R3]
         { info_tbl: [(cbq7I,
                       label: GHC.IO.Handle.$fShowHandlePosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq7I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq7J; else goto cbq7K;
       cbq7J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbq7K: // global
           I64[Sp - 16] = block_cbq7F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubq7O; else goto cbq7G;
       ubq7O: // global
           call _cbq7F(R1) args: 0, res: 0, upd: 0;
       cbq7G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq7F() //  [R1]
         { info_tbl: [(cbq7F,
                       label: block_cbq7F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq7F: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.899552013 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cbq7T,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq7T: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.$fShowHandlePosn1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.900287293 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_closure" {
     GHC.IO.Handle.$fShowHandlePosn_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure+3;
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_closure+1;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.900844917 UTC

[section ""cstring" . GHC.IO.Handle.hLookAhead3_bytes" {
     GHC.IO.Handle.hLookAhead3_bytes:
         I8[] [104,76,111,111,107,65,104,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.901592022 UTC

[section ""data" . GHC.IO.Handle.hLookAhead2_closure" {
     GHC.IO.Handle.hLookAhead2_closure:
         const GHC.IO.Handle.hLookAhead2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hLookAhead2_entry() //  [R1]
         { info_tbl: [(cbq82,
                       label: GHC.IO.Handle.hLookAhead2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq82: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq83; else goto cbq84;
       cbq83: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq84: // global
           (_cbq7Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbq7Z::I64 == 0) goto cbq81; else goto cbq80;
       cbq81: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbq80: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbq7Z::I64;
           R2 = GHC.IO.Handle.hLookAhead3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.902586096 UTC

[section ""data" . GHC.IO.Handle.hLookAhead1_closure" {
     GHC.IO.Handle.hLookAhead1_closure:
         const GHC.IO.Handle.hLookAhead1_info;
         const 0;
 },
 GHC.IO.Handle.hLookAhead1_entry() //  [R2]
         { info_tbl: [(cbq89,
                       label: GHC.IO.Handle.hLookAhead1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq89: // global
           R4 = GHC.IO.Handle.Internals.hLookAhead_1_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hLookAhead2_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.903417562 UTC

[section ""data" . GHC.IO.Handle.hLookAhead_closure" {
     GHC.IO.Handle.hLookAhead_closure:
         const GHC.IO.Handle.hLookAhead_info;
         const 0;
 },
 GHC.IO.Handle.hLookAhead_entry() //  [R2]
         { info_tbl: [(cbq8g,
                       label: GHC.IO.Handle.hLookAhead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq8g: // global
           R2 = R2;
           call GHC.IO.Handle.hLookAhead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.904094683 UTC

[section ""cstring" . GHC.IO.Handle.hFlush3_bytes" {
     GHC.IO.Handle.hFlush3_bytes:
         I8[] [104,70,108,117,115,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.904787432 UTC

[section ""data" . GHC.IO.Handle.hFlush2_closure" {
     GHC.IO.Handle.hFlush2_closure:
         const GHC.IO.Handle.hFlush2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFlush2_entry() //  [R1]
         { info_tbl: [(cbq8p,
                       label: GHC.IO.Handle.hFlush2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq8p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq8q; else goto cbq8r;
       cbq8q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq8r: // global
           (_cbq8m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbq8m::I64 == 0) goto cbq8o; else goto cbq8n;
       cbq8o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbq8n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbq8m::I64;
           R2 = GHC.IO.Handle.hFlush3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.905887431 UTC

[section ""data" . GHC.IO.Handle.hFlush1_closure" {
     GHC.IO.Handle.hFlush1_closure:
         const GHC.IO.Handle.hFlush1_info;
         const 0;
 },
 GHC.IO.Handle.hFlush1_entry() //  [R2]
         { info_tbl: [(cbq8w,
                       label: GHC.IO.Handle.hFlush1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq8w: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.906742645 UTC

[section ""data" . GHC.IO.Handle.hFlush_closure" {
     GHC.IO.Handle.hFlush_closure:
         const GHC.IO.Handle.hFlush_info;
         const 0;
 },
 GHC.IO.Handle.hFlush_entry() //  [R2]
         { info_tbl: [(cbq8D,
                       label: GHC.IO.Handle.hFlush_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq8D: // global
           R2 = R2;
           call GHC.IO.Handle.hFlush1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.907443076 UTC

[section ""cstring" . GHC.IO.Handle.hFlushAll4_bytes" {
     GHC.IO.Handle.hFlushAll4_bytes:
         I8[] [104,70,108,117,115,104,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.908131995 UTC

[section ""data" . GHC.IO.Handle.hFlushAll3_closure" {
     GHC.IO.Handle.hFlushAll3_closure:
         const GHC.IO.Handle.hFlushAll3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFlushAll3_entry() //  [R1]
         { info_tbl: [(cbq8M,
                       label: GHC.IO.Handle.hFlushAll3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq8M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq8N; else goto cbq8O;
       cbq8N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbq8O: // global
           (_cbq8J::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbq8J::I64 == 0) goto cbq8L; else goto cbq8K;
       cbq8L: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbq8K: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbq8J::I64;
           R2 = GHC.IO.Handle.hFlushAll4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.909286874 UTC

[section ""data" . GHC.IO.Handle.hFlushAll2_closure" {
     GHC.IO.Handle.hFlushAll2_closure:
         const GHC.IO.Handle.hFlushAll2_info;
         const 0;
 },
 GHC.IO.Handle.hFlushAll2_entry() //  [R2]
         { info_tbl: [(cbq8W,
                       label: GHC.IO.Handle.hFlushAll2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq8W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq8X; else goto cbq8Y;
       cbq8X: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFlushAll2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbq8Y: // global
           I64[Sp - 16] = block_cbq8T_info;
           _sbnYR::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbnYR::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbq8T() //  [R1]
         { info_tbl: [(cbq8T,
                       label: block_cbq8T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq8T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbq91; else goto cbq90;
       cbq91: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbq90: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.911436075 UTC

[section ""data" . GHC.IO.Handle.hFlushAll1_closure" {
     GHC.IO.Handle.hFlushAll1_closure:
         const GHC.IO.Handle.hFlushAll1_info;
         const 0;
 },
 io_sbnZ5_entry() //  [R1]
         { info_tbl: [(cbq9n,
                       label: io_sbnZ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq9r; else goto cbq9s;
       cbq9r: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbq9s: // global
           I64[Sp - 16] = block_cbq9i_info;
           _sbnZ1::P64 = P64[R1 + 15];
           R5 = _sbnZ1::P64;
           R4 = GHC.IO.Handle.hFlushAll2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFlushAll3_closure;
           P64[Sp - 8] = _sbnZ1::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbq9i() //  [R1]
         { info_tbl: [(cbq9i,
                       label: block_cbq9i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9i: // global
           I64[Sp] = block_cbq9k_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubq9x; else goto cbq9l;
       ubq9x: // global
           call _cbq9k(R1) args: 0, res: 0, upd: 0;
       cbq9l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq9k() //  [R1]
         { info_tbl: [(cbq9k,
                       label: block_cbq9k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9k: // global
           I64[Sp] = block_cbq9q_info;
           R2 = P64[R1 + 7];
           _sbnZc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbnZc::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq9q() //  []
         { info_tbl: [(cbq9q,
                       label: block_cbq9q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbnZl_entry() //  [R1]
         { info_tbl: [(cbq9M,
                       label: io_sbnZl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbq9Q; else goto cbq9R;
       cbq9Q: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbq9R: // global
           I64[Sp - 16] = block_cbq9H_info;
           _sbnZg::P64 = P64[R1 + 15];
           R5 = _sbnZg::P64;
           R4 = GHC.IO.Handle.hFlushAll2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFlushAll3_closure;
           P64[Sp - 8] = _sbnZg::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbq9H() //  [R1]
         { info_tbl: [(cbq9H,
                       label: block_cbq9H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9H: // global
           I64[Sp] = block_cbq9J_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubq9W; else goto cbq9K;
       ubq9W: // global
           call _cbq9J(R1) args: 0, res: 0, upd: 0;
       cbq9K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq9J() //  [R1]
         { info_tbl: [(cbq9J,
                       label: block_cbq9J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9J: // global
           I64[Sp] = block_cbq9P_info;
           R2 = P64[R1 + 7];
           _sbnZs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbnZs::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq9P() //  []
         { info_tbl: [(cbq9P,
                       label: block_cbq9P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9P: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hFlushAll1_entry() //  [R2]
         { info_tbl: [(cbqa1,
                       label: GHC.IO.Handle.hFlushAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqa1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqa2; else goto cbqa3;
       cbqa2: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFlushAll1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqa3: // global
           I64[Sp - 8] = block_cbq96_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqak; else goto cbq97;
       ubqak: // global
           call _cbq96(R1) args: 0, res: 0, upd: 0;
       cbq97: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbq96() //  [R1]
         { info_tbl: [(cbq96,
                       label: block_cbq96_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq96: // global
           if (R1 & 7 == 1) goto cbq9Y; else goto cbq9Z;
       cbq9Y: // global
           I64[Sp - 16] = block_cbq9b_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbq9Z: // global
           I64[Sp - 16] = block_cbq9A_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbq9b() //  [R1]
         { info_tbl: [(cbq9b,
                       label: block_cbq9b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqa7; else goto cbqa6;
       cbqa7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqa6: // global
           I64[Hp - 16] = io_sbnZ5_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbq9d::P64 = Hp - 15;
           if (R1 == 0) goto cbqab; else goto cbqaa;
       cbqab: // global
           R1 = _cbq9d::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqaa: // global
           R1 = _cbq9d::P64;
           Sp = Sp + 24;
           call io_sbnZ5_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbq9A() //  [R1]
         { info_tbl: [(cbq9A,
                       label: block_cbq9A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbq9A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqaf; else goto cbqae;
       cbqaf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqae: // global
           I64[Hp - 16] = io_sbnZl_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbq9C::P64 = Hp - 15;
           if (R1 == 0) goto cbqaj; else goto cbqai;
       cbqaj: // global
           R1 = _cbq9C::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqai: // global
           R1 = _cbq9C::P64;
           Sp = Sp + 24;
           call io_sbnZl_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.914840988 UTC

[section ""data" . GHC.IO.Handle.hFlushAll_closure" {
     GHC.IO.Handle.hFlushAll_closure:
         const GHC.IO.Handle.hFlushAll_info;
         const 0;
 },
 GHC.IO.Handle.hFlushAll_entry() //  [R2]
         { info_tbl: [(cbqap,
                       label: GHC.IO.Handle.hFlushAll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqap: // global
           R2 = R2;
           call GHC.IO.Handle.hFlushAll1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.915552862 UTC

[section ""cstring" . GHC.IO.Handle.hGetEcho7_bytes" {
     GHC.IO.Handle.hGetEcho7_bytes:
         I8[] [104,73,115,84,101,114,109,105,110,97,108,68,101,118,105,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.916279313 UTC

[section ""data" . GHC.IO.Handle.hGetEcho_fun_closure" {
     GHC.IO.Handle.hGetEcho_fun_closure:
         const GHC.IO.Handle.hGetEcho_fun_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEcho_fun_entry() //  [R1]
         { info_tbl: [(cbqay,
                       label: GHC.IO.Handle.hGetEcho_fun_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqay: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqaz; else goto cbqaA;
       cbqaz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqaA: // global
           (_cbqav::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqav::I64 == 0) goto cbqax; else goto cbqaw;
       cbqax: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqaw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqav::I64;
           R2 = GHC.IO.Handle.hGetEcho7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.9176207 UTC

[section ""data" . GHC.IO.Handle.hGetEcho6_closure" {
     GHC.IO.Handle.hGetEcho6_closure:
         const GHC.IO.Handle.hGetEcho6_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho6_entry() //  [R2]
         { info_tbl: [(cbqaI,
                       label: GHC.IO.Handle.hGetEcho6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqaI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbqaJ; else goto cbqaK;
       cbqaJ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqaK: // global
           I64[Sp - 8] = block_cbqaF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqb8; else goto cbqaG;
       ubqb8: // global
           call _cbqaF(R1) args: 0, res: 0, upd: 0;
       cbqaG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqaF() //  [R1]
         { info_tbl: [(cbqaF,
                       label: block_cbqaF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqaF: // global
           I64[Sp - 24] = block_cbqaN_info;
           _sbnZx::P64 = R1;
           _sbnZy::P64 = P64[R1 + 7];
           _sbnZB::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbnZy::P64;
           P64[Sp - 8] = _sbnZB::P64;
           P64[Sp] = _sbnZx::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqb7; else goto cbqaP;
       ubqb7: // global
           call _cbqaN(R1) args: 0, res: 0, upd: 0;
       cbqaP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqaN() //  [R1]
         { info_tbl: [(cbqaN,
                       label: block_cbqaN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqaN: // global
           if (R1 & 7 == 1) goto cbqb5; else goto cbqaY;
       cbqb5: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbqaY: // global
           _sbnZB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbqaT_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbnZB::P64;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbqaT() //  [R1]
         { info_tbl: [(cbqaT,
                       label: block_cbqaT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqaT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqb1; else goto cbqb0;
       cbqb1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqb0: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.920198632 UTC

[section ""data" . GHC.IO.Handle.hGetEcho5_closure" {
     GHC.IO.Handle.hGetEcho5_closure:
         const GHC.IO.Handle.hGetEcho5_info;
         const 0;
 },
 io_sbo02_entry() //  [R1]
         { info_tbl: [(cbqbu,
                       label: io_sbo02_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqby; else goto cbqbz;
       cbqby: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqbz: // global
           I64[Sp - 16] = block_cbqbp_info;
           _sbnZY::P64 = P64[R1 + 15];
           R5 = _sbnZY::P64;
           R4 = GHC.IO.Handle.hGetEcho6_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho_fun_closure;
           P64[Sp - 8] = _sbnZY::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqbp() //  [R1]
         { info_tbl: [(cbqbp,
                       label: block_cbqbp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbp: // global
           I64[Sp] = block_cbqbr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqbE; else goto cbqbs;
       ubqbE: // global
           call _cbqbr(R1) args: 0, res: 0, upd: 0;
       cbqbs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqbr() //  [R1]
         { info_tbl: [(cbqbr,
                       label: block_cbqbr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbr: // global
           I64[Sp] = block_cbqbx_info;
           R2 = P64[R1 + 7];
           _sbo09::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo09::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqbx() //  []
         { info_tbl: [(cbqbx,
                       label: block_cbqbx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbo0i_entry() //  [R1]
         { info_tbl: [(cbqbT,
                       label: io_sbo0i_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqbX; else goto cbqbY;
       cbqbX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqbY: // global
           I64[Sp - 16] = block_cbqbO_info;
           _sbo0d::P64 = P64[R1 + 15];
           R5 = _sbo0d::P64;
           R4 = GHC.IO.Handle.hGetEcho6_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho_fun_closure;
           P64[Sp - 8] = _sbo0d::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqbO() //  [R1]
         { info_tbl: [(cbqbO,
                       label: block_cbqbO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbO: // global
           I64[Sp] = block_cbqbQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqc3; else goto cbqbR;
       ubqc3: // global
           call _cbqbQ(R1) args: 0, res: 0, upd: 0;
       cbqbR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqbQ() //  [R1]
         { info_tbl: [(cbqbQ,
                       label: block_cbqbQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbQ: // global
           I64[Sp] = block_cbqbW_info;
           R2 = P64[R1 + 7];
           _sbo0p::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo0p::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqbW() //  []
         { info_tbl: [(cbqbW,
                       label: block_cbqbW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hGetEcho5_entry() //  [R2]
         { info_tbl: [(cbqc8,
                       label: GHC.IO.Handle.hGetEcho5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqc8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqc9; else goto cbqca;
       cbqc9: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho5_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqca: // global
           I64[Sp - 8] = block_cbqbd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqcr; else goto cbqbe;
       ubqcr: // global
           call _cbqbd(R1) args: 0, res: 0, upd: 0;
       cbqbe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqbd() //  [R1]
         { info_tbl: [(cbqbd,
                       label: block_cbqbd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbd: // global
           if (R1 & 7 == 1) goto cbqc5; else goto cbqc6;
       cbqc5: // global
           I64[Sp - 16] = block_cbqbi_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbqc6: // global
           I64[Sp - 16] = block_cbqbH_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbqbi() //  [R1]
         { info_tbl: [(cbqbi,
                       label: block_cbqbi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqce; else goto cbqcd;
       cbqce: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqcd: // global
           I64[Hp - 16] = io_sbo02_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqbk::P64 = Hp - 15;
           if (R1 == 0) goto cbqci; else goto cbqch;
       cbqci: // global
           R1 = _cbqbk::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqch: // global
           R1 = _cbqbk::P64;
           Sp = Sp + 24;
           call io_sbo02_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqbH() //  [R1]
         { info_tbl: [(cbqbH,
                       label: block_cbqbH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqbH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqcm; else goto cbqcl;
       cbqcm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqcl: // global
           I64[Hp - 16] = io_sbo0i_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqbJ::P64 = Hp - 15;
           if (R1 == 0) goto cbqcq; else goto cbqcp;
       cbqcq: // global
           R1 = _cbqbJ::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqcp: // global
           R1 = _cbqbJ::P64;
           Sp = Sp + 24;
           call io_sbo0i_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.923504179 UTC

[section ""data" . GHC.IO.Handle.hIsTerminalDevice_closure" {
     GHC.IO.Handle.hIsTerminalDevice_closure:
         const GHC.IO.Handle.hIsTerminalDevice_info;
         const 0;
 },
 GHC.IO.Handle.hIsTerminalDevice_entry() //  [R2]
         { info_tbl: [(cbqcw,
                       label: GHC.IO.Handle.hIsTerminalDevice_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqcw: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.924211602 UTC

[section ""cstring" . lvl_rbnWB_bytes" {
     lvl_rbnWB_bytes:
         I8[] [104,68,117,112,108,105,99,97,116,101,84,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.924930418 UTC

[section ""data" . lvl1_rbnWC_closure" {
     lvl1_rbnWC_closure:
         const lvl1_rbnWC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbnWC_entry() //  [R1]
         { info_tbl: [(cbqcF,
                       label: lvl1_rbnWC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqcF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqcG; else goto cbqcH;
       cbqcG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqcH: // global
           (_cbqcC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqcC::I64 == 0) goto cbqcE; else goto cbqcD;
       cbqcE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqcD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqcC::I64;
           R2 = lvl_rbnWB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.925774014 UTC

[section ""cstring" . lvl2_rbnWD_bytes" {
     lvl2_rbnWD_bytes:
         I8[] [104,97,110,100,108,101,115,32,97,114,101,32,105,110,99,111,109,112,97,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.926475891 UTC

[section ""data" . lvl3_rbnWE_closure" {
     lvl3_rbnWE_closure:
         const lvl3_rbnWE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbnWE_entry() //  [R1]
         { info_tbl: [(cbqcO,
                       label: lvl3_rbnWE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqcO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqcP; else goto cbqcQ;
       cbqcP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqcQ: // global
           (_cbqcL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqcL::I64 == 0) goto cbqcN; else goto cbqcM;
       cbqcN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqcM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqcL::I64;
           R2 = lvl2_rbnWD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.927697569 UTC

[section ""data" . ioe_dupHandlesNotCompatible_rbnWF_closure" {
     ioe_dupHandlesNotCompatible_rbnWF_closure:
         const ioe_dupHandlesNotCompatible_rbnWF_info;
         const 0;
 },
 sat_sbo0w_entry() //  [R1]
         { info_tbl: [(cbqd1,
                       label: sat_sbo0w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqd1: // global
           _sbo0w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbqd2; else goto cbqd3;
       cbqd3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbqd5; else goto cbqd4;
       cbqd5: // global
           HpAlloc = 72;
           goto cbqd2;
       cbqd2: // global
           R1 = _sbo0w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqd4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbo0w::P64;
           _sbo0s::P64 = P64[_sbo0w::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbo0s::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = lvl1_rbnWC_closure;
           P64[Hp - 16] = lvl3_rbnWE_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ioe_dupHandlesNotCompatible_rbnWF_entry() //  [R2]
         { info_tbl: [(cbqd6,
                       label: ioe_dupHandlesNotCompatible_rbnWF_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqd6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqda; else goto cbqd9;
       cbqda: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = ioe_dupHandlesNotCompatible_rbnWF_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqd9: // global
           I64[Hp - 16] = sat_sbo0w_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.928947299 UTC

[section ""cstring" . GHC.IO.Handle.$trModule4_bytes" {
     GHC.IO.Handle.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.929498574 UTC

[section ""data" . GHC.IO.Handle.$trModule3_closure" {
     GHC.IO.Handle.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.930060975 UTC

[section ""cstring" . GHC.IO.Handle.$trModule2_bytes" {
     GHC.IO.Handle.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.930590176 UTC

[section ""data" . GHC.IO.Handle.$trModule1_closure" {
     GHC.IO.Handle.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.931118715 UTC

[section ""data" . GHC.IO.Handle.$trModule_closure" {
     GHC.IO.Handle.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.$trModule3_closure+1;
         const GHC.IO.Handle.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.931706619 UTC

[section ""data" . $krep_rbnWG_closure" {
     $krep_rbnWG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.932325282 UTC

[section ""data" . $krep1_rbnWH_closure" {
     $krep1_rbnWH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.932888704 UTC

[section ""cstring" . GHC.IO.Handle.$tcHandlePosn2_bytes" {
     GHC.IO.Handle.$tcHandlePosn2_bytes:
         I8[] [72,97,110,100,108,101,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.9334994 UTC

[section ""data" . GHC.IO.Handle.$tcHandlePosn1_closure" {
     GHC.IO.Handle.$tcHandlePosn1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$tcHandlePosn2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.934025355 UTC

[section ""data" . GHC.IO.Handle.$tcHandlePosn_closure" {
     GHC.IO.Handle.$tcHandlePosn_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.$trModule_closure+1;
         const GHC.IO.Handle.$tcHandlePosn1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14603627022044816180;
         const 6047646306417636971;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.934637707 UTC

[section ""data" . $krep2_rbnWI_closure" {
     $krep2_rbnWI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.$tcHandlePosn_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.935225522 UTC

[section ""data" . $krep3_rbnWJ_closure" {
     $krep3_rbnWJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbnWG_closure+1;
         const $krep2_rbnWI_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.935788008 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn1_closure" {
     GHC.IO.Handle.$tc'HandlePosn1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rbnWH_closure+1;
         const $krep3_rbnWJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.938157222 UTC

[section ""cstring" . GHC.IO.Handle.$tc'HandlePosn3_bytes" {
     GHC.IO.Handle.$tc'HandlePosn3_bytes:
         I8[] [39,72,97,110,100,108,101,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.9386881 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn2_closure" {
     GHC.IO.Handle.$tc'HandlePosn2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$tc'HandlePosn3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.939229019 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn_closure" {
     GHC.IO.Handle.$tc'HandlePosn_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.$trModule_closure+1;
         const GHC.IO.Handle.$tc'HandlePosn2_closure+1;
         const GHC.IO.Handle.$tc'HandlePosn1_closure+4;
         const 2346493220596692855;
         const 1604707260447826943;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.940903089 UTC

[section ""data" . dupHandle__rbnWK_closure" {
     dupHandle__rbnWK_closure:
         const dupHandle__rbnWK_info;
         const 0;
 },
 dupHandle__rbnWK_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqdc: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 dupHandle__rbnWK_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbqdj,
                       label: dupHandle__rbnWK_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqdj: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbqdk; else goto cbqdl;
       cbqdk: // global
           R1 = dupHandle__rbnWK_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cbqdl: // global
           I64[Sp - 40] = block_cbqdg_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubqe1; else goto cbqdh;
       ubqe1: // global
           call _cbqdg(R1) args: 0, res: 0, upd: 0;
       cbqdh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqdg() //  [R1]
         { info_tbl: [(cbqdg,
                       label: block_cbqdg_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqdg: // global
           I64[Sp - 24] = block_cbqdq_info;
           _sbo0L::P64 = P64[R1 + 39];
           _sbo0U::P64 = P64[R1 + 111];
           _sbo0V::P64 = P64[R1 + 119];
           R1 = P64[R1 + 87];
           P64[Sp - 16] = _sbo0U::P64;
           P64[Sp - 8] = _sbo0V::P64;
           P64[Sp] = _sbo0L::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqe0; else goto cbqdy;
       ubqe0: // global
           call _cbqdq(R1) args: 0, res: 0, upd: 0;
       cbqdy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqdq() //  [R1]
         { info_tbl: [(cbqdq,
                       label: block_cbqdq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqdq: // global
           if (R1 & 7 == 1) goto cbqdE; else goto cbqdJ;
       cbqdE: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _cbqdt() args: 0, res: 0, upd: 0;
       cbqdJ: // global
           I64[Sp] = block_cbqdH_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubqe2; else goto cbqdK;
       ubqe2: // global
           call _cbqdH(R1) args: 0, res: 0, upd: 0;
       cbqdK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqdH() //  [R1]
         { info_tbl: [(cbqdH,
                       label: block_cbqdH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqdH: // global
           I64[Sp] = block_cbqdO_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqdO() //  [R1]
         { info_tbl: [(cbqdO,
                       label: block_cbqdO_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqdO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqdT; else goto cbqdS;
       cbqdT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqdS: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 6;
           call _cbqdt() args: 0, res: 0, upd: 0;
     }
 },
 _cbqdt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqdt: // global
           Hp = Hp + 24;
           _sbo0Z::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cbqdx; else goto cbqdw;
       cbqdx: // global
           HpAlloc = 24;
           I64[Sp] = block_cbqds_info;
           R1 = _sbo0Z::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqdw: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 72];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = GHC.Types.True_closure+2;
           P64[Sp + 56] = _sbo0Z::P64;
           _sbo0C::P64 = P64[Sp + 64];
           P64[Sp + 64] = Hp - 15;
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sbo0C::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 },
 _cbqds() //  [R1]
         { info_tbl: [(cbqds,
                       label: block_cbqds_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqds: // global
           P64[Sp] = R1;
           call _cbqdt() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.943432621 UTC

[section ""cstring" . lvl4_rbnWL_bytes" {
     lvl4_rbnWL_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,55,49,51,58,55,45,50,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.944128861 UTC

[section ""data" . lvl5_rbnWM_closure" {
     lvl5_rbnWM_closure:
         const lvl5_rbnWM_info;
         const 0;
 },
 lvl5_rbnWM_entry() //  []
         { info_tbl: [(cbqec,
                       label: lvl5_rbnWM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqec: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbqed; else goto cbqee;
       cbqed: // global
           R1 = lvl5_rbnWM_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqee: // global
           I64[Sp - 8] = block_cbqea_info;
           R2 = lvl4_rbnWL_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqea() //  [R1]
         { info_tbl: [(cbqea,
                       label: block_cbqea_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqea: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.946081238 UTC

[section ""data" . dupHandleTo_rbnWN_closure" {
     dupHandleTo_rbnWN_closure:
         const dupHandleTo_rbnWN_info;
         const 0;
 },
 dupHandleTo_rbnWN_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbqep,
                       label: dupHandleTo_rbnWN_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqep: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cbqet; else goto cbqeu;
       cbqet: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = dupHandleTo_rbnWN_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbqeu: // global
           I64[Sp - 40] = block_cbqem_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubqfa; else goto cbqen;
       ubqfa: // global
           call _cbqem(R1) args: 0, res: 0, upd: 0;
       cbqen: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqem() //  [R1]
         { info_tbl: [(cbqem,
                       label: block_cbqem_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqem: // global
           I64[Sp - 8] = block_cbqes_info;
           _sbo1m::P64 = P64[R1 + 23];
           _sbo1n::P64 = P64[R1 + 31];
           R1 = P64[Sp + 32];
           P64[Sp] = _sbo1n::P64;
           P64[Sp + 32] = _sbo1m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqf9; else goto cbqew;
       ubqf9: // global
           call _cbqes(R1) args: 0, res: 0, upd: 0;
       cbqew: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqes() //  [R1]
         { info_tbl: [(cbqes,
                       label: block_cbqes_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqes: // global
           I64[Sp - 40] = block_cbqeA_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqeA() //  []
         { info_tbl: [(cbqeA,
                       label: block_cbqeA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqeA: // global
           I64[Sp] = block_cbqeC_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 80];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqeC() //  [R1]
         { info_tbl: [(cbqeC,
                       label: block_cbqeC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqeC: // global
           if (R1 & 7 == 1) goto cbqeK; else goto cbqeT;
       cbqeK: // global
           R2 = P64[Sp + 64];
           Sp = Sp + 96;
           call ioe_dupHandlesNotCompatible_rbnWF_entry(R2) args: 8, res: 0, upd: 8;
       cbqeT: // global
           I64[Sp] = block_cbqeN_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 48];
           Sp = Sp - 24;
           call GHC.IO.Device.dup2_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbqeN() //  []
         { info_tbl: [(cbqeN,
                       label: block_cbqeN_info
                       rep:StackRep [False, False, False, True, False, False, False, True,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqeN: // global
           _sbo1h::P64 = P64[Sp + 88];
           I64[Sp + 88] = block_cbqeP_info;
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 64] = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 40];
           P64[Sp + 80] = _sbo1h::P64;
           Sp = Sp + 64;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbqeP() //  [R1]
         { info_tbl: [(cbqeP,
                       label: block_cbqeP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqeP: // global
           I64[Sp] = block_cbqeR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqfb; else goto cbqeW;
       ubqfb: // global
           call _cbqeR(R1) args: 0, res: 0, upd: 0;
       cbqeW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqeR() //  [R1]
         { info_tbl: [(cbqeR,
                       label: block_cbqeR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqeR: // global
           if (R1 & 7 == 1) goto cbqf2; else goto cbqf6;
       cbqf2: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
       cbqf6: // global
           Sp = Sp + 8;
           call lvl5_rbnWM_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.948412489 UTC

[section ""cstring" . lvl6_rbnWO_bytes" {
     lvl6_rbnWO_bytes:
         I8[] [100,117,112,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.94918809 UTC

[section ""data" . lvl7_rbnWP_closure" {
     lvl7_rbnWP_closure:
         const lvl7_rbnWP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rbnWP_entry() //  [R1]
         { info_tbl: [(cbqfi,
                       label: lvl7_rbnWP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqfi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqfj; else goto cbqfk;
       cbqfj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqfk: // global
           (_cbqff::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqff::I64 == 0) goto cbqfh; else goto cbqfg;
       cbqfh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqfg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqff::I64;
           R2 = lvl6_rbnWO_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.950091067 UTC

[section ""cstring" . GHC.IO.Handle.hSetNewlineMode3_bytes" {
     GHC.IO.Handle.hSetNewlineMode3_bytes:
         I8[] [104,83,101,116,78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.950807787 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode2_closure" {
     GHC.IO.Handle.hSetNewlineMode2_closure:
         const GHC.IO.Handle.hSetNewlineMode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode2_entry() //  [R1]
         { info_tbl: [(cbqfr,
                       label: GHC.IO.Handle.hSetNewlineMode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqfr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqfs; else goto cbqft;
       cbqfs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqft: // global
           (_cbqfo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqfo::I64 == 0) goto cbqfq; else goto cbqfp;
       cbqfq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqfp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqfo::I64;
           R2 = GHC.IO.Handle.hSetNewlineMode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.952502134 UTC

[section ""data" . GHC.IO.Handle.$whSetNewlineMode_closure" {
     GHC.IO.Handle.$whSetNewlineMode_closure:
         const GHC.IO.Handle.$whSetNewlineMode_info;
         const 0;
 },
 sat_sbo2y_entry() //  [R1, R2]
         { info_tbl: [(cbqfG,
                       label: sat_sbo2y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqfG: // global
           if ((Sp + -136) < SpLim) (likely: False) goto cbqfM; else goto cbqfN;
       cbqfM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqfN: // global
           I64[Sp - 24] = block_cbqfD_info;
           _sbo28::P64 = P64[R1 + 6];
           _sbo29::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbo28::P64;
           P64[Sp - 8] = _sbo29::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqfS; else goto cbqfE;
       ubqfS: // global
           call _cbqfD(R1) args: 0, res: 0, upd: 0;
       cbqfE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqfD() //  [R1]
         { info_tbl: [(cbqfD,
                       label: block_cbqfD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqfD: // global
           I64[Sp - 112] = block_cbqfJ_info;
           R2 = R1;
           P64[Sp - 104] = P64[R1 + 15];
           P64[Sp - 96] = P64[R1 + 23];
           P64[Sp - 88] = P64[R1 + 31];
           P64[Sp - 80] = P64[R1 + 39];
           P64[Sp - 72] = P64[R1 + 47];
           P64[Sp - 64] = P64[R1 + 55];
           P64[Sp - 56] = P64[R1 + 63];
           P64[Sp - 48] = P64[R1 + 71];
           P64[Sp - 40] = P64[R1 + 79];
           P64[Sp - 32] = P64[R1 + 87];
           P64[Sp - 24] = P64[R1 + 95];
           P64[Sp - 16] = P64[R1 + 103];
           P64[Sp - 8] = P64[R1 + 127];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 112;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqfJ() //  [R1]
         { info_tbl: [(cbqfJ,
                       label: block_cbqfJ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqfJ: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbqfR; else goto cbqfQ;
       cbqfR: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqfQ: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 112];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 56];
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = P64[Sp + 104];
           R1 = Hp - 127;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.$whSetNewlineMode_entry() //  [R2, R3, R4]
         { info_tbl: [(cbqfT,
                       label: GHC.IO.Handle.$whSetNewlineMode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqfT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqfX; else goto cbqfW;
       cbqfX: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$whSetNewlineMode_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqfW: // global
           I64[Hp - 16] = sat_sbo2y_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.hSetNewlineMode2_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.954718205 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode1_closure" {
     GHC.IO.Handle.hSetNewlineMode1_closure:
         const GHC.IO.Handle.hSetNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(cbqg5,
                       label: GHC.IO.Handle.hSetNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqg5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqg6; else goto cbqg7;
       cbqg6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetNewlineMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqg7: // global
           I64[Sp - 16] = block_cbqg2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubqgb; else goto cbqg3;
       ubqgb: // global
           call _cbqg2(R1) args: 0, res: 0, upd: 0;
       cbqg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqg2() //  [R1]
         { info_tbl: [(cbqg2,
                       label: block_cbqg2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqg2: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$whSetNewlineMode_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.955864955 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode_closure" {
     GHC.IO.Handle.hSetNewlineMode_closure:
         const GHC.IO.Handle.hSetNewlineMode_info;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode_entry() //  [R2, R3]
         { info_tbl: [(cbqgg,
                       label: GHC.IO.Handle.hSetNewlineMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqgg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetNewlineMode1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.956525538 UTC

[section ""cstring" . lvl8_rbnWQ_bytes" {
     lvl8_rbnWQ_bytes:
         I8[] [104,83,101,116,66,105,110,97,114,121,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.957197571 UTC

[section ""data" . lvl9_rbnWR_closure" {
     lvl9_rbnWR_closure:
         const lvl9_rbnWR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rbnWR_entry() //  [R1]
         { info_tbl: [(cbqgp,
                       label: lvl9_rbnWR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqgp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqgq; else goto cbqgr;
       cbqgq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqgr: // global
           (_cbqgm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqgm::I64 == 0) goto cbqgo; else goto cbqgn;
       cbqgo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqgn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqgm::I64;
           R2 = lvl8_rbnWQ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.95832978 UTC

[section ""cstring" . lvl10_rbnWS_bytes" {
     lvl10_rbnWS_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.95907018 UTC

[section ""data" . lvl11_rbnWT_closure" {
     lvl11_rbnWT_closure:
         const lvl11_rbnWT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rbnWT_entry() //  [R1]
         { info_tbl: [(cbqgA,
                       label: lvl11_rbnWT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqgA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqgB; else goto cbqgC;
       cbqgB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqgC: // global
           (_cbqgv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqgv::I64 == 0) goto cbqgx; else goto cbqgw;
       cbqgx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqgw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqgv::I64;
           I64[Sp - 24] = block_cbqgy_info;
           R2 = lvl10_rbnWS_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbqgy() //  [R1]
         { info_tbl: [(cbqgy,
                       label: block_cbqgy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqgy: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.967234011 UTC

[section ""data" . GHC.IO.Handle.hSetBinaryMode1_closure" {
     GHC.IO.Handle.hSetBinaryMode1_closure:
         const GHC.IO.Handle.hSetBinaryMode1_info;
         const 0;
 },
 lvl48_sbo2J_entry() //  [R1]
         { info_tbl: [(cbqgR,
                       label: lvl48_sbo2J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqgR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqgS; else goto cbqgT;
       cbqgS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqgT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbqgO_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqgX; else goto cbqgP;
       ubqgX: // global
           call _cbqgO() args: 0, res: 0, upd: 0;
       cbqgP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqgO() //  []
         { info_tbl: [(cbqgO,
                       label: block_cbqgO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqgO: // global
           R1 = GHC.IO.Handle.Types.LF_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo5C_entry() //  [R1]
         { info_tbl: [(cbqhJ,
                       label: sat_sbo5C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqhJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqhN; else goto cbqhO;
       cbqhN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqhO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbqhG_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqhS; else goto cbqhH;
       ubqhS: // global
           call _cbqhG(R1) args: 0, res: 0, upd: 0;
       cbqhH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqhG() //  [R1]
         { info_tbl: [(cbqhG,
                       label: block_cbqhG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqhG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqhR; else goto cbqhQ;
       cbqhR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbqhQ: // global
           _sbo5x::P64 = P64[R1 + 7];
           _sbo5y::P64 = P64[R1 + 15];
           _sbo5w::I64 = I64[R1 + 23];
           _sbo5z::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo5x::P64;
           P64[Hp - 32] = _sbo5y::P64;
           I64[Hp - 24] = _sbo5w::I64;
           I64[Hp - 16] = _sbo5z::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo5V_entry() //  [R1]
         { info_tbl: [(cbqif,
                       label: sat_sbo5V_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqif: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbqim; else goto cbqin;
       cbqim: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqin: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbqic_info;
           _sbo5L::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbo5L::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubqir; else goto cbqid;
       ubqir: // global
           call _cbqic(R1) args: 0, res: 0, upd: 0;
       cbqid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqic() //  [R1]
         { info_tbl: [(cbqic,
                       label: block_cbqic_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqic: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqiq; else goto cbqip;
       cbqiq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbqip: // global
           _sbo5P::P64 = P64[R1 + 7];
           _sbo5Q::P64 = P64[R1 + 15];
           _sbo5O::I64 = I64[R1 + 23];
           _sbo5R::I64 = I64[R1 + 31];
           _sbo5T::I64 = I64[R1 + 47];
           _sbo5U::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo5P::P64;
           P64[Hp - 32] = _sbo5Q::P64;
           I64[Hp - 24] = _sbo5O::I64;
           I64[Hp - 16] = _sbo5R::I64;
           I64[Hp - 8] = _sbo5U::I64;
           I64[Hp] = _sbo5T::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo6i_entry() //  [R1, R2]
         { info_tbl: [(cbqis,
                       label: sat_sbo6i_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqis: // global
           if ((Sp + -176) < SpLim) (likely: False) goto cbqit; else goto cbqiu;
       cbqit: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqiu: // global
           I64[Sp - 24] = block_cbqh3_info;
           _sbo2H::P64 = P64[R1 + 6];
           _sbo2J::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbo2H::P64;
           P64[Sp - 8] = _sbo2J::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqo4; else goto cbqh4;
       ubqo4: // global
           call _cbqh3(R1) args: 0, res: 0, upd: 0;
       cbqh4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqh3() //  [R1]
         { info_tbl: [(cbqh3,
                       label: block_cbqh3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqh3: // global
           I64[Sp - 104] = block_cbqh8_info;
           _sbo2O::P64 = P64[R1 + 7];
           _sbo2P::P64 = P64[R1 + 15];
           _sbo2Q::P64 = P64[R1 + 23];
           _sbo2R::P64 = P64[R1 + 31];
           _sbo2S::P64 = P64[R1 + 39];
           _sbo2T::P64 = P64[R1 + 47];
           _sbo2U::P64 = P64[R1 + 55];
           _sbo2V::P64 = P64[R1 + 63];
           _sbo2W::P64 = P64[R1 + 71];
           _sbo2X::P64 = P64[R1 + 79];
           _sbo2Y::P64 = P64[R1 + 87];
           _sbo2Z::P64 = P64[R1 + 95];
           _sbo33::P64 = P64[R1 + 127];
           R1 = P64[_sbo2W::P64 + 8];
           P64[Sp - 96] = _sbo2P::P64;
           P64[Sp - 88] = _sbo2Q::P64;
           P64[Sp - 80] = _sbo2R::P64;
           P64[Sp - 72] = _sbo2S::P64;
           P64[Sp - 64] = _sbo2T::P64;
           P64[Sp - 56] = _sbo2U::P64;
           P64[Sp - 48] = _sbo2V::P64;
           P64[Sp - 40] = _sbo2W::P64;
           P64[Sp - 32] = _sbo2X::P64;
           P64[Sp - 24] = _sbo2Y::P64;
           P64[Sp - 16] = _sbo2Z::P64;
           P64[Sp - 8] = _sbo33::P64;
           P64[Sp] = _sbo2O::P64;
           Sp = Sp - 104;
           if (R1 & 7 != 0) goto ubqnR; else goto cbqh9;
       ubqnR: // global
           call _cbqh8(R1) args: 0, res: 0, upd: 0;
       cbqh9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqh8() //  [R1]
         { info_tbl: [(cbqh8,
                       label: block_cbqh8_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqh8: // global
           I64[Sp - 16] = block_cbqhf_info;
           _sbo3c::I64 = I64[R1 + 39];
           _sbo3d::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo3d::I64;
           I64[Sp] = _sbo3c::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubqnS; else goto cbqhg;
       ubqnS: // global
           call _cbqhf(R1) args: 0, res: 0, upd: 0;
       cbqhg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqhf() //  [R1]
         { info_tbl: [(cbqhf,
                       label: block_cbqhf_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqhf: // global
           if (R1 & 7 == 1) goto cbqmg; else goto cbqnb;
       cbqmg: // global
           _sbo5c::P64 = P64[P64[Sp + 80] + 8];
           I64[Sp + 16] = block_cbqhk_info;
           R1 = _sbo5c::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubqnT; else goto cbqhl;
       ubqnT: // global
           call _cbqhk(R1) args: 0, res: 0, upd: 0;
       cbqhl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqnb: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubqnC; else goto cbqn9;
       ubqnC: // global
           Sp = Sp + 24;
           call _sbo3e() args: 0, res: 0, upd: 0;
       cbqn9: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 144;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqhk() //  [R1]
         { info_tbl: [(cbqhk,
                       label: block_cbqhk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqhk: // global
           I64[Sp - 16] = block_cbqhp_info;
           _sbo5i::I64 = I64[R1 + 39];
           _sbo5j::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo5j::I64;
           I64[Sp] = _sbo5i::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubqnV; else goto cbqhq;
       ubqnV: // global
           call _cbqhp(R1) args: 0, res: 0, upd: 0;
       cbqhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqhp() //  [R1]
         { info_tbl: [(cbqhp,
                       label: block_cbqhp_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqhp: // global
           if (R1 & 7 == 1) goto cbqmY; else goto ubqnD;
       cbqmY: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubqnE; else goto cbqmk;
       ubqnE: // global
           Sp = Sp + 24;
           goto ubqnY;
       cbqmk: // global
           _sbo5o::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cbqhx_info;
           R1 = _sbo5o::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubqnW; else goto cbqhy;
       ubqnW: // global
           call _cbqhx(R1) args: 0, res: 0, upd: 0;
       cbqhy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubqnD: // global
           Sp = Sp + 24;
           goto ubqnY;
       ubqnY: // global
           call _sbo3e() args: 0, res: 0, upd: 0;
     }
 },
 _cbqhx() //  [R1]
         { info_tbl: [(cbqhx,
                       label: block_cbqhx_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqhx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqmn; else goto cbqmm;
       cbqmn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqmm: // global
           _sbo2W::P64 = P64[Sp + 64];
           _sbo5q::P64 = P64[R1 + 7];
           _sbo5r::P64 = P64[R1 + 15];
           _sbo5u::P64 = P64[_sbo2W::P64 + 8];
           I64[Hp - 16] = sat_sbo5C_info;
           P64[Hp] = _sbo5u::P64;
           call MO_WriteBarrier();
           P64[_sbo2W::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2W::P64);
           I64[Sp - 8] = block_cbqhW_info;
           R1 = _sbo5u::P64;
           P64[Sp] = _sbo5r::P64;
           P64[Sp + 56] = _sbo5q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqnZ; else goto cbqhX;
       ubqnZ: // global
           call _cbqhW(R1) args: 0, res: 0, upd: 0;
       cbqhX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqhW() //  [R1]
         { info_tbl: [(cbqhW,
                       label: block_cbqhW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqhW: // global
           _sbo5L::I64 = I64[R1 + 39];
           if (_sbo5L::I64 != 0) goto cbqmq; else goto cbqmV;
       cbqmq: // global
           I64[Sp - 32] = block_cbqi3_info;
           _sbo5G::P64 = P64[R1 + 7];
           _sbo5H::P64 = P64[R1 + 15];
           _sbo5F::I64 = I64[R1 + 23];
           R1 = P64[Sp + 96];
           P64[Sp - 24] = _sbo5G::P64;
           P64[Sp - 16] = _sbo5H::P64;
           I64[Sp - 8] = _sbo5L::I64;
           I64[Sp] = _sbo5F::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubqo0; else goto cbqi4;
       ubqo0: // global
           call _cbqi3(R1) args: 0, res: 0, upd: 0;
       cbqi4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqmV: // global
           _sbo2T::P64 = P64[Sp + 48];
           _sbo5r::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbo2T::P64 + 8] = _sbo5r::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2T::P64);
           Sp = Sp + 16;
           call _sbo3e() args: 0, res: 0, upd: 0;
     }
 },
 _cbqi3() //  [R1]
         { info_tbl: [(cbqi3,
                       label: block_cbqi3_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqi3: // global
           if (R1 & 7 == 1) goto cbqms; else goto cbqmK;
       cbqms: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbqmv; else goto cbqmu;
       cbqmv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqmu: // global
           I64[Hp - 24] = sat_sbo5V_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 24];
           _sbo2T::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sbo2T::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2T::P64);
           Sp = Sp + 48;
           call _sbo3e() args: 0, res: 0, upd: 0;
       cbqmK: // global
           I64[Sp] = block_cbqmy_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqo2; else goto cbqmz;
       ubqo2: // global
           call _cbqmy(R1) args: 0, res: 0, upd: 0;
       cbqmz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqmy() //  [R1]
         { info_tbl: [(cbqmy,
                       label: block_cbqmy_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqmy: // global
           I64[Sp - 8] = block_cbqmD_info;
           R2 = P64[Sp + 96];
           _sbo5Z::P64 = P64[R1 + 7];
           _sbo60::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbo60::P64;
           P64[Sp + 96] = _sbo5Z::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqmD() //  [R1]
         { info_tbl: [(cbqmD,
                       label: block_cbqmD_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqmD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqmO; else goto cbqmN;
       cbqmO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqmN: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbo5r::P64 = P64[Sp + 48];
           I64[Sp + 48] = block_cbqmG_info;
           R5 = Hp - 47;
           R4 = _sbo5r::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 104];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqmG() //  [R1]
         { info_tbl: [(cbqmG,
                       label: block_cbqmG_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqmG: // global
           I64[Sp] = block_cbqmI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqom; else goto cbqmQ;
       ubqom: // global
           call _cbqmI(R1) args: 0, res: 0, upd: 0;
       cbqmQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqmI() //  [R1]
         { info_tbl: [(cbqmI,
                       label: block_cbqmI_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqmI: // global
           _sbo2T::P64 = P64[Sp + 40];
           _sbo6c::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbo2T::P64 + 8] = _sbo6c::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2T::P64);
           Sp = Sp + 8;
           call _sbo3e() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3e() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3e: // global
           I64[Sp - 8] = block_cbqiC_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqoo; else goto cbqle;
       ubqoo: // global
           call _cbqiC(R1) args: 0, res: 0, upd: 0;
       cbqle: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqiC() //  [R1]
         { info_tbl: [(cbqiC,
                       label: block_cbqiC_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqiC: // global
           if (R1 & 7 == 1) goto cbqll; else goto cbqlK;
       cbqll: // global
           I64[Sp] = block_cbqli_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubqo5; else goto cbqlm;
       ubqo5: // global
           call _cbqli(R1) args: 0, res: 0, upd: 0;
       cbqlm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqlK: // global
           I64[Sp] = block_cbqlI_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqo6; else goto cbqlL;
       ubqo6: // global
           call _cbqlI(R1) args: 0, res: 0, upd: 0;
       cbqlL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqli() //  [R1]
         { info_tbl: [(cbqli,
                       label: block_cbqli_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqli: // global
           if (R1 & 7 == 1) goto ubqnK; else goto cbqlC;
       ubqnK: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
       cbqlC: // global
           I64[Sp] = block_cbqlv_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqof; else goto cbqlw;
       ubqof: // global
           call _cbqlv(R1) args: 0, res: 0, upd: 0;
       cbqlw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqlv() //  [R1]
         { info_tbl: [(cbqlv,
                       label: block_cbqlv_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqlv: // global
           I64[Sp] = block_cbqlA_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqlA() //  []
         { info_tbl: [(cbqlA,
                       label: block_cbqlA_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqlA: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
     }
 },
 _cbqlI() //  [R1]
         { info_tbl: [(cbqlI,
                       label: block_cbqlI_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqlI: // global
           I64[Sp] = block_cbqlP_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqlP() //  []
         { info_tbl: [(cbqlP,
                       label: block_cbqlP_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqlP: // global
           I64[Sp] = block_cbqlR_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubqoi; else goto cbqlU;
       ubqoi: // global
           call _cbqlR(R1) args: 0, res: 0, upd: 0;
       cbqlU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqlR() //  [R1]
         { info_tbl: [(cbqlR,
                       label: block_cbqlR_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqlR: // global
           if (R1 & 7 == 1) goto ubqnI; else goto cbqma;
       ubqnI: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
       cbqma: // global
           I64[Sp] = block_cbqm3_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqoj; else goto cbqm4;
       ubqoj: // global
           call _cbqm3(R1) args: 0, res: 0, upd: 0;
       cbqm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqm3() //  [R1]
         { info_tbl: [(cbqm3,
                       label: block_cbqm3_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqm3: // global
           I64[Sp] = block_cbqm8_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqm8() //  []
         { info_tbl: [(cbqm8,
                       label: block_cbqm8_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqm8: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3g: // global
           I64[Sp - 8] = block_cbqiJ_info;
           R1 = P64[Sp + 104];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqop; else goto cbqkS;
       ubqop: // global
           call _cbqiJ(R1) args: 0, res: 0, upd: 0;
       cbqkS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqiJ() //  [R1]
         { info_tbl: [(cbqiJ,
                       label: block_cbqiJ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqiJ: // global
           if (R1 & 7 == 1) goto cbqkZ; else goto cbqld;
       cbqkZ: // global
           I64[Sp] = block_cbqkW_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubqo7; else goto cbql0;
       ubqo7: // global
           call _cbqkW(R1) args: 0, res: 0, upd: 0;
       cbql0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqld: // global
           P64[Sp + 112] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbo3i() args: 0, res: 0, upd: 0;
     }
 },
 _cbqkW() //  [R1]
         { info_tbl: [(cbqkW,
                       label: block_cbqkW_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqkW: // global
           I64[Sp] = block_cbql4_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbql4() //  [R1]
         { info_tbl: [(cbql4,
                       label: block_cbql4_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbql4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbql9; else goto cbql8;
       cbql9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbql8: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 112] = Hp - 6;
           Sp = Sp + 8;
           call _sbo3i() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3i() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3i: // global
           I64[Sp - 8] = block_cbqiO_info;
           R1 = P64[Sp + 104];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqoq; else goto cbqiQ;
       ubqoq: // global
           call _cbqiO(R1) args: 0, res: 0, upd: 0;
       cbqiQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqiO() //  [R1]
         { info_tbl: [(cbqiO,
                       label: block_cbqiO_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqiO: // global
           if (R1 & 7 == 1) goto cbqiZ; else goto cbqja;
       cbqiZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqj2; else goto cbqj1;
       cbqj2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqj1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbqiV_info;
           R1 = Hp - 15;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbqja: // global
           I64[Sp] = block_cbqj8_info;
           _sbo3l::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 112] = _sbo3l::P64;
           if (R1 & 7 != 0) goto ubqo9; else goto cbqjb;
       ubqo9: // global
           call _cbqj8(R1) args: 0, res: 0, upd: 0;
       cbqjb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqiV() //  [R1]
         { info_tbl: [(cbqiV,
                       label: block_cbqiV_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqiV: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbqj5; else goto cbqj4;
       cbqj5: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqj4: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqj8() //  [R1]
         { info_tbl: [(cbqj8,
                       label: block_cbqj8_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqj8: // global
           I64[Sp] = block_cbqjh_info;
           _sbo3x::P64 = P64[R1 + 15];
           _sbo3y::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp + 80] = _sbo3y::P64;
           P64[Sp + 88] = _sbo3x::P64;
           if (R1 & 7 != 0) goto ubqoa; else goto cbqkt;
       ubqoa: // global
           call _cbqjh(R1) args: 0, res: 0, upd: 0;
       cbqkt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqjh() //  [R1]
         { info_tbl: [(cbqjh,
                       label: block_cbqjh_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqjh: // global
           _sbo3x::P64 = P64[Sp + 88];
           _cbqnv::P64 = R1 & 7;
           if (_cbqnv::P64 != 3) goto ubqnz; else goto cbqkE;
       ubqnz: // global
           if (_cbqnv::P64 != 6) goto cbqkz; else goto cbqkN;
       cbqkz: // global
           P64[Sp + 88] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbo3z() args: 0, res: 0, upd: 0;
       cbqkN: // global
           I64[Sp] = block_cbqkL_info;
           R1 = _sbo3x::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbqkE: // global
           I64[Sp] = block_cbqkC_info;
           R1 = _sbo3x::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqkL() //  [R1]
         { info_tbl: [(cbqkL,
                       label: block_cbqkL_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqkL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqkR; else goto cbqkQ;
       cbqkR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqkQ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 88] = Hp - 6;
           Sp = Sp + 8;
           call _sbo3z() args: 0, res: 0, upd: 0;
     }
 },
 _cbqkC() //  [R1]
         { info_tbl: [(cbqkC,
                       label: block_cbqkC_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqkC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqkI; else goto cbqkH;
       cbqkI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqkH: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 88] = Hp - 6;
           Sp = Sp + 8;
           call _sbo3z() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3z: // global
           I64[Sp - 8] = block_cbqjm_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqor; else goto cbqjo;
       ubqor: // global
           call _cbqjm(R1) args: 0, res: 0, upd: 0;
       cbqjo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqjm() //  [R1]
         { info_tbl: [(cbqjm,
                       label: block_cbqjm_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqjm: // global
           _sbo3y::P64 = P64[Sp + 80];
           _cbqny::P64 = R1 & 7;
           if (_cbqny::P64 < 5) goto ubqnA; else goto ubqnB;
       ubqnA: // global
           if (_cbqny::P64 < 4) goto cbqjx; else goto cbqjO;
       cbqjx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqjA; else goto cbqjz;
       cbqjA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqjz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbqjt_info;
           _sbo3C::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo3C::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbqjO: // global
           I64[Sp] = block_cbqjG_info;
           R1 = _sbo3y::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ubqnB: // global
           if (_cbqny::P64 < 6) goto cbqk5; else goto cbqkm;
       cbqk5: // global
           I64[Sp] = block_cbqjX_info;
           R1 = _sbo3y::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbqkm: // global
           I64[Sp] = block_cbqke_info;
           R1 = _sbo3y::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqjt() //  [R1]
         { info_tbl: [(cbqjt,
                       label: block_cbqjt_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqjt: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbqjD; else goto cbqjC;
       cbqjD: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqjC: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqjG() //  [R1]
         { info_tbl: [(cbqjG,
                       label: block_cbqjG_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqjG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqjR; else goto cbqjQ;
       cbqjR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqjQ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbqjJ_info;
           _sbo3N::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo3N::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqjJ() //  [R1]
         { info_tbl: [(cbqjJ,
                       label: block_cbqjJ_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqjJ: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbqjU; else goto cbqjT;
       cbqjU: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqjT: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqjX() //  [R1]
         { info_tbl: [(cbqjX,
                       label: block_cbqjX_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqjX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqk8; else goto cbqk7;
       cbqk8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqk7: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbqk0_info;
           _sbo3Z::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo3Z::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqk0() //  [R1]
         { info_tbl: [(cbqk0,
                       label: block_cbqk0_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqk0: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbqkb; else goto cbqka;
       cbqkb: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqka: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.AppendHandle_closure+5;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqke() //  [R1]
         { info_tbl: [(cbqke,
                       label: block_cbqke_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqke: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqkp; else goto cbqko;
       cbqkp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqko: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbqkh_info;
           _sbo4b::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo4b::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqkh() //  [R1]
         { info_tbl: [(cbqkh,
                       label: block_cbqkh_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqkh: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbqks; else goto cbqkr;
       cbqks: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqkr: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetBinaryMode1_entry() //  [R2, R3]
         { info_tbl: [(cbqos,
                       label: GHC.IO.Handle.hSetBinaryMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqos: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbqow; else goto cbqov;
       cbqow: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetBinaryMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqov: // global
           I64[Hp - 40] = lvl48_sbo2J_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbo6i_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = R2;
           R2 = lvl9_rbnWR_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.98276669 UTC

[section ""data" . GHC.IO.Handle.hSetBinaryMode_closure" {
     GHC.IO.Handle.hSetBinaryMode_closure:
         const GHC.IO.Handle.hSetBinaryMode_info;
         const 0;
 },
 GHC.IO.Handle.hSetBinaryMode_entry() //  [R2, R3]
         { info_tbl: [(cbqoB,
                       label: GHC.IO.Handle.hSetBinaryMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqoB: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetBinaryMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.983514818 UTC

[section ""cstring" . GHC.IO.Handle.hIsSeekable4_bytes" {
     GHC.IO.Handle.hIsSeekable4_bytes:
         I8[] [104,73,115,83,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.984245065 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable3_closure" {
     GHC.IO.Handle.hIsSeekable3_closure:
         const GHC.IO.Handle.hIsSeekable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable3_entry() //  [R1]
         { info_tbl: [(cbqoK,
                       label: GHC.IO.Handle.hIsSeekable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqoK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqoL; else goto cbqoM;
       cbqoL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqoM: // global
           (_cbqoH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqoH::I64 == 0) goto cbqoJ; else goto cbqoI;
       cbqoJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqoI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqoH::I64;
           R2 = GHC.IO.Handle.hIsSeekable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.985799327 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable2_closure" {
     GHC.IO.Handle.hIsSeekable2_closure:
         const GHC.IO.Handle.hIsSeekable2_info;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable2_entry() //  [R2]
         { info_tbl: [(cbqoU,
                       label: GHC.IO.Handle.hIsSeekable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqoU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbqoV; else goto cbqoW;
       cbqoV: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsSeekable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqoW: // global
           I64[Sp - 8] = block_cbqoR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqpx; else goto cbqoS;
       ubqpx: // global
           call _cbqoR(R1) args: 0, res: 0, upd: 0;
       cbqoS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqoR() //  [R1]
         { info_tbl: [(cbqoR,
                       label: block_cbqoR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqoR: // global
           I64[Sp - 24] = block_cbqoZ_info;
           _sbo6l::P64 = R1;
           _sbo6m::P64 = P64[R1 + 7];
           _sbo6p::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbo6m::P64;
           P64[Sp - 8] = _sbo6p::P64;
           P64[Sp] = _sbo6l::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqpw; else goto cbqp1;
       ubqpw: // global
           call _cbqoZ(R1) args: 0, res: 0, upd: 0;
       cbqp1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqoZ() //  [R1]
         { info_tbl: [(cbqoZ,
                       label: block_cbqoZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqoZ: // global
           _cbqpt::P64 = R1 & 7;
           if (_cbqpt::P64 < 3) goto ubqpu; else goto ubqpv;
       ubqpu: // global
           if (_cbqpt::P64 < 2) goto cbqph; else goto cbqpl;
       cbqph: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbqpl: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       ubqpv: // global
           if (_cbqpt::P64 == 5) goto cbqpp; else goto cbqpa;
       cbqpp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqps; else goto cbqpr;
       cbqps: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqpr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbqpa: // global
           _sbo6p::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbqp5_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbo6p::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbqp5() //  [R1]
         { info_tbl: [(cbqp5,
                       label: block_cbqp5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqp5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqpd; else goto cbqpc;
       cbqpd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqpc: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.98867307 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable1_closure" {
     GHC.IO.Handle.hIsSeekable1_closure:
         const GHC.IO.Handle.hIsSeekable1_info;
         const 0;
 },
 io_sbo6S_entry() //  [R1]
         { info_tbl: [(cbqpT,
                       label: io_sbo6S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqpT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqpX; else goto cbqpY;
       cbqpX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqpY: // global
           I64[Sp - 16] = block_cbqpO_info;
           _sbo6O::P64 = P64[R1 + 15];
           R5 = _sbo6O::P64;
           R4 = GHC.IO.Handle.hIsSeekable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsSeekable3_closure;
           P64[Sp - 8] = _sbo6O::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqpO() //  [R1]
         { info_tbl: [(cbqpO,
                       label: block_cbqpO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqpO: // global
           I64[Sp] = block_cbqpQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqq3; else goto cbqpR;
       ubqq3: // global
           call _cbqpQ(R1) args: 0, res: 0, upd: 0;
       cbqpR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqpQ() //  [R1]
         { info_tbl: [(cbqpQ,
                       label: block_cbqpQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqpQ: // global
           I64[Sp] = block_cbqpW_info;
           R2 = P64[R1 + 7];
           _sbo6Z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo6Z::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqpW() //  []
         { info_tbl: [(cbqpW,
                       label: block_cbqpW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqpW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbo78_entry() //  [R1]
         { info_tbl: [(cbqqi,
                       label: io_sbo78_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqqi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqqm; else goto cbqqn;
       cbqqm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqqn: // global
           I64[Sp - 16] = block_cbqqd_info;
           _sbo73::P64 = P64[R1 + 15];
           R5 = _sbo73::P64;
           R4 = GHC.IO.Handle.hIsSeekable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsSeekable3_closure;
           P64[Sp - 8] = _sbo73::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqqd() //  [R1]
         { info_tbl: [(cbqqd,
                       label: block_cbqqd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqqd: // global
           I64[Sp] = block_cbqqf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqqs; else goto cbqqg;
       ubqqs: // global
           call _cbqqf(R1) args: 0, res: 0, upd: 0;
       cbqqg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqqf() //  [R1]
         { info_tbl: [(cbqqf,
                       label: block_cbqqf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqqf: // global
           I64[Sp] = block_cbqql_info;
           R2 = P64[R1 + 7];
           _sbo7f::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo7f::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqql() //  []
         { info_tbl: [(cbqql,
                       label: block_cbqql_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqql: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsSeekable1_entry() //  [R2]
         { info_tbl: [(cbqqx,
                       label: GHC.IO.Handle.hIsSeekable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqqx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqqy; else goto cbqqz;
       cbqqy: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsSeekable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqqz: // global
           I64[Sp - 8] = block_cbqpC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqqQ; else goto cbqpD;
       ubqqQ: // global
           call _cbqpC(R1) args: 0, res: 0, upd: 0;
       cbqpD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqpC() //  [R1]
         { info_tbl: [(cbqpC,
                       label: block_cbqpC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqpC: // global
           if (R1 & 7 == 1) goto cbqqu; else goto cbqqv;
       cbqqu: // global
           I64[Sp - 16] = block_cbqpH_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbqqv: // global
           I64[Sp - 16] = block_cbqq6_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbqpH() //  [R1]
         { info_tbl: [(cbqpH,
                       label: block_cbqpH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqpH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqqD; else goto cbqqC;
       cbqqD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqqC: // global
           I64[Hp - 16] = io_sbo6S_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqpJ::P64 = Hp - 15;
           if (R1 == 0) goto cbqqH; else goto cbqqG;
       cbqqH: // global
           R1 = _cbqpJ::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqqG: // global
           R1 = _cbqpJ::P64;
           Sp = Sp + 24;
           call io_sbo6S_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqq6() //  [R1]
         { info_tbl: [(cbqq6,
                       label: block_cbqq6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqq6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqqL; else goto cbqqK;
       cbqqL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqqK: // global
           I64[Hp - 16] = io_sbo78_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqq8::P64 = Hp - 15;
           if (R1 == 0) goto cbqqP; else goto cbqqO;
       cbqqP: // global
           R1 = _cbqq8::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqqO: // global
           R1 = _cbqq8::P64;
           Sp = Sp + 24;
           call io_sbo78_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.99185078 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable_closure" {
     GHC.IO.Handle.hIsSeekable_closure:
         const GHC.IO.Handle.hIsSeekable_info;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable_entry() //  [R2]
         { info_tbl: [(cbqqV,
                       label: GHC.IO.Handle.hIsSeekable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqqV: // global
           R2 = R2;
           call GHC.IO.Handle.hIsSeekable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.992532154 UTC

[section ""cstring" . GHC.IO.Handle.hGetPosn4_bytes" {
     GHC.IO.Handle.hGetPosn4_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.993230999 UTC

[section ""data" . GHC.IO.Handle.hGetPosn3_closure" {
     GHC.IO.Handle.hGetPosn3_closure:
         const GHC.IO.Handle.hGetPosn3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetPosn3_entry() //  [R1]
         { info_tbl: [(cbqr4,
                       label: GHC.IO.Handle.hGetPosn3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqr4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqr5; else goto cbqr6;
       cbqr5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqr6: // global
           (_cbqr1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqr1::I64 == 0) goto cbqr3; else goto cbqr2;
       cbqr3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqr2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqr1::I64;
           R2 = GHC.IO.Handle.hGetPosn4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:16.997160535 UTC

[section ""data" . GHC.IO.Handle.hGetPosn2_closure" {
     GHC.IO.Handle.hGetPosn2_closure:
         const GHC.IO.Handle.hGetPosn2_info;
         const 0;
 },
 sat_sbo88_entry() //  [R1]
         { info_tbl: [(cbqrz,
                       label: sat_sbo88_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqrz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbqrA; else goto cbqrB;
       cbqrA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqrB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbqrw_info;
           _sbo7D::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbo7D::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubqs9; else goto cbqrx;
       ubqs9: // global
           call _cbqrw(R1) args: 0, res: 0, upd: 0;
       cbqrx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqrw() //  [R1]
         { info_tbl: [(cbqrw,
                       label: block_cbqrw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqrw: // global
           I64[Sp - 16] = block_cbqrE_info;
           _sbo81::I64 = I64[R1 + 39];
           _sbo82::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo82::I64;
           I64[Sp] = _sbo81::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubqs8; else goto cbqrG;
       ubqs8: // global
           call _cbqrE(R1) args: 0, res: 0, upd: 0;
       cbqrG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqrE() //  [R1]
         { info_tbl: [(cbqrE,
                       label: block_cbqrE_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqrE: // global
           _sbo81::I64 = I64[Sp + 16];
           _sbo82::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbqrQ; else goto cbqs2;
       cbqrQ: // global
           I64[Sp + 16] = block_cbqrN_info;
           R2 = _sbo82::I64 - _sbo81::I64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
       cbqs2: // global
           I64[Sp + 16] = block_cbqs0_info;
           R2 = _sbo82::I64 - _sbo81::I64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbqrN() //  [R1]
         { info_tbl: [(cbqrN,
                       label: block_cbqrN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqrN: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 _cbqs0() //  [R1]
         { info_tbl: [(cbqs0,
                       label: block_cbqs0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqs0: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo8C_entry() //  [R1]
         { info_tbl: [(cbqsE,
                       label: sat_sbo8C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqsE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqsI; else goto cbqsJ;
       cbqsI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqsJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbqsB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqsN; else goto cbqsC;
       ubqsN: // global
           call _cbqsB(R1) args: 0, res: 0, upd: 0;
       cbqsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqsB() //  [R1]
         { info_tbl: [(cbqsB,
                       label: block_cbqsB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqsB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqsM; else goto cbqsL;
       cbqsM: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbqsL: // global
           _sbo8x::P64 = P64[R1 + 7];
           _sbo8y::P64 = P64[R1 + 15];
           _sbo8w::I64 = I64[R1 + 23];
           _sbo8z::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo8x::P64;
           P64[Hp - 32] = _sbo8y::P64;
           I64[Hp - 24] = _sbo8w::I64;
           I64[Hp - 16] = _sbo8z::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo8V_entry() //  [R1]
         { info_tbl: [(cbqta,
                       label: sat_sbo8V_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqta: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbqth; else goto cbqti;
       cbqth: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqti: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbqt7_info;
           _sbo8L::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbo8L::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubqtm; else goto cbqt8;
       ubqtm: // global
           call _cbqt7(R1) args: 0, res: 0, upd: 0;
       cbqt8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqt7() //  [R1]
         { info_tbl: [(cbqt7,
                       label: block_cbqt7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqt7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqtl; else goto cbqtk;
       cbqtl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbqtk: // global
           _sbo8P::P64 = P64[R1 + 7];
           _sbo8Q::P64 = P64[R1 + 15];
           _sbo8O::I64 = I64[R1 + 23];
           _sbo8R::I64 = I64[R1 + 31];
           _sbo8T::I64 = I64[R1 + 47];
           _sbo8U::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo8P::P64;
           P64[Hp - 32] = _sbo8Q::P64;
           I64[Hp - 24] = _sbo8O::I64;
           I64[Hp - 16] = _sbo8R::I64;
           I64[Hp - 8] = _sbo8U::I64;
           I64[Hp] = _sbo8T::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.hGetPosn2_entry() //  [R2]
         { info_tbl: [(cbqtn,
                       label: GHC.IO.Handle.hGetPosn2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqtn: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbqto; else goto cbqtp;
       cbqto: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetPosn2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqtp: // global
           I64[Sp - 8] = block_cbqrb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubquZ; else goto cbqrc;
       ubquZ: // global
           call _cbqrb(R1) args: 0, res: 0, upd: 0;
       cbqrc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqrb() //  [R1]
         { info_tbl: [(cbqrb,
                       label: block_cbqrb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqrb: // global
           I64[Sp - 32] = block_cbqrg_info;
           R2 = P64[R1 + 7];
           I64[Sp - 48] = stg_ap_pv_info;
           P64[Sp - 40] = P64[R1 + 31];
           P64[Sp - 24] = P64[R1 + 63];
           P64[Sp - 16] = P64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 95];
           P64[Sp] = P64[R1 + 47];
           Sp = Sp - 48;
           call GHC.IO.Device.tell_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbqrg() //  [R1]
         { info_tbl: [(cbqrg,
                       label: block_cbqrg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqrg: // global
           _sbo7G::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp - 8] = block_cbqri_info;
           _sbo7D::P64 = R1;
           R1 = _sbo7G::P64;
           P64[Sp] = _sbo7D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubquM; else goto cbqrj;
       ubquM: // global
           call _cbqri(R1) args: 0, res: 0, upd: 0;
       cbqrj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqri() //  [R1]
         { info_tbl: [(cbqri,
                       label: block_cbqri_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqri: // global
           I64[Sp - 16] = block_cbqsa_info;
           _sbo7M::I64 = I64[R1 + 39];
           _sbo7N::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo7N::I64;
           I64[Sp] = _sbo7M::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubquN; else goto cbqsb;
       ubquN: // global
           call _cbqsa(R1) args: 0, res: 0, upd: 0;
       cbqsb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqsa() //  [R1]
         { info_tbl: [(cbqsa,
                       label: block_cbqsa_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqsa: // global
           if (R1 & 7 == 1) goto cbqty; else goto cbqut;
       cbqty: // global
           _sbo8c::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_cbqsf_info;
           R1 = _sbo8c::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubquO; else goto cbqsg;
       ubquO: // global
           call _cbqsf(R1) args: 0, res: 0, upd: 0;
       cbqsg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqut: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubquH; else goto cbqur;
       ubquH: // global
           Sp = Sp + 16;
           call _cbqrq() args: 0, res: 0, upd: 0;
       cbqur: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqsf() //  [R1]
         { info_tbl: [(cbqsf,
                       label: block_cbqsf_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqsf: // global
           I64[Sp - 16] = block_cbqsk_info;
           _sbo8i::I64 = I64[R1 + 39];
           _sbo8j::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo8j::I64;
           I64[Sp] = _sbo8i::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubquQ; else goto cbqsl;
       ubquQ: // global
           call _cbqsk(R1) args: 0, res: 0, upd: 0;
       cbqsl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqsk() //  [R1]
         { info_tbl: [(cbqsk,
                       label: block_cbqsk_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqsk: // global
           if (R1 & 7 == 1) goto cbqug; else goto ubquI;
       cbqug: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubquJ; else goto cbqtC;
       ubquJ: // global
           Sp = Sp + 16;
           goto ubquT;
       cbqtC: // global
           _sbo8o::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cbqss_info;
           R1 = _sbo8o::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubquR; else goto cbqst;
       ubquR: // global
           call _cbqss(R1) args: 0, res: 0, upd: 0;
       cbqst: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubquI: // global
           Sp = Sp + 16;
           goto ubquT;
       ubquT: // global
           call _cbqrq() args: 0, res: 0, upd: 0;
     }
 },
 _cbqss() //  [R1]
         { info_tbl: [(cbqss,
                       label: block_cbqss_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqss: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqtF; else goto cbqtE;
       cbqtF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqtE: // global
           _sbo7t::P64 = P64[Sp + 24];
           _sbo8q::P64 = P64[R1 + 7];
           _sbo8r::P64 = P64[R1 + 15];
           _sbo8u::P64 = P64[_sbo7t::P64 + 8];
           I64[Hp - 16] = sat_sbo8C_info;
           P64[Hp] = _sbo8u::P64;
           call MO_WriteBarrier();
           P64[_sbo7t::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7t::P64);
           I64[Sp - 8] = block_cbqsR_info;
           R1 = _sbo8u::P64;
           P64[Sp] = _sbo8r::P64;
           P64[Sp + 16] = _sbo8q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubquU; else goto cbqsS;
       ubquU: // global
           call _cbqsR(R1) args: 0, res: 0, upd: 0;
       cbqsS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqsR() //  [R1]
         { info_tbl: [(cbqsR,
                       label: block_cbqsR_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqsR: // global
           _sbo8L::I64 = I64[R1 + 39];
           if (_sbo8L::I64 != 0) goto cbqtI; else goto cbqud;
       cbqtI: // global
           I64[Sp - 24] = block_cbqsY_info;
           _sbo8G::P64 = P64[R1 + 7];
           _sbo8H::P64 = P64[R1 + 15];
           _sbo8F::I64 = I64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _sbo8H::P64;
           I64[Sp - 8] = _sbo8L::I64;
           P64[Sp] = _sbo8G::P64;
           I64[Sp + 40] = _sbo8F::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubquV; else goto cbqsZ;
       ubquV: // global
           call _cbqsY(R1) args: 0, res: 0, upd: 0;
       cbqsZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqud: // global
           _sbo7q::P64 = P64[Sp + 48];
           _sbo8r::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbo7q::P64 + 8] = _sbo8r::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7q::P64);
           Sp = Sp + 8;
           call _cbqrq() args: 0, res: 0, upd: 0;
     }
 },
 _cbqsY() //  [R1]
         { info_tbl: [(cbqsY,
                       label: block_cbqsY_info
                       rep:StackRep [False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqsY: // global
           if (R1 & 7 == 1) goto cbqtK; else goto cbqu2;
       cbqtK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbqtN; else goto cbqtM;
       cbqtN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqtM: // global
           I64[Hp - 24] = sat_sbo8V_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sbo7q::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sbo7q::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7q::P64);
           Sp = Sp + 32;
           call _cbqrq() args: 0, res: 0, upd: 0;
       cbqu2: // global
           I64[Sp] = block_cbqtQ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubquX; else goto cbqtR;
       ubquX: // global
           call _cbqtQ(R1) args: 0, res: 0, upd: 0;
       cbqtR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqtQ() //  [R1]
         { info_tbl: [(cbqtQ,
                       label: block_cbqtQ_info
                       rep:StackRep [False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqtQ: // global
           I64[Sp - 8] = block_cbqtV_info;
           R2 = P64[Sp + 48];
           _sbo8Z::P64 = P64[R1 + 7];
           _sbo90::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbo90::P64;
           P64[Sp + 48] = _sbo8Z::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqtV() //  [R1]
         { info_tbl: [(cbqtV,
                       label: block_cbqtV_info
                       rep:StackRep [False, False, True, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqtV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqu6; else goto cbqu5;
       cbqu6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqu5: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbo8r::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbqtY_info;
           R5 = Hp - 47;
           R4 = _sbo8r::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqtY() //  [R1]
         { info_tbl: [(cbqtY,
                       label: block_cbqtY_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqtY: // global
           I64[Sp] = block_cbqu0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqv0; else goto cbqu8;
       ubqv0: // global
           call _cbqu0(R1) args: 0, res: 0, upd: 0;
       cbqu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqu0() //  [R1]
         { info_tbl: [(cbqu0,
                       label: block_cbqu0_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqu0: // global
           _sbo7q::P64 = P64[Sp + 40];
           _sbo9c::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbo7q::P64 + 8] = _sbo9c::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7q::P64);
           call _cbqrq() args: 0, res: 0, upd: 0;
     }
 },
 _cbqrq() //  []
         { info_tbl: [(cbqrq,
                       label: block_cbqrq_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqrq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbqtv; else goto cbqtu;
       cbqtv: // global
           HpAlloc = 32;
           I64[Sp] = block_cbqrq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbqtu: // global
           I64[Hp - 24] = sat_sbo88_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[P64[Sp + 40] + 8];
           R1 = Hp - 24;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.004384807 UTC

[section ""data" . GHC.IO.Handle.hTell1_closure" {
     GHC.IO.Handle.hTell1_closure:
         const GHC.IO.Handle.hTell1_info;
         const 0;
 },
 GHC.IO.Handle.hTell1_entry() //  [R2]
         { info_tbl: [(cbqv6,
                       label: GHC.IO.Handle.hTell1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqv6: // global
           R4 = GHC.IO.Handle.hGetPosn2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hGetPosn3_closure;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.00527254 UTC

[section ""data" . GHC.IO.Handle.hTell_closure" {
     GHC.IO.Handle.hTell_closure:
         const GHC.IO.Handle.hTell_info;
         const 0;
 },
 GHC.IO.Handle.hTell_entry() //  [R2]
         { info_tbl: [(cbqvd,
                       label: GHC.IO.Handle.hTell_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqvd: // global
           R2 = R2;
           call GHC.IO.Handle.hTell1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.005961775 UTC

[section ""cstring" . lvl12_rbnWU_bytes" {
     lvl12_rbnWU_bytes:
         I8[] [104,83,101,101,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.006660443 UTC

[section ""data" . lvl13_rbnWV_closure" {
     lvl13_rbnWV_closure:
         const lvl13_rbnWV_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rbnWV_entry() //  [R1]
         { info_tbl: [(cbqvm,
                       label: lvl13_rbnWV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqvm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqvn; else goto cbqvo;
       cbqvn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqvo: // global
           (_cbqvj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqvj::I64 == 0) goto cbqvl; else goto cbqvk;
       cbqvl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqvk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqvj::I64;
           R2 = lvl12_rbnWU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.007687787 UTC

[section ""data" . lvl14_rbnWW_closure" {
     lvl14_rbnWW_closure:
         const lvl14_rbnWW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_rbnWW_entry() //  [R1]
         { info_tbl: [(cbqvv,
                       label: lvl14_rbnWW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqvv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqvw; else goto cbqvx;
       cbqvw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqvx: // global
           (_cbqvs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqvs::I64 == 0) goto cbqvu; else goto cbqvt;
       cbqvu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqvt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqvs::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.013860109 UTC

[section ""data" . GHC.IO.Handle.hSeek1_closure" {
     GHC.IO.Handle.hSeek1_closure:
         const GHC.IO.Handle.hSeek1_info;
         const 0;
 },
 lvl48_sbo9n_entry() //  [R1]
         { info_tbl: [(cbqvI,
                       label: lvl48_sbo9n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqvI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqvM; else goto cbqvN;
       cbqvM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqvN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbqvG_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbqvG() //  [R1]
         { info_tbl: [(cbqvG,
                       label: block_cbqvG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqvG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqvQ; else goto cbqvP;
       cbqvQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cbqvP: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl49_sbo9p_entry() //  [R1]
         { info_tbl: [(cbqvX,
                       label: lvl49_sbo9p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqvX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqw1; else goto cbqw2;
       cbqw1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqw2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbqvV_info;
           R3 = lvl14_rbnWW_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbqvV() //  [R1]
         { info_tbl: [(cbqvV,
                       label: block_cbqvV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqvV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqw5; else goto cbqw4;
       cbqw5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cbqw4: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboao_entry() //  [R1]
         { info_tbl: [(cbqwU,
                       label: sat_sboao_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqwU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqwY; else goto cbqwZ;
       cbqwY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqwZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbqwR_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqx3; else goto cbqwS;
       ubqx3: // global
           call _cbqwR(R1) args: 0, res: 0, upd: 0;
       cbqwS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqwR() //  [R1]
         { info_tbl: [(cbqwR,
                       label: block_cbqwR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqwR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqx2; else goto cbqx1;
       cbqx2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbqx1: // global
           _sboaj::P64 = P64[R1 + 7];
           _sboak::P64 = P64[R1 + 15];
           _sboai::I64 = I64[R1 + 23];
           _sboal::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sboaj::P64;
           P64[Hp - 32] = _sboak::P64;
           I64[Hp - 24] = _sboai::I64;
           I64[Hp - 16] = _sboal::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboaH_entry() //  [R1]
         { info_tbl: [(cbqxq,
                       label: sat_sboaH_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqxq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbqxx; else goto cbqxy;
       cbqxx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqxy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbqxn_info;
           _sboax::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sboax::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubqxC; else goto cbqxo;
       ubqxC: // global
           call _cbqxn(R1) args: 0, res: 0, upd: 0;
       cbqxo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqxn() //  [R1]
         { info_tbl: [(cbqxn,
                       label: block_cbqxn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqxn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqxB; else goto cbqxA;
       cbqxB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbqxA: // global
           _sboaB::P64 = P64[R1 + 7];
           _sboaC::P64 = P64[R1 + 15];
           _sboaA::I64 = I64[R1 + 23];
           _sboaD::I64 = I64[R1 + 31];
           _sboaF::I64 = I64[R1 + 47];
           _sboaG::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sboaB::P64;
           P64[Hp - 32] = _sboaC::P64;
           I64[Hp - 24] = _sboaA::I64;
           I64[Hp - 16] = _sboaD::I64;
           I64[Hp - 8] = _sboaG::I64;
           I64[Hp] = _sboaF::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbobs_entry() //  [R1]
         { info_tbl: [(cbqyf,
                       label: sat_sbobs_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqyf: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbqym; else goto cbqyn;
       cbqym: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqyn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cbqyc_info;
           _sbo9P::P64 = P64[R1 + 24];
           _sbo9O::I64 = I64[R1 + 32];
           _sbo9R::I64 = I64[R1 + 40];
           _sbo9S::I64 = I64[R1 + 48];
           _sbo9T::I64 = I64[R1 + 56];
           R1 = P64[R1 + 16];
           I64[Sp - 56] = _sbo9O::I64;
           P64[Sp - 48] = _sbo9P::P64;
           I64[Sp - 40] = _sbo9R::I64;
           I64[Sp - 32] = _sbo9S::I64;
           I64[Sp - 24] = _sbo9T::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubqyr; else goto cbqyd;
       ubqyr: // global
           call _cbqyc(R1) args: 0, res: 0, upd: 0;
       cbqyd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqyc() //  [R1]
         { info_tbl: [(cbqyc,
                       label: block_cbqyc_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqyc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqyq; else goto cbqyp;
       cbqyq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbqyp: // global
           _sbobr::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = _sbobr::I64;
           I64[Hp] = I64[Sp + 40];
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbobV_entry() //  [R1, R2]
         { info_tbl: [(cbqys,
                       label: sat_sbobV_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqys: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cbqyt; else goto cbqyu;
       cbqyt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqyu: // global
           I64[Sp - 40] = block_cbqwb_info;
           _sbo9k::P64 = P64[R1 + 6];
           _sbo9l::P64 = P64[R1 + 14];
           _sbo9n::P64 = P64[R1 + 22];
           _sbo9p::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 32] = _sbo9k::P64;
           P64[Sp - 24] = _sbo9l::P64;
           P64[Sp - 16] = _sbo9n::P64;
           P64[Sp - 8] = _sbo9p::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubqBl; else goto cbqwc;
       ubqBl: // global
           call _cbqwb(R1) args: 0, res: 0, upd: 0;
       cbqwc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqwb() //  [R1]
         { info_tbl: [(cbqwb,
                       label: block_cbqwb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqwb: // global
           I64[Sp - 64] = block_cbqwg_info;
           _sbo9t::P64 = R1;
           _sbo9u::P64 = P64[R1 + 7];
           _sbo9v::P64 = P64[R1 + 15];
           _sbo9x::P64 = P64[R1 + 31];
           _sbo9z::P64 = P64[R1 + 47];
           _sbo9B::P64 = P64[R1 + 63];
           _sbo9C::P64 = P64[R1 + 71];
           _sbo9F::P64 = P64[R1 + 95];
           R1 = P64[_sbo9C::P64 + 8];
           P64[Sp - 56] = _sbo9u::P64;
           P64[Sp - 48] = _sbo9v::P64;
           P64[Sp - 40] = _sbo9x::P64;
           P64[Sp - 32] = _sbo9z::P64;
           P64[Sp - 24] = _sbo9B::P64;
           P64[Sp - 16] = _sbo9C::P64;
           P64[Sp - 8] = _sbo9F::P64;
           P64[Sp] = _sbo9t::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubqB6; else goto cbqwh;
       ubqB6: // global
           call _cbqwg(R1) args: 0, res: 0, upd: 0;
       cbqwh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqwg() //  [R1]
         { info_tbl: [(cbqwg,
                       label: block_cbqwg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqwg: // global
           I64[Sp - 40] = block_cbqwl_info;
           _sbo9P::P64 = P64[R1 + 7];
           _sbo9O::I64 = I64[R1 + 23];
           _sbo9R::I64 = I64[R1 + 31];
           _sbo9S::I64 = I64[R1 + 39];
           _sbo9T::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _sbo9P::P64;
           I64[Sp - 24] = _sbo9R::I64;
           I64[Sp - 16] = _sbo9S::I64;
           I64[Sp - 8] = _sbo9T::I64;
           I64[Sp] = _sbo9O::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubqB7; else goto cbqwm;
       ubqB7: // global
           call _cbqwl(R1) args: 0, res: 0, upd: 0;
       cbqwm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqwl() //  [R1]
         { info_tbl: [(cbqwl,
                       label: block_cbqwl_info
                       rep:StackRep [False, True, True, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqwl: // global
           if (R1 & 7 == 1) goto cbqzM; else goto cbqAh;
       cbqzM: // global
           I64[Sp] = block_cbqxD_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto ubqB8; else goto cbqxE;
       ubqB8: // global
           call _cbqxD(R1) args: 0, res: 0, upd: 0;
       cbqxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqAh: // global
           _sbobx::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 40] = block_cbqAf_info;
           R1 = _sbobx::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ubqB9; else goto cbqAi;
       ubqB9: // global
           call _cbqAf(R1) args: 0, res: 0, upd: 0;
       cbqAi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqxD() //  [R1]
         { info_tbl: [(cbqxD,
                       label: block_cbqxD_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqxD: // global
           if (R1 & 7 == 2) goto cbqzS; else goto ubqB2;
       cbqzS: // global
           I64[Sp] = block_cbqxJ_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto ubqBf; else goto cbqxK;
       ubqBf: // global
           call _cbqxJ(R1) args: 0, res: 0, upd: 0;
       cbqxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubqB2: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _cbqxJ() //  [R1]
         { info_tbl: [(cbqxJ,
                       label: block_cbqxJ_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqxJ: // global
           if (R1 & 7 == 1) goto cbqzV; else goto ubqB3;
       cbqzV: // global
           I64[Sp] = block_cbqxO_info;
           R1 = P64[Sp + 136];
           if (R1 & 7 != 0) goto ubqBh; else goto cbqxP;
       ubqBh: // global
           call _cbqxO(R1) args: 0, res: 0, upd: 0;
       cbqxP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubqB3: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _cbqxO() //  [R1]
         { info_tbl: [(cbqxO,
                       label: block_cbqxO_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqxO: // global
           if (I64[R1 + 7] == 1) goto cbqzZ; else goto ubqB4;
       cbqzZ: // global
           _sbobm::I64 = I64[Sp + 32] - I64[Sp + 24];
           I64[Sp] = block_cbqxZ_info;
           R2 = _sbobm::I64;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       ubqB4: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _cbqxZ() //  [R1]
         { info_tbl: [(cbqxZ,
                       label: block_cbqxZ_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqxZ: // global
           I64[Sp] = block_cbqy3_info;
           R3 = R1;
           R2 = P64[Sp + 120];
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqy3() //  [R1]
         { info_tbl: [(cbqy3,
                       label: block_cbqy3_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqy3: // global
           if (R1 == 1) goto cbqA5; else goto ubqB5;
       cbqA5: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbqA8; else goto cbqA7;
       cbqA8: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqA7: // global
           I64[Hp - 56] = sat_sbobs_info;
           P64[Hp - 40] = P64[Sp + 128];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 32];
           _sbo9C::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sbo9C::P64 + 8] = Hp - 56;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9C::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ubqB5: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _sbo9V() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo9V: // global
           _sbo9Y::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 8] = block_cbqwv_info;
           R1 = _sbo9Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqBr; else goto cbqww;
       ubqBr: // global
           call _cbqwv(R1) args: 0, res: 0, upd: 0;
       cbqww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqwv() //  [R1]
         { info_tbl: [(cbqwv,
                       label: block_cbqwv_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqwv: // global
           I64[Sp] = block_cbqwA_info;
           _sboa4::I64 = I64[R1 + 39];
           _sboa5::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp + 88] = _sboa5::I64;
           I64[Sp + 96] = _sboa4::I64;
           if (R1 & 7 != 0) goto ubqBa; else goto cbqwB;
       ubqBa: // global
           call _cbqwA(R1) args: 0, res: 0, upd: 0;
       cbqwB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqwA() //  [R1]
         { info_tbl: [(cbqwA,
                       label: block_cbqwA_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqwA: // global
           _sbo9t::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto cbqzD; else goto cbqzI;
       cbqzD: // global
           if (I64[Sp + 96] == I64[Sp + 88]) goto cbqzz; else goto cbqyC;
       cbqzz: // global
           I64[Sp] = block_cbqzy_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
       cbqyC: // global
           _sboaa::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbqwI_info;
           R1 = _sboaa::P64;
           if (R1 & 7 != 0) goto ubqBb; else goto cbqwJ;
       ubqBb: // global
           call _cbqwI(R1) args: 0, res: 0, upd: 0;
       cbqwJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqzI: // global
           I64[Sp] = block_cbqzG_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqzy() //  []
         { info_tbl: [(cbqzy,
                       label: block_cbqzy_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqzy: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbqwI() //  [R1]
         { info_tbl: [(cbqwI,
                       label: block_cbqwI_info
                       rep:StackRep [False, True, False, False, True, False, False, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqwI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqyF; else goto cbqyE;
       cbqyF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqyE: // global
           _sbo9C::P64 = P64[Sp + 48];
           _sboac::P64 = P64[R1 + 7];
           _sboad::P64 = P64[R1 + 15];
           _sboag::P64 = P64[_sbo9C::P64 + 8];
           I64[Hp - 16] = sat_sboao_info;
           P64[Hp] = _sboag::P64;
           call MO_WriteBarrier();
           P64[_sbo9C::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9C::P64);
           I64[Sp] = block_cbqx7_info;
           R1 = _sboag::P64;
           P64[Sp + 88] = _sboad::P64;
           P64[Sp + 96] = _sboac::P64;
           if (R1 & 7 != 0) goto ubqBc; else goto cbqx8;
       ubqBc: // global
           call _cbqx7(R1) args: 0, res: 0, upd: 0;
       cbqx8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqx7() //  [R1]
         { info_tbl: [(cbqx7,
                       label: block_cbqx7_info
                       rep:StackRep [False, True, False, False, True, True, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqx7: // global
           _sboax::I64 = I64[R1 + 39];
           if (_sboax::I64 != 0) goto cbqyI; else goto cbqzu;
       cbqyI: // global
           I64[Sp] = block_cbqxe_info;
           _sboas::P64 = P64[R1 + 7];
           _sboat::P64 = P64[R1 + 15];
           _sboar::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           I64[Sp + 16] = _sboax::I64;
           P64[Sp + 40] = _sboat::P64;
           P64[Sp + 48] = _sboas::P64;
           I64[Sp + 56] = _sboar::I64;
           if (R1 & 7 != 0) goto ubqBd; else goto cbqxf;
       ubqBd: // global
           call _cbqxe(R1) args: 0, res: 0, upd: 0;
       cbqxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqzu: // global
           _sbo9t::P64 = P64[Sp + 64];
           _sbo9z::P64 = P64[Sp + 32];
           _sboad::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = _sboad::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           I64[Sp] = block_cbqzt_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqxe() //  [R1]
         { info_tbl: [(cbqxe,
                       label: block_cbqxe_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqxe: // global
           if (R1 & 7 == 1) goto cbqyO; else goto cbqzg;
       cbqyO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbqyR; else goto cbqyQ;
       cbqyR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqyQ: // global
           I64[Hp - 24] = sat_sboaH_info;
           P64[Hp - 8] = P64[Sp + 88];
           I64[Hp] = I64[Sp + 16];
           _sbo9t::P64 = P64[Sp + 64];
           _sbo9z::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           I64[Sp] = block_cbqyM_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
       cbqzg: // global
           I64[Sp] = block_cbqyW_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqBe; else goto cbqyX;
       ubqBe: // global
           call _cbqyW(R1) args: 0, res: 0, upd: 0;
       cbqyX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqyM() //  []
         { info_tbl: [(cbqyM,
                       label: block_cbqyM_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqyM: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbqyW() //  [R1]
         { info_tbl: [(cbqyW,
                       label: block_cbqyW_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqyW: // global
           I64[Sp - 8] = block_cbqz1_info;
           R2 = P64[Sp + 96];
           _sboaO::P64 = P64[R1 + 7];
           _sboaP::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sboaP::P64;
           P64[Sp + 96] = _sboaO::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqz1() //  [R1]
         { info_tbl: [(cbqz1,
                       label: block_cbqz1_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqz1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqzk; else goto cbqzj;
       cbqzk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqzj: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 48];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sboaP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbqz4_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 96];
           R3 = _sboaP::P64;
           R2 = P64[Sp + 104];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqz4() //  [R1]
         { info_tbl: [(cbqz4,
                       label: block_cbqz4_info
                       rep:StackRep [False, True, False, False, True, True, True, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqz4: // global
           I64[Sp] = block_cbqz6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqBm; else goto cbqz7;
       ubqBm: // global
           call _cbqz6(R1) args: 0, res: 0, upd: 0;
       cbqz7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqz6() //  [R1]
         { info_tbl: [(cbqz6,
                       label: block_cbqz6_info
                       rep:StackRep [False, True, False, False, True, True, True, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqz6: // global
           _sbo9t::P64 = P64[Sp + 64];
           _sbo9z::P64 = P64[Sp + 32];
           _sbob1::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = _sbob1::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           I64[Sp] = block_cbqze_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqze() //  []
         { info_tbl: [(cbqze,
                       label: block_cbqze_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqze: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbqzt() //  []
         { info_tbl: [(cbqzt,
                       label: block_cbqzt_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqzt: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbqzG() //  []
         { info_tbl: [(cbqzG,
                       label: block_cbqzG_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqzG: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbqAf() //  [R1]
         { info_tbl: [(cbqAf,
                       label: block_cbqAf_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqAf: // global
           I64[Sp] = block_cbqAm_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubqBn; else goto cbqAo;
       ubqBn: // global
           call _cbqAm(R1) args: 0, res: 0, upd: 0;
       cbqAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqAm() //  [R1]
         { info_tbl: [(cbqAm,
                       label: block_cbqAm_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqAm: // global
           if (R1 & 7 == 1) goto ubqB0; else goto cbqAz;
       ubqB0: // global
           Sp = Sp + 8;
           call _cbqAN() args: 0, res: 0, upd: 0;
       cbqAz: // global
           _sbobI::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp] = block_cbqAx_info;
           R1 = _sbobI::P64;
           if (R1 & 7 != 0) goto ubqBo; else goto cbqAA;
       ubqBo: // global
           call _cbqAx(R1) args: 0, res: 0, upd: 0;
       cbqAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqAx() //  [R1]
         { info_tbl: [(cbqAx,
                       label: block_cbqAx_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqAx: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubqB1; else goto cbqAK;
       ubqB1: // global
           Sp = Sp + 8;
           call _cbqAN() args: 0, res: 0, upd: 0;
       cbqAK: // global
           I64[Sp] = block_cbqAI_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbqAN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqAN: // global
           R2 = P64[Sp];
           _sbo9k::P64 = P64[Sp + 64];
           I64[Sp + 64] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 16];
           P64[Sp + 80] = _sbo9k::P64;
           P64[Sp + 88] = _sbo9l::P64;
           Sp = Sp + 64;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbqAI() //  [R1]
         { info_tbl: [(cbqAI,
                       label: block_cbqAI_info
                       rep:StackRep [False, True, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqAI: // global
           _sbo9k::P64 = P64[Sp + 72];
           _sbo9l::P64 = P64[Sp + 80];
           _sbo9u::P64 = P64[Sp + 8];
           _sbo9x::P64 = P64[Sp + 24];
           _sbo9z::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           R2 = _sbo9u::P64;
           I64[Sp + 72] = stg_ap_pppv_info;
           P64[Sp + 80] = _sbo9x::P64;
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSeek1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbqBs,
                       label: GHC.IO.Handle.hSeek1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqBs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbqBw; else goto cbqBv;
       cbqBw: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSeek1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqBv: // global
           I64[Hp - 80] = lvl48_sbo9n_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl49_sbo9p_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sbobV_info;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = Hp - 30;
           R3 = R2;
           R2 = lvl13_rbnWV_closure;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.026704124 UTC

[section ""data" . GHC.IO.Handle.hSeek_closure" {
     GHC.IO.Handle.hSeek_closure:
         const GHC.IO.Handle.hSeek_info;
         const 0;
 },
 GHC.IO.Handle.hSeek_entry() //  [R2, R3, R4]
         { info_tbl: [(cbqBB,
                       label: GHC.IO.Handle.hSeek_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqBB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSeek1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.027753829 UTC

[section ""data" . GHC.IO.Handle.hSetPosn1_closure" {
     GHC.IO.Handle.hSetPosn1_closure:
         const GHC.IO.Handle.hSetPosn1_info;
         const 0;
 },
 GHC.IO.Handle.hSetPosn1_entry() //  [R2]
         { info_tbl: [(cbqBL,
                       label: GHC.IO.Handle.hSetPosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqBL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbqBM; else goto cbqBN;
       cbqBM: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hSetPosn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqBN: // global
           I64[Sp - 8] = block_cbqBI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqBR; else goto cbqBJ;
       ubqBR: // global
           call _cbqBI(R1) args: 0, res: 0, upd: 0;
       cbqBJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqBI() //  [R1]
         { info_tbl: [(cbqBI,
                       label: block_cbqBI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqBI: // global
           R4 = P64[R1 + 15];
           R3 = GHC.IO.Device.AbsoluteSeek_closure+1;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.hSeek1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.028940864 UTC

[section ""data" . GHC.IO.Handle.hSetPosn_closure" {
     GHC.IO.Handle.hSetPosn_closure:
         const GHC.IO.Handle.hSetPosn_info;
         const 0;
 },
 GHC.IO.Handle.hSetPosn_entry() //  [R2]
         { info_tbl: [(cbqBW,
                       label: GHC.IO.Handle.hSetPosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqBW: // global
           R2 = R2;
           call GHC.IO.Handle.hSetPosn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.029673431 UTC

[section ""cstring" . GHC.IO.Handle.hGetEncoding4_bytes" {
     GHC.IO.Handle.hGetEncoding4_bytes:
         I8[] [104,71,101,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.033407098 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding3_closure" {
     GHC.IO.Handle.hGetEncoding3_closure:
         const GHC.IO.Handle.hGetEncoding3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEncoding3_entry() //  [R1]
         { info_tbl: [(cbqC5,
                       label: GHC.IO.Handle.hGetEncoding3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqC5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqC6; else goto cbqC7;
       cbqC6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqC7: // global
           (_cbqC2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqC2::I64 == 0) goto cbqC4; else goto cbqC3;
       cbqC4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqC3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqC2::I64;
           R2 = GHC.IO.Handle.hGetEncoding4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.034587354 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding2_closure" {
     GHC.IO.Handle.hGetEncoding2_closure:
         const GHC.IO.Handle.hGetEncoding2_info;
 },
 GHC.IO.Handle.hGetEncoding2_entry() //  [R2]
         { info_tbl: [(cbqCf,
                       label: GHC.IO.Handle.hGetEncoding2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqCf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbqCj; else goto cbqCk;
       cbqCj: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEncoding2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqCk: // global
           I64[Sp - 8] = block_cbqCc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqCo; else goto cbqCd;
       ubqCo: // global
           call _cbqCc(R1) args: 0, res: 0, upd: 0;
       cbqCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqCc() //  [R1]
         { info_tbl: [(cbqCc,
                       label: block_cbqCc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqCc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqCn; else goto cbqCm;
       cbqCn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqCm: // global
           _sbocg::P64 = P64[R1 + 103];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sbocg::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.036776656 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding1_closure" {
     GHC.IO.Handle.hGetEncoding1_closure:
         const GHC.IO.Handle.hGetEncoding1_info;
         const 0;
 },
 io_sboct_entry() //  [R1]
         { info_tbl: [(cbqCK,
                       label: io_sboct_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqCK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqCO; else goto cbqCP;
       cbqCO: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqCP: // global
           I64[Sp - 16] = block_cbqCF_info;
           _sbocp::P64 = P64[R1 + 15];
           R5 = _sbocp::P64;
           R4 = GHC.IO.Handle.hGetEncoding2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEncoding3_closure;
           P64[Sp - 8] = _sbocp::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqCF() //  [R1]
         { info_tbl: [(cbqCF,
                       label: block_cbqCF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqCF: // global
           I64[Sp] = block_cbqCH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqCU; else goto cbqCI;
       ubqCU: // global
           call _cbqCH(R1) args: 0, res: 0, upd: 0;
       cbqCI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqCH() //  [R1]
         { info_tbl: [(cbqCH,
                       label: block_cbqCH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqCH: // global
           I64[Sp] = block_cbqCN_info;
           R2 = P64[R1 + 7];
           _sbocA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbocA::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqCN() //  []
         { info_tbl: [(cbqCN,
                       label: block_cbqCN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqCN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbocJ_entry() //  [R1]
         { info_tbl: [(cbqD9,
                       label: io_sbocJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqD9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqDd; else goto cbqDe;
       cbqDd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqDe: // global
           I64[Sp - 16] = block_cbqD4_info;
           _sbocE::P64 = P64[R1 + 15];
           R5 = _sbocE::P64;
           R4 = GHC.IO.Handle.hGetEncoding2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEncoding3_closure;
           P64[Sp - 8] = _sbocE::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqD4() //  [R1]
         { info_tbl: [(cbqD4,
                       label: block_cbqD4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqD4: // global
           I64[Sp] = block_cbqD6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqDj; else goto cbqD7;
       ubqDj: // global
           call _cbqD6(R1) args: 0, res: 0, upd: 0;
       cbqD7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqD6() //  [R1]
         { info_tbl: [(cbqD6,
                       label: block_cbqD6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqD6: // global
           I64[Sp] = block_cbqDc_info;
           R2 = P64[R1 + 7];
           _sbocQ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbocQ::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqDc() //  []
         { info_tbl: [(cbqDc,
                       label: block_cbqDc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqDc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hGetEncoding1_entry() //  [R2]
         { info_tbl: [(cbqDo,
                       label: GHC.IO.Handle.hGetEncoding1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqDo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqDp; else goto cbqDq;
       cbqDp: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEncoding1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqDq: // global
           I64[Sp - 8] = block_cbqCt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqDH; else goto cbqCu;
       ubqDH: // global
           call _cbqCt(R1) args: 0, res: 0, upd: 0;
       cbqCu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqCt() //  [R1]
         { info_tbl: [(cbqCt,
                       label: block_cbqCt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqCt: // global
           if (R1 & 7 == 1) goto cbqDl; else goto cbqDm;
       cbqDl: // global
           I64[Sp - 16] = block_cbqCy_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbqDm: // global
           I64[Sp - 16] = block_cbqCX_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbqCy() //  [R1]
         { info_tbl: [(cbqCy,
                       label: block_cbqCy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqCy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqDu; else goto cbqDt;
       cbqDu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqDt: // global
           I64[Hp - 16] = io_sboct_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqCA::P64 = Hp - 15;
           if (R1 == 0) goto cbqDy; else goto cbqDx;
       cbqDy: // global
           R1 = _cbqCA::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqDx: // global
           R1 = _cbqCA::P64;
           Sp = Sp + 24;
           call io_sboct_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqCX() //  [R1]
         { info_tbl: [(cbqCX,
                       label: block_cbqCX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqCX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqDC; else goto cbqDB;
       cbqDC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqDB: // global
           I64[Hp - 16] = io_sbocJ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqCZ::P64 = Hp - 15;
           if (R1 == 0) goto cbqDG; else goto cbqDF;
       cbqDG: // global
           R1 = _cbqCZ::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqDF: // global
           R1 = _cbqCZ::P64;
           Sp = Sp + 24;
           call io_sbocJ_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.039827448 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding_closure" {
     GHC.IO.Handle.hGetEncoding_closure:
         const GHC.IO.Handle.hGetEncoding_info;
         const 0;
 },
 GHC.IO.Handle.hGetEncoding_entry() //  [R2]
         { info_tbl: [(cbqDM,
                       label: GHC.IO.Handle.hGetEncoding_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqDM: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.040497884 UTC

[section ""cstring" . lvl15_rbnWX_bytes" {
     lvl15_rbnWX_bytes:
         I8[] [104,83,101,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.041189307 UTC

[section ""data" . lvl16_rbnWY_closure" {
     lvl16_rbnWY_closure:
         const lvl16_rbnWY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_rbnWY_entry() //  [R1]
         { info_tbl: [(cbqDV,
                       label: lvl16_rbnWY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqDV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqDW; else goto cbqDX;
       cbqDW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqDX: // global
           (_cbqDS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqDS::I64 == 0) goto cbqDU; else goto cbqDT;
       cbqDU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqDT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqDS::I64;
           R2 = lvl15_rbnWX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.042066148 UTC

[section ""cstring" . lvl17_rbnWZ_bytes" {
     lvl17_rbnWZ_bytes:
         I8[] [108,97,115,116,95,100,101,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.042860784 UTC

[section ""data" . lvl18_rbnX0_closure" {
     lvl18_rbnX0_closure:
         const lvl18_rbnX0_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rbnX0_entry() //  [R1]
         { info_tbl: [(cbqE6,
                       label: lvl18_rbnX0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqE6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqE7; else goto cbqE8;
       cbqE7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqE8: // global
           (_cbqE1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqE1::I64 == 0) goto cbqE3; else goto cbqE2;
       cbqE3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqE2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqE1::I64;
           I64[Sp - 24] = block_cbqE4_info;
           R2 = lvl17_rbnWZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbqE4() //  [R1]
         { info_tbl: [(cbqE4,
                       label: block_cbqE4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqE4: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.049679094 UTC

[section ""data" . GHC.IO.Handle.hSetEncoding1_closure" {
     GHC.IO.Handle.hSetEncoding1_closure:
         const GHC.IO.Handle.hSetEncoding1_info;
         const 0;
 },
 sat_sbofq_entry() //  [R1]
         { info_tbl: [(cbqF2,
                       label: sat_sbofq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqF2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqF6; else goto cbqF7;
       cbqF6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqF7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbqEZ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqFb; else goto cbqF0;
       ubqFb: // global
           call _cbqEZ(R1) args: 0, res: 0, upd: 0;
       cbqF0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqEZ() //  [R1]
         { info_tbl: [(cbqEZ,
                       label: block_cbqEZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqEZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqFa; else goto cbqF9;
       cbqFa: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbqF9: // global
           _sbofl::P64 = P64[R1 + 7];
           _sbofm::P64 = P64[R1 + 15];
           _sbofk::I64 = I64[R1 + 23];
           _sbofn::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbofl::P64;
           P64[Hp - 32] = _sbofm::P64;
           I64[Hp - 24] = _sbofk::I64;
           I64[Hp - 16] = _sbofn::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbofJ_entry() //  [R1]
         { info_tbl: [(cbqFy,
                       label: sat_sbofJ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqFy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbqFF; else goto cbqFG;
       cbqFF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqFG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbqFv_info;
           _sbofz::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbofz::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubqFK; else goto cbqFw;
       ubqFK: // global
           call _cbqFv(R1) args: 0, res: 0, upd: 0;
       cbqFw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbqFv() //  [R1]
         { info_tbl: [(cbqFv,
                       label: block_cbqFv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqFv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqFJ; else goto cbqFI;
       cbqFJ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbqFI: // global
           _sbofD::P64 = P64[R1 + 7];
           _sbofE::P64 = P64[R1 + 15];
           _sbofC::I64 = I64[R1 + 23];
           _sbofF::I64 = I64[R1 + 31];
           _sbofH::I64 = I64[R1 + 47];
           _sbofI::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbofD::P64;
           P64[Hp - 32] = _sbofE::P64;
           I64[Hp - 24] = _sbofC::I64;
           I64[Hp - 16] = _sbofF::I64;
           I64[Hp - 8] = _sbofI::I64;
           I64[Hp] = _sbofH::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbog6_entry() //  [R1, R2]
         { info_tbl: [(cbqFL,
                       label: sat_sbog6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqFL: // global
           if ((Sp + -192) < SpLim) (likely: False) goto cbqFM; else goto cbqFN;
       cbqFM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqFN: // global
           I64[Sp - 24] = block_cbqEm_info;
           _sbocV::P64 = P64[R1 + 6];
           _sbocX::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbocV::P64;
           P64[Sp - 8] = _sbocX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqKi; else goto cbqEn;
       ubqKi: // global
           call _cbqEm(R1) args: 0, res: 0, upd: 0;
       cbqEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqEm() //  [R1]
         { info_tbl: [(cbqEm,
                       label: block_cbqEm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqEm: // global
           I64[Sp - 120] = block_cbqEr_info;
           _sbod1::P64 = P64[R1 + 7];
           _sbod2::P64 = P64[R1 + 15];
           _sbod3::P64 = P64[R1 + 23];
           _sbod4::P64 = P64[R1 + 31];
           _sbod5::P64 = P64[R1 + 39];
           _sbod6::P64 = P64[R1 + 47];
           _sbod7::P64 = P64[R1 + 55];
           _sbod8::P64 = P64[R1 + 63];
           _sbod9::P64 = P64[R1 + 71];
           _sboda::P64 = P64[R1 + 79];
           _sbodb::P64 = P64[R1 + 87];
           _sbodc::P64 = P64[R1 + 95];
           _sbode::P64 = P64[R1 + 111];
           _sbodf::P64 = P64[R1 + 119];
           _sbodg::P64 = P64[R1 + 127];
           R1 = P64[_sbod9::P64 + 8];
           P64[Sp - 112] = _sbod2::P64;
           P64[Sp - 104] = _sbod3::P64;
           P64[Sp - 96] = _sbod4::P64;
           P64[Sp - 88] = _sbod5::P64;
           P64[Sp - 80] = _sbod6::P64;
           P64[Sp - 72] = _sbod7::P64;
           P64[Sp - 64] = _sbod8::P64;
           P64[Sp - 56] = _sbod9::P64;
           P64[Sp - 48] = _sboda::P64;
           P64[Sp - 40] = _sbodb::P64;
           P64[Sp - 32] = _sbodc::P64;
           P64[Sp - 24] = _sbode::P64;
           P64[Sp - 16] = _sbodf::P64;
           P64[Sp - 8] = _sbodg::P64;
           P64[Sp] = _sbod1::P64;
           Sp = Sp - 120;
           if (R1 & 7 != 0) goto ubqK5; else goto cbqEs;
       ubqK5: // global
           call _cbqEr(R1) args: 0, res: 0, upd: 0;
       cbqEs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqEr() //  [R1]
         { info_tbl: [(cbqEr,
                       label: block_cbqEr_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqEr: // global
           I64[Sp - 16] = block_cbqEy_info;
           _sbodp::I64 = I64[R1 + 39];
           _sbodq::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbodq::I64;
           I64[Sp] = _sbodp::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubqK6; else goto cbqEz;
       ubqK6: // global
           call _cbqEy(R1) args: 0, res: 0, upd: 0;
       cbqEz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqEy() //  [R1]
         { info_tbl: [(cbqEy,
                       label: block_cbqEy_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqEy: // global
           if (R1 & 7 == 1) goto cbqIz; else goto cbqJu;
       cbqIz: // global
           _sbof0::P64 = P64[P64[Sp + 80] + 8];
           I64[Sp + 16] = block_cbqED_info;
           R1 = _sbof0::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubqK7; else goto cbqEE;
       ubqK7: // global
           call _cbqED(R1) args: 0, res: 0, upd: 0;
       cbqEE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqJu: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubqJS; else goto cbqJs;
       ubqJS: // global
           Sp = Sp + 24;
           call _sbodr() args: 0, res: 0, upd: 0;
       cbqJs: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 160;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqED() //  [R1]
         { info_tbl: [(cbqED,
                       label: block_cbqED_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqED: // global
           I64[Sp - 16] = block_cbqEI_info;
           _sbof6::I64 = I64[R1 + 39];
           _sbof7::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbof7::I64;
           I64[Sp] = _sbof6::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubqK9; else goto cbqEJ;
       ubqK9: // global
           call _cbqEI(R1) args: 0, res: 0, upd: 0;
       cbqEJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqEI() //  [R1]
         { info_tbl: [(cbqEI,
                       label: block_cbqEI_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqEI: // global
           if (R1 & 7 == 1) goto cbqJh; else goto ubqJT;
       cbqJh: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubqJU; else goto cbqID;
       ubqJU: // global
           Sp = Sp + 24;
           goto ubqKc;
       cbqID: // global
           _sbofc::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cbqEQ_info;
           R1 = _sbofc::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubqKa; else goto cbqER;
       ubqKa: // global
           call _cbqEQ(R1) args: 0, res: 0, upd: 0;
       cbqER: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubqJT: // global
           Sp = Sp + 24;
           goto ubqKc;
       ubqKc: // global
           call _sbodr() args: 0, res: 0, upd: 0;
     }
 },
 _cbqEQ() //  [R1]
         { info_tbl: [(cbqEQ,
                       label: block_cbqEQ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqEQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqIG; else goto cbqIF;
       cbqIG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqIF: // global
           _sbod9::P64 = P64[Sp + 64];
           _sbofe::P64 = P64[R1 + 7];
           _sboff::P64 = P64[R1 + 15];
           _sbofi::P64 = P64[_sbod9::P64 + 8];
           I64[Hp - 16] = sat_sbofq_info;
           P64[Hp] = _sbofi::P64;
           call MO_WriteBarrier();
           P64[_sbod9::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod9::P64);
           I64[Sp - 8] = block_cbqFf_info;
           R1 = _sbofi::P64;
           P64[Sp] = _sboff::P64;
           P64[Sp + 56] = _sbofe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqKd; else goto cbqFg;
       ubqKd: // global
           call _cbqFf(R1) args: 0, res: 0, upd: 0;
       cbqFg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqFf() //  [R1]
         { info_tbl: [(cbqFf,
                       label: block_cbqFf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqFf: // global
           _sbofz::I64 = I64[R1 + 39];
           if (_sbofz::I64 != 0) goto cbqIJ; else goto cbqJe;
       cbqIJ: // global
           I64[Sp - 32] = block_cbqFm_info;
           _sbofu::P64 = P64[R1 + 7];
           _sbofv::P64 = P64[R1 + 15];
           _sboft::I64 = I64[R1 + 23];
           R1 = P64[Sp + 96];
           P64[Sp - 24] = _sbofu::P64;
           P64[Sp - 16] = _sbofv::P64;
           I64[Sp - 8] = _sbofz::I64;
           I64[Sp] = _sboft::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubqKe; else goto cbqFn;
       ubqKe: // global
           call _cbqFm(R1) args: 0, res: 0, upd: 0;
       cbqFn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqJe: // global
           _sbod6::P64 = P64[Sp + 48];
           _sboff::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbod6::P64 + 8] = _sboff::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod6::P64);
           Sp = Sp + 16;
           call _sbodr() args: 0, res: 0, upd: 0;
     }
 },
 _cbqFm() //  [R1]
         { info_tbl: [(cbqFm,
                       label: block_cbqFm_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqFm: // global
           if (R1 & 7 == 1) goto cbqIL; else goto cbqJ3;
       cbqIL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbqIO; else goto cbqIN;
       cbqIO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqIN: // global
           I64[Hp - 24] = sat_sbofJ_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 24];
           _sbod6::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sbod6::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod6::P64);
           Sp = Sp + 48;
           call _sbodr() args: 0, res: 0, upd: 0;
       cbqJ3: // global
           I64[Sp] = block_cbqIR_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqKg; else goto cbqIS;
       ubqKg: // global
           call _cbqIR(R1) args: 0, res: 0, upd: 0;
       cbqIS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqIR() //  [R1]
         { info_tbl: [(cbqIR,
                       label: block_cbqIR_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqIR: // global
           I64[Sp - 8] = block_cbqIW_info;
           R2 = P64[Sp + 96];
           _sbofN::P64 = P64[R1 + 7];
           _sbofO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbofO::P64;
           P64[Sp + 96] = _sbofN::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqIW() //  [R1]
         { info_tbl: [(cbqIW,
                       label: block_cbqIW_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqIW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbqJ7; else goto cbqJ6;
       cbqJ7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqJ6: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sboff::P64 = P64[Sp + 48];
           I64[Sp + 48] = block_cbqIZ_info;
           R5 = Hp - 47;
           R4 = _sboff::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 104];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqIZ() //  [R1]
         { info_tbl: [(cbqIZ,
                       label: block_cbqIZ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqIZ: // global
           I64[Sp] = block_cbqJ1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqKw; else goto cbqJ9;
       ubqKw: // global
           call _cbqJ1(R1) args: 0, res: 0, upd: 0;
       cbqJ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqJ1() //  [R1]
         { info_tbl: [(cbqJ1,
                       label: block_cbqJ1_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqJ1: // global
           _sbod6::P64 = P64[Sp + 40];
           _sbog0::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbod6::P64 + 8] = _sbog0::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod6::P64);
           Sp = Sp + 8;
           call _sbodr() args: 0, res: 0, upd: 0;
     }
 },
 _sbodr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbodr: // global
           I64[Sp - 8] = block_cbqFV_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqKy; else goto cbqHx;
       ubqKy: // global
           call _cbqFV(R1) args: 0, res: 0, upd: 0;
       cbqHx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqFV() //  [R1]
         { info_tbl: [(cbqFV,
                       label: block_cbqFV_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqFV: // global
           if (R1 & 7 == 1) goto cbqHE; else goto cbqI3;
       cbqHE: // global
           I64[Sp] = block_cbqHB_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubqKj; else goto cbqHF;
       ubqKj: // global
           call _cbqHB(R1) args: 0, res: 0, upd: 0;
       cbqHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqI3: // global
           I64[Sp] = block_cbqI1_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqKk; else goto cbqI4;
       ubqKk: // global
           call _cbqI1(R1) args: 0, res: 0, upd: 0;
       cbqI4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqHB() //  [R1]
         { info_tbl: [(cbqHB,
                       label: block_cbqHB_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqHB: // global
           if (R1 & 7 == 1) goto ubqK0; else goto cbqHV;
       ubqK0: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
       cbqHV: // global
           I64[Sp] = block_cbqHO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqKp; else goto cbqHP;
       ubqKp: // global
           call _cbqHO(R1) args: 0, res: 0, upd: 0;
       cbqHP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqHO() //  [R1]
         { info_tbl: [(cbqHO,
                       label: block_cbqHO_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqHO: // global
           I64[Sp] = block_cbqHT_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqHT() //  []
         { info_tbl: [(cbqHT,
                       label: block_cbqHT_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqHT: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
     }
 },
 _cbqI1() //  [R1]
         { info_tbl: [(cbqI1,
                       label: block_cbqI1_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqI1: // global
           I64[Sp] = block_cbqI8_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqI8() //  []
         { info_tbl: [(cbqI8,
                       label: block_cbqI8_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqI8: // global
           I64[Sp] = block_cbqIa_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubqKs; else goto cbqId;
       ubqKs: // global
           call _cbqIa(R1) args: 0, res: 0, upd: 0;
       cbqId: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqIa() //  [R1]
         { info_tbl: [(cbqIa,
                       label: block_cbqIa_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqIa: // global
           if (R1 & 7 == 1) goto ubqJY; else goto cbqIt;
       ubqJY: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
       cbqIt: // global
           I64[Sp] = block_cbqIm_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqKt; else goto cbqIn;
       ubqKt: // global
           call _cbqIm(R1) args: 0, res: 0, upd: 0;
       cbqIn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqIm() //  [R1]
         { info_tbl: [(cbqIm,
                       label: block_cbqIm_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqIm: // global
           I64[Sp] = block_cbqIr_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqIr() //  []
         { info_tbl: [(cbqIr,
                       label: block_cbqIr_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqIr: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
     }
 },
 _sbodt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbodt: // global
           I64[Sp - 8] = block_cbqG0_info;
           R1 = P64[Sp + 120];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqKz; else goto cbqG2;
       ubqKz: // global
           call _cbqG0(R1) args: 0, res: 0, upd: 0;
       cbqG2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqG0() //  [R1]
         { info_tbl: [(cbqG0,
                       label: block_cbqG0_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqG0: // global
           I64[Sp] = block_cbqG8_info;
           _sbodx::P64 = P64[R1 + 15];
           _sbody::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp + 88] = _sbody::P64;
           P64[Sp + 128] = _sbodx::P64;
           if (R1 & 7 != 0) goto ubqKl; else goto cbqH8;
       ubqKl: // global
           call _cbqG8(R1) args: 0, res: 0, upd: 0;
       cbqH8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqG8() //  [R1]
         { info_tbl: [(cbqG8,
                       label: block_cbqG8_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqG8: // global
           _sbodx::P64 = P64[Sp + 128];
           _cbqJL::P64 = R1 & 7;
           if (_cbqJL::P64 != 3) goto ubqJP; else goto cbqHj;
       ubqJP: // global
           if (_cbqJL::P64 != 6) goto cbqHe; else goto cbqHs;
       cbqHe: // global
           P64[Sp + 128] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbodz() args: 0, res: 0, upd: 0;
       cbqHs: // global
           I64[Sp] = block_cbqHq_info;
           R1 = _sbodx::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbqHj: // global
           I64[Sp] = block_cbqHh_info;
           R1 = _sbodx::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqHq() //  [R1]
         { info_tbl: [(cbqHq,
                       label: block_cbqHq_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqHq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqHw; else goto cbqHv;
       cbqHw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqHv: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 128] = Hp - 6;
           Sp = Sp + 8;
           call _sbodz() args: 0, res: 0, upd: 0;
     }
 },
 _cbqHh() //  [R1]
         { info_tbl: [(cbqHh,
                       label: block_cbqHh_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqHh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqHn; else goto cbqHm;
       cbqHn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqHm: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 128] = Hp - 6;
           Sp = Sp + 8;
           call _sbodz() args: 0, res: 0, upd: 0;
     }
 },
 _sbodz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbodz: // global
           I64[Sp - 8] = block_cbqGd_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqKA; else goto cbqGf;
       ubqKA: // global
           call _cbqGd(R1) args: 0, res: 0, upd: 0;
       cbqGf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqGd() //  [R1]
         { info_tbl: [(cbqGd,
                       label: block_cbqGd_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqGd: // global
           _sbody::P64 = P64[Sp + 88];
           _cbqJO::P64 = R1 & 7;
           if (_cbqJO::P64 < 5) goto ubqJQ; else goto ubqJR;
       ubqJQ: // global
           if (_cbqJO::P64 < 4) goto cbqGo; else goto cbqGB;
       cbqGo: // global
           I64[Sp] = block_cbqGj_info;
           _sbodC::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbodC::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbqGB: // global
           I64[Sp] = block_cbqGu_info;
           R1 = _sbody::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ubqJR: // global
           if (_cbqJO::P64 < 6) goto cbqGP; else goto cbqH3;
       cbqGP: // global
           I64[Sp] = block_cbqGI_info;
           R1 = _sbody::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbqH3: // global
           I64[Sp] = block_cbqGW_info;
           R1 = _sbody::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqGj() //  [R1]
         { info_tbl: [(cbqGj,
                       label: block_cbqGj_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqGj: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbqGr; else goto cbqGq;
       cbqGr: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqGq: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 88];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqGu() //  [R1]
         { info_tbl: [(cbqGu,
                       label: block_cbqGu_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqGu: // global
           I64[Sp] = block_cbqGw_info;
           _sbodM::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbodM::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqGw() //  [R1]
         { info_tbl: [(cbqGw,
                       label: block_cbqGw_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqGw: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbqGF; else goto cbqGE;
       cbqGF: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqGE: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqGI() //  [R1]
         { info_tbl: [(cbqGI,
                       label: block_cbqGI_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqGI: // global
           I64[Sp] = block_cbqGK_info;
           _sbodX::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbodX::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqGK() //  [R1]
         { info_tbl: [(cbqGK,
                       label: block_cbqGK_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqGK: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbqGT; else goto cbqGS;
       cbqGT: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqGS: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.AppendHandle_closure+5;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqGW() //  [R1]
         { info_tbl: [(cbqGW,
                       label: block_cbqGW_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqGW: // global
           I64[Sp] = block_cbqGY_info;
           _sboe8::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sboe8::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqGY() //  [R1]
         { info_tbl: [(cbqGY,
                       label: block_cbqGY_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqGY: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbqH7; else goto cbqH6;
       cbqH7: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqH6: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetEncoding1_entry() //  [R2, R3]
         { info_tbl: [(cbqKB,
                       label: GHC.IO.Handle.hSetEncoding1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqKB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbqKF; else goto cbqKE;
       cbqKF: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetEncoding1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqKE: // global
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbog6_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 30;
           R4 = Hp - 14;
           R3 = R2;
           R2 = lvl16_rbnWY_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.062669604 UTC

[section ""data" . GHC.IO.Handle.hSetEncoding_closure" {
     GHC.IO.Handle.hSetEncoding_closure:
         const GHC.IO.Handle.hSetEncoding_info;
         const 0;
 },
 GHC.IO.Handle.hSetEncoding_entry() //  [R2, R3]
         { info_tbl: [(cbqKK,
                       label: GHC.IO.Handle.hSetEncoding_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqKK: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetEncoding1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.063434627 UTC

[section ""cstring" . GHC.IO.Handle.hSetBuffering3_bytes" {
     GHC.IO.Handle.hSetBuffering3_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.064179583 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering2_closure" {
     GHC.IO.Handle.hSetBuffering2_closure:
         const GHC.IO.Handle.hSetBuffering2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetBuffering2_entry() //  [R1]
         { info_tbl: [(cbqKT,
                       label: GHC.IO.Handle.hSetBuffering2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqKT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqKU; else goto cbqKV;
       cbqKU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqKV: // global
           (_cbqKQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqKQ::I64 == 0) goto cbqKS; else goto cbqKR;
       cbqKS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqKR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqKQ::I64;
           R2 = GHC.IO.Handle.hSetBuffering3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.069222319 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering1_closure" {
     GHC.IO.Handle.hSetBuffering1_closure:
         const GHC.IO.Handle.hSetBuffering1_info;
         const 0;
 },
 sat_sbohh_entry() //  [R1, R2]
         { info_tbl: [(cbqL8,
                       label: sat_sbohh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqL8: // global
           if ((Sp + -176) < SpLim) (likely: False) goto cbqL9; else goto cbqLa;
       cbqL9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqLa: // global
           I64[Sp - 16] = block_cbqL5_info;
           _sbog8::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbog8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubqPC; else goto cbqL6;
       ubqPC: // global
           call _cbqL5(R1) args: 0, res: 0, upd: 0;
       cbqL6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqL5() //  [R1]
         { info_tbl: [(cbqL5,
                       label: block_cbqL5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqL5: // global
           I64[Sp - 128] = block_cbqLd_info;
           _sbogc::P64 = R1;
           _sbogd::P64 = P64[R1 + 7];
           _sboge::P64 = P64[R1 + 15];
           _sbogf::P64 = P64[R1 + 23];
           _sbogg::P64 = P64[R1 + 31];
           _sbogi::P64 = P64[R1 + 47];
           _sbogj::P64 = P64[R1 + 55];
           _sbogk::P64 = P64[R1 + 63];
           _sbogl::P64 = P64[R1 + 71];
           _sbogm::P64 = P64[R1 + 79];
           _sbogn::P64 = P64[R1 + 87];
           _sbogo::P64 = P64[R1 + 95];
           _sbogp::P64 = P64[R1 + 103];
           _sbogq::P64 = P64[R1 + 111];
           _sbogr::P64 = P64[R1 + 119];
           _sbogs::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sbogd::P64;
           P64[Sp - 112] = _sboge::P64;
           P64[Sp - 104] = _sbogf::P64;
           P64[Sp - 96] = _sbogg::P64;
           P64[Sp - 88] = _sbogi::P64;
           P64[Sp - 80] = _sbogj::P64;
           P64[Sp - 72] = _sbogk::P64;
           P64[Sp - 64] = _sbogl::P64;
           P64[Sp - 56] = _sbogm::P64;
           P64[Sp - 48] = _sbogn::P64;
           P64[Sp - 40] = _sbogo::P64;
           P64[Sp - 32] = _sbogp::P64;
           P64[Sp - 24] = _sbogq::P64;
           P64[Sp - 16] = _sbogr::P64;
           P64[Sp - 8] = _sbogs::P64;
           P64[Sp] = _sbogc::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto ubqPB; else goto cbqLf;
       ubqPB: // global
           call _cbqLd(R1) args: 0, res: 0, upd: 0;
       cbqLf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqLd() //  [R1]
         { info_tbl: [(cbqLd,
                       label: block_cbqLd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqLd: // global
           if (R1 & 7 == 1) goto cbqP8; else goto cbqNo;
       cbqP8: // global
           Sp = Sp + 144;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbqNo: // global
           I64[Sp - 8] = block_cbqLl_info;
           _sbogt::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp] = _sbogt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqPD; else goto cbqNp;
       ubqPD: // global
           call _cbqLl(R1) args: 0, res: 0, upd: 0;
       cbqNp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqLl() //  [R1]
         { info_tbl: [(cbqLl,
                       label: block_cbqLl_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqLl: // global
           _sbogj::P64 = P64[Sp + 56];
           _cbqPa::P64 = R1 & 7;
           if (_cbqPa::P64 < 3) goto ubqPm; else goto cbqO2;
       ubqPm: // global
           if (_cbqPa::P64 < 2) goto cbqNw; else goto cbqNM;
       cbqNw: // global
           I64[Sp] = block_cbqNt_info;
           R1 = _sbogj::P64;
           if (R1 & 7 != 0) goto ubqPE; else goto cbqNx;
       ubqPE: // global
           call _cbqNt(R1) args: 0, res: 0, upd: 0;
       cbqNx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqNM: // global
           I64[Sp] = block_cbqNK_info;
           R1 = _sbogj::P64;
           if (R1 & 7 != 0) goto ubqPF; else goto cbqNN;
       ubqPF: // global
           call _cbqNK(R1) args: 0, res: 0, upd: 0;
       cbqNN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqO2: // global
           I64[Sp] = block_cbqO0_info;
           _sboh3::P64 = P64[R1 + 5];
           R1 = _sbogj::P64;
           P64[Sp + 56] = _sboh3::P64;
           if (R1 & 7 != 0) goto ubqPG; else goto cbqO3;
       ubqPG: // global
           call _cbqO0(R1) args: 0, res: 0, upd: 0;
       cbqO3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqNt() //  [R1]
         { info_tbl: [(cbqNt,
                       label: block_cbqNt_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqNt: // global
           if (R1 & 7 == 1) goto ubqPo; else goto ubqPp;
       ubqPo: // global
           Sp = Sp + 136;
           call _cbqP4() args: 0, res: 0, upd: 0;
       ubqPp: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbqNK() //  [R1]
         { info_tbl: [(cbqNK,
                       label: block_cbqNK_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqNK: // global
           if (R1 & 7 == 2) goto ubqPq; else goto ubqPr;
       ubqPq: // global
           Sp = Sp + 136;
           call _cbqP4() args: 0, res: 0, upd: 0;
       ubqPr: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbqO0() //  [R1]
         { info_tbl: [(cbqO0,
                       label: block_cbqO0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqO0: // global
           if (R1 & 7 == 3) goto cbqOe; else goto ubqPs;
       cbqOe: // global
           I64[Sp] = block_cbqOc_info;
           _sboh5::P64 = P64[R1 + 5];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _sboh5::P64;
           if (R1 & 7 != 0) goto ubqPT; else goto cbqOf;
       ubqPT: // global
           call _cbqOc(R1) args: 0, res: 0, upd: 0;
       cbqOf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubqPs: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbqOc() //  [R1]
         { info_tbl: [(cbqOc,
                       label: block_cbqOc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqOc: // global
           _sboh5::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cbqOm; else goto cbqOC;
       cbqOm: // global
           I64[Sp] = block_cbqOj_info;
           R1 = _sboh5::P64;
           if (R1 & 7 != 0) goto ubqPV; else goto cbqOn;
       ubqPV: // global
           call _cbqOj(R1) args: 0, res: 0, upd: 0;
       cbqOn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqOC: // global
           I64[Sp] = block_cbqOA_info;
           _sboh9::P64 = P64[R1 + 6];
           R1 = _sboh5::P64;
           P64[Sp + 56] = _sboh9::P64;
           if (R1 & 7 != 0) goto ubqPW; else goto cbqOD;
       ubqPW: // global
           call _cbqOA(R1) args: 0, res: 0, upd: 0;
       cbqOD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqOj() //  [R1]
         { info_tbl: [(cbqOj,
                       label: block_cbqOj_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqOj: // global
           if (R1 & 7 == 1) goto ubqPw; else goto ubqPx;
       ubqPw: // global
           Sp = Sp + 136;
           call _cbqP4() args: 0, res: 0, upd: 0;
       ubqPx: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbqOA() //  [R1]
         { info_tbl: [(cbqOA,
                       label: block_cbqOA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqOA: // global
           if (R1 & 7 == 1) goto ubqPt; else goto cbqOT;
       ubqPt: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
       cbqOT: // global
           I64[Sp] = block_cbqOM_info;
           _sbohb::P64 = P64[R1 + 6];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _sbohb::P64;
           if (R1 & 7 != 0) goto ubqPZ; else goto cbqON;
       ubqPZ: // global
           call _cbqOM(R1) args: 0, res: 0, upd: 0;
       cbqON: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqOM() //  [R1]
         { info_tbl: [(cbqOM,
                       label: block_cbqOM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqOM: // global
           I64[Sp] = block_cbqOR_info;
           _sbohd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp + 56] = _sbohd::I64;
           if (R1 & 7 != 0) goto ubqQ1; else goto cbqOV;
       ubqQ1: // global
           call _cbqOR(R1) args: 0, res: 0, upd: 0;
       cbqOV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqOR() //  [R1]
         { info_tbl: [(cbqOR,
                       label: block_cbqOR_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqOR: // global
           if (I64[Sp + 56] == I64[R1 + 7]) goto ubqPu; else goto ubqPv;
       ubqPu: // global
           Sp = Sp + 136;
           call _cbqP4() args: 0, res: 0, upd: 0;
       ubqPv: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbqP4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqP4: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _sbogu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbogu: // global
           I64[Sp - 8] = block_cbqLs_info;
           R1 = P64[Sp + 136];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqQ4; else goto cbqMP;
       ubqQ4: // global
           call _cbqLs(R1) args: 0, res: 0, upd: 0;
       cbqMP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqLs() //  [R1]
         { info_tbl: [(cbqLs,
                       label: block_cbqLs_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqLs: // global
           if (R1 & 7 == 3) goto cbqN0; else goto ubqPy;
       cbqN0: // global
           I64[Sp] = block_cbqMY_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto ubqPH; else goto cbqN1;
       ubqPH: // global
           call _cbqMY(R1) args: 0, res: 0, upd: 0;
       cbqN1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubqPy: // global
           Sp = Sp + 8;
           call _sbogv() args: 0, res: 0, upd: 0;
     }
 },
 _cbqMY() //  [R1]
         { info_tbl: [(cbqMY,
                       label: block_cbqMY_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqMY: // global
           if (R1 & 7 == 1) goto ubqPz; else goto cbqNc;
       ubqPz: // global
           Sp = Sp + 8;
           call _sbogv() args: 0, res: 0, upd: 0;
       cbqNc: // global
           I64[Sp] = block_cbqNa_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubqPM; else goto cbqNd;
       ubqPM: // global
           call _cbqNa(R1) args: 0, res: 0, upd: 0;
       cbqNd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqNa() //  [R1]
         { info_tbl: [(cbqNa,
                       label: block_cbqNa_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqNa: // global
           _sbogX::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sbogX::I64, 0)) goto ubqPA; else goto cbqNm;
       ubqPA: // global
           Sp = Sp + 8;
           call _sbogv() args: 0, res: 0, upd: 0;
       cbqNm: // global
           R2 = _sbogX::I64;
           Sp = Sp + 152;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _sbogv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbogv: // global
           I64[Sp - 8] = block_cbqLx_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbqLx() //  [R1]
         { info_tbl: [(cbqLx,
                       label: block_cbqLx_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqLx: // global
           I64[Sp] = block_cbqLz_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqPJ; else goto cbqLC;
       ubqPJ: // global
           call _cbqLz(R1) args: 0, res: 0, upd: 0;
       cbqLC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqLz() //  [R1]
         { info_tbl: [(cbqLz,
                       label: block_cbqLz_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqLz: // global
           _sbogt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbqLL; else goto cbqMt;
       cbqLL: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbqLO; else goto cbqLN;
       cbqLO: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqLN: // global
           _sbog8::P64 = P64[Sp + 144];
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = _sbogt::P64;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = _sbog8::P64;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbqMt: // global
           I64[Sp] = block_cbqLT_info;
           R1 = _sbogt::P64;
           if (R1 & 7 != 0) goto ubqPK; else goto cbqMu;
       ubqPK: // global
           call _cbqLT(R1) args: 0, res: 0, upd: 0;
       cbqMu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqLT() //  [R1]
         { info_tbl: [(cbqLT,
                       label: block_cbqLT_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqLT: // global
           _sbog8::P64 = P64[Sp + 144];
           _cbqPk::P64 = R1 & 7;
           if (_cbqPk::P64 == 3) goto sbogD; else goto ubqPn;
       ubqPn: // global
           if (_cbqPk::P64 == 6) goto sbogD; else goto cbqMD;
       sbogD: // global
           I64[Sp] = block_cbqLY_info;
           R1 = _sbog8::P64;
           if (R1 & 7 != 0) goto ubqPL; else goto cbqM0;
       ubqPL: // global
           call _cbqLY(R1) args: 0, res: 0, upd: 0;
       cbqM0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqMD: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbqMG; else goto cbqMF;
       cbqMG: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqMF: // global
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = R1;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = _sbog8::P64;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqLY() //  [R1]
         { info_tbl: [(cbqLY,
                       label: block_cbqLY_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqLY: // global
           _sbogd::P64 = P64[Sp + 16];
           _sbogg::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbqMp; else goto cbqMc;
       cbqMp: // global
           I64[Sp] = block_cbqMi_info;
           R2 = _sbogd::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sbogg::P64;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 24;
           call GHC.IO.Device.setRaw_entry(R2) args: 32, res: 8, upd: 8;
       cbqMc: // global
           I64[Sp] = block_cbqM4_info;
           R2 = _sbogd::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sbogg::P64;
           P64[Sp - 8] = GHC.Types.False_closure+1;
           P64[Sp + 144] = R1;
           Sp = Sp - 24;
           call GHC.IO.Device.setRaw_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbqMi() //  [R1]
         { info_tbl: [(cbqMi,
                       label: block_cbqMi_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqMi: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbqMs; else goto cbqMr;
       cbqMs: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqMr: // global
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           _sbogt::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = _sbogt::P64;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqM4() //  [R1]
         { info_tbl: [(cbqM4,
                       label: block_cbqM4_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqM4: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbqMf; else goto cbqMe;
       cbqMf: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqMe: // global
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           _sbogt::P64 = P64[Sp + 8];
           _sbogE::P64 = P64[Sp + 144];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = _sbogt::P64;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = _sbogE::P64;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubqQa_srtd" {
     ubqQa_srtd:
         const SboCL_srt+256;
         const 34;
         const 16106127361;
 },
 GHC.IO.Handle.hSetBuffering1_entry() //  [R2, R3]
         { info_tbl: [(cbqQ5,
                       label: GHC.IO.Handle.hSetBuffering1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqQ5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqQ9; else goto cbqQ8;
       cbqQ9: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetBuffering1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqQ8: // global
           I64[Hp - 8] = sat_sbohh_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = R2;
           R2 = GHC.IO.Handle.hSetBuffering2_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.078327453 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering_closure" {
     GHC.IO.Handle.hSetBuffering_closure:
         const GHC.IO.Handle.hSetBuffering_info;
         const 0;
 },
 GHC.IO.Handle.hSetBuffering_entry() //  [R2, R3]
         { info_tbl: [(cbqQf,
                       label: GHC.IO.Handle.hSetBuffering_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqQf: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetBuffering1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.079044254 UTC

[section ""cstring" . GHC.IO.Handle.hIsEOF4_bytes" {
     GHC.IO.Handle.hIsEOF4_bytes:
         I8[] [104,73,115,69,79,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.079787566 UTC

[section ""data" . GHC.IO.Handle.hIsEOF3_closure" {
     GHC.IO.Handle.hIsEOF3_closure:
         const GHC.IO.Handle.hIsEOF3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsEOF3_entry() //  [R1]
         { info_tbl: [(cbqQo,
                       label: GHC.IO.Handle.hIsEOF3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqQo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqQp; else goto cbqQq;
       cbqQp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqQq: // global
           (_cbqQl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqQl::I64 == 0) goto cbqQn; else goto cbqQm;
       cbqQn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqQm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqQl::I64;
           R2 = GHC.IO.Handle.hIsEOF4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.081684163 UTC

[section ""data" . GHC.IO.Handle.hIsEOF2_closure" {
     GHC.IO.Handle.hIsEOF2_closure:
         const GHC.IO.Handle.hIsEOF2_info;
 },
 GHC.IO.Handle.hIsEOF2_entry() //  [R2]
         { info_tbl: [(cbqQy,
                       label: GHC.IO.Handle.hIsEOF2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqQy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbqQC; else goto cbqQD;
       cbqQC: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsEOF2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqQD: // global
           I64[Sp - 8] = block_cbqQv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqRu; else goto cbqQw;
       ubqRu: // global
           call _cbqQv(R1) args: 0, res: 0, upd: 0;
       cbqQw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqQv() //  [R1]
         { info_tbl: [(cbqQv,
                       label: block_cbqQv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqQv: // global
           _sbohD::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 24] = block_cbqQB_info;
           _sbohm::P64 = P64[R1 + 15];
           _sboho::P64 = P64[R1 + 31];
           _sbohq::P64 = P64[R1 + 47];
           R1 = _sbohD::P64;
           P64[Sp - 16] = _sboho::P64;
           P64[Sp - 8] = _sbohq::P64;
           P64[Sp] = _sbohm::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubqRt; else goto cbqQF;
       ubqRt: // global
           call _cbqQB(R1) args: 0, res: 0, upd: 0;
       cbqQF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqQB() //  [R1]
         { info_tbl: [(cbqQB,
                       label: block_cbqQB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqQB: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbqQR; else goto ubqRr;
       cbqQR: // global
           _sbohO::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbqQQ_info;
           R1 = _sbohO::P64;
           if (R1 & 7 != 0) goto ubqRv; else goto cbqQS;
       ubqRv: // global
           call _cbqQQ(R1) args: 0, res: 0, upd: 0;
       cbqQS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubqRr: // global
           Sp = Sp + 32;
           call _cbqR0() args: 0, res: 0, upd: 0;
     }
 },
 _cbqQQ() //  [R1]
         { info_tbl: [(cbqQQ,
                       label: block_cbqQQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqQQ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbqRb; else goto ubqRs;
       cbqRb: // global
           _sboho::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbqR3_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sboho::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       ubqRs: // global
           Sp = Sp + 32;
           call _cbqR0() args: 0, res: 0, upd: 0;
     }
 },
 _cbqR3() //  [R1]
         { info_tbl: [(cbqR3,
                       label: block_cbqR3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqR3: // global
           I64[Sp] = block_cbqR5_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqRy; else goto cbqR6;
       ubqRy: // global
           call _cbqR5(R1) args: 0, res: 0, upd: 0;
       cbqR6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqR5() //  [R1]
         { info_tbl: [(cbqR5,
                       label: block_cbqR5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqR5: // global
           I64[Sp] = block_cbqRa_info;
           _sboi2::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 16] = _sboi2::P64;
           if (R1 & 7 != 0) goto ubqRz; else goto cbqRe;
       ubqRz: // global
           call _cbqRa(R1) args: 0, res: 0, upd: 0;
       cbqRe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqRa() //  [R1]
         { info_tbl: [(cbqRa,
                       label: block_cbqRa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqRa: // global
           if (I64[R1 + 7] == 0) goto cbqRm; else goto cbqRl;
       cbqRm: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbqRl: // global
           _sbohq::P64 = P64[Sp + 8];
           _sboi2::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbohq::P64 + 8] = _sboi2::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbohq::P64);
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqR0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqR0: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.084067981 UTC

[section ""data" . GHC.IO.Handle.hIsEOF1_closure" {
     GHC.IO.Handle.hIsEOF1_closure:
         const GHC.IO.Handle.hIsEOF1_info;
         const 0;
 },
 GHC.IO.Handle.hIsEOF1_entry() //  [R2]
         { info_tbl: [(cbqRE,
                       label: GHC.IO.Handle.hIsEOF1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqRE: // global
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.084921226 UTC

[section ""data" . GHC.IO.Handle.hIsEOF_closure" {
     GHC.IO.Handle.hIsEOF_closure:
         const GHC.IO.Handle.hIsEOF_info;
         const 0;
 },
 GHC.IO.Handle.hIsEOF_entry() //  [R2]
         { info_tbl: [(cbqRL,
                       label: GHC.IO.Handle.hIsEOF_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqRL: // global
           R2 = R2;
           call GHC.IO.Handle.hIsEOF1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.085777163 UTC

[section ""data" . GHC.IO.Handle.isEOF1_closure" {
     GHC.IO.Handle.isEOF1_closure:
         const GHC.IO.Handle.isEOF1_info;
         const 0;
 },
 GHC.IO.Handle.isEOF1_entry() //  []
         { info_tbl: [(cbqRS,
                       label: GHC.IO.Handle.isEOF1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqRS: // global
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.08661047 UTC

[section ""data" . GHC.IO.Handle.isEOF_closure" {
     GHC.IO.Handle.isEOF_closure:
         const GHC.IO.Handle.isEOF_info;
         const 0;
 },
 GHC.IO.Handle.isEOF_entry() //  []
         { info_tbl: [(cbqRZ,
                       label: GHC.IO.Handle.isEOF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqRZ: // global
           call GHC.IO.Handle.isEOF1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.08727757 UTC

[section ""cstring" . lvl19_rbnX1_bytes" {
     lvl19_rbnX1_bytes:
         I8[] [104,83,101,116,70,105,108,101,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.087973473 UTC

[section ""data" . lvl20_rbnX2_closure" {
     lvl20_rbnX2_closure:
         const lvl20_rbnX2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_rbnX2_entry() //  [R1]
         { info_tbl: [(cbqS8,
                       label: lvl20_rbnX2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqS8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqS9; else goto cbqSa;
       cbqS9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqSa: // global
           (_cbqS5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqS5::I64 == 0) goto cbqS7; else goto cbqS6;
       cbqS7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqS6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqS5::I64;
           R2 = lvl19_rbnX1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.091554967 UTC

[section ""data" . GHC.IO.Handle.hSetFileSize1_closure" {
     GHC.IO.Handle.hSetFileSize1_closure:
         const GHC.IO.Handle.hSetFileSize1_info;
         const 0;
 },
 act_sboib_entry() //  [R1, R2]
         { info_tbl: [(cbqSn,
                       label: act_sboib_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqSn: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbqSo; else goto cbqSp;
       cbqSo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqSp: // global
           I64[Sp - 16] = block_cbqSk_info;
           _sboi9::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sboi9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubqTx; else goto cbqSl;
       ubqTx: // global
           call _cbqSk(R1) args: 0, res: 0, upd: 0;
       cbqSl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqSk() //  [R1]
         { info_tbl: [(cbqSk,
                       label: block_cbqSk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqSk: // global
           I64[Sp - 32] = block_cbqSs_info;
           _sboif::P64 = P64[R1 + 7];
           _sboig::P64 = P64[R1 + 15];
           _sboii::P64 = P64[R1 + 31];
           _sboik::P64 = P64[R1 + 47];
           R1 = P64[R1 + 39];
           P64[Sp - 24] = _sboig::P64;
           P64[Sp - 16] = _sboii::P64;
           P64[Sp - 8] = _sboik::P64;
           P64[Sp] = _sboif::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubqTw; else goto cbqSu;
       ubqTw: // global
           call _cbqSs(R1) args: 0, res: 0, upd: 0;
       cbqSu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqSs() //  [R1]
         { info_tbl: [(cbqSs,
                       label: block_cbqSs_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqSs: // global
           _cbqTt::P64 = R1 & 7;
           if (_cbqTt::P64 != 1) goto ubqTv; else goto cbqTo;
       ubqTv: // global
           if (_cbqTt::P64 != 2) goto cbqSB; else goto cbqTs;
       cbqSB: // global
           _sboiy::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbqSy_info;
           R1 = _sboiy::P64;
           if (R1 & 7 != 0) goto ubqTy; else goto cbqSC;
       ubqTy: // global
           call _cbqSy(R1) args: 0, res: 0, upd: 0;
       cbqSC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqTs: // global
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbqTo: // global
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbqSy() //  [R1]
         { info_tbl: [(cbqSy,
                       label: block_cbqSy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqSy: // global
           I64[Sp] = block_cbqSG_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubqTz; else goto cbqSI;
       ubqTz: // global
           call _cbqSG(R1) args: 0, res: 0, upd: 0;
       cbqSI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqSG() //  [R1]
         { info_tbl: [(cbqSG,
                       label: block_cbqSG_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqSG: // global
           if (R1 & 7 == 1) goto cbqSP; else goto cbqSW;
       cbqSP: // global
           _sboi9::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbqSM_info;
           R2 = P64[Sp + 32];
           _sboii::P64 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_ppv_info;
           P64[Sp + 24] = _sboii::P64;
           P64[Sp + 32] = _sboi9::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
       cbqSW: // global
           _sboiM::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbqSU_info;
           R1 = _sboiM::P64;
           if (R1 & 7 != 0) goto ubqTA; else goto cbqSX;
       ubqTA: // global
           call _cbqSU(R1) args: 0, res: 0, upd: 0;
       cbqSX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqSM() //  []
         { info_tbl: [(cbqSM,
                       label: block_cbqSM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqSM: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqSU() //  [R1]
         { info_tbl: [(cbqSU,
                       label: block_cbqSU_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqSU: // global
           _sboii::P64 = P64[Sp + 16];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbqTi; else goto cbqTc;
       cbqTi: // global
           _sboi9::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbqTh_info;
           R2 = P64[Sp + 32];
           I64[Sp + 16] = stg_ap_ppv_info;
           P64[Sp + 24] = _sboii::P64;
           P64[Sp + 32] = _sboi9::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
       cbqTc: // global
           _sboig::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbqT5_info;
           R2 = _sboig::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sboii::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbqTh() //  []
         { info_tbl: [(cbqTh,
                       label: block_cbqTh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqTh: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqT5() //  [R1]
         { info_tbl: [(cbqT5,
                       label: block_cbqT5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqT5: // global
           _sboi9::P64 = P64[Sp + 32];
           _sboif::P64 = P64[Sp + 24];
           _sboii::P64 = P64[Sp + 8];
           _sboik::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sboik::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sboik::P64);
           I64[Sp + 32] = block_cbqTa_info;
           R2 = _sboif::P64;
           I64[Sp + 8] = stg_ap_ppv_info;
           P64[Sp + 16] = _sboii::P64;
           P64[Sp + 24] = _sboi9::P64;
           Sp = Sp + 8;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbqTa() //  []
         { info_tbl: [(cbqTa,
                       label: block_cbqTa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqTa: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbojj_entry() //  [R1, R2]
         { info_tbl: [(cbqTV,
                       label: sat_sbojj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqTV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqTW; else goto cbqTX;
       cbqTW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqTX: // global
           I64[Sp - 16] = block_cbqTS_info;
           _sbojd::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbojd::P64;
           Sp = Sp - 16;
           call act_sboib_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqTS() //  [R1]
         { info_tbl: [(cbqTS,
                       label: block_cbqTS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqTS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqU0; else goto cbqTZ;
       cbqU0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqTZ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbojb_entry() //  [R1]
         { info_tbl: [(cbqU6,
                       label: io_sbojb_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqU6: // global
           _sbojb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbqUa; else goto cbqUb;
       cbqUb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqUd; else goto cbqUc;
       cbqUd: // global
           HpAlloc = 16;
           goto cbqUa;
       cbqUa: // global
           R1 = _sbojb::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqUc: // global
           _sboib::P64 = P64[_sbojb::P64 + 7];
           _sboj5::P64 = P64[_sbojb::P64 + 15];
           _sboj7::P64 = P64[_sbojb::P64 + 23];
           I64[Hp - 8] = sat_sbojj_info;
           P64[Hp] = _sboib::P64;
           I64[Sp - 16] = block_cbqU1_info;
           R5 = _sboj7::P64;
           R4 = Hp - 6;
           R3 = _sboj5::P64;
           R2 = lvl20_rbnX2_closure;
           P64[Sp - 8] = _sboj7::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqU1() //  [R1]
         { info_tbl: [(cbqU1,
                       label: block_cbqU1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqU1: // global
           I64[Sp] = block_cbqU3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqUi; else goto cbqU4;
       ubqUi: // global
           call _cbqU3(R1) args: 0, res: 0, upd: 0;
       cbqU4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqU3() //  [R1]
         { info_tbl: [(cbqU3,
                       label: block_cbqU3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqU3: // global
           I64[Sp] = block_cbqU9_info;
           R2 = P64[R1 + 7];
           _sbojp::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbojp::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqU9() //  []
         { info_tbl: [(cbqU9,
                       label: block_cbqU9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqU9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbojG_entry() //  [R1, R2]
         { info_tbl: [(cbqUA,
                       label: sat_sbojG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqUA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqUB; else goto cbqUC;
       cbqUB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqUC: // global
           I64[Sp - 16] = block_cbqUx_info;
           _sbojA::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbojA::P64;
           Sp = Sp - 16;
           call act_sboib_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqUx() //  [R1]
         { info_tbl: [(cbqUx,
                       label: block_cbqUx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqUx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqUF; else goto cbqUE;
       cbqUF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqUE: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbojy_entry() //  [R1]
         { info_tbl: [(cbqUL,
                       label: io_sbojy_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqUL: // global
           _sbojy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbqUP; else goto cbqUQ;
       cbqUQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqUS; else goto cbqUR;
       cbqUS: // global
           HpAlloc = 16;
           goto cbqUP;
       cbqUP: // global
           R1 = _sbojy::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqUR: // global
           _sboib::P64 = P64[_sbojy::P64 + 7];
           _sboj5::P64 = P64[_sbojy::P64 + 15];
           _sbojt::P64 = P64[_sbojy::P64 + 23];
           I64[Hp - 8] = sat_sbojG_info;
           P64[Hp] = _sboib::P64;
           I64[Sp - 16] = block_cbqUG_info;
           R5 = _sbojt::P64;
           R4 = Hp - 6;
           R3 = _sboj5::P64;
           R2 = lvl20_rbnX2_closure;
           P64[Sp - 8] = _sbojt::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqUG() //  [R1]
         { info_tbl: [(cbqUG,
                       label: block_cbqUG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqUG: // global
           I64[Sp] = block_cbqUI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqUX; else goto cbqUJ;
       ubqUX: // global
           call _cbqUI(R1) args: 0, res: 0, upd: 0;
       cbqUJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqUI() //  [R1]
         { info_tbl: [(cbqUI,
                       label: block_cbqUI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqUI: // global
           I64[Sp] = block_cbqUO_info;
           R2 = P64[R1 + 7];
           _sbojM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbojM::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqUO() //  []
         { info_tbl: [(cbqUO,
                       label: block_cbqUO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqUO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetFileSize1_entry() //  [R2, R3]
         { info_tbl: [(cbqV2,
                       label: GHC.IO.Handle.hSetFileSize1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqV2: // global
           _sboi9::P64 = R3;
           _sboi8::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbqV3; else goto cbqV4;
       cbqV4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbqV6; else goto cbqV5;
       cbqV6: // global
           HpAlloc = 16;
           goto cbqV3;
       cbqV3: // global
           R3 = _sboi9::P64;
           R2 = _sboi8::P64;
           R1 = GHC.IO.Handle.hSetFileSize1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqV5: // global
           I64[Hp - 8] = act_sboib_info;
           P64[Hp] = _sboi9::P64;
           I64[Sp - 16] = block_cbqTB_info;
           R1 = _sboi8::P64;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubqVn; else goto cbqTC;
       ubqVn: // global
           call _cbqTB(R1) args: 0, res: 0, upd: 0;
       cbqTC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqTB() //  [R1]
         { info_tbl: [(cbqTB,
                       label: block_cbqTB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqTB: // global
           if (R1 & 7 == 1) goto cbqUZ; else goto cbqV0;
       cbqUZ: // global
           I64[Sp - 16] = block_cbqTG_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbqV0: // global
           I64[Sp - 16] = block_cbqUl_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbqTG() //  [R1]
         { info_tbl: [(cbqTG,
                       label: block_cbqTG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqTG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbqVa; else goto cbqV9;
       cbqVa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqV9: // global
           I64[Hp - 24] = io_sbojb_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqTI::P64 = Hp - 23;
           if (R1 == 0) goto cbqVe; else goto cbqVd;
       cbqVe: // global
           R1 = _cbqTI::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqVd: // global
           R1 = _cbqTI::P64;
           Sp = Sp + 32;
           call io_sbojb_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqUl() //  [R1]
         { info_tbl: [(cbqUl,
                       label: block_cbqUl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqUl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbqVi; else goto cbqVh;
       cbqVi: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqVh: // global
           I64[Hp - 24] = io_sbojy_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqUn::P64 = Hp - 23;
           if (R1 == 0) goto cbqVm; else goto cbqVl;
       cbqVm: // global
           R1 = _cbqUn::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqVl: // global
           R1 = _cbqUn::P64;
           Sp = Sp + 32;
           call io_sbojy_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.098421141 UTC

[section ""data" . GHC.IO.Handle.hSetFileSize_closure" {
     GHC.IO.Handle.hSetFileSize_closure:
         const GHC.IO.Handle.hSetFileSize_info;
         const 0;
 },
 GHC.IO.Handle.hSetFileSize_entry() //  [R2, R3]
         { info_tbl: [(cbqVs,
                       label: GHC.IO.Handle.hSetFileSize_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqVs: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetFileSize1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.099157069 UTC

[section ""cstring" . GHC.IO.Handle.hFileSize9_bytes" {
     GHC.IO.Handle.hFileSize9_bytes:
         I8[] [104,70,105,108,101,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.099860011 UTC

[section ""data" . GHC.IO.Handle.hFileSize8_closure" {
     GHC.IO.Handle.hFileSize8_closure:
         const GHC.IO.Handle.hFileSize8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize8_entry() //  [R1]
         { info_tbl: [(cbqVB,
                       label: GHC.IO.Handle.hFileSize8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqVB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqVC; else goto cbqVD;
       cbqVC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqVD: // global
           (_cbqVy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqVy::I64 == 0) goto cbqVA; else goto cbqVz;
       cbqVA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqVz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqVy::I64;
           R2 = GHC.IO.Handle.hFileSize9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.100664971 UTC

[section ""cstring" . GHC.IO.Handle.hFileSize7_bytes" {
     GHC.IO.Handle.hFileSize7_bytes:
         I8[] [110,111,116,32,97,32,114,101,103,117,108,97,114,32,102,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.1013864 UTC

[section ""data" . GHC.IO.Handle.hFileSize6_closure" {
     GHC.IO.Handle.hFileSize6_closure:
         const GHC.IO.Handle.hFileSize6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize6_entry() //  [R1]
         { info_tbl: [(cbqVK,
                       label: GHC.IO.Handle.hFileSize6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqVK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqVL; else goto cbqVM;
       cbqVL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqVM: // global
           (_cbqVH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqVH::I64 == 0) goto cbqVJ; else goto cbqVI;
       cbqVJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqVI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqVH::I64;
           R2 = GHC.IO.Handle.hFileSize7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.102198228 UTC

[section ""data" . GHC.IO.Handle.hFileSize5_closure" {
     GHC.IO.Handle.hFileSize5_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Handle.hFileSize8_closure;
         const GHC.IO.Handle.hFileSize6_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.102950647 UTC

[section ""data" . GHC.IO.Handle.hFileSize4_closure" {
     GHC.IO.Handle.hFileSize4_closure:
         const GHC.IO.Handle.hFileSize4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize4_entry() //  [R1]
         { info_tbl: [(cbqVT,
                       label: GHC.IO.Handle.hFileSize4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqVT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqVU; else goto cbqVV;
       cbqVU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqVV: // global
           (_cbqVQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqVQ::I64 == 0) goto cbqVS; else goto cbqVR;
       cbqVS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqVR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqVQ::I64;
           R2 = GHC.IO.Handle.hFileSize5_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.103865877 UTC

[section ""data" . sat_sbojP_closure" {
     sat_sbojP_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.104432127 UTC

[section ""data" . sat_sbojQ_closure" {
     sat_sbojQ_closure:
         const :_con_info;
         const sat_sbojP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.105174734 UTC

[section ""data" . GHC.IO.Handle.hFileSize10_closure" {
     GHC.IO.Handle.hFileSize10_closure:
         const GHC.IO.Handle.hFileSize10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize10_entry() //  [R1]
         { info_tbl: [(cbqW2,
                       label: GHC.IO.Handle.hFileSize10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqW2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqW3; else goto cbqW4;
       cbqW3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbqW4: // global
           (_cbqVZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbqVZ::I64 == 0) goto cbqW1; else goto cbqW0;
       cbqW1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbqW0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbqVZ::I64;
           R3 = sat_sbojQ_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.107357344 UTC

[section ""data" . GHC.IO.Handle.hFileSize3_closure" {
     GHC.IO.Handle.hFileSize3_closure:
         const GHC.IO.Handle.hFileSize3_info;
         const 0;
 },
 section ""relreadonly" . ubqXG_srtd" {
     ubqXG_srtd:
         const SboCL_srt+328;
         const 38;
         const 240522362881;
 },
 GHC.IO.Handle.hFileSize3_entry() //  [R2]
         { info_tbl: [(cbqWc,
                       label: GHC.IO.Handle.hFileSize3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqWc: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbqWd; else goto cbqWe;
       cbqWd: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqWe: // global
           I64[Sp - 8] = block_cbqW9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqXz; else goto cbqWa;
       ubqXz: // global
           call _cbqW9(R1) args: 0, res: 0, upd: 0;
       cbqWa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubqXH_srtd" {
     ubqXH_srtd:
         const SboCL_srt+328;
         const 38;
         const 206162624513;
 },
 _cbqW9() //  [R1]
         { info_tbl: [(cbqW9,
                       label: block_cbqW9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqW9: // global
           I64[Sp - 32] = block_cbqWh_info;
           _sbojU::P64 = P64[R1 + 7];
           _sbojV::P64 = P64[R1 + 15];
           _sbojX::P64 = P64[R1 + 31];
           _sbojZ::P64 = P64[R1 + 47];
           R1 = P64[R1 + 39];
           P64[Sp - 24] = _sbojV::P64;
           P64[Sp - 16] = _sbojX::P64;
           P64[Sp - 8] = _sbojZ::P64;
           P64[Sp] = _sbojU::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubqXy; else goto cbqWj;
       ubqXy: // global
           call _cbqWh(R1) args: 0, res: 0, upd: 0;
       cbqWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubqXI_srtd" {
     ubqXI_srtd:
         const SboCL_srt+328;
         const 38;
         const 206162624513;
 },
 _cbqWh() //  [R1]
         { info_tbl: [(cbqWh,
                       label: block_cbqWh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqWh: // global
           _cbqXp::P64 = R1 & 7;
           if (_cbqXp::P64 != 1) goto ubqXu; else goto cbqXk;
       ubqXu: // global
           if (_cbqXp::P64 != 2) goto cbqWq; else goto cbqXo;
       cbqWq: // global
           _sbokd::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbqWn_info;
           R1 = _sbokd::P64;
           if (R1 & 7 != 0) goto ubqXA; else goto cbqWr;
       ubqXA: // global
           call _cbqWn(R1) args: 0, res: 0, upd: 0;
       cbqWr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbqXo: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbqXk: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbqWn() //  [R1]
         { info_tbl: [(cbqWn,
                       label: block_cbqWn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqWn: // global
           I64[Sp] = block_cbqWx_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubqXB; else goto cbqWR;
       ubqXB: // global
           call _cbqWx(R1) args: 0, res: 0, upd: 0;
       cbqWR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqWx() //  [R1]
         { info_tbl: [(cbqWx,
                       label: block_cbqWx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqWx: // global
           if (R1 & 7 == 1) goto ubqXv; else goto cbqX2;
       ubqXv: // global
           Sp = Sp + 16;
           call _sbokl() args: 0, res: 0, upd: 0;
       cbqX2: // global
           _sboku::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbqX0_info;
           R1 = _sboku::P64;
           if (R1 & 7 != 0) goto ubqXC; else goto cbqX3;
       ubqXC: // global
           call _cbqX0(R1) args: 0, res: 0, upd: 0;
       cbqX3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqX0() //  [R1]
         { info_tbl: [(cbqX0,
                       label: block_cbqX0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqX0: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubqXw; else goto cbqXd;
       ubqXw: // global
           Sp = Sp + 16;
           call _sbokl() args: 0, res: 0, upd: 0;
       cbqXd: // global
           _sbojV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbqXb_info;
           R2 = _sbojV::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbqXb() //  [R1]
         { info_tbl: [(cbqXb,
                       label: block_cbqXb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqXb: // global
           _sbojZ::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbojZ::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbojZ::P64);
           Sp = Sp + 8;
           call _sbokl() args: 0, res: 0, upd: 0;
     }
 },
 _sbokl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbokl: // global
           _sbojU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbqWC_info;
           R2 = _sbojU::P64;
           _sbojX::P64 = P64[Sp];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbojX::P64;
           call GHC.IO.Device.getSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbqWC() //  [R1]
         { info_tbl: [(cbqWC,
                       label: block_cbqWC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqWC: // global
           I64[Sp - 8] = block_cbqWE_info;
           R3 = GHC.IO.Handle.hFileSize10_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqWE() //  [R1]
         { info_tbl: [(cbqWE,
                       label: block_cbqWE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqWE: // global
           if (R1 == 1) goto cbqWQ; else goto cbqWM;
       cbqWQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbqWM: // global
           R1 = GHC.IO.Handle.hFileSize4_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.110471357 UTC

[section ""data" . GHC.IO.Handle.hFileSize2_closure" {
     GHC.IO.Handle.hFileSize2_closure:
         const GHC.IO.Handle.hFileSize2_info;
         const 0;
 },
 GHC.IO.Handle.hFileSize2_entry() //  [R2]
         { info_tbl: [(cbqXQ,
                       label: GHC.IO.Handle.hFileSize2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqXQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqXR; else goto cbqXS;
       cbqXR: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqXS: // global
           I64[Sp - 16] = block_cbqXN_info;
           _sbokH::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbokH::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hFileSize3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqXN() //  [R1]
         { info_tbl: [(cbqXN,
                       label: block_cbqXN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqXN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqXV; else goto cbqXU;
       cbqXV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqXU: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.112632151 UTC

[section ""data" . GHC.IO.Handle.hFileSize1_closure" {
     GHC.IO.Handle.hFileSize1_closure:
         const GHC.IO.Handle.hFileSize1_info;
         const 0;
 },
 io_sbokV_entry() //  [R1]
         { info_tbl: [(cbqYh,
                       label: io_sbokV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqYl; else goto cbqYm;
       cbqYl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqYm: // global
           I64[Sp - 16] = block_cbqYc_info;
           _sbokR::P64 = P64[R1 + 15];
           R5 = _sbokR::P64;
           R4 = GHC.IO.Handle.hFileSize2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFileSize8_closure;
           P64[Sp - 8] = _sbokR::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqYc() //  [R1]
         { info_tbl: [(cbqYc,
                       label: block_cbqYc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYc: // global
           I64[Sp] = block_cbqYe_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqYr; else goto cbqYf;
       ubqYr: // global
           call _cbqYe(R1) args: 0, res: 0, upd: 0;
       cbqYf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqYe() //  [R1]
         { info_tbl: [(cbqYe,
                       label: block_cbqYe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYe: // global
           I64[Sp] = block_cbqYk_info;
           R2 = P64[R1 + 7];
           _sbol2::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbol2::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqYk() //  []
         { info_tbl: [(cbqYk,
                       label: block_cbqYk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbolb_entry() //  [R1]
         { info_tbl: [(cbqYG,
                       label: io_sbolb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbqYK; else goto cbqYL;
       cbqYK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbqYL: // global
           I64[Sp - 16] = block_cbqYB_info;
           _sbol6::P64 = P64[R1 + 15];
           R5 = _sbol6::P64;
           R4 = GHC.IO.Handle.hFileSize2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFileSize8_closure;
           P64[Sp - 8] = _sbol6::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbqYB() //  [R1]
         { info_tbl: [(cbqYB,
                       label: block_cbqYB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYB: // global
           I64[Sp] = block_cbqYD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubqYQ; else goto cbqYE;
       ubqYQ: // global
           call _cbqYD(R1) args: 0, res: 0, upd: 0;
       cbqYE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqYD() //  [R1]
         { info_tbl: [(cbqYD,
                       label: block_cbqYD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYD: // global
           I64[Sp] = block_cbqYJ_info;
           R2 = P64[R1 + 7];
           _sboli::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboli::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqYJ() //  []
         { info_tbl: [(cbqYJ,
                       label: block_cbqYJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hFileSize1_entry() //  [R2]
         { info_tbl: [(cbqYV,
                       label: GHC.IO.Handle.hFileSize1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqYW; else goto cbqYX;
       cbqYW: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqYX: // global
           I64[Sp - 8] = block_cbqY0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubqZe; else goto cbqY1;
       ubqZe: // global
           call _cbqY0(R1) args: 0, res: 0, upd: 0;
       cbqY1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbqY0() //  [R1]
         { info_tbl: [(cbqY0,
                       label: block_cbqY0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqY0: // global
           if (R1 & 7 == 1) goto cbqYS; else goto cbqYT;
       cbqYS: // global
           I64[Sp - 16] = block_cbqY5_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbqYT: // global
           I64[Sp - 16] = block_cbqYu_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbqY5() //  [R1]
         { info_tbl: [(cbqY5,
                       label: block_cbqY5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqY5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqZ1; else goto cbqZ0;
       cbqZ1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqZ0: // global
           I64[Hp - 16] = io_sbokV_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqY7::P64 = Hp - 15;
           if (R1 == 0) goto cbqZ5; else goto cbqZ4;
       cbqZ5: // global
           R1 = _cbqY7::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqZ4: // global
           R1 = _cbqY7::P64;
           Sp = Sp + 24;
           call io_sbokV_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbqYu() //  [R1]
         { info_tbl: [(cbqYu,
                       label: block_cbqYu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqYu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqZ9; else goto cbqZ8;
       cbqZ9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbqZ8: // global
           I64[Hp - 16] = io_sbolb_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbqYw::P64 = Hp - 15;
           if (R1 == 0) goto cbqZd; else goto cbqZc;
       cbqZd: // global
           R1 = _cbqYw::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbqZc: // global
           R1 = _cbqYw::P64;
           Sp = Sp + 24;
           call io_sbolb_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.11586423 UTC

[section ""data" . GHC.IO.Handle.hFileSize_closure" {
     GHC.IO.Handle.hFileSize_closure:
         const GHC.IO.Handle.hFileSize_info;
         const 0;
 },
 GHC.IO.Handle.hFileSize_entry() //  [R2]
         { info_tbl: [(cbqZj,
                       label: GHC.IO.Handle.hFileSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqZj: // global
           R2 = R2;
           call GHC.IO.Handle.hFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.116608501 UTC

[section ""data" . lvl21_rbnX3_closure" {
     lvl21_rbnX3_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.120169982 UTC

[section ""data" . GHC.IO.Handle.hDuplicateTo1_closure" {
     GHC.IO.Handle.hDuplicateTo1_closure:
         const GHC.IO.Handle.hDuplicateTo1_info;
         const 0;
 },
 sat_sbolF_entry() //  [R1, R2]
         { info_tbl: [(cbqZP,
                       label: sat_sbolF_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqZP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbqZQ; else goto cbqZR;
       cbqZQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqZR: // global
           I64[Sp - 16] = block_cbqZM_info;
           R6 = R2;
           R5 = P64[R1 + 22];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 6];
           _sbolz::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = lvl21_rbnX3_closure+2;
           P64[Sp - 8] = _sbolz::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbqZM() //  [R1]
         { info_tbl: [(cbqZM,
                       label: block_cbqZM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqZM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbqZU; else goto cbqZT;
       cbqZU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqZT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr1H_srtd" {
     ubr1H_srtd:
         const SboCL_srt+176;
         const 64;
         const 17293822569102704641;
 },
 sat_sbolG_entry() //  [R1, R2]
         { info_tbl: [(cbqZV,
                       label: sat_sbolG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqZV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbqZW; else goto cbqZX;
       cbqZW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbqZX: // global
           I64[Sp - 40] = block_cbqZF_info;
           _sbolu::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 14];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _sbolu::P64;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr1I_srtd" {
     ubr1I_srtd:
         const SboCL_srt+176;
         const 64;
         const 12682136550675316737;
 },
 _cbqZF() //  [R1]
         { info_tbl: [(cbqZF,
                       label: block_cbqZF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqZF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbr00; else goto cbqZZ;
       cbr00: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbqZZ: // global
           I64[Hp - 24] = sat_sbolF_info;
           _sbolo::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sbolo::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 32];
           R5 = Hp - 22;
           R4 = P64[Sp + 24];
           R3 = _sbolo::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbom4_entry() //  [R1, R2]
         { info_tbl: [(cbr0o,
                       label: sat_sbom4_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr0o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbr0p; else goto cbr0q;
       cbr0p: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr0q: // global
           I64[Sp - 16] = block_cbr0l_info;
           R6 = R2;
           R5 = P64[R1 + 22];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 6];
           _sbolY::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = lvl21_rbnX3_closure+2;
           P64[Sp - 8] = _sbolY::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbr0l() //  [R1]
         { info_tbl: [(cbr0l,
                       label: block_cbr0l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr0l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr0t; else goto cbr0s;
       cbr0t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr0s: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr1J_srtd" {
     ubr1J_srtd:
         const SboCL_srt+176;
         const 64;
         const 17293822569102704641;
 },
 sat_sbom5_entry() //  [R1, R2]
         { info_tbl: [(cbr0u,
                       label: sat_sbom5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr0u: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbr0v; else goto cbr0w;
       cbr0v: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr0w: // global
           I64[Sp - 40] = block_cbr0e_info;
           _sbolT::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 14];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _sbolT::P64;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr1K_srtd" {
     ubr1K_srtd:
         const SboCL_srt+176;
         const 64;
         const 12682136550675316737;
 },
 _cbr0e() //  [R1]
         { info_tbl: [(cbr0e,
                       label: block_cbr0e_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr0e: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbr0z; else goto cbr0y;
       cbr0z: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr0y: // global
           I64[Hp - 24] = sat_sbom4_info;
           _sbolo::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sbolo::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 32];
           R5 = Hp - 22;
           R4 = P64[Sp + 24];
           R3 = _sbolo::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbomm_entry() //  [R1, R2]
         { info_tbl: [(cbr0T,
                       label: sat_sbomm_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr0T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbr0U; else goto cbr0V;
       cbr0U: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr0V: // global
           I64[Sp - 16] = block_cbr0Q_info;
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 6];
           _sbomg::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _sbomg::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbr0Q() //  [R1]
         { info_tbl: [(cbr0Q,
                       label: block_cbr0Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr0Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr0Y; else goto cbr0X;
       cbr0Y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr0X: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr1L_srtd" {
     ubr1L_srtd:
         const SboCL_srt+176;
         const 64;
         const 16140901064495857665;
 },
 sat_sbomn_entry() //  [R1, R2]
         { info_tbl: [(cbr0Z,
                       label: sat_sbomn_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr0Z: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbr10; else goto cbr11;
       cbr10: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr11: // global
           I64[Sp - 48] = block_cbr0J_info;
           _sbomb::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = P64[R1 + 6];
           P64[Sp - 32] = P64[R1 + 14];
           P64[Sp - 24] = P64[R1 + 22];
           P64[Sp - 16] = P64[R1 + 30];
           P64[Sp - 8] = _sbomb::P64;
           Sp = Sp - 48;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr1M_srtd" {
     ubr1M_srtd:
         const SboCL_srt+176;
         const 64;
         const 11529215046068469761;
 },
 _cbr0J() //  [R1]
         { info_tbl: [(cbr0J,
                       label: block_cbr0J_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr0J: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbr14; else goto cbr13;
       cbr14: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr13: // global
           I64[Hp - 32] = sat_sbomm_info;
           _sbolo::P64 = P64[Sp + 8];
           P64[Hp - 24] = _sbolo::P64;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R5 = Hp - 30;
           R4 = P64[Sp + 24];
           R3 = _sbolo::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr1N_srtd" {
     ubr1N_srtd:
         const SboCL_srt+176;
         const 66;
         const 17293822569102704645;
         const 3;
 },
 GHC.IO.Handle.hDuplicateTo1_entry() //  [R2, R3]
         { info_tbl: [(cbr19,
                       label: GHC.IO.Handle.hDuplicateTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr19: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbr1a; else goto cbr1b;
       cbr1a: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hDuplicateTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbr1b: // global
           I64[Sp - 16] = block_cbqZq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubr1G; else goto cbqZr;
       ubr1G: // global
           call _cbqZq(R1) args: 0, res: 0, upd: 0;
       cbqZr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr1O_srtd" {
     ubr1O_srtd:
         const SboCL_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbqZq() //  [R1]
         { info_tbl: [(cbqZq,
                       label: block_cbqZq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqZq: // global
           _sbolm::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbr16; else goto cbr17;
       cbr16: // global
           I64[Sp - 16] = block_cbqZv_info;
           _sbolo::P64 = R1;
           _sbolp::P64 = P64[R1 + 7];
           _sbolq::P64 = P64[R1 + 15];
           R1 = _sbolm::P64;
           P64[Sp - 8] = _sbolq::P64;
           P64[Sp] = _sbolp::P64;
           P64[Sp + 8] = _sbolo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubr1C; else goto cbqZw;
       ubr1C: // global
           call _cbqZv(R1) args: 0, res: 0, upd: 0;
       cbqZw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbr17: // global
           I64[Sp - 24] = block_cbr03_info;
           _sbolo::P64 = R1;
           _sbolK::P64 = P64[R1 + 6];
           _sbolL::P64 = P64[R1 + 14];
           _sbolM::P64 = P64[R1 + 22];
           R1 = _sbolm::P64;
           P64[Sp - 16] = _sbolL::P64;
           P64[Sp - 8] = _sbolM::P64;
           P64[Sp] = _sbolK::P64;
           P64[Sp + 8] = _sbolo::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubr1D; else goto cbr04;
       ubr1D: // global
           call _cbr03(R1) args: 0, res: 0, upd: 0;
       cbr04: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr1P_srtd" {
     ubr1P_srtd:
         const SboCL_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbqZv() //  [R1]
         { info_tbl: [(cbqZv,
                       label: block_cbqZv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbqZv: // global
           if (R1 & 7 == 1) goto cbr1e; else goto ubr1B;
       cbr1e: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbr1h; else goto cbr1g;
       cbr1h: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr1g: // global
           _sbolt::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sbolG_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R5 = Hp - 22;
           R4 = _sbolt::P64;
           R3 = R1;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       ubr1B: // global
           Sp = Sp + 24;
           call _cbr1q() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubr1Q_srtd" {
     ubr1Q_srtd:
         const SboCL_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbr03() //  [R1]
         { info_tbl: [(cbr03,
                       label: block_cbr03_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr03: // global
           if (R1 & 7 == 1) goto ubr1A; else goto cbr1r;
       ubr1A: // global
           Sp = Sp + 32;
           call _cbr1q() args: 0, res: 0, upd: 0;
       cbr1r: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbr1u; else goto cbr1t;
       cbr1u: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr1t: // global
           _sbolR::P64 = P64[R1 + 14];
           _sbolS::P64 = P64[R1 + 22];
           I64[Hp - 24] = sat_sbom5_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 16] = block_cbr0A_info;
           R5 = Hp - 22;
           R4 = _sbolS::P64;
           R3 = R1;
           R2 = lvl1_rbnWC_closure;
           P64[Sp - 8] = _sbolR::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbr1q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr1q: // global
           R2 = P64[Sp];
           Sp = Sp + 8;
           call ioe_dupHandlesNotCompatible_rbnWF_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr1R_srtd" {
     ubr1R_srtd:
         const SboCL_srt+176;
         const 65;
         const 16140901064495857665;
         const 1;
 },
 _cbr0A() //  [R1]
         { info_tbl: [(cbr0A,
                       label: block_cbr0A_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr0A: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbr1x; else goto cbr1w;
       cbr1x: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr1w: // global
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = P64[Sp + 32];
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = sat_sbomn_info;
           P64[Hp - 24] = P64[Sp + 48];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           R5 = Hp - 30;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.130766168 UTC

[section ""data" . GHC.IO.Handle.hDuplicateTo_closure" {
     GHC.IO.Handle.hDuplicateTo_closure:
         const GHC.IO.Handle.hDuplicateTo_info;
         const 0;
 },
 GHC.IO.Handle.hDuplicateTo_entry() //  [R2, R3]
         { info_tbl: [(cbr1W,
                       label: GHC.IO.Handle.hDuplicateTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr1W: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hDuplicateTo1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.131450767 UTC

[section ""cstring" . lvl22_rbnX4_bytes" {
     lvl22_rbnX4_bytes:
         I8[] [104,68,117,112,108,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.132187041 UTC

[section ""data" . lvl23_rbnX5_closure" {
     lvl23_rbnX5_closure:
         const lvl23_rbnX5_info;
         const 0;
         const 0;
         const 0;
 },
 lvl23_rbnX5_entry() //  [R1]
         { info_tbl: [(cbr25,
                       label: lvl23_rbnX5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr25: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbr26; else goto cbr27;
       cbr26: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbr27: // global
           (_cbr22::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbr22::I64 == 0) goto cbr24; else goto cbr23;
       cbr24: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbr23: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbr22::I64;
           R2 = lvl22_rbnX4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.133059194 UTC

[section ""cstring" . lvl24_rbnX6_bytes" {
     lvl24_rbnX6_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,54,50,54,58,51,45,51,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.133769145 UTC

[section ""data" . lvl25_rbnX7_closure" {
     lvl25_rbnX7_closure:
         const lvl25_rbnX7_info;
         const 0;
 },
 lvl25_rbnX7_entry() //  []
         { info_tbl: [(cbr2e,
                       label: lvl25_rbnX7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbr2f; else goto cbr2g;
       cbr2f: // global
           R1 = lvl25_rbnX7_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbr2g: // global
           I64[Sp - 8] = block_cbr2c_info;
           R2 = lvl24_rbnX6_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbr2c() //  [R1]
         { info_tbl: [(cbr2c,
                       label: block_cbr2c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2c: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.134621487 UTC

[section ""cstring" . lvl26_rbnX8_bytes" {
     lvl26_rbnX8_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,54,50,51,58,51,45,51,53]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.135300149 UTC

[section ""data" . lvl27_rbnX9_closure" {
     lvl27_rbnX9_closure:
         const lvl27_rbnX9_info;
         const 0;
 },
 lvl27_rbnX9_entry() //  []
         { info_tbl: [(cbr2q,
                       label: lvl27_rbnX9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbr2r; else goto cbr2s;
       cbr2r: // global
           R1 = lvl27_rbnX9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbr2s: // global
           I64[Sp - 8] = block_cbr2o_info;
           R2 = lvl26_rbnX8_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbr2o() //  [R1]
         { info_tbl: [(cbr2o,
                       label: block_cbr2o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2o: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.138850528 UTC

[section ""data" . GHC.IO.Handle.hDuplicate1_closure" {
     GHC.IO.Handle.hDuplicate1_closure:
         const GHC.IO.Handle.hDuplicate1_info;
         const 0;
 },
 section ""relreadonly" . ubr5d_srtd" {
     ubr5d_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 sat_sbon0_entry() //  [R1, R2]
         { info_tbl: [(cbr2N,
                       label: sat_sbon0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2N: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbr2X; else goto cbr2Y;
       cbr2X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr2Y: // global
           I64[Sp - 16] = block_cbr2K_info;
           _sbomv::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbomv::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubr35; else goto cbr2L;
       ubr35: // global
           call _cbr2K(R1) args: 0, res: 0, upd: 0;
       cbr2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5e_srtd" {
     ubr5e_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 _cbr2K() //  [R1]
         { info_tbl: [(cbr2K,
                       label: block_cbr2K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2K: // global
           I64[Sp - 40] = block_cbr2Q_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5f_srtd" {
     ubr5f_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbr2Q() //  []
         { info_tbl: [(cbr2Q,
                       label: block_cbr2Q_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2Q: // global
           I64[Sp] = block_cbr2S_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 16;
           call GHC.IO.Device.dup_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5g_srtd" {
     ubr5g_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbr2S() //  [R1]
         { info_tbl: [(cbr2S,
                       label: block_cbr2S_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2S: // global
           I64[Sp + 32] = block_cbr2U_info;
           R6 = P64[Sp + 48];
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = lvl21_rbnX3_closure+2;
           Sp = Sp + 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbr2U() //  [R1]
         { info_tbl: [(cbr2U,
                       label: block_cbr2U_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr34; else goto cbr33;
       cbr34: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr33: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr5h_srtd" {
     ubr5h_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 sat_sbonx_entry() //  [R1, R2]
         { info_tbl: [(cbr3g,
                       label: sat_sbonx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3g: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbr3q; else goto cbr3r;
       cbr3q: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr3r: // global
           I64[Sp - 16] = block_cbr3d_info;
           _sbon1::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbon1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubr3y; else goto cbr3e;
       ubr3y: // global
           call _cbr3d(R1) args: 0, res: 0, upd: 0;
       cbr3e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5i_srtd" {
     ubr5i_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 _cbr3d() //  [R1]
         { info_tbl: [(cbr3d,
                       label: block_cbr3d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3d: // global
           I64[Sp - 40] = block_cbr3j_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5j_srtd" {
     ubr5j_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbr3j() //  []
         { info_tbl: [(cbr3j,
                       label: block_cbr3j_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3j: // global
           I64[Sp] = block_cbr3l_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 16;
           call GHC.IO.Device.dup_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5k_srtd" {
     ubr5k_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbr3l() //  [R1]
         { info_tbl: [(cbr3l,
                       label: block_cbr3l_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3l: // global
           I64[Sp + 32] = block_cbr3n_info;
           R6 = P64[Sp + 48];
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = lvl21_rbnX3_closure+2;
           Sp = Sp + 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbr3n() //  [R1]
         { info_tbl: [(cbr3n,
                       label: block_cbr3n_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr3x; else goto cbr3w;
       cbr3x: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr3w: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sboop_entry() //  [R1, R2]
         { info_tbl: [(cbr42,
                       label: sat_sboop_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr42: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbr48; else goto cbr49;
       cbr48: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr49: // global
           I64[Sp - 32] = block_cbr3Z_info;
           _sbon1::P64 = P64[R1 + 6];
           _sbonF::P64 = P64[R1 + 14];
           _sbonI::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sbon1::P64;
           P64[Sp - 16] = _sbonF::P64;
           P64[Sp - 8] = _sbonI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubr4e; else goto cbr40;
       ubr4e: // global
           call _cbr3Z(R1) args: 0, res: 0, upd: 0;
       cbr40: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr3Z() //  [R1]
         { info_tbl: [(cbr3Z,
                       label: block_cbr3Z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3Z: // global
           _sbonF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbr45_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sbonF::P64;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbr45() //  [R1]
         { info_tbl: [(cbr45,
                       label: block_cbr45_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr45: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr4d; else goto cbr4c;
       cbr4d: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr4c: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr5l_srtd" {
     ubr5l_srtd:
         const SboCL_srt+96;
         const 81;
         const 1;
         const 98816;
 },
 sat_sboou_entry() //  [R1, R2]
         { info_tbl: [(cbr4f,
                       label: sat_sboou_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr4f: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbr4j; else goto cbr4k;
       cbr4j: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr4k: // global
           I64[Sp - 40] = block_cbr3N_info;
           _sbomu::P64 = P64[R1 + 6];
           _sbon1::P64 = P64[R1 + 14];
           _sbonD::P64 = P64[R1 + 22];
           _sbonF::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 32] = _sbomu::P64;
           P64[Sp - 24] = _sbon1::P64;
           P64[Sp - 16] = _sbonD::P64;
           P64[Sp - 8] = _sbonF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubr4s; else goto cbr3O;
       ubr4s: // global
           call _cbr3N(R1) args: 0, res: 0, upd: 0;
       cbr3O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5m_srtd" {
     ubr5m_srtd:
         const SboCL_srt+96;
         const 81;
         const 1;
         const 98816;
 },
 _cbr3N() //  [R1]
         { info_tbl: [(cbr3N,
                       label: block_cbr3N_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3N: // global
           I64[Sp - 8] = block_cbr3S_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbr3S() //  [R1]
         { info_tbl: [(cbr3S,
                       label: block_cbr3S_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbr4o; else goto cbr4n;
       cbr4o: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr4n: // global
           I64[Hp - 24] = sat_sboop_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cbr4g_info;
           R5 = Hp - 22;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = lvl7_rbnWP_closure;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbr4g() //  [R1]
         { info_tbl: [(cbr4g,
                       label: block_cbr4g_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr4g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr4r; else goto cbr4q;
       cbr4r: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr4q: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr5n_srtd" {
     ubr5n_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 512576;
 },
 GHC.IO.Handle.hDuplicate1_entry() //  [R2]
         { info_tbl: [(cbr4x,
                       label: GHC.IO.Handle.hDuplicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr4x: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbr4y; else goto cbr4z;
       cbr4y: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hDuplicate1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr4z: // global
           I64[Sp - 8] = block_cbr2A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubr5b; else goto cbr2B;
       ubr5b: // global
           call _cbr2A(R1) args: 0, res: 0, upd: 0;
       cbr2B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5o_srtd" {
     ubr5o_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 381504;
 },
 _cbr2A() //  [R1]
         { info_tbl: [(cbr2A,
                       label: block_cbr2A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr2A: // global
           if (R1 & 7 == 1) goto cbr4u; else goto cbr4v;
       cbr4u: // global
           Hp = Hp + 16;
           _sbomu::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbr4F; else goto cbr4B;
       cbr4B: // global
           _sbomv::P64 = P64[_sbomu::P64 + 7];
           _sbomw::P64 = P64[_sbomu::P64 + 15];
           I64[Hp - 8] = sat_sbon0_info;
           P64[Hp] = _sbomv::P64;
           R5 = Hp - 6;
           R4 = _sbomw::P64;
           R3 = _sbomu::P64;
           R2 = lvl23_rbnX5_closure;
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cbr4v: // global
           Hp = Hp + 16;
           _sbomu::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbr4F; else goto cbr4E;
       cbr4F: // global
           HpAlloc = 16;
           R1 = _sbomu::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr4E: // global
           _sbon1::P64 = P64[_sbomu::P64 + 6];
           _sbon2::P64 = P64[_sbomu::P64 + 14];
           _sbon3::P64 = P64[_sbomu::P64 + 22];
           I64[Hp - 8] = sat_sbonx_info;
           P64[Hp] = _sbon1::P64;
           I64[Sp - 24] = block_cbr3z_info;
           R5 = Hp - 6;
           R4 = _sbon3::P64;
           R3 = _sbomu::P64;
           R2 = lvl23_rbnX5_closure;
           P64[Sp - 16] = _sbon1::P64;
           P64[Sp - 8] = _sbon2::P64;
           P64[Sp] = _sbomu::P64;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5p_srtd" {
     ubr5p_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 381440;
 },
 _cbr3z() //  [R1]
         { info_tbl: [(cbr3z,
                       label: block_cbr3z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3z: // global
           I64[Sp] = block_cbr3B_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubr5a; else goto cbr3C;
       ubr5a: // global
           call _cbr3B(R1) args: 0, res: 0, upd: 0;
       cbr3C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr5q_srtd" {
     ubr5q_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 381440;
 },
 _cbr3B() //  [R1]
         { info_tbl: [(cbr3B,
                       label: block_cbr3B_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr3B: // global
           if (R1 & 7 == 1) goto cbr4L; else goto cbr57;
       cbr4L: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbr4O; else goto cbr4N;
       cbr4O: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr4N: // global
           _sbonD::P64 = P64[R1 + 15];
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = _sbonD::P64;
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = sat_sboou_info;
           _sbomu::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sbomu::P64;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sbonD::P64;
           P64[Hp] = Hp - 46;
           I64[Sp] = block_cbr4H_info;
           R5 = Hp - 30;
           R4 = P64[Sp + 16];
           R3 = _sbomu::P64;
           R2 = lvl23_rbnX5_closure;
           P64[Sp + 24] = _sbonD::P64;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
       cbr57: // global
           Sp = Sp + 32;
           call lvl27_rbnX9_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbr4H() //  [R1]
         { info_tbl: [(cbr4H,
                       label: block_cbr4H_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr4H: // global
           I64[Sp] = block_cbr4J_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubr5c; else goto cbr4Q;
       ubr5c: // global
           call _cbr4J(R1) args: 0, res: 0, upd: 0;
       cbr4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr4J() //  [R1]
         { info_tbl: [(cbr4J,
                       label: block_cbr4J_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr4J: // global
           if (R1 & 7 == 1) goto cbr4W; else goto cbr53;
       cbr4W: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbr4Z; else goto cbr4Y;
       cbr4Z: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr4Y: // global
           _sbooA::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sbooA::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbr53: // global
           Sp = Sp + 32;
           call lvl25_rbnX7_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.145915525 UTC

[section ""data" . GHC.IO.Handle.hDuplicate_closure" {
     GHC.IO.Handle.hDuplicate_closure:
         const GHC.IO.Handle.hDuplicate_info;
         const 0;
 },
 GHC.IO.Handle.hDuplicate_entry() //  [R2]
         { info_tbl: [(cbr5v,
                       label: GHC.IO.Handle.hDuplicate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr5v: // global
           R2 = R2;
           call GHC.IO.Handle.hDuplicate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.146583822 UTC

[section ""cstring" . GHC.IO.Handle.hGetEcho4_bytes" {
     GHC.IO.Handle.hGetEcho4_bytes:
         I8[] [104,71,101,116,69,99,104,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.14725448 UTC

[section ""data" . GHC.IO.Handle.hGetEcho3_closure" {
     GHC.IO.Handle.hGetEcho3_closure:
         const GHC.IO.Handle.hGetEcho3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEcho3_entry() //  [R1]
         { info_tbl: [(cbr5E,
                       label: GHC.IO.Handle.hGetEcho3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr5E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbr5F; else goto cbr5G;
       cbr5F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbr5G: // global
           (_cbr5B::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbr5B::I64 == 0) goto cbr5D; else goto cbr5C;
       cbr5D: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbr5C: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbr5B::I64;
           R2 = GHC.IO.Handle.hGetEcho4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.148569524 UTC

[section ""data" . GHC.IO.Handle.hGetEcho2_closure" {
     GHC.IO.Handle.hGetEcho2_closure:
         const GHC.IO.Handle.hGetEcho2_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho2_entry() //  [R2]
         { info_tbl: [(cbr5O,
                       label: GHC.IO.Handle.hGetEcho2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr5O: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbr5P; else goto cbr5Q;
       cbr5P: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr5Q: // global
           I64[Sp - 8] = block_cbr5L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubr6e; else goto cbr5M;
       ubr6e: // global
           call _cbr5L(R1) args: 0, res: 0, upd: 0;
       cbr5M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr5L() //  [R1]
         { info_tbl: [(cbr5L,
                       label: block_cbr5L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr5L: // global
           I64[Sp - 24] = block_cbr5T_info;
           _sbooK::P64 = R1;
           _sbooL::P64 = P64[R1 + 7];
           _sbooO::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbooL::P64;
           P64[Sp - 8] = _sbooO::P64;
           P64[Sp] = _sbooK::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubr6d; else goto cbr5V;
       ubr6d: // global
           call _cbr5T(R1) args: 0, res: 0, upd: 0;
       cbr5V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr5T() //  [R1]
         { info_tbl: [(cbr5T,
                       label: block_cbr5T_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr5T: // global
           if (R1 & 7 == 1) goto cbr6b; else goto cbr64;
       cbr6b: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbr64: // global
           _sbooO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbr5Z_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbooO::P64;
           call GHC.IO.Device.getEcho_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbr5Z() //  [R1]
         { info_tbl: [(cbr5Z,
                       label: block_cbr5Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr5Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr67; else goto cbr66;
       cbr67: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr66: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.151306991 UTC

[section ""data" . GHC.IO.Handle.hGetEcho1_closure" {
     GHC.IO.Handle.hGetEcho1_closure:
         const GHC.IO.Handle.hGetEcho1_info;
         const 0;
 },
 section ""relreadonly" . ubr7P_srtd" {
     ubr7P_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 io_sbopj_entry() //  [R1]
         { info_tbl: [(cbr6I,
                       label: io_sbopj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr6I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbr6M; else goto cbr6N;
       cbr6M: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbr6N: // global
           I64[Sp - 16] = block_cbr6D_info;
           _sbopf::P64 = P64[R1 + 15];
           R5 = _sbopf::P64;
           R4 = GHC.IO.Handle.hGetEcho2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho3_closure;
           P64[Sp - 8] = _sbopf::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbr6D() //  [R1]
         { info_tbl: [(cbr6D,
                       label: block_cbr6D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr6D: // global
           I64[Sp] = block_cbr6F_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubr6S; else goto cbr6G;
       ubr6S: // global
           call _cbr6F(R1) args: 0, res: 0, upd: 0;
       cbr6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr6F() //  [R1]
         { info_tbl: [(cbr6F,
                       label: block_cbr6F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr6F: // global
           I64[Sp] = block_cbr6L_info;
           R2 = P64[R1 + 7];
           _sbopq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbopq::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr6L() //  []
         { info_tbl: [(cbr6L,
                       label: block_cbr6L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr6L: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr7Q_srtd" {
     ubr7Q_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 io_sbopz_entry() //  [R1]
         { info_tbl: [(cbr77,
                       label: io_sbopz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbr7b; else goto cbr7c;
       cbr7b: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbr7c: // global
           I64[Sp - 16] = block_cbr72_info;
           _sbopu::P64 = P64[R1 + 15];
           R5 = _sbopu::P64;
           R4 = GHC.IO.Handle.hGetEcho2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho3_closure;
           P64[Sp - 8] = _sbopu::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbr72() //  [R1]
         { info_tbl: [(cbr72,
                       label: block_cbr72_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr72: // global
           I64[Sp] = block_cbr74_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubr7h; else goto cbr75;
       ubr7h: // global
           call _cbr74(R1) args: 0, res: 0, upd: 0;
       cbr75: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr74() //  [R1]
         { info_tbl: [(cbr74,
                       label: block_cbr74_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr74: // global
           I64[Sp] = block_cbr7a_info;
           R2 = P64[R1 + 7];
           _sbopG::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbopG::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr7a() //  []
         { info_tbl: [(cbr7a,
                       label: block_cbr7a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr7a: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr7R_srtd" {
     ubr7R_srtd:
         const SboCL_srt+160;
         const 79;
         const 137438953473;
         const 26624;
 },
 GHC.IO.Handle.hGetEcho1_entry() //  [R2]
         { info_tbl: [(cbr7m,
                       label: GHC.IO.Handle.hGetEcho1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr7m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbr7n; else goto cbr7o;
       cbr7n: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr7o: // global
           I64[Sp - 16] = block_cbr6j_info;
           _sbop7::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbop7::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr7S_srtd" {
     ubr7S_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbr6j() //  [R1]
         { info_tbl: [(cbr6j,
                       label: block_cbr6j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr6j: // global
           I64[Sp] = block_cbr6l_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubr7N; else goto cbr6m;
       ubr7N: // global
           call _cbr6l(R1) args: 0, res: 0, upd: 0;
       cbr6m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr7T_srtd" {
     ubr7T_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbr6l() //  [R1]
         { info_tbl: [(cbr6l,
                       label: block_cbr6l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr6l: // global
           if (R1 & 7 == 1) goto cbr7j; else goto cbr7k;
       cbr7j: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbr7k: // global
           _sbop7::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbr6r_info;
           R1 = _sbop7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubr7O; else goto cbr6s;
       ubr7O: // global
           call _cbr6r(R1) args: 0, res: 0, upd: 0;
       cbr6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr7U_srtd" {
     ubr7U_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbr6r() //  [R1]
         { info_tbl: [(cbr6r,
                       label: block_cbr6r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr6r: // global
           if (R1 & 7 == 1) goto cbr7v; else goto cbr7E;
       cbr7v: // global
           I64[Sp - 16] = block_cbr6w_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbr7E: // global
           I64[Sp - 16] = block_cbr6V_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubr7V_srtd" {
     ubr7V_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbr6w() //  [R1]
         { info_tbl: [(cbr6w,
                       label: block_cbr6w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr6w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr7y; else goto cbr7x;
       cbr7y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbr7x: // global
           I64[Hp - 16] = io_sbopj_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbr6y::P64 = Hp - 15;
           if (R1 == 0) goto cbr7C; else goto cbr7B;
       cbr7C: // global
           R1 = _cbr6y::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbr7B: // global
           R1 = _cbr6y::P64;
           Sp = Sp + 24;
           call io_sbopj_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubr7W_srtd" {
     ubr7W_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbr6V() //  [R1]
         { info_tbl: [(cbr6V,
                       label: block_cbr6V_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr6V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr7H; else goto cbr7G;
       cbr7H: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbr7G: // global
           I64[Hp - 16] = io_sbopz_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbr6X::P64 = Hp - 15;
           if (R1 == 0) goto cbr7L; else goto cbr7K;
       cbr7L: // global
           R1 = _cbr6X::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbr7K: // global
           R1 = _cbr6X::P64;
           Sp = Sp + 24;
           call io_sbopz_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.155350818 UTC

[section ""data" . GHC.IO.Handle.hGetEcho_closure" {
     GHC.IO.Handle.hGetEcho_closure:
         const GHC.IO.Handle.hGetEcho_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho_entry() //  [R2]
         { info_tbl: [(cbr81,
                       label: GHC.IO.Handle.hGetEcho_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr81: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEcho1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.156062448 UTC

[section ""cstring" . GHC.IO.Handle.hSetEcho3_bytes" {
     GHC.IO.Handle.hSetEcho3_bytes:
         I8[] [104,83,101,116,69,99,104,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.156763629 UTC

[section ""data" . GHC.IO.Handle.hSetEcho2_closure" {
     GHC.IO.Handle.hSetEcho2_closure:
         const GHC.IO.Handle.hSetEcho2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetEcho2_entry() //  [R1]
         { info_tbl: [(cbr8a,
                       label: GHC.IO.Handle.hSetEcho2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr8a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbr8b; else goto cbr8c;
       cbr8b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbr8c: // global
           (_cbr87::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbr87::I64 == 0) goto cbr89; else goto cbr88;
       cbr89: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbr88: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbr87::I64;
           R2 = GHC.IO.Handle.hSetEcho3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.159938203 UTC

[section ""data" . GHC.IO.Handle.hSetEcho1_closure" {
     GHC.IO.Handle.hSetEcho1_closure:
         const GHC.IO.Handle.hSetEcho1_info;
         const 0;
 },
 sat_sboqn_entry() //  [R1, R2]
         { info_tbl: [(cbr8J,
                       label: sat_sboqn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr8J: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbr8K; else goto cbr8L;
       cbr8K: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr8L: // global
           I64[Sp - 16] = block_cbr8G_info;
           _sbopK::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbopK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubr99; else goto cbr8H;
       ubr99: // global
           call _cbr8G(R1) args: 0, res: 0, upd: 0;
       cbr8H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr8G() //  [R1]
         { info_tbl: [(cbr8G,
                       label: block_cbr8G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr8G: // global
           I64[Sp - 24] = block_cbr8O_info;
           _sboq0::P64 = R1;
           _sboq1::P64 = P64[R1 + 7];
           _sboq4::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sboq1::P64;
           P64[Sp - 8] = _sboq4::P64;
           P64[Sp] = _sboq0::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubr98; else goto cbr8Q;
       ubr98: // global
           call _cbr8O(R1) args: 0, res: 0, upd: 0;
       cbr8Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr8O() //  [R1]
         { info_tbl: [(cbr8O,
                       label: block_cbr8O_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr8O: // global
           if (R1 & 7 == 1) goto cbr96; else goto cbr8Z;
       cbr96: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbr8Z: // global
           _sboq4::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbr8U_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sboq4::P64;
           P64[Sp + 8] = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.IO.Device.setEcho_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbr8U() //  [R1]
         { info_tbl: [(cbr8U,
                       label: block_cbr8U_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr8U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbr92; else goto cbr91;
       cbr92: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbr91: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubraZ_srtd" {
     ubraZ_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 io_sbopW_entry() //  [R1]
         { info_tbl: [(cbr9f,
                       label: io_sbopW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr9f: // global
           _sbopW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbr9j; else goto cbr9k;
       cbr9k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbr9m; else goto cbr9l;
       cbr9m: // global
           HpAlloc = 16;
           goto cbr9j;
       cbr9j: // global
           R1 = _sbopW::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbr9l: // global
           _sbopK::P64 = P64[_sbopW::P64 + 7];
           _sbopQ::P64 = P64[_sbopW::P64 + 15];
           _sbopS::P64 = P64[_sbopW::P64 + 23];
           I64[Hp - 8] = sat_sboqn_info;
           P64[Hp] = _sbopK::P64;
           I64[Sp - 16] = block_cbr9a_info;
           R5 = _sbopS::P64;
           R4 = Hp - 6;
           R3 = _sbopQ::P64;
           R2 = GHC.IO.Handle.hSetEcho2_closure;
           P64[Sp - 8] = _sbopS::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbr9a() //  [R1]
         { info_tbl: [(cbr9a,
                       label: block_cbr9a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr9a: // global
           I64[Sp] = block_cbr9c_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubr9r; else goto cbr9d;
       ubr9r: // global
           call _cbr9c(R1) args: 0, res: 0, upd: 0;
       cbr9d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr9c() //  [R1]
         { info_tbl: [(cbr9c,
                       label: block_cbr9c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr9c: // global
           I64[Sp] = block_cbr9i_info;
           R2 = P64[R1 + 7];
           _sboqt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboqt::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr9i() //  []
         { info_tbl: [(cbr9i,
                       label: block_cbr9i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr9i: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbor3_entry() //  [R1, R2]
         { info_tbl: [(cbr9J,
                       label: sat_sbor3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr9J: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbr9K; else goto cbr9L;
       cbr9K: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbr9L: // global
           I64[Sp - 16] = block_cbr9G_info;
           _sbopK::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbopK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubra9; else goto cbr9H;
       ubra9: // global
           call _cbr9G(R1) args: 0, res: 0, upd: 0;
       cbr9H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr9G() //  [R1]
         { info_tbl: [(cbr9G,
                       label: block_cbr9G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr9G: // global
           I64[Sp - 24] = block_cbr9O_info;
           _sboqG::P64 = R1;
           _sboqH::P64 = P64[R1 + 7];
           _sboqK::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sboqH::P64;
           P64[Sp - 8] = _sboqK::P64;
           P64[Sp] = _sboqG::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubra8; else goto cbr9Q;
       ubra8: // global
           call _cbr9O(R1) args: 0, res: 0, upd: 0;
       cbr9Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbr9O() //  [R1]
         { info_tbl: [(cbr9O,
                       label: block_cbr9O_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr9O: // global
           if (R1 & 7 == 1) goto cbra6; else goto cbr9Z;
       cbra6: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbr9Z: // global
           _sboqK::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbr9U_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sboqK::P64;
           P64[Sp + 8] = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.IO.Device.setEcho_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbr9U() //  [R1]
         { info_tbl: [(cbr9U,
                       label: block_cbr9U_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr9U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbra2; else goto cbra1;
       cbra2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbra1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrb0_srtd" {
     ubrb0_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 io_sboqC_entry() //  [R1]
         { info_tbl: [(cbraf,
                       label: io_sboqC_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbraf: // global
           _sboqC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbraj; else goto cbrak;
       cbrak: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbram; else goto cbral;
       cbram: // global
           HpAlloc = 16;
           goto cbraj;
       cbraj: // global
           R1 = _sboqC::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbral: // global
           _sbopK::P64 = P64[_sboqC::P64 + 7];
           _sbopQ::P64 = P64[_sboqC::P64 + 15];
           _sboqx::P64 = P64[_sboqC::P64 + 23];
           I64[Hp - 8] = sat_sbor3_info;
           P64[Hp] = _sbopK::P64;
           I64[Sp - 16] = block_cbraa_info;
           R5 = _sboqx::P64;
           R4 = Hp - 6;
           R3 = _sbopQ::P64;
           R2 = GHC.IO.Handle.hSetEcho2_closure;
           P64[Sp - 8] = _sboqx::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbraa() //  [R1]
         { info_tbl: [(cbraa,
                       label: block_cbraa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbraa: // global
           I64[Sp] = block_cbrac_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrar; else goto cbrad;
       ubrar: // global
           call _cbrac(R1) args: 0, res: 0, upd: 0;
       cbrad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrac() //  [R1]
         { info_tbl: [(cbrac,
                       label: block_cbrac_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrac: // global
           I64[Sp] = block_cbrai_info;
           R2 = P64[R1 + 7];
           _sbor9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbor9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrai() //  []
         { info_tbl: [(cbrai,
                       label: block_cbrai_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrai: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrb1_srtd" {
     ubrb1_srtd:
         const SboCL_srt+160;
         const 81;
         const 137438953473;
         const 102400;
 },
 GHC.IO.Handle.hSetEcho1_entry() //  [R2, R3]
         { info_tbl: [(cbraw,
                       label: GHC.IO.Handle.hSetEcho1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbraw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbrax; else goto cbray;
       cbrax: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetEcho1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbray: // global
           I64[Sp - 24] = block_cbr8h_info;
           _sbopJ::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbopJ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrb2_srtd" {
     ubrb2_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbr8h() //  [R1]
         { info_tbl: [(cbr8h,
                       label: block_cbr8h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr8h: // global
           I64[Sp] = block_cbr8j_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubraX; else goto cbr8k;
       ubraX: // global
           call _cbr8j(R1) args: 0, res: 0, upd: 0;
       cbr8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrb3_srtd" {
     ubrb3_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbr8j() //  [R1]
         { info_tbl: [(cbr8j,
                       label: block_cbr8j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr8j: // global
           if (R1 & 7 == 1) goto cbrat; else goto cbrau;
       cbrat: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbrau: // global
           _sbopJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbr8p_info;
           R1 = _sbopJ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubraY; else goto cbr8q;
       ubraY: // global
           call _cbr8p(R1) args: 0, res: 0, upd: 0;
       cbr8q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrb4_srtd" {
     ubrb4_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbr8p() //  [R1]
         { info_tbl: [(cbr8p,
                       label: block_cbr8p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr8p: // global
           if (R1 & 7 == 1) goto cbraF; else goto cbraO;
       cbraF: // global
           I64[Sp - 16] = block_cbr8u_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbraO: // global
           I64[Sp - 16] = block_cbr9u_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrb5_srtd" {
     ubrb5_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbr8u() //  [R1]
         { info_tbl: [(cbr8u,
                       label: block_cbr8u_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr8u: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbraI; else goto cbraH;
       cbraI: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbraH: // global
           I64[Hp - 24] = io_sbopW_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbr8w::P64 = Hp - 23;
           if (R1 == 0) goto cbraM; else goto cbraL;
       cbraM: // global
           R1 = _cbr8w::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbraL: // global
           R1 = _cbr8w::P64;
           Sp = Sp + 32;
           call io_sbopW_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrb6_srtd" {
     ubrb6_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbr9u() //  [R1]
         { info_tbl: [(cbr9u,
                       label: block_cbr9u_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbr9u: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbraR; else goto cbraQ;
       cbraR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbraQ: // global
           I64[Hp - 24] = io_sboqC_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbr9w::P64 = Hp - 23;
           if (R1 == 0) goto cbraV; else goto cbraU;
       cbraV: // global
           R1 = _cbr9w::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbraU: // global
           R1 = _cbr9w::P64;
           Sp = Sp + 32;
           call io_sboqC_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.166111639 UTC

[section ""data" . GHC.IO.Handle.hSetEcho_closure" {
     GHC.IO.Handle.hSetEcho_closure:
         const GHC.IO.Handle.hSetEcho_info;
         const 0;
 },
 GHC.IO.Handle.hSetEcho_entry() //  [R2, R3]
         { info_tbl: [(cbrbb,
                       label: GHC.IO.Handle.hSetEcho_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrbb: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetEcho1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.166809136 UTC

[section ""cstring" . GHC.IO.Handle.hGetBuffering3_bytes" {
     GHC.IO.Handle.hGetBuffering3_bytes:
         I8[] [104,71,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.167469858 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering_fun_closure" {
     GHC.IO.Handle.hGetBuffering_fun_closure:
         const GHC.IO.Handle.hGetBuffering_fun_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering_fun_entry() //  [R1]
         { info_tbl: [(cbrbk,
                       label: GHC.IO.Handle.hGetBuffering_fun_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrbk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrbl; else goto cbrbm;
       cbrbl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrbm: // global
           (_cbrbh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrbh::I64 == 0) goto cbrbj; else goto cbrbi;
       cbrbj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrbi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrbh::I64;
           R2 = GHC.IO.Handle.hGetBuffering3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.168725403 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering2_closure" {
     GHC.IO.Handle.hGetBuffering2_closure:
         const GHC.IO.Handle.hGetBuffering2_info;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering2_entry() //  [R2]
         { info_tbl: [(cbrbu,
                       label: GHC.IO.Handle.hGetBuffering2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrbu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrbv; else goto cbrbw;
       cbrbv: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetBuffering2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrbw: // global
           I64[Sp - 8] = block_cbrbr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrbR; else goto cbrbs;
       ubrbR: // global
           call _cbrbr(R1) args: 0, res: 0, upd: 0;
       cbrbs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrbr() //  [R1]
         { info_tbl: [(cbrbr,
                       label: block_cbrbr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrbr: // global
           I64[Sp - 16] = block_cbrbz_info;
           _sbore::P64 = R1;
           _sborl::P64 = P64[R1 + 55];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _sborl::P64;
           P64[Sp] = _sbore::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubrbQ; else goto cbrbB;
       ubrbQ: // global
           call _cbrbz(R1) args: 0, res: 0, upd: 0;
       cbrbB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrbz() //  [R1]
         { info_tbl: [(cbrbz,
                       label: block_cbrbz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrbz: // global
           if (R1 & 7 == 1) goto cbrbO; else goto cbrbH;
       cbrbO: // global
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbrbH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrbK; else goto cbrbJ;
       cbrbK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrbJ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.171180692 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering1_closure" {
     GHC.IO.Handle.hGetBuffering1_closure:
         const GHC.IO.Handle.hGetBuffering1_info;
         const 0;
 },
 section ""relreadonly" . ubrdb_srtd" {
     ubrdb_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 io_sborG_entry() //  [R1]
         { info_tbl: [(cbrcd,
                       label: io_sborG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrcd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrch; else goto cbrci;
       cbrch: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrci: // global
           I64[Sp - 16] = block_cbrc8_info;
           _sborC::P64 = P64[R1 + 15];
           R5 = _sborC::P64;
           R4 = GHC.IO.Handle.hGetBuffering2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetBuffering_fun_closure;
           P64[Sp - 8] = _sborC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrc8() //  [R1]
         { info_tbl: [(cbrc8,
                       label: block_cbrc8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrc8: // global
           I64[Sp] = block_cbrca_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrcn; else goto cbrcb;
       ubrcn: // global
           call _cbrca(R1) args: 0, res: 0, upd: 0;
       cbrcb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrca() //  [R1]
         { info_tbl: [(cbrca,
                       label: block_cbrca_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrca: // global
           I64[Sp] = block_cbrcg_info;
           R2 = P64[R1 + 7];
           _sborN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sborN::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrcg() //  []
         { info_tbl: [(cbrcg,
                       label: block_cbrcg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrcg: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrdc_srtd" {
     ubrdc_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 io_sborW_entry() //  [R1]
         { info_tbl: [(cbrcC,
                       label: io_sborW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrcC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrcG; else goto cbrcH;
       cbrcG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrcH: // global
           I64[Sp - 16] = block_cbrcx_info;
           _sborR::P64 = P64[R1 + 15];
           R5 = _sborR::P64;
           R4 = GHC.IO.Handle.hGetBuffering2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetBuffering_fun_closure;
           P64[Sp - 8] = _sborR::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrcx() //  [R1]
         { info_tbl: [(cbrcx,
                       label: block_cbrcx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrcx: // global
           I64[Sp] = block_cbrcz_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrcM; else goto cbrcA;
       ubrcM: // global
           call _cbrcz(R1) args: 0, res: 0, upd: 0;
       cbrcA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrcz() //  [R1]
         { info_tbl: [(cbrcz,
                       label: block_cbrcz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrcz: // global
           I64[Sp] = block_cbrcF_info;
           R2 = P64[R1 + 7];
           _sbos3::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbos3::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrcF() //  []
         { info_tbl: [(cbrcF,
                       label: block_cbrcF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrcF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrdd_srtd" {
     ubrdd_srtd:
         const SboCL_srt+456;
         const 47;
         const 123145302310913;
 },
 GHC.IO.Handle.hGetBuffering1_entry() //  [R2]
         { info_tbl: [(cbrcR,
                       label: GHC.IO.Handle.hGetBuffering1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrcR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrcS; else goto cbrcT;
       cbrcS: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetBuffering1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrcT: // global
           I64[Sp - 8] = block_cbrbW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrda; else goto cbrbX;
       ubrda: // global
           call _cbrbW(R1) args: 0, res: 0, upd: 0;
       cbrbX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrde_srtd" {
     ubrde_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbrbW() //  [R1]
         { info_tbl: [(cbrbW,
                       label: block_cbrbW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrbW: // global
           if (R1 & 7 == 1) goto cbrcO; else goto cbrcP;
       cbrcO: // global
           I64[Sp - 16] = block_cbrc1_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbrcP: // global
           I64[Sp - 16] = block_cbrcq_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrdf_srtd" {
     ubrdf_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbrc1() //  [R1]
         { info_tbl: [(cbrc1,
                       label: block_cbrc1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrc1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrcX; else goto cbrcW;
       cbrcX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrcW: // global
           I64[Hp - 16] = io_sborG_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrc3::P64 = Hp - 15;
           if (R1 == 0) goto cbrd1; else goto cbrd0;
       cbrd1: // global
           R1 = _cbrc3::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrd0: // global
           R1 = _cbrc3::P64;
           Sp = Sp + 24;
           call io_sborG_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrdg_srtd" {
     ubrdg_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbrcq() //  [R1]
         { info_tbl: [(cbrcq,
                       label: block_cbrcq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrcq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrd5; else goto cbrd4;
       cbrd5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrd4: // global
           I64[Hp - 16] = io_sborW_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrcs::P64 = Hp - 15;
           if (R1 == 0) goto cbrd9; else goto cbrd8;
       cbrd9: // global
           R1 = _cbrcs::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrd8: // global
           R1 = _cbrcs::P64;
           Sp = Sp + 24;
           call io_sborW_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.174683737 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering_closure" {
     GHC.IO.Handle.hGetBuffering_closure:
         const GHC.IO.Handle.hGetBuffering_info;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering_entry() //  [R2]
         { info_tbl: [(cbrdl,
                       label: GHC.IO.Handle.hGetBuffering_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrdl: // global
           R2 = R2;
           call GHC.IO.Handle.hGetBuffering1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.175376571 UTC

[section ""cstring" . GHC.IO.Handle.hIsWritable4_bytes" {
     GHC.IO.Handle.hIsWritable4_bytes:
         I8[] [104,73,115,87,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.176102846 UTC

[section ""data" . GHC.IO.Handle.hIsWritable3_closure" {
     GHC.IO.Handle.hIsWritable3_closure:
         const GHC.IO.Handle.hIsWritable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsWritable3_entry() //  [R1]
         { info_tbl: [(cbrdu,
                       label: GHC.IO.Handle.hIsWritable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrdu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrdv; else goto cbrdw;
       cbrdv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrdw: // global
           (_cbrdr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrdr::I64 == 0) goto cbrdt; else goto cbrds;
       cbrdt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrds: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrdr::I64;
           R2 = GHC.IO.Handle.hIsWritable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.177736936 UTC

[section ""data" . GHC.IO.Handle.hIsWritable2_closure" {
     GHC.IO.Handle.hIsWritable2_closure:
         const GHC.IO.Handle.hIsWritable2_info;
         const 0;
 },
 sat_sbosr_entry() //  [R1]
         { info_tbl: [(cbrdY,
                       label: sat_sbosr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrdY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrdZ; else goto cbre0;
       cbrdZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbre0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbrdP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubree; else goto cbrdQ;
       ubree: // global
           call _cbrdP(R1) args: 0, res: 0, upd: 0;
       cbrdQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrdP() //  [R1]
         { info_tbl: [(cbrdP,
                       label: block_cbrdP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrdP: // global
           _cbrdX::P64 = R1 & 7;
           if (_cbrdX::P64 < 4) goto cbrdT; else goto ubred;
       cbrdT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ubred: // global
           if (_cbrdX::P64 != 5) goto cbrdW; else goto cbrdW;
       cbrdW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubreB_srtd" {
     ubreB_srtd:
         const SboCL_srt+328;
         const 64;
         const 9259400833873739777;
 },
 GHC.IO.Handle.hIsWritable2_entry() //  [R2]
         { info_tbl: [(cbref,
                       label: GHC.IO.Handle.hIsWritable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbref: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbreg; else goto cbreh;
       cbreg: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsWritable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbreh: // global
           I64[Sp - 8] = block_cbrdB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubreA; else goto cbrdC;
       ubreA: // global
           call _cbrdB(R1) args: 0, res: 0, upd: 0;
       cbrdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubreC_srtd" {
     ubreC_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbrdB() //  [R1]
         { info_tbl: [(cbrdB,
                       label: block_cbrdB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrdB: // global
           I64[Sp - 8] = block_cbrdG_info;
           _sbos8::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbos8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrez; else goto cbrdH;
       ubrez: // global
           call _cbrdG(R1) args: 0, res: 0, upd: 0;
       cbrdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubreD_srtd" {
     ubreD_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbrdG() //  [R1]
         { info_tbl: [(cbrdG,
                       label: block_cbrdG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrdG: // global
           _cbrex::P64 = R1 & 7;
           if (_cbrex::P64 == 1) goto cbres; else goto ubrey;
       cbres: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       ubrey: // global
           if (_cbrex::P64 == 2) goto cbrew; else goto cbrel;
       cbrew: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbrel: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbreo; else goto cbren;
       cbreo: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbren: // global
           I64[Hp - 40] = sat_sbosr_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.180447924 UTC

[section ""data" . GHC.IO.Handle.hIsWritable1_closure" {
     GHC.IO.Handle.hIsWritable1_closure:
         const GHC.IO.Handle.hIsWritable1_info;
         const 0;
 },
 section ""relreadonly" . ubrft_srtd" {
     ubrft_srtd:
         const SboCL_srt+456;
         const 49;
         const 422212465065985;
 },
 io_sbosD_entry() //  [R1]
         { info_tbl: [(cbreZ,
                       label: io_sbosD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbreZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrf3; else goto cbrf4;
       cbrf3: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrf4: // global
           I64[Sp - 16] = block_cbreU_info;
           _sbosz::P64 = P64[R1 + 15];
           R5 = _sbosz::P64;
           R4 = GHC.IO.Handle.hIsWritable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsWritable3_closure;
           P64[Sp - 8] = _sbosz::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbreU() //  [R1]
         { info_tbl: [(cbreU,
                       label: block_cbreU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbreU: // global
           I64[Sp] = block_cbreW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrf9; else goto cbreX;
       ubrf9: // global
           call _cbreW(R1) args: 0, res: 0, upd: 0;
       cbreX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbreW() //  [R1]
         { info_tbl: [(cbreW,
                       label: block_cbreW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbreW: // global
           I64[Sp] = block_cbrf2_info;
           R2 = P64[R1 + 7];
           _sbosK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbosK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrf2() //  []
         { info_tbl: [(cbrf2,
                       label: block_cbrf2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrf2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrfu_srtd" {
     ubrfu_srtd:
         const SboCL_srt+456;
         const 50;
         const 985162418487297;
 },
 GHC.IO.Handle.hIsWritable1_entry() //  [R2]
         { info_tbl: [(cbrfe,
                       label: GHC.IO.Handle.hIsWritable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrfe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrff; else goto cbrfg;
       cbrff: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsWritable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrfg: // global
           I64[Sp - 8] = block_cbreI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrfs; else goto cbreJ;
       ubrfs: // global
           call _cbreI(R1) args: 0, res: 0, upd: 0;
       cbreJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrfv_srtd" {
     ubrfv_srtd:
         const SboCL_srt+456;
         const 49;
         const 422212465065985;
 },
 _cbreI() //  [R1]
         { info_tbl: [(cbreI,
                       label: block_cbreI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbreI: // global
           if (R1 & 7 == 1) goto cbrfb; else goto cbrfc;
       cbrfb: // global
           I64[Sp - 16] = block_cbreN_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbrfc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrfw_srtd" {
     ubrfw_srtd:
         const SboCL_srt+456;
         const 49;
         const 422212465065985;
 },
 _cbreN() //  [R1]
         { info_tbl: [(cbreN,
                       label: block_cbreN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbreN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrfk; else goto cbrfj;
       cbrfk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrfj: // global
           I64[Hp - 16] = io_sbosD_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbreP::P64 = Hp - 15;
           if (R1 == 0) goto cbrfo; else goto cbrfn;
       cbrfo: // global
           R1 = _cbreP::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrfn: // global
           R1 = _cbreP::P64;
           Sp = Sp + 24;
           call io_sbosD_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.182863591 UTC

[section ""data" . GHC.IO.Handle.hIsWritable_closure" {
     GHC.IO.Handle.hIsWritable_closure:
         const GHC.IO.Handle.hIsWritable_info;
         const 0;
 },
 GHC.IO.Handle.hIsWritable_entry() //  [R2]
         { info_tbl: [(cbrfB,
                       label: GHC.IO.Handle.hIsWritable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrfB: // global
           R2 = R2;
           call GHC.IO.Handle.hIsWritable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.183557001 UTC

[section ""cstring" . GHC.IO.Handle.hIsReadable4_bytes" {
     GHC.IO.Handle.hIsReadable4_bytes:
         I8[] [104,73,115,82,101,97,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.184282932 UTC

[section ""data" . GHC.IO.Handle.hIsReadable3_closure" {
     GHC.IO.Handle.hIsReadable3_closure:
         const GHC.IO.Handle.hIsReadable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsReadable3_entry() //  [R1]
         { info_tbl: [(cbrfK,
                       label: GHC.IO.Handle.hIsReadable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrfK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrfL; else goto cbrfM;
       cbrfL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrfM: // global
           (_cbrfH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrfH::I64 == 0) goto cbrfJ; else goto cbrfI;
       cbrfJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrfI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrfH::I64;
           R2 = GHC.IO.Handle.hIsReadable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.18589123 UTC

[section ""data" . GHC.IO.Handle.hIsReadable2_closure" {
     GHC.IO.Handle.hIsReadable2_closure:
         const GHC.IO.Handle.hIsReadable2_info;
         const 0;
 },
 sat_sbotb_entry() //  [R1]
         { info_tbl: [(cbrgd,
                       label: sat_sbotb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrgd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrge; else goto cbrgf;
       cbrge: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrgf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbrg5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubrgq; else goto cbrg6;
       ubrgq: // global
           call _cbrg5(R1) args: 0, res: 0, upd: 0;
       cbrg6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrg5() //  [R1]
         { info_tbl: [(cbrg5,
                       label: block_cbrg5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrg5: // global
           _cbrgc::P64 = R1 & 7;
           if (_cbrgc::P64 == 3) goto cbrgb; else goto ubrgp;
       ubrgp: // global
           if (_cbrgc::P64 == 6) goto cbrgb; else goto cbrg9;
       cbrgb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbrg9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubrgN_srtd" {
     ubrgN_srtd:
         const SboCL_srt+328;
         const 67;
         const 36028797018963969;
         const 4;
 },
 GHC.IO.Handle.hIsReadable2_entry() //  [R2]
         { info_tbl: [(cbrgr,
                       label: GHC.IO.Handle.hIsReadable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrgr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrgs; else goto cbrgt;
       cbrgs: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsReadable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrgt: // global
           I64[Sp - 8] = block_cbrfR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrgM; else goto cbrfS;
       ubrgM: // global
           call _cbrfR(R1) args: 0, res: 0, upd: 0;
       cbrfS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrgO_srtd" {
     ubrgO_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbrfR() //  [R1]
         { info_tbl: [(cbrfR,
                       label: block_cbrfR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrfR: // global
           I64[Sp - 8] = block_cbrfW_info;
           _sbosS::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbosS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrgL; else goto cbrfX;
       ubrgL: // global
           call _cbrfW(R1) args: 0, res: 0, upd: 0;
       cbrfX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrgP_srtd" {
     ubrgP_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbrfW() //  [R1]
         { info_tbl: [(cbrfW,
                       label: block_cbrfW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrfW: // global
           _cbrgJ::P64 = R1 & 7;
           if (_cbrgJ::P64 == 1) goto cbrgE; else goto ubrgK;
       cbrgE: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       ubrgK: // global
           if (_cbrgJ::P64 == 2) goto cbrgI; else goto cbrgx;
       cbrgI: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbrgx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbrgA; else goto cbrgz;
       cbrgA: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrgz: // global
           I64[Hp - 40] = sat_sbotb_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.188613265 UTC

[section ""data" . GHC.IO.Handle.hIsReadable1_closure" {
     GHC.IO.Handle.hIsReadable1_closure:
         const GHC.IO.Handle.hIsReadable1_info;
         const 0;
 },
 section ""relreadonly" . ubrhF_srtd" {
     ubrhF_srtd:
         const SboCL_srt+456;
         const 52;
         const 3377699720527873;
 },
 io_sbotn_entry() //  [R1]
         { info_tbl: [(cbrhb,
                       label: io_sbotn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrhb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrhf; else goto cbrhg;
       cbrhf: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrhg: // global
           I64[Sp - 16] = block_cbrh6_info;
           _sbotj::P64 = P64[R1 + 15];
           R5 = _sbotj::P64;
           R4 = GHC.IO.Handle.hIsReadable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsReadable3_closure;
           P64[Sp - 8] = _sbotj::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrh6() //  [R1]
         { info_tbl: [(cbrh6,
                       label: block_cbrh6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrh6: // global
           I64[Sp] = block_cbrh8_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrhl; else goto cbrh9;
       ubrhl: // global
           call _cbrh8(R1) args: 0, res: 0, upd: 0;
       cbrh9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrh8() //  [R1]
         { info_tbl: [(cbrh8,
                       label: block_cbrh8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrh8: // global
           I64[Sp] = block_cbrhe_info;
           R2 = P64[R1 + 7];
           _sbotu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbotu::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrhe() //  []
         { info_tbl: [(cbrhe,
                       label: block_cbrhe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrhe: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrhG_srtd" {
     ubrhG_srtd:
         const SboCL_srt+456;
         const 53;
         const 7881299347898369;
 },
 GHC.IO.Handle.hIsReadable1_entry() //  [R2]
         { info_tbl: [(cbrhq,
                       label: GHC.IO.Handle.hIsReadable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrhq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrhr; else goto cbrhs;
       cbrhr: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsReadable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrhs: // global
           I64[Sp - 8] = block_cbrgU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrhE; else goto cbrgV;
       ubrhE: // global
           call _cbrgU(R1) args: 0, res: 0, upd: 0;
       cbrgV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrhH_srtd" {
     ubrhH_srtd:
         const SboCL_srt+456;
         const 52;
         const 3377699720527873;
 },
 _cbrgU() //  [R1]
         { info_tbl: [(cbrgU,
                       label: block_cbrgU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrgU: // global
           if (R1 & 7 == 1) goto cbrhn; else goto cbrho;
       cbrhn: // global
           I64[Sp - 16] = block_cbrgZ_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbrho: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrhI_srtd" {
     ubrhI_srtd:
         const SboCL_srt+456;
         const 52;
         const 3377699720527873;
 },
 _cbrgZ() //  [R1]
         { info_tbl: [(cbrgZ,
                       label: block_cbrgZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrgZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrhw; else goto cbrhv;
       cbrhw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrhv: // global
           I64[Hp - 16] = io_sbotn_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrh1::P64 = Hp - 15;
           if (R1 == 0) goto cbrhA; else goto cbrhz;
       cbrhA: // global
           R1 = _cbrh1::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrhz: // global
           R1 = _cbrh1::P64;
           Sp = Sp + 24;
           call io_sbotn_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.190908428 UTC

[section ""data" . GHC.IO.Handle.hIsReadable_closure" {
     GHC.IO.Handle.hIsReadable_closure:
         const GHC.IO.Handle.hIsReadable_info;
         const 0;
 },
 GHC.IO.Handle.hIsReadable_entry() //  [R2]
         { info_tbl: [(cbrhN,
                       label: GHC.IO.Handle.hIsReadable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrhN: // global
           R2 = R2;
           call GHC.IO.Handle.hIsReadable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.191577305 UTC

[section ""cstring" . GHC.IO.Handle.hIsClosed4_bytes" {
     GHC.IO.Handle.hIsClosed4_bytes:
         I8[] [104,73,115,67,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.192281566 UTC

[section ""data" . GHC.IO.Handle.hIsClosed3_closure" {
     GHC.IO.Handle.hIsClosed3_closure:
         const GHC.IO.Handle.hIsClosed3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsClosed3_entry() //  [R1]
         { info_tbl: [(cbrhW,
                       label: GHC.IO.Handle.hIsClosed3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrhW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrhX; else goto cbrhY;
       cbrhX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrhY: // global
           (_cbrhT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrhT::I64 == 0) goto cbrhV; else goto cbrhU;
       cbrhV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrhU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrhT::I64;
           R2 = GHC.IO.Handle.hIsClosed4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.193760404 UTC

[section ""data" . GHC.IO.Handle.hIsClosed2_closure" {
     GHC.IO.Handle.hIsClosed2_closure:
         const GHC.IO.Handle.hIsClosed2_info;
 },
 GHC.IO.Handle.hIsClosed2_entry() //  [R2]
         { info_tbl: [(cbri6,
                       label: GHC.IO.Handle.hIsClosed2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbri6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbri7; else goto cbri8;
       cbri7: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsClosed2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbri8: // global
           I64[Sp - 8] = block_cbri3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubriw; else goto cbri4;
       ubriw: // global
           call _cbri3(R1) args: 0, res: 0, upd: 0;
       cbri4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbri3() //  [R1]
         { info_tbl: [(cbri3,
                       label: block_cbri3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbri3: // global
           I64[Sp - 8] = block_cbrib_info;
           _sbotC::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbotC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubriv; else goto cbrid;
       ubriv: // global
           call _cbrib(R1) args: 0, res: 0, upd: 0;
       cbrid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrib() //  [R1]
         { info_tbl: [(cbrib,
                       label: block_cbrib_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrib: // global
           _sbotC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbriq; else goto cbrij;
       cbriq: // global
           Hp = Hp + 24;
           _sbotT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrit; else goto cbris;
       cbris: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbotC::P64;
           P64[Hp] = GHC.Types.True_closure+2;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbrij: // global
           Hp = Hp + 24;
           _sbotT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrit; else goto cbril;
       cbrit: // global
           HpAlloc = 24;
           R1 = _sbotT::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbril: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbotC::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.196236085 UTC

[section ""data" . GHC.IO.Handle.hIsClosed1_closure" {
     GHC.IO.Handle.hIsClosed1_closure:
         const GHC.IO.Handle.hIsClosed1_info;
         const 0;
 },
 io_sbou4_entry() //  [R1]
         { info_tbl: [(cbriS,
                       label: io_sbou4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbriS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbriW; else goto cbriX;
       cbriW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbriX: // global
           I64[Sp - 16] = block_cbriN_info;
           _sbou0::P64 = P64[R1 + 15];
           R5 = _sbou0::P64;
           R4 = GHC.IO.Handle.hIsClosed2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsClosed3_closure;
           P64[Sp - 8] = _sbou0::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbriN() //  [R1]
         { info_tbl: [(cbriN,
                       label: block_cbriN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbriN: // global
           I64[Sp] = block_cbriP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrj2; else goto cbriQ;
       ubrj2: // global
           call _cbriP(R1) args: 0, res: 0, upd: 0;
       cbriQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbriP() //  [R1]
         { info_tbl: [(cbriP,
                       label: block_cbriP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbriP: // global
           I64[Sp] = block_cbriV_info;
           R2 = P64[R1 + 7];
           _sboub::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboub::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbriV() //  []
         { info_tbl: [(cbriV,
                       label: block_cbriV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbriV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbouk_entry() //  [R1]
         { info_tbl: [(cbrjh,
                       label: io_sbouk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrjh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrjl; else goto cbrjm;
       cbrjl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrjm: // global
           I64[Sp - 16] = block_cbrjc_info;
           _sbouf::P64 = P64[R1 + 15];
           R5 = _sbouf::P64;
           R4 = GHC.IO.Handle.hIsClosed2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsClosed3_closure;
           P64[Sp - 8] = _sbouf::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrjc() //  [R1]
         { info_tbl: [(cbrjc,
                       label: block_cbrjc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrjc: // global
           I64[Sp] = block_cbrje_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrjr; else goto cbrjf;
       ubrjr: // global
           call _cbrje(R1) args: 0, res: 0, upd: 0;
       cbrjf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrje() //  [R1]
         { info_tbl: [(cbrje,
                       label: block_cbrje_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrje: // global
           I64[Sp] = block_cbrjk_info;
           R2 = P64[R1 + 7];
           _sbour::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbour::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrjk() //  []
         { info_tbl: [(cbrjk,
                       label: block_cbrjk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrjk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsClosed1_entry() //  [R2]
         { info_tbl: [(cbrjw,
                       label: GHC.IO.Handle.hIsClosed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrjw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrjx; else goto cbrjy;
       cbrjx: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsClosed1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrjy: // global
           I64[Sp - 8] = block_cbriB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrjP; else goto cbriC;
       ubrjP: // global
           call _cbriB(R1) args: 0, res: 0, upd: 0;
       cbriC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbriB() //  [R1]
         { info_tbl: [(cbriB,
                       label: block_cbriB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbriB: // global
           if (R1 & 7 == 1) goto cbrjt; else goto cbrju;
       cbrjt: // global
           I64[Sp - 16] = block_cbriG_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbrju: // global
           I64[Sp - 16] = block_cbrj5_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbriG() //  [R1]
         { info_tbl: [(cbriG,
                       label: block_cbriG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbriG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrjC; else goto cbrjB;
       cbrjC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrjB: // global
           I64[Hp - 16] = io_sbou4_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbriI::P64 = Hp - 15;
           if (R1 == 0) goto cbrjG; else goto cbrjF;
       cbrjG: // global
           R1 = _cbriI::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrjF: // global
           R1 = _cbriI::P64;
           Sp = Sp + 24;
           call io_sbou4_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrj5() //  [R1]
         { info_tbl: [(cbrj5,
                       label: block_cbrj5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrj5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrjK; else goto cbrjJ;
       cbrjK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrjJ: // global
           I64[Hp - 16] = io_sbouk_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrj7::P64 = Hp - 15;
           if (R1 == 0) goto cbrjO; else goto cbrjN;
       cbrjO: // global
           R1 = _cbrj7::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrjN: // global
           R1 = _cbrj7::P64;
           Sp = Sp + 24;
           call io_sbouk_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.199406714 UTC

[section ""data" . GHC.IO.Handle.hIsClosed_closure" {
     GHC.IO.Handle.hIsClosed_closure:
         const GHC.IO.Handle.hIsClosed_info;
         const 0;
 },
 GHC.IO.Handle.hIsClosed_entry() //  [R2]
         { info_tbl: [(cbrjU,
                       label: GHC.IO.Handle.hIsClosed_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrjU: // global
           R2 = R2;
           call GHC.IO.Handle.hIsClosed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.200085035 UTC

[section ""cstring" . GHC.IO.Handle.hIsOpen4_bytes" {
     GHC.IO.Handle.hIsOpen4_bytes:
         I8[] [104,73,115,79,112,101,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.200798797 UTC

[section ""data" . GHC.IO.Handle.hIsOpen3_closure" {
     GHC.IO.Handle.hIsOpen3_closure:
         const GHC.IO.Handle.hIsOpen3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsOpen3_entry() //  [R1]
         { info_tbl: [(cbrk3,
                       label: GHC.IO.Handle.hIsOpen3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrk3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrk4; else goto cbrk5;
       cbrk4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrk5: // global
           (_cbrk0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrk0::I64 == 0) goto cbrk2; else goto cbrk1;
       cbrk2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrk1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrk0::I64;
           R2 = GHC.IO.Handle.hIsOpen4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.20228994 UTC

[section ""data" . GHC.IO.Handle.hIsOpen2_closure" {
     GHC.IO.Handle.hIsOpen2_closure:
         const GHC.IO.Handle.hIsOpen2_info;
 },
 GHC.IO.Handle.hIsOpen2_entry() //  [R2]
         { info_tbl: [(cbrkd,
                       label: GHC.IO.Handle.hIsOpen2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrkd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrke; else goto cbrkf;
       cbrke: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsOpen2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrkf: // global
           I64[Sp - 8] = block_cbrka_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrkL; else goto cbrkb;
       ubrkL: // global
           call _cbrka(R1) args: 0, res: 0, upd: 0;
       cbrkb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrka() //  [R1]
         { info_tbl: [(cbrka,
                       label: block_cbrka_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrka: // global
           I64[Sp - 8] = block_cbrki_info;
           _sbouw::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbouw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrkK; else goto cbrkk;
       ubrkK: // global
           call _cbrki(R1) args: 0, res: 0, upd: 0;
       cbrkk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrki() //  [R1]
         { info_tbl: [(cbrki,
                       label: block_cbrki_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrki: // global
           _sbouw::P64 = P64[Sp + 8];
           _cbrkI::P64 = R1 & 7;
           if (_cbrkI::P64 == 1) goto cbrkx; else goto ubrkJ;
       cbrkx: // global
           Hp = Hp + 24;
           _sbouN::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrkH; else goto cbrkz;
       cbrkz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbouw::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ubrkJ: // global
           if (_cbrkI::P64 == 2) goto cbrkE; else goto cbrkq;
       cbrkE: // global
           Hp = Hp + 24;
           _sbouN::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrkH; else goto cbrkG;
       cbrkG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbouw::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbrkq: // global
           Hp = Hp + 24;
           _sbouN::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrkH; else goto cbrks;
       cbrkH: // global
           HpAlloc = 24;
           R1 = _sbouN::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrks: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbouw::P64;
           P64[Hp] = GHC.Types.True_closure+2;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.204950549 UTC

[section ""data" . GHC.IO.Handle.hIsOpen1_closure" {
     GHC.IO.Handle.hIsOpen1_closure:
         const GHC.IO.Handle.hIsOpen1_info;
         const 0;
 },
 io_sbouZ_entry() //  [R1]
         { info_tbl: [(cbrl7,
                       label: io_sbouZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrl7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrlb; else goto cbrlc;
       cbrlb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrlc: // global
           I64[Sp - 16] = block_cbrl2_info;
           _sbouV::P64 = P64[R1 + 15];
           R5 = _sbouV::P64;
           R4 = GHC.IO.Handle.hIsOpen2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsOpen3_closure;
           P64[Sp - 8] = _sbouV::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrl2() //  [R1]
         { info_tbl: [(cbrl2,
                       label: block_cbrl2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrl2: // global
           I64[Sp] = block_cbrl4_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrlh; else goto cbrl5;
       ubrlh: // global
           call _cbrl4(R1) args: 0, res: 0, upd: 0;
       cbrl5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrl4() //  [R1]
         { info_tbl: [(cbrl4,
                       label: block_cbrl4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrl4: // global
           I64[Sp] = block_cbrla_info;
           R2 = P64[R1 + 7];
           _sbov6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbov6::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrla() //  []
         { info_tbl: [(cbrla,
                       label: block_cbrla_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrla: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbovf_entry() //  [R1]
         { info_tbl: [(cbrlw,
                       label: io_sbovf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrlw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrlA; else goto cbrlB;
       cbrlA: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrlB: // global
           I64[Sp - 16] = block_cbrlr_info;
           _sbova::P64 = P64[R1 + 15];
           R5 = _sbova::P64;
           R4 = GHC.IO.Handle.hIsOpen2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsOpen3_closure;
           P64[Sp - 8] = _sbova::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrlr() //  [R1]
         { info_tbl: [(cbrlr,
                       label: block_cbrlr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrlr: // global
           I64[Sp] = block_cbrlt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrlG; else goto cbrlu;
       ubrlG: // global
           call _cbrlt(R1) args: 0, res: 0, upd: 0;
       cbrlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrlt() //  [R1]
         { info_tbl: [(cbrlt,
                       label: block_cbrlt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrlt: // global
           I64[Sp] = block_cbrlz_info;
           R2 = P64[R1 + 7];
           _sbovm::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbovm::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrlz() //  []
         { info_tbl: [(cbrlz,
                       label: block_cbrlz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrlz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsOpen1_entry() //  [R2]
         { info_tbl: [(cbrlL,
                       label: GHC.IO.Handle.hIsOpen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrlL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrlM; else goto cbrlN;
       cbrlM: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsOpen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrlN: // global
           I64[Sp - 8] = block_cbrkQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrm4; else goto cbrkR;
       ubrm4: // global
           call _cbrkQ(R1) args: 0, res: 0, upd: 0;
       cbrkR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrkQ() //  [R1]
         { info_tbl: [(cbrkQ,
                       label: block_cbrkQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrkQ: // global
           if (R1 & 7 == 1) goto cbrlI; else goto cbrlJ;
       cbrlI: // global
           I64[Sp - 16] = block_cbrkV_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbrlJ: // global
           I64[Sp - 16] = block_cbrlk_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbrkV() //  [R1]
         { info_tbl: [(cbrkV,
                       label: block_cbrkV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrkV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrlR; else goto cbrlQ;
       cbrlR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrlQ: // global
           I64[Hp - 16] = io_sbouZ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrkX::P64 = Hp - 15;
           if (R1 == 0) goto cbrlV; else goto cbrlU;
       cbrlV: // global
           R1 = _cbrkX::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrlU: // global
           R1 = _cbrkX::P64;
           Sp = Sp + 24;
           call io_sbouZ_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrlk() //  [R1]
         { info_tbl: [(cbrlk,
                       label: block_cbrlk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrlk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrlZ; else goto cbrlY;
       cbrlZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrlY: // global
           I64[Hp - 16] = io_sbovf_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrlm::P64 = Hp - 15;
           if (R1 == 0) goto cbrm3; else goto cbrm2;
       cbrm3: // global
           R1 = _cbrlm::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrm2: // global
           R1 = _cbrlm::P64;
           Sp = Sp + 24;
           call io_sbovf_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.21162275 UTC

[section ""data" . GHC.IO.Handle.hIsOpen_closure" {
     GHC.IO.Handle.hIsOpen_closure:
         const GHC.IO.Handle.hIsOpen_info;
         const 0;
 },
 GHC.IO.Handle.hIsOpen_entry() //  [R2]
         { info_tbl: [(cbrm9,
                       label: GHC.IO.Handle.hIsOpen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrm9: // global
           R2 = R2;
           call GHC.IO.Handle.hIsOpen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.21258555 UTC

[section ""data" . GHC.IO.Handle.hGetPosn1_closure" {
     GHC.IO.Handle.hGetPosn1_closure:
         const GHC.IO.Handle.hGetPosn1_info;
         const 0;
 },
 GHC.IO.Handle.hGetPosn1_entry() //  [R2]
         { info_tbl: [(cbrmj,
                       label: GHC.IO.Handle.hGetPosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrmj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrmk; else goto cbrml;
       cbrmk: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetPosn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrml: // global
           I64[Sp - 16] = block_cbrmg_info;
           R4 = GHC.IO.Handle.hGetPosn2_closure+2;
           R3 = R2;
           _sbovp::P64 = R2;
           R2 = GHC.IO.Handle.hGetPosn3_closure;
           P64[Sp - 8] = _sbovp::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrmg() //  [R1]
         { info_tbl: [(cbrmg,
                       label: block_cbrmg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrmg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrmo; else goto cbrmn;
       cbrmo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrmn: // global
           I64[Hp - 16] = GHC.IO.Handle.HandlePosn_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.21380182 UTC

[section ""data" . GHC.IO.Handle.hGetPosn_closure" {
     GHC.IO.Handle.hGetPosn_closure:
         const GHC.IO.Handle.hGetPosn_info;
         const 0;
 },
 GHC.IO.Handle.hGetPosn_entry() //  [R2]
         { info_tbl: [(cbrmt,
                       label: GHC.IO.Handle.hGetPosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrmt: // global
           R2 = R2;
           call GHC.IO.Handle.hGetPosn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.214478327 UTC

[section ""cstring" . GHC.IO.Handle.hClose3_bytes" {
     GHC.IO.Handle.hClose3_bytes:
         I8[] [104,67,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.215163059 UTC

[section ""data" . GHC.IO.Handle.hClose2_closure" {
     GHC.IO.Handle.hClose2_closure:
         const GHC.IO.Handle.hClose2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hClose2_entry() //  [R1]
         { info_tbl: [(cbrmC,
                       label: GHC.IO.Handle.hClose2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrmC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrmD; else goto cbrmE;
       cbrmD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrmE: // global
           (_cbrmz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrmz::I64 == 0) goto cbrmB; else goto cbrmA;
       cbrmB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrmA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrmz::I64;
           R2 = GHC.IO.Handle.hClose3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.216934091 UTC

[section ""data" . GHC.IO.Handle.$wlvl_closure" {
     GHC.IO.Handle.$wlvl_closure:
         const GHC.IO.Handle.$wlvl_info;
         const 0;
 },
 sat_sbovK_entry() //  [R1]
         { info_tbl: [(cbrmY,
                       label: sat_sbovK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrmY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbrmZ; else goto cbrn0;
       cbrmZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrn0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbrmR_info;
           _sbovv::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbovv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubrnr; else goto cbrmS;
       ubrnr: // global
           call _cbrmR(R1) args: 0, res: 0, upd: 0;
       cbrmS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrmR() //  [R1]
         { info_tbl: [(cbrmR,
                       label: block_cbrmR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrmR: // global
           if (R1 & 7 == 1) goto cbrmV; else goto cbrmW;
       cbrmV: // global
           _sbovv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbrn3_info;
           R1 = _sbovv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubrnq; else goto cbrn5;
       ubrnq: // global
           call _cbrn3(R1) args: 0, res: 0, upd: 0;
       cbrn5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbrmW: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cbrn3() //  [R1]
         { info_tbl: [(cbrn3,
                       label: block_cbrn3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrn3: // global
           if (R1 & 7 == 1) goto cbrnb; else goto cbrni;
       cbrnb: // global
           Hp = Hp + 16;
           _sbovD::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrnl; else goto cbrnd;
       cbrnd: // global
           _sbovE::P64 = P64[_sbovD::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbovE::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbrni: // global
           Hp = Hp + 16;
           _sbovD::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrnl; else goto cbrnk;
       cbrnl: // global
           HpAlloc = 16;
           R1 = _sbovD::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbrnk: // global
           _sbovG::P64 = P64[_sbovD::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbovG::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbovM_entry() //  [R1]
         { info_tbl: [(cbrnu,
                       label: sat_sbovM_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrnu: // global
           _sbovM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrnv; else goto cbrnw;
       cbrnw: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbrny; else goto cbrnx;
       cbrny: // global
           HpAlloc = 104;
           goto cbrnv;
       cbrnv: // global
           R1 = _sbovM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrnx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbovM::P64;
           _sbovv::P64 = P64[_sbovM::P64 + 16];
           _sbovw::P64 = P64[_sbovM::P64 + 24];
           _sbovx::P64 = P64[_sbovM::P64 + 32];
           _sbovy::P64 = P64[_sbovM::P64 + 40];
           _sbovz::P64 = P64[_sbovM::P64 + 48];
           I64[Hp - 96] = sat_sbovK_info;
           P64[Hp - 80] = _sbovv::P64;
           P64[Hp - 72] = _sbovz::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbovv::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sbovw::P64;
           P64[Hp - 24] = GHC.IO.Handle.hClose2_closure;
           P64[Hp - 16] = _sbovx::P64;
           P64[Hp - 8] = _sbovy::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.$wlvl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbrnz,
                       label: GHC.IO.Handle.$wlvl_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrnz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbrnD; else goto cbrnC;
       cbrnD: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$wlvl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrnC: // global
           I64[Hp - 48] = sat_sbovM_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.220699092 UTC

[section ""data" . GHC.IO.Handle.hClose1_closure" {
     GHC.IO.Handle.hClose1_closure:
         const GHC.IO.Handle.hClose1_info;
         const 0;
 },
 section ""relreadonly" . ubrpC_srtd" {
     ubrpC_srtd:
         const SboCL_srt+240;
         const 94;
         const 54043195528445953;
         const 973078528;
 },
 GHC.IO.Handle.hClose1_entry() //  [R2]
         { info_tbl: [(cbrnP,
                       label: GHC.IO.Handle.hClose1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrnP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbrnQ; else goto cbrnR;
       cbrnQ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hClose1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrnR: // global
           I64[Sp - 8] = block_cbrnI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrpw; else goto cbrnJ;
       ubrpw: // global
           call _cbrnI(R1) args: 0, res: 0, upd: 0;
       cbrnJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrpD_srtd" {
     ubrpD_srtd:
         const SboCL_srt+240;
         const 93;
         const 54043195528445953;
         const 436207616;
 },
 _cbrnI() //  [R1]
         { info_tbl: [(cbrnI,
                       label: block_cbrnI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrnI: // global
           if (R1 & 7 == 1) goto cbrnM; else goto cbrnN;
       cbrnM: // global
           I64[Sp - 8] = block_cbrnU_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
       cbrnN: // global
           I64[Sp - 16] = block_cbroD_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[R1 + 14];
           R3 = R1;
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrpE_srtd" {
     ubrpE_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbrnU() //  [R1]
         { info_tbl: [(cbrnU,
                       label: block_cbrnU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrnU: // global
           I64[Sp] = block_cbrnW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrpx; else goto cbrnZ;
       ubrpx: // global
           call _cbrnW(R1) args: 0, res: 0, upd: 0;
       cbrnZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrpF_srtd" {
     ubrpF_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbrnW() //  [R1]
         { info_tbl: [(cbrnW,
                       label: block_cbrnW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrnW: // global
           if (R1 & 7 == 1) goto ubrpv; else goto cbrof;
       ubrpv: // global
           Sp = Sp + 16;
           call _cbroU() args: 0, res: 0, upd: 0;
       cbrof: // global
           I64[Sp] = block_cbro8_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubrpy; else goto cbro9;
       ubrpy: // global
           call _cbro8(R1) args: 0, res: 0, upd: 0;
       cbro9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrpG_srtd" {
     ubrpG_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbro8() //  [R1]
         { info_tbl: [(cbro8,
                       label: block_cbro8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbro8: // global
           I64[Sp - 16] = block_cbrod_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrpH_srtd" {
     ubrpH_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbrod() //  [R1]
         { info_tbl: [(cbrod,
                       label: block_cbrod_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrod: // global
           I64[Sp] = block_cbrok_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrok() //  [R1]
         { info_tbl: [(cbrok,
                       label: block_cbrok_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrok: // global
           if (R1 & 7 == 1) goto cbror; else goto cbrow;
       cbror: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbrow: // global
           I64[Sp + 16] = block_cbrou_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrou() //  [R1]
         { info_tbl: [(cbrou,
                       label: block_cbrou_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrou: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 39];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$wlvl_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrpI_srtd" {
     ubrpI_srtd:
         const SboCL_srt+240;
         const 93;
         const 54043195528445953;
         const 436207616;
 },
 _cbroD() //  [R1]
         { info_tbl: [(cbroD,
                       label: block_cbroD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbroD: // global
           I64[Sp] = block_cbroF_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrpJ_srtd" {
     ubrpJ_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbroF() //  [R1]
         { info_tbl: [(cbroF,
                       label: block_cbroF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbroF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbroO; else goto cbroN;
       cbroO: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbroN: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 38;
           I64[Sp + 8] = block_cbroJ_info;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call Data.Maybe.catMaybes1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrpK_srtd" {
     ubrpK_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbroJ() //  [R1]
         { info_tbl: [(cbroJ,
                       label: block_cbroJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbroJ: // global
           if (R1 & 7 == 1) goto ubrpu; else goto cbrp4;
       ubrpu: // global
           Sp = Sp + 16;
           call _cbroU() args: 0, res: 0, upd: 0;
       cbrp4: // global
           I64[Sp] = block_cbroX_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubrpA; else goto cbroY;
       ubrpA: // global
           call _cbroX(R1) args: 0, res: 0, upd: 0;
       cbroY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbroU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbroU: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubrpL_srtd" {
     ubrpL_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbroX() //  [R1]
         { info_tbl: [(cbroX,
                       label: block_cbroX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbroX: // global
           I64[Sp - 16] = block_cbrp2_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubrpM_srtd" {
     ubrpM_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbrp2() //  [R1]
         { info_tbl: [(cbrp2,
                       label: block_cbrp2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrp2: // global
           I64[Sp] = block_cbrp9_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrp9() //  [R1]
         { info_tbl: [(cbrp9,
                       label: block_cbrp9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrp9: // global
           if (R1 & 7 == 1) goto cbrpg; else goto cbrpl;
       cbrpg: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbrpl: // global
           I64[Sp + 16] = block_cbrpj_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrpj() //  [R1]
         { info_tbl: [(cbrpj,
                       label: block_cbrpj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrpj: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 39];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$wlvl_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.224789607 UTC

[section ""data" . GHC.IO.Handle.hClose_closure" {
     GHC.IO.Handle.hClose_closure:
         const GHC.IO.Handle.hClose_info;
         const 0;
 },
 GHC.IO.Handle.hClose_entry() //  [R2]
         { info_tbl: [(cbrpR,
                       label: GHC.IO.Handle.hClose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrpR: // global
           R2 = R2;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.225499728 UTC

[section ""data" . lvl28_rbnXa_closure" {
     lvl28_rbnXa_closure:
         const GHC.Types.C#_con_info;
         const 123;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.226035583 UTC

[section ""data" . lvl29_rbnXb_closure" {
     lvl29_rbnXb_closure:
         const GHC.Types.C#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.226578725 UTC

[section ""cstring" . lvl30_rbnXc_bytes" {
     lvl30_rbnXc_bytes:
         I8[] [100,117,112,108,101,120,32,40,114,101,97,100,45,119,114,105,116,101,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.227261999 UTC

[section ""data" . lvl31_rbnXd_closure" {
     lvl31_rbnXd_closure:
         const lvl31_rbnXd_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_rbnXd_entry() //  [R1]
         { info_tbl: [(cbrq0,
                       label: lvl31_rbnXd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrq0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrq1; else goto cbrq2;
       cbrq1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrq2: // global
           (_cbrpX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrpX::I64 == 0) goto cbrpZ; else goto cbrpY;
       cbrpZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrpY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrpX::I64;
           R2 = lvl30_rbnXc_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.228111343 UTC

[section ""cstring" . lvl32_rbnXe_bytes" {
     lvl32_rbnXe_bytes:
         I8[] [110,111,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.228822114 UTC

[section ""data" . lvl33_rbnXf_closure" {
     lvl33_rbnXf_closure:
         const lvl33_rbnXf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl33_rbnXf_entry() //  [R1]
         { info_tbl: [(cbrq9,
                       label: lvl33_rbnXf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrq9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrqa; else goto cbrqb;
       cbrqa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrqb: // global
           (_cbrq6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrq6::I64 == 0) goto cbrq8; else goto cbrq7;
       cbrq8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrq7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrq6::I64;
           R2 = lvl32_rbnXe_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.229866377 UTC

[section ""cstring" . lvl34_rbnXg_bytes" {
     lvl34_rbnXg_bytes:
         I8[] [108,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.23056538 UTC

[section ""data" . lvl35_rbnXh_closure" {
     lvl35_rbnXh_closure:
         const lvl35_rbnXh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_rbnXh_entry() //  [R1]
         { info_tbl: [(cbrqi,
                       label: lvl35_rbnXh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrqi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrqj; else goto cbrqk;
       cbrqj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrqk: // global
           (_cbrqf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrqf::I64 == 0) goto cbrqh; else goto cbrqg;
       cbrqh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrqg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrqf::I64;
           R2 = lvl34_rbnXg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.231390651 UTC

[section ""cstring" . lvl36_rbnXi_bytes" {
     lvl36_rbnXi_bytes:
         I8[] [115,104,111,119,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.232061622 UTC

[section ""data" . lvl37_rbnXj_closure" {
     lvl37_rbnXj_closure:
         const lvl37_rbnXj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_rbnXj_entry() //  [R1]
         { info_tbl: [(cbrqr,
                       label: lvl37_rbnXj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrqr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrqs; else goto cbrqt;
       cbrqs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrqt: // global
           (_cbrqo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrqo::I64 == 0) goto cbrqq; else goto cbrqp;
       cbrqq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrqp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrqo::I64;
           R2 = lvl36_rbnXi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.232925275 UTC

[section ""cstring" . lvl38_rbnXk_bytes" {
     lvl38_rbnXk_bytes:
         I8[] [108,111,99,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.2334241 UTC

[section ""cstring" . lvl39_rbnXl_bytes" {
     lvl39_rbnXl_bytes:
         I8[] [116,121,112,101,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.233923084 UTC

[section ""cstring" . lvl40_rbnXm_bytes" {
     lvl40_rbnXm_bytes:
         I8[] [98,117,102,102,101,114,105,110,103,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.234429214 UTC

[section ""cstring" . lvl41_rbnXn_bytes" {
     lvl41_rbnXn_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.235129989 UTC

[section ""data" . lvl42_rbnXo_closure" {
     lvl42_rbnXo_closure:
         const lvl42_rbnXo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rbnXo_entry() //  [R1]
         { info_tbl: [(cbrqA,
                       label: lvl42_rbnXo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrqA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrqB; else goto cbrqC;
       cbrqB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrqC: // global
           (_cbrqx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrqx::I64 == 0) goto cbrqz; else goto cbrqy;
       cbrqz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrqy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrqx::I64;
           R2 = lvl41_rbnXn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.236132983 UTC

[section ""data" . lvl43_rbnXp_closure" {
     lvl43_rbnXp_closure:
         const lvl43_rbnXp_info;
         const 0;
         const 0;
         const 0;
 },
 lvl43_rbnXp_entry() //  [R1]
         { info_tbl: [(cbrqJ,
                       label: lvl43_rbnXp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrqJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrqK; else goto cbrqL;
       cbrqK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrqL: // global
           (_cbrqG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrqG::I64 == 0) goto cbrqI; else goto cbrqH;
       cbrqI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrqH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrqG::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = lvl33_rbnXf_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.237204081 UTC

[section ""data" . lvl44_rbnXq_closure" {
     lvl44_rbnXq_closure:
         const lvl44_rbnXq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rbnXq_entry() //  [R1]
         { info_tbl: [(cbrqS,
                       label: lvl44_rbnXq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrqS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrqT; else goto cbrqU;
       cbrqT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrqU: // global
           (_cbrqP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrqP::I64 == 0) goto cbrqR; else goto cbrqQ;
       cbrqR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrqQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrqP::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = lvl35_rbnXh_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.23813637 UTC

[section ""cstring" . lvl45_rbnXr_bytes" {
     lvl45_rbnXr_bytes:
         I8[] [98,108,111,99,107,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.238674282 UTC

[section ""data" . lvl46_rbnXs_closure" {
     lvl46_rbnXs_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const lvl42_rbnXo_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.23941332 UTC

[section ""data" . lvl47_rbnXt_closure" {
     lvl47_rbnXt_closure:
         const lvl47_rbnXt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl47_rbnXt_entry() //  [R1]
         { info_tbl: [(cbrr1,
                       label: lvl47_rbnXt_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrr1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrr2; else goto cbrr3;
       cbrr2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrr3: // global
           (_cbrqY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrqY::I64 == 0) goto cbrr0; else goto cbrqZ;
       cbrr0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrqZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrqY::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.245254869 UTC

[section ""data" . GHC.IO.Handle.hShow2_closure" {
     GHC.IO.Handle.hShow2_closure:
         const GHC.IO.Handle.hShow2_info;
         const 0;
 },
 sat_sboxg_entry() //  [R1]
         { info_tbl: [(cbrs9,
                       label: sat_sboxg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrs9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbrsf; else goto cbrsg;
       cbrsf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrsg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbrs1_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _cbrs1() //  []
         { info_tbl: [(cbrs1,
                       label: block_cbrs1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrs1: // global
           _sbox5::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cbrs6_info;
           R1 = _sbox5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubrsn; else goto cbrs7;
       ubrsn: // global
           call _cbrs6(R1) args: 0, res: 0, upd: 0;
       cbrs7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrs6() //  [R1]
         { info_tbl: [(cbrs6,
                       label: block_cbrs6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrs6: // global
           I64[Sp] = block_cbrsc_info;
           R4 = lvl46_rbnXs_closure+2;
           R3 = I64[R1 + 31];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbrsc() //  [R1, R2]
         { info_tbl: [(cbrsc,
                       label: block_cbrsc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrsc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrsm; else goto cbrsl;
       cbrsm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbrsl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxo_entry() //  [R1]
         { info_tbl: [(cbrsx,
                       label: sat_sboxo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrsx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrsD; else goto cbrsE;
       cbrsD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrsE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbrsu_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubrsJ; else goto cbrsv;
       ubrsJ: // global
           call _cbrsu(R1) args: 0, res: 0, upd: 0;
       cbrsv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrsu() //  [R1]
         { info_tbl: [(cbrsu,
                       label: block_cbrsu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrsu: // global
           I64[Sp] = block_cbrsA_info;
           R4 = lvl46_rbnXs_closure+2;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbrsA() //  [R1, R2]
         { info_tbl: [(cbrsA,
                       label: block_cbrsA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrsA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrsI; else goto cbrsH;
       cbrsI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbrsH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxq_entry() //  [R1]
         { info_tbl: [(cbrsP,
                       label: sat_sboxq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrsP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbrsQ; else goto cbrsR;
       cbrsQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrsR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbrrL_info;
           _sbowP::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbowP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubrtb; else goto cbrrM;
       ubrtb: // global
           call _cbrrL(R1) args: 0, res: 0, upd: 0;
       cbrrM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrrL() //  [R1]
         { info_tbl: [(cbrrL,
                       label: block_cbrrL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrrL: // global
           _cbrsO::P64 = R1 & 7;
           if (_cbrsO::P64 < 3) goto ubrt9; else goto cbrsN;
       ubrt9: // global
           if (_cbrsO::P64 < 2) goto cbrsL; else goto cbrsM;
       cbrsL: // global
           R1 = lvl43_rbnXp_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbrsM: // global
           R1 = lvl44_rbnXq_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbrsN: // global
           I64[Sp] = block_cbrrS_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto ubrta; else goto cbrrT;
       ubrta: // global
           call _cbrrS(R1) args: 0, res: 0, upd: 0;
       cbrrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrrS() //  [R1]
         { info_tbl: [(cbrrS,
                       label: block_cbrrS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrrS: // global
           if (R1 & 7 == 1) goto cbrsZ; else goto cbrt4;
       cbrsZ: // global
           Hp = Hp + 48;
           _sbox1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrt7; else goto cbrt1;
       cbrt1: // global
           I64[Hp - 40] = sat_sboxg_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = lvl45_rbnXr_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cbrt4: // global
           Hp = Hp + 48;
           _sbox1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrt7; else goto cbrt6;
       cbrt7: // global
           HpAlloc = 48;
           R1 = _sbox1::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbrt6: // global
           _sboxi::P64 = P64[_sbox1::P64 + 6];
           I64[Hp - 40] = sat_sboxo_info;
           P64[Hp - 24] = _sboxi::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = lvl45_rbnXr_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 karg_sbowY_entry() //  [R1]
         { info_tbl: [(cbrtc,
                       label: karg_sbowY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrtc: // global
           _sbowY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrtd; else goto cbrte;
       cbrte: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrtg; else goto cbrtf;
       cbrtg: // global
           HpAlloc = 32;
           goto cbrtd;
       cbrtd: // global
           R1 = _sbowY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrtf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbowY::P64;
           _sbowN::P64 = P64[_sbowY::P64 + 16];
           _sbowP::P64 = P64[_sbowY::P64 + 24];
           I64[Hp - 24] = sat_sboxq_info;
           P64[Hp - 8] = _sbowN::P64;
           P64[Hp] = _sbowP::P64;
           R3 = Hp - 24;
           R2 = lvl40_rbnXm_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxz_entry() //  [R1]
         { info_tbl: [(cbrto,
                       label: sat_sboxz_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrto: // global
           _sboxz::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbrtp; else goto cbrtq;
       cbrtq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrts; else goto cbrtr;
       cbrts: // global
           HpAlloc = 32;
           goto cbrtp;
       cbrtp: // global
           R1 = _sboxz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrtr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sboxz::P64;
           _sbowA::P64 = P64[_sboxz::P64 + 16];
           _sbowN::P64 = P64[_sboxz::P64 + 24];
           _sbowP::P64 = P64[_sboxz::P64 + 32];
           _sbowX::P64 = P64[_sboxz::P64 + 40];
           I64[Hp - 24] = karg_sbowY_info;
           P64[Hp - 8] = _sbowN::P64;
           P64[Hp] = _sbowP::P64;
           I64[Sp - 40] = block_cbrth_info;
           R1 = _sbowA::P64;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sbowX::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubruk; else goto cbrti;
       ubruk: // global
           call _cbrth(R1) args: 0, res: 0, upd: 0;
       cbrti: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrth() //  [R1]
         { info_tbl: [(cbrth,
                       label: block_cbrth_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrth: // global
           if (R1 & 7 == 1) goto cbrtl; else goto cbrtm;
       cbrtl: // global
           I64[Sp] = block_cbrtv_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubruj; else goto cbrtx;
       ubruj: // global
           call _cbrtv(R1) args: 0, res: 0, upd: 0;
       cbrtx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbrtm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrue; else goto cbrud;
       cbrue: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbrud: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 14;
           R2 = lvl31_rbnXd_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 _cbrtv() //  [R1]
         { info_tbl: [(cbrtv,
                       label: block_cbrtv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrtv: // global
           _cbrrD::P64 = P64[Sp + 8];
           _cbruf::P64 = R1 & 7;
           if (_cbruf::P64 < 5) goto ubrug; else goto ubrui;
       ubrug: // global
           if (_cbruf::P64 < 4) goto ubruh; else goto cbrtR;
       ubruh: // global
           if (_cbruf::P64 < 3) goto cbrtD; else goto cbrtK;
       cbrtD: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbru8; else goto cbrtF;
       cbrtF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbrrD::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbrtK: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbru8; else goto cbrtM;
       cbrtM: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbrrD::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbrtR: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbru8; else goto cbrtT;
       cbrtT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbrrD::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       ubrui: // global
           if (_cbruf::P64 < 6) goto cbrtY; else goto cbru5;
       cbrtY: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbru8; else goto cbru0;
       cbru0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbrrD::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbru5: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbru8; else goto cbru7;
       cbru8: // global
           HpAlloc = 24;
           R1 = _sboxs::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbru7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbrrD::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxA_entry() //  [R1]
         { info_tbl: [(cbrul,
                       label: sat_sboxA_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrul: // global
           _sboxA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrum; else goto cbrun;
       cbrun: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbrup; else goto cbruo;
       cbrup: // global
           HpAlloc = 48;
           goto cbrum;
       cbrum: // global
           R1 = _sboxA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbruo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sboxA::P64;
           _sbowA::P64 = P64[_sboxA::P64 + 16];
           _sbowN::P64 = P64[_sboxA::P64 + 24];
           _sbowP::P64 = P64[_sboxA::P64 + 32];
           _sbowX::P64 = P64[_sboxA::P64 + 40];
           I64[Hp - 40] = sat_sboxz_info;
           P64[Hp - 24] = _sbowA::P64;
           P64[Hp - 16] = _sbowN::P64;
           P64[Hp - 8] = _sbowP::P64;
           P64[Hp] = _sbowX::P64;
           R3 = Hp - 40;
           R2 = lvl39_rbnXl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxC_entry() //  [R1]
         { info_tbl: [(cbrur,
                       label: sat_sboxC_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrur: // global
           _sboxC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrus; else goto cbrut;
       cbrut: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbruv; else goto cbruu;
       cbruv: // global
           HpAlloc = 72;
           goto cbrus;
       cbrus: // global
           R1 = _sboxC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbruu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sboxC::P64;
           _sbowz::P64 = P64[_sboxC::P64 + 16];
           _sbowA::P64 = P64[_sboxC::P64 + 24];
           _sbowN::P64 = P64[_sboxC::P64 + 32];
           _sbowP::P64 = P64[_sboxC::P64 + 40];
           _sbowX::P64 = P64[_sboxC::P64 + 48];
           I64[Hp - 64] = sat_sboxA_info;
           P64[Hp - 48] = _sbowA::P64;
           P64[Hp - 40] = _sbowN::P64;
           P64[Hp - 32] = _sbowP::P64;
           P64[Hp - 24] = _sbowX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _sbowz::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxD_entry() //  [R1]
         { info_tbl: [(cbruw,
                       label: sat_sboxD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbruw: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbrux; else goto cbruy;
       cbrux: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbruy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbrrh_info;
           _sbowz::P64 = P64[R1 + 16];
           _sbowA::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbowz::P64;
           P64[Sp - 24] = _sbowA::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubruL; else goto cbrri;
       ubruL: // global
           call _cbrrh(R1) args: 0, res: 0, upd: 0;
       cbrri: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrrh() //  [R1]
         { info_tbl: [(cbrrh,
                       label: block_cbrrh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrrh: // global
           I64[Sp - 16] = block_cbrrm_info;
           _sbowN::P64 = P64[R1 + 55];
           _sbowP::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _sbowP::P64;
           P64[Sp] = _sbowN::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubruK; else goto cbrrn;
       ubruK: // global
           call _cbrrm(R1) args: 0, res: 0, upd: 0;
       cbrrn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrrm() //  [R1]
         { info_tbl: [(cbrrm,
                       label: block_cbrrm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrrm: // global
           if (R1 & 7 == 1) goto cbruI; else goto cbruB;
       cbruI: // global
           R1 = lvl47_rbnXt_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbruB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbruE; else goto cbruD;
       cbruE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbruD: // global
           I64[Hp - 48] = sat_sboxC_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R3 = Hp - 48;
           R2 = lvl38_rbnXk_bytes;
           Sp = Sp + 40;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 act_sbowD_entry() //  [R1, R2]
         { info_tbl: [(cbruN,
                       label: act_sbowD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbruN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbruR; else goto cbruQ;
       cbruR: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbruQ: // global
           _sbowz::P64 = P64[R1 + 6];
           _sbowA::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sboxD_info;
           P64[Hp - 40] = _sbowz::P64;
           P64[Hp - 32] = _sbowA::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl28_rbnXa_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sboxT_entry() //  [R1, R2]
         { info_tbl: [(cbrvc,
                       label: sat_sboxT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrvd; else goto cbrve;
       cbrvd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrve: // global
           I64[Sp - 16] = block_cbrv9_info;
           _sboxN::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sboxN::P64;
           Sp = Sp - 16;
           call act_sbowD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrv9() //  [R1]
         { info_tbl: [(cbrv9,
                       label: block_cbrv9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrv9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrvh; else goto cbrvg;
       cbrvh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrvg: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sboxL_entry() //  [R1]
         { info_tbl: [(cbrvn,
                       label: io_sboxL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvn: // global
           _sboxL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrvr; else goto cbrvs;
       cbrvs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbrvu; else goto cbrvt;
       cbrvu: // global
           HpAlloc = 16;
           goto cbrvr;
       cbrvr: // global
           R1 = _sboxL::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrvt: // global
           _sbowD::P64 = P64[_sboxL::P64 + 7];
           _sboxF::P64 = P64[_sboxL::P64 + 15];
           _sboxH::P64 = P64[_sboxL::P64 + 23];
           I64[Hp - 8] = sat_sboxT_info;
           P64[Hp] = _sbowD::P64;
           I64[Sp - 16] = block_cbrvi_info;
           R5 = _sboxH::P64;
           R4 = Hp - 6;
           R3 = _sboxF::P64;
           R2 = lvl37_rbnXj_closure;
           P64[Sp - 8] = _sboxH::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrvi() //  [R1]
         { info_tbl: [(cbrvi,
                       label: block_cbrvi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvi: // global
           I64[Sp] = block_cbrvk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrvz; else goto cbrvl;
       ubrvz: // global
           call _cbrvk(R1) args: 0, res: 0, upd: 0;
       cbrvl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrvk() //  [R1]
         { info_tbl: [(cbrvk,
                       label: block_cbrvk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvk: // global
           I64[Sp] = block_cbrvq_info;
           R2 = P64[R1 + 7];
           _sboxZ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboxZ::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrvq() //  []
         { info_tbl: [(cbrvq,
                       label: block_cbrvq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sboyg_entry() //  [R1, R2]
         { info_tbl: [(cbrvR,
                       label: sat_sboyg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrvS; else goto cbrvT;
       cbrvS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrvT: // global
           I64[Sp - 16] = block_cbrvO_info;
           _sboya::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sboya::P64;
           Sp = Sp - 16;
           call act_sbowD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrvO() //  [R1]
         { info_tbl: [(cbrvO,
                       label: block_cbrvO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrvW; else goto cbrvV;
       cbrvW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrvV: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sboy8_entry() //  [R1]
         { info_tbl: [(cbrw2,
                       label: io_sboy8_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrw2: // global
           _sboy8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrw6; else goto cbrw7;
       cbrw7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbrw9; else goto cbrw8;
       cbrw9: // global
           HpAlloc = 16;
           goto cbrw6;
       cbrw6: // global
           R1 = _sboy8::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrw8: // global
           _sbowD::P64 = P64[_sboy8::P64 + 7];
           _sboxF::P64 = P64[_sboy8::P64 + 15];
           _sboy3::P64 = P64[_sboy8::P64 + 23];
           I64[Hp - 8] = sat_sboyg_info;
           P64[Hp] = _sbowD::P64;
           I64[Sp - 16] = block_cbrvX_info;
           R5 = _sboy3::P64;
           R4 = Hp - 6;
           R3 = _sboxF::P64;
           R2 = lvl37_rbnXj_closure;
           P64[Sp - 8] = _sboy3::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrvX() //  [R1]
         { info_tbl: [(cbrvX,
                       label: block_cbrvX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvX: // global
           I64[Sp] = block_cbrvZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrwe; else goto cbrw0;
       ubrwe: // global
           call _cbrvZ(R1) args: 0, res: 0, upd: 0;
       cbrw0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrvZ() //  [R1]
         { info_tbl: [(cbrvZ,
                       label: block_cbrvZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvZ: // global
           I64[Sp] = block_cbrw5_info;
           R2 = P64[R1 + 7];
           _sboym::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboym::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrw5() //  []
         { info_tbl: [(cbrw5,
                       label: block_cbrw5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrw5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hShow2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbrwj,
                       label: GHC.IO.Handle.hShow2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrwj: // global
           _sbowB::P64 = R4;
           _sbowA::P64 = R3;
           _sbowz::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbrwk; else goto cbrwl;
       cbrwl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrwn; else goto cbrwm;
       cbrwn: // global
           HpAlloc = 24;
           goto cbrwk;
       cbrwk: // global
           R4 = _sbowB::P64;
           R3 = _sbowA::P64;
           R2 = _sbowz::P64;
           R1 = GHC.IO.Handle.hShow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrwm: // global
           I64[Hp - 16] = act_sbowD_info;
           P64[Hp - 8] = _sbowz::P64;
           P64[Hp] = _sbowA::P64;
           I64[Sp - 16] = block_cbruS_info;
           R1 = _sbowB::P64;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubrwE; else goto cbruT;
       ubrwE: // global
           call _cbruS(R1) args: 0, res: 0, upd: 0;
       cbruT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbruS() //  [R1]
         { info_tbl: [(cbruS,
                       label: block_cbruS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbruS: // global
           if (R1 & 7 == 1) goto cbrwg; else goto cbrwh;
       cbrwg: // global
           I64[Sp - 16] = block_cbruX_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbrwh: // global
           I64[Sp - 16] = block_cbrvC_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbruX() //  [R1]
         { info_tbl: [(cbruX,
                       label: block_cbruX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbruX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrwr; else goto cbrwq;
       cbrwr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrwq: // global
           I64[Hp - 24] = io_sboxL_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbruZ::P64 = Hp - 23;
           if (R1 == 0) goto cbrwv; else goto cbrwu;
       cbrwv: // global
           R1 = _cbruZ::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrwu: // global
           R1 = _cbruZ::P64;
           Sp = Sp + 32;
           call io_sboxL_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrvC() //  [R1]
         { info_tbl: [(cbrvC,
                       label: block_cbrvC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrvC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrwz; else goto cbrwy;
       cbrwz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrwy: // global
           I64[Hp - 24] = io_sboy8_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrvE::P64 = Hp - 23;
           if (R1 == 0) goto cbrwD; else goto cbrwC;
       cbrwD: // global
           R1 = _cbrvE::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrwC: // global
           R1 = _cbrvE::P64;
           Sp = Sp + 32;
           call io_sboy8_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.257027288 UTC

[section ""data" . GHC.IO.Handle.hShow1_closure" {
     GHC.IO.Handle.hShow1_closure:
         const GHC.IO.Handle.hShow1_info;
         const 0;
 },
 GHC.IO.Handle.hShow1_entry() //  [R2]
         { info_tbl: [(cbrwQ,
                       label: GHC.IO.Handle.hShow1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrwQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbrwR; else goto cbrwS;
       cbrwR: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hShow1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrwS: // global
           I64[Sp - 8] = block_cbrwJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrwZ; else goto cbrwK;
       ubrwZ: // global
           call _cbrwJ(R1) args: 0, res: 0, upd: 0;
       cbrwK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrwJ() //  [R1]
         { info_tbl: [(cbrwJ,
                       label: block_cbrwJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrwJ: // global
           if (R1 & 7 == 1) goto cbrwN; else goto cbrwO;
       cbrwN: // global
           R4 = R1;
           R3 = GHC.Types.False_closure+1;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.hShow2_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cbrwO: // global
           R4 = R1;
           R3 = GHC.Types.True_closure+2;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.IO.Handle.hShow2_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.258250253 UTC

[section ""data" . GHC.IO.Handle.hShow_closure" {
     GHC.IO.Handle.hShow_closure:
         const GHC.IO.Handle.hShow_info;
         const 0;
 },
 GHC.IO.Handle.hShow_entry() //  [R2]
         { info_tbl: [(cbrx4,
                       label: GHC.IO.Handle.hShow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrx4: // global
           R2 = R2;
           call GHC.IO.Handle.hShow1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.259143107 UTC

[section ""data" . GHC.IO.Handle.HandlePosn_closure" {
     GHC.IO.Handle.HandlePosn_closure:
         const GHC.IO.Handle.HandlePosn_info;
 },
 GHC.IO.Handle.HandlePosn_entry() //  [R2, R3]
         { info_tbl: [(cbrxc,
                       label: GHC.IO.Handle.HandlePosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrxc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrxg; else goto cbrxf;
       cbrxg: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.HandlePosn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrxf: // global
           I64[Hp - 16] = GHC.IO.Handle.HandlePosn_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.260039878 UTC

[GHC.IO.Handle.HandlePosn_con_entry() //  [R1]
         { info_tbl: [(cbrxh,
                       label: GHC.IO.Handle.HandlePosn_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,72,97,110,100,108,101,80,111,115,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrxh: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.260675428 UTC

[section ""relreadonly" . SboCL_srt" {
     SboCL_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.IO.Handle.$w$cshowsPrec_closure;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure;
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_closure;
         const GHC.IO.Handle.$fShowHandlePosn1_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.hLookAhead2_closure;
         const GHC.IO.Handle.hLookAhead1_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.hFlush2_closure;
         const GHC.IO.Handle.hFlush1_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const GHC.IO.Handle.hFlushAll2_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hFlushAll3_closure;
         const GHC.IO.Handle.hFlushAll1_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hGetEcho6_closure;
         const GHC.IO.Handle.hGetEcho_fun_closure;
         const GHC.IO.Handle.hGetEcho5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl1_rbnWC_closure;
         const lvl3_rbnWE_closure;
         const ioe_dupHandlesNotCompatible_rbnWF_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const dupHandle__rbnWK_closure;
         const GHC.IO.failIO1_closure;
         const lvl5_rbnWM_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const dupHandleTo_rbnWN_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.$whSetNewlineMode_closure;
         const GHC.IO.Handle.hSetNewlineMode2_closure;
         const GHC.IO.Handle.hSetNewlineMode1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const lvl11_rbnWT_closure;
         const GHC.IO.Handle.hSetBinaryMode1_closure;
         const lvl9_rbnWR_closure;
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure;
         const GHC.IO.Handle.hIsSeekable2_closure;
         const GHC.IO.Handle.hIsSeekable3_closure;
         const GHC.IO.Handle.hIsSeekable1_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.IO.Handle.hGetPosn2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.hGetPosn3_closure;
         const GHC.IO.Handle.hTell1_closure;
         const lvl14_rbnWW_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.hSeek1_closure;
         const lvl13_rbnWV_closure;
         const GHC.IO.Handle.hSetPosn1_closure;
         const GHC.IO.Handle.hGetEncoding3_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hGetEncoding1_closure;
         const lvl18_rbnX0_closure;
         const GHC.IO.Handle.hSetEncoding1_closure;
         const lvl16_rbnWY_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hSetBuffering1_closure;
         const GHC.IO.Handle.hSetBuffering2_closure;
         const GHC.IO.Handle.hIsEOF3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.hIsEOF1_closure;
         const GHC.IO.Handle.FD.stdin_closure;
         const GHC.IO.Handle.isEOF1_closure;
         const lvl20_rbnX2_closure;
         const GHC.IO.Handle.hSetFileSize1_closure;
         const GHC.IO.Handle.hFileSize5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const sat_sbojQ_closure;
         const GHC.IO.Handle.hFileSize3_closure;
         const GHC.IO.Handle.hFileSize4_closure;
         const GHC.IO.Handle.hFileSize10_closure;
         const GHC.IO.Handle.hFileSize2_closure;
         const GHC.IO.Handle.hFileSize8_closure;
         const GHC.IO.Handle.hFileSize1_closure;
         const lvl21_rbnX3_closure;
         const dupHandleTo_rbnWN_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.hDuplicateTo1_closure;
         const lvl25_rbnX7_closure;
         const GHC.IO.failIO1_closure;
         const lvl27_rbnX9_closure;
         const dupHandle__rbnWK_closure;
         const lvl7_rbnWP_closure;
         const GHC.IO.Handle.hDuplicate1_closure;
         const lvl23_rbnX5_closure;
         const GHC.IO.Handle.hGetEcho2_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hGetEcho3_closure;
         const GHC.IO.Handle.hGetEcho1_closure;
         const GHC.IO.Handle.hSetEcho2_closure;
         const GHC.IO.Handle.hSetEcho1_closure;
         const GHC.IO.Handle.hGetBuffering2_closure;
         const GHC.IO.Handle.hGetBuffering_fun_closure;
         const GHC.IO.Handle.hGetBuffering1_closure;
         const GHC.IO.Handle.hIsWritable2_closure;
         const GHC.IO.Handle.hIsWritable3_closure;
         const GHC.IO.Handle.hIsWritable1_closure;
         const GHC.IO.Handle.hIsReadable2_closure;
         const GHC.IO.Handle.hIsReadable3_closure;
         const GHC.IO.Handle.hIsReadable1_closure;
         const GHC.IO.Handle.hIsClosed3_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hIsClosed1_closure;
         const GHC.IO.Handle.hIsOpen3_closure;
         const GHC.IO.Handle.hIsOpen1_closure;
         const GHC.IO.Handle.hGetPosn1_closure;
         const GHC.IO.Handle.hGetPosn3_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.hGetPosn2_closure;
         const GHC.IO.Handle.hClose2_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.$wlvl_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.hClose1_closure;
         const lvl33_rbnXf_closure;
         const lvl42_rbnXo_closure;
         const lvl35_rbnXh_closure;
         const GHC.IO.Handle.Types.$fShowHandleType11_closure;
         const lvl46_rbnXs_closure;
         const lvl43_rbnXp_closure;
         const lvl44_rbnXq_closure;
         const GHC.IO.Handle.Types.$fShowHandleType1_closure;
         const GHC.IO.Handle.Types.$fShowHandleType3_closure;
         const GHC.IO.Handle.Types.$fShowHandleType5_closure;
         const GHC.IO.Handle.Types.$fShowHandleType7_closure;
         const GHC.IO.Handle.Types.$fShowHandleType9_closure;
         const lvl31_rbnXd_closure;
         const lvl47_rbnXt_closure;
         const lvl37_rbnXj_closure;
         const GHC.IO.Handle.hShow2_closure;
         const GHC.IO.Handle.hShow1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.26226859 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:17.263655386 UTC

[section ""data" . GHC.IO.Handle.$w$c==_closure" {
     GHC.IO.Handle.$w$c==_closure:
         const GHC.IO.Handle.$w$c==_info;
 },
 GHC.IO.Handle.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbrxs,
                       label: GHC.IO.Handle.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrxs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrxt; else goto cbrxu;
       cbrxt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrxu: // global
           I64[Sp - 24] = block_cbrxn_info;
           _sbnXw::P64 = R3;
           R3 = R5;
           _sbnXv::P64 = R2;
           R2 = _sbnXw::P64;
           P64[Sp - 16] = _sbnXv::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrxn() //  [R1]
         { info_tbl: [(cbrxn,
                       label: block_cbrxn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrxn: // global
           if (R1 == 1) goto cbrxr; else goto cbrxq;
       cbrxr: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fEqHandle_$c==_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cbrxq: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.272102848 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_$c==_closure" {
     GHC.IO.Handle.$fEqHandlePosn_$c==_closure:
         const GHC.IO.Handle.$fEqHandlePosn_$c==_info;
 },
 GHC.IO.Handle.$fEqHandlePosn_$c==_entry() //  [R2, R3]
         { info_tbl: [(cbrxR,
                       label: GHC.IO.Handle.$fEqHandlePosn_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrxR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrxV; else goto cbrxW;
       cbrxV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fEqHandlePosn_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrxW: // global
           I64[Sp - 16] = block_cbrxO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubry4; else goto cbrxP;
       ubry4: // global
           call _cbrxO(R1) args: 0, res: 0, upd: 0;
       cbrxP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrxO() //  [R1]
         { info_tbl: [(cbrxO,
                       label: block_cbrxO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrxO: // global
           I64[Sp - 8] = block_cbrxU_info;
           _sbnXD::P64 = P64[R1 + 7];
           _sbnXE::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbnXE::P64;
           P64[Sp + 8] = _sbnXD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubry3; else goto cbrxY;
       ubry3: // global
           call _cbrxU(R1) args: 0, res: 0, upd: 0;
       cbrxY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrxU() //  [R1]
         { info_tbl: [(cbrxU,
                       label: block_cbrxU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrxU: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.$w$c==_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.280091677 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_$c/=_closure" {
     GHC.IO.Handle.$fEqHandlePosn_$c/=_closure:
         const GHC.IO.Handle.$fEqHandlePosn_$c/=_info;
 },
 GHC.IO.Handle.$fEqHandlePosn_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cbryp,
                       label: GHC.IO.Handle.$fEqHandlePosn_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbryp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbryt; else goto cbryu;
       cbryt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fEqHandlePosn_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbryu: // global
           I64[Sp - 16] = block_cbrym_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubrA1; else goto cbryn;
       ubrA1: // global
           call _cbrym(R1) args: 0, res: 0, upd: 0;
       cbryn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrym() //  [R1]
         { info_tbl: [(cbrym,
                       label: block_cbrym_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrym: // global
           I64[Sp - 8] = block_cbrys_info;
           _sbnXL::P64 = P64[R1 + 7];
           _sbnXM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbnXM::P64;
           P64[Sp + 8] = _sbnXL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrA0; else goto cbryw;
       ubrA0: // global
           call _cbrys(R1) args: 0, res: 0, upd: 0;
       cbryw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrys() //  [R1]
         { info_tbl: [(cbrys,
                       label: block_cbrys_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrys: // global
           I64[Sp] = block_cbryA_info;
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbryA() //  [R1]
         { info_tbl: [(cbryA,
                       label: block_cbryA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbryA: // global
           if (R1 == 1) goto cbryM; else goto ubrzT;
       cbryM: // global
           I64[Sp] = block_cbryK_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubrA2; else goto cbryN;
       ubrA2: // global
           call _cbryK(R1) args: 0, res: 0, upd: 0;
       cbryN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubrzT: // global
           Sp = Sp + 24;
           call _cbrzF() args: 0, res: 0, upd: 0;
     }
 },
 _cbryK() //  [R1]
         { info_tbl: [(cbryK,
                       label: block_cbryK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbryK: // global
           _sbnXO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbryU; else goto cbrzp;
       cbryU: // global
           I64[Sp + 8] = block_cbryR_info;
           _sbnXT::P64 = P64[R1 + 15];
           R1 = _sbnXO::P64;
           P64[Sp + 16] = _sbnXT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubrA4; else goto cbryV;
       ubrA4: // global
           call _cbryR(R1) args: 0, res: 0, upd: 0;
       cbryV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbrzp: // global
           I64[Sp + 8] = block_cbrzn_info;
           _sbnY2::P64 = P64[R1 + 14];
           R1 = _sbnXO::P64;
           P64[Sp + 16] = _sbnY2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubrA5; else goto cbrzq;
       ubrA5: // global
           call _cbrzn(R1) args: 0, res: 0, upd: 0;
       cbrzq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbryR() //  [R1]
         { info_tbl: [(cbryR,
                       label: block_cbryR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbryR: // global
           if (R1 & 7 == 1) goto cbrzg; else goto ubrzX;
       cbrzg: // global
           if (P64[Sp + 8] == P64[R1 + 15]) goto ubrzY; else goto ubrzZ;
       ubrzY: // global
           Sp = Sp + 16;
           call _cbrzL() args: 0, res: 0, upd: 0;
       ubrzZ: // global
           Sp = Sp + 16;
           goto ubrA8;
       ubrzX: // global
           Sp = Sp + 16;
           goto ubrA8;
       ubrA8: // global
           call _cbrzF() args: 0, res: 0, upd: 0;
     }
 },
 _cbrzn() //  [R1]
         { info_tbl: [(cbrzn,
                       label: block_cbrzn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrzn: // global
           if (R1 & 7 == 1) goto ubrzU; else goto cbrzP;
       ubrzU: // global
           Sp = Sp + 16;
           goto ubrAb;
       cbrzP: // global
           if (P64[Sp + 8] == P64[R1 + 14]) goto ubrzV; else goto ubrzW;
       ubrzV: // global
           Sp = Sp + 16;
           call _cbrzL() args: 0, res: 0, upd: 0;
       ubrzW: // global
           Sp = Sp + 16;
           goto ubrAb;
       ubrAb: // global
           call _cbrzF() args: 0, res: 0, upd: 0;
     }
 },
 _cbrzL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrzL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrzF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrzF: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.296224462 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_closure" {
     GHC.IO.Handle.$fEqHandlePosn_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.$fEqHandlePosn_$c==_closure+2;
         const GHC.IO.Handle.$fEqHandlePosn_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.297996533 UTC

[section ""cstring" . GHC.IO.Handle.$fShowHandlePosn2_bytes" {
     GHC.IO.Handle.$fShowHandlePosn2_bytes:
         I8[] [32,97,116,32,112,111,115,105,116,105,111,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.301971485 UTC

[section ""data" . GHC.IO.Handle.$w$cshowsPrec_closure" {
     GHC.IO.Handle.$w$cshowsPrec_closure:
         const GHC.IO.Handle.$w$cshowsPrec_info;
         const 0;
 },
 sat_sbnYk_entry() //  [R1]
         { info_tbl: [(cbrBn,
                       label: sat_sbnYk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrBn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrBo; else goto cbrBp;
       cbrBo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrBp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbrBk_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbrBk() //  [R1, R2]
         { info_tbl: [(cbrBk,
                       label: block_cbrBk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrBk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrBs; else goto cbrBr;
       cbrBs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbrBr: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYl_entry() //  [R1]
         { info_tbl: [(cbrBt,
                       label: sat_sbnYl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrBt: // global
           _sbnYl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrBu; else goto cbrBv;
       cbrBv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrBx; else goto cbrBw;
       cbrBx: // global
           HpAlloc = 32;
           goto cbrBu;
       cbrBu: // global
           R1 = _sbnYl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrBw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYl::P64;
           _sbnYc::P64 = P64[_sbnYl::P64 + 16];
           _sbnYd::P64 = P64[_sbnYl::P64 + 24];
           I64[Hp - 24] = sat_sbnYk_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.$fShowHandlePosn2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYm_entry() //  [R1]
         { info_tbl: [(cbrBy,
                       label: sat_sbnYm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrBy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrBC; else goto cbrBB;
       cbrBC: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrBB: // global
           _sbnYc::P64 = P64[R1 + 16];
           _sbnYd::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbnYl_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbnYn_entry() //  [R1]
         { info_tbl: [(cbrBD,
                       label: sat_sbnYn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrBD: // global
           _sbnYn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrBE; else goto cbrBF;
       cbrBF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrBH; else goto cbrBG;
       cbrBH: // global
           HpAlloc = 32;
           goto cbrBE;
       cbrBE: // global
           R1 = _sbnYn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrBG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYn::P64;
           _sbnYc::P64 = P64[_sbnYn::P64 + 16];
           _sbnYd::P64 = P64[_sbnYn::P64 + 24];
           _sbnYf::P64 = P64[_sbnYn::P64 + 32];
           I64[Hp - 24] = sat_sbnYm_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = _sbnYf::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYu_entry() //  [R1]
         { info_tbl: [(cbrC3,
                       label: sat_sbnYu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrC3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrC4; else goto cbrC5;
       cbrC4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrC5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbrC0_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbrC0() //  [R1, R2]
         { info_tbl: [(cbrC0,
                       label: block_cbrC0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrC0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrC8; else goto cbrC7;
       cbrC8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbrC7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYv_entry() //  [R1]
         { info_tbl: [(cbrC9,
                       label: sat_sbnYv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrC9: // global
           _sbnYv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrCa; else goto cbrCb;
       cbrCb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrCd; else goto cbrCc;
       cbrCd: // global
           HpAlloc = 32;
           goto cbrCa;
       cbrCa: // global
           R1 = _sbnYv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrCc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYv::P64;
           _sbnYc::P64 = P64[_sbnYv::P64 + 16];
           _sbnYd::P64 = P64[_sbnYv::P64 + 24];
           I64[Hp - 24] = sat_sbnYu_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.$fShowHandlePosn2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbnYw_entry() //  [R1]
         { info_tbl: [(cbrCe,
                       label: sat_sbnYw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrCe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrCi; else goto cbrCh;
       cbrCi: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrCh: // global
           _sbnYc::P64 = P64[R1 + 16];
           _sbnYd::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbnYv_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbnYx_entry() //  [R1]
         { info_tbl: [(cbrCj,
                       label: sat_sbnYx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrCj: // global
           _sbnYx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrCk; else goto cbrCl;
       cbrCl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrCn; else goto cbrCm;
       cbrCn: // global
           HpAlloc = 32;
           goto cbrCk;
       cbrCk: // global
           R1 = _sbnYx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrCm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbnYx::P64;
           _sbnYc::P64 = P64[_sbnYx::P64 + 16];
           _sbnYd::P64 = P64[_sbnYx::P64 + 24];
           _sbnYo::P64 = P64[_sbnYx::P64 + 32];
           I64[Hp - 24] = sat_sbnYw_info;
           P64[Hp - 8] = _sbnYc::P64;
           P64[Hp] = _sbnYd::P64;
           R3 = Hp - 24;
           R2 = _sbnYo::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbrCs,
                       label: GHC.IO.Handle.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrCs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrCt; else goto cbrCu;
       cbrCt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrCu: // global
           I64[Sp - 24] = block_cbrAZ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubrCB; else goto cbrB0;
       ubrCB: // global
           call _cbrAZ(R1) args: 0, res: 0, upd: 0;
       cbrB0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrAZ() //  [R1]
         { info_tbl: [(cbrAZ,
                       label: block_cbrAZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrAZ: // global
           _sbnYc::P64 = P64[Sp + 8];
           _sbnYd::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbrCp; else goto cbrCq;
       cbrCp: // global
           Hp = Hp + 40;
           _sbnYe::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrCA; else goto cbrCw;
       cbrCw: // global
           _sbnYf::P64 = P64[_sbnYe::P64 + 7];
           I64[Hp - 32] = sat_sbnYn_info;
           P64[Hp - 16] = _sbnYc::P64;
           P64[Hp - 8] = _sbnYd::P64;
           P64[Hp] = _sbnYf::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cbrCq: // global
           Hp = Hp + 40;
           _sbnYe::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbrCA; else goto cbrCz;
       cbrCA: // global
           HpAlloc = 40;
           R1 = _sbnYe::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrCz: // global
           _sbnYo::P64 = P64[_sbnYe::P64 + 6];
           I64[Hp - 32] = sat_sbnYx_info;
           P64[Hp - 16] = _sbnYc::P64;
           P64[Hp - 8] = _sbnYd::P64;
           P64[Hp] = _sbnYo::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.329445343 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbrDw,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrDw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrDx; else goto cbrDy;
       cbrDx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrDy: // global
           I64[Sp - 16] = block_cbrDt_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubrDC; else goto cbrDu;
       ubrDC: // global
           call _cbrDt(R1) args: 0, res: 0, upd: 0;
       cbrDu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrDt() //  [R1]
         { info_tbl: [(cbrDt,
                       label: block_cbrDt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrDt: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.334688328 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn3_closure" {
     GHC.IO.Handle.$fShowHandlePosn3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.336496663 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshow_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshow_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshow_entry() //  [R2]
         { info_tbl: [(cbrDU,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrDU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbrDV; else goto cbrDW;
       cbrDV: // global
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrDW: // global
           I64[Sp - 8] = block_cbrDR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrE0; else goto cbrDS;
       ubrE0: // global
           call _cbrDR(R1) args: 0, res: 0, upd: 0;
       cbrDS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrDR() //  [R1]
         { info_tbl: [(cbrDR,
                       label: block_cbrDR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrDR: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.342143619 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn1_closure" {
     GHC.IO.Handle.$fShowHandlePosn1_closure:
         const GHC.IO.Handle.$fShowHandlePosn1_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn1_entry() //  [R2, R3]
         { info_tbl: [(cbrEh,
                       label: GHC.IO.Handle.$fShowHandlePosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrEh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrEi; else goto cbrEj;
       cbrEi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrEj: // global
           I64[Sp - 16] = block_cbrEe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubrEn; else goto cbrEf;
       ubrEn: // global
           call _cbrEe(R1) args: 0, res: 0, upd: 0;
       cbrEf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrEe() //  [R1]
         { info_tbl: [(cbrEe,
                       label: block_cbrEe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrEe: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.348055174 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cbrEB,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrEB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.$fShowHandlePosn1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.35169941 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_closure" {
     GHC.IO.Handle.$fShowHandlePosn_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure+3;
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_closure+1;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.35341915 UTC

[section ""cstring" . GHC.IO.Handle.hLookAhead3_bytes" {
     GHC.IO.Handle.hLookAhead3_bytes:
         I8[] [104,76,111,111,107,65,104,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.355262013 UTC

[section ""data" . GHC.IO.Handle.hLookAhead2_closure" {
     GHC.IO.Handle.hLookAhead2_closure:
         const GHC.IO.Handle.hLookAhead2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hLookAhead2_entry() //  [R1]
         { info_tbl: [(cbrEQ,
                       label: GHC.IO.Handle.hLookAhead2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrEQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrER; else goto cbrES;
       cbrER: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrES: // global
           (_cbrEN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrEN::I64 == 0) goto cbrEP; else goto cbrEO;
       cbrEP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrEO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrEN::I64;
           R2 = GHC.IO.Handle.hLookAhead3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.359147952 UTC

[section ""data" . GHC.IO.Handle.hLookAhead1_closure" {
     GHC.IO.Handle.hLookAhead1_closure:
         const GHC.IO.Handle.hLookAhead1_info;
         const 0;
 },
 GHC.IO.Handle.hLookAhead1_entry() //  [R2]
         { info_tbl: [(cbrF4,
                       label: GHC.IO.Handle.hLookAhead1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrF4: // global
           R4 = GHC.IO.Handle.Internals.hLookAhead_1_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hLookAhead2_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.362787603 UTC

[section ""data" . GHC.IO.Handle.hLookAhead_closure" {
     GHC.IO.Handle.hLookAhead_closure:
         const GHC.IO.Handle.hLookAhead_info;
         const 0;
 },
 GHC.IO.Handle.hLookAhead_entry() //  [R2]
         { info_tbl: [(cbrFf,
                       label: GHC.IO.Handle.hLookAhead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrFf: // global
           R2 = R2;
           call GHC.IO.Handle.hLookAhead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.365817936 UTC

[section ""cstring" . GHC.IO.Handle.hFlush3_bytes" {
     GHC.IO.Handle.hFlush3_bytes:
         I8[] [104,70,108,117,115,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.367641195 UTC

[section ""data" . GHC.IO.Handle.hFlush2_closure" {
     GHC.IO.Handle.hFlush2_closure:
         const GHC.IO.Handle.hFlush2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFlush2_entry() //  [R1]
         { info_tbl: [(cbrFt,
                       label: GHC.IO.Handle.hFlush2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrFt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrFu; else goto cbrFv;
       cbrFu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrFv: // global
           (_cbrFq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrFq::I64 == 0) goto cbrFs; else goto cbrFr;
       cbrFs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrFr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrFq::I64;
           R2 = GHC.IO.Handle.hFlush3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.371603877 UTC

[section ""data" . GHC.IO.Handle.hFlush1_closure" {
     GHC.IO.Handle.hFlush1_closure:
         const GHC.IO.Handle.hFlush1_info;
         const 0;
 },
 GHC.IO.Handle.hFlush1_entry() //  [R2]
         { info_tbl: [(cbrFH,
                       label: GHC.IO.Handle.hFlush1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrFH: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.375355755 UTC

[section ""data" . GHC.IO.Handle.hFlush_closure" {
     GHC.IO.Handle.hFlush_closure:
         const GHC.IO.Handle.hFlush_info;
         const 0;
 },
 GHC.IO.Handle.hFlush_entry() //  [R2]
         { info_tbl: [(cbrFS,
                       label: GHC.IO.Handle.hFlush_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrFS: // global
           R2 = R2;
           call GHC.IO.Handle.hFlush1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.379084148 UTC

[section ""cstring" . GHC.IO.Handle.hFlushAll4_bytes" {
     GHC.IO.Handle.hFlushAll4_bytes:
         I8[] [104,70,108,117,115,104,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.380892921 UTC

[section ""data" . GHC.IO.Handle.hFlushAll3_closure" {
     GHC.IO.Handle.hFlushAll3_closure:
         const GHC.IO.Handle.hFlushAll3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFlushAll3_entry() //  [R1]
         { info_tbl: [(cbrG6,
                       label: GHC.IO.Handle.hFlushAll3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrG6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrG7; else goto cbrG8;
       cbrG7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrG8: // global
           (_cbrG3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrG3::I64 == 0) goto cbrG5; else goto cbrG4;
       cbrG5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrG4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrG3::I64;
           R2 = GHC.IO.Handle.hFlushAll4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.385049447 UTC

[section ""data" . GHC.IO.Handle.hFlushAll2_closure" {
     GHC.IO.Handle.hFlushAll2_closure:
         const GHC.IO.Handle.hFlushAll2_info;
         const 0;
 },
 GHC.IO.Handle.hFlushAll2_entry() //  [R2]
         { info_tbl: [(cbrGn,
                       label: GHC.IO.Handle.hFlushAll2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrGn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrGo; else goto cbrGp;
       cbrGo: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFlushAll2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrGp: // global
           I64[Sp - 16] = block_cbrGk_info;
           _sbnYR::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbnYR::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrGk() //  [R1]
         { info_tbl: [(cbrGk,
                       label: block_cbrGk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrGk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrGs; else goto cbrGr;
       cbrGs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrGr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.391970275 UTC

[section ""data" . GHC.IO.Handle.hFlushAll1_closure" {
     GHC.IO.Handle.hFlushAll1_closure:
         const GHC.IO.Handle.hFlushAll1_info;
         const 0;
 },
 io_sbnZ5_entry() //  [R1]
         { info_tbl: [(cbrGY,
                       label: io_sbnZ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrGY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrH2; else goto cbrH3;
       cbrH2: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrH3: // global
           I64[Sp - 16] = block_cbrGT_info;
           _sbnZ1::P64 = P64[R1 + 15];
           R5 = _sbnZ1::P64;
           R4 = GHC.IO.Handle.hFlushAll2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFlushAll3_closure;
           P64[Sp - 8] = _sbnZ1::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrGT() //  [R1]
         { info_tbl: [(cbrGT,
                       label: block_cbrGT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrGT: // global
           I64[Sp] = block_cbrGV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrH8; else goto cbrGW;
       ubrH8: // global
           call _cbrGV(R1) args: 0, res: 0, upd: 0;
       cbrGW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrGV() //  [R1]
         { info_tbl: [(cbrGV,
                       label: block_cbrGV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrGV: // global
           I64[Sp] = block_cbrH1_info;
           R2 = P64[R1 + 7];
           _sbnZc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbnZc::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrH1() //  []
         { info_tbl: [(cbrH1,
                       label: block_cbrH1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrH1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbnZl_entry() //  [R1]
         { info_tbl: [(cbrHn,
                       label: io_sbnZl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrHn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrHr; else goto cbrHs;
       cbrHr: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrHs: // global
           I64[Sp - 16] = block_cbrHi_info;
           _sbnZg::P64 = P64[R1 + 15];
           R5 = _sbnZg::P64;
           R4 = GHC.IO.Handle.hFlushAll2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFlushAll3_closure;
           P64[Sp - 8] = _sbnZg::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrHi() //  [R1]
         { info_tbl: [(cbrHi,
                       label: block_cbrHi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrHi: // global
           I64[Sp] = block_cbrHk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrHx; else goto cbrHl;
       ubrHx: // global
           call _cbrHk(R1) args: 0, res: 0, upd: 0;
       cbrHl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrHk() //  [R1]
         { info_tbl: [(cbrHk,
                       label: block_cbrHk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrHk: // global
           I64[Sp] = block_cbrHq_info;
           R2 = P64[R1 + 7];
           _sbnZs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbnZs::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrHq() //  []
         { info_tbl: [(cbrHq,
                       label: block_cbrHq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrHq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hFlushAll1_entry() //  [R2]
         { info_tbl: [(cbrHC,
                       label: GHC.IO.Handle.hFlushAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrHC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrHD; else goto cbrHE;
       cbrHD: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFlushAll1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrHE: // global
           I64[Sp - 8] = block_cbrGH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrHV; else goto cbrGI;
       ubrHV: // global
           call _cbrGH(R1) args: 0, res: 0, upd: 0;
       cbrGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrGH() //  [R1]
         { info_tbl: [(cbrGH,
                       label: block_cbrGH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrGH: // global
           if (R1 & 7 == 1) goto cbrHz; else goto cbrHA;
       cbrHz: // global
           I64[Sp - 16] = block_cbrGM_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbrHA: // global
           I64[Sp - 16] = block_cbrHb_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbrGM() //  [R1]
         { info_tbl: [(cbrGM,
                       label: block_cbrGM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrGM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrHI; else goto cbrHH;
       cbrHI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrHH: // global
           I64[Hp - 16] = io_sbnZ5_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrGO::P64 = Hp - 15;
           if (R1 == 0) goto cbrHM; else goto cbrHL;
       cbrHM: // global
           R1 = _cbrGO::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrHL: // global
           R1 = _cbrGO::P64;
           Sp = Sp + 24;
           call io_sbnZ5_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrHb() //  [R1]
         { info_tbl: [(cbrHb,
                       label: block_cbrHb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrHb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrHQ; else goto cbrHP;
       cbrHQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrHP: // global
           I64[Hp - 16] = io_sbnZl_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrHd::P64 = Hp - 15;
           if (R1 == 0) goto cbrHU; else goto cbrHT;
       cbrHU: // global
           R1 = _cbrHd::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrHT: // global
           R1 = _cbrHd::P64;
           Sp = Sp + 24;
           call io_sbnZl_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.415198072 UTC

[section ""data" . GHC.IO.Handle.hFlushAll_closure" {
     GHC.IO.Handle.hFlushAll_closure:
         const GHC.IO.Handle.hFlushAll_info;
         const 0;
 },
 GHC.IO.Handle.hFlushAll_entry() //  [R2]
         { info_tbl: [(cbrIR,
                       label: GHC.IO.Handle.hFlushAll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrIR: // global
           R2 = R2;
           call GHC.IO.Handle.hFlushAll1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.418316833 UTC

[section ""cstring" . GHC.IO.Handle.hGetEcho7_bytes" {
     GHC.IO.Handle.hGetEcho7_bytes:
         I8[] [104,73,115,84,101,114,109,105,110,97,108,68,101,118,105,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.420109034 UTC

[section ""data" . GHC.IO.Handle.hGetEcho_fun_closure" {
     GHC.IO.Handle.hGetEcho_fun_closure:
         const GHC.IO.Handle.hGetEcho_fun_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEcho_fun_entry() //  [R1]
         { info_tbl: [(cbrJ5,
                       label: GHC.IO.Handle.hGetEcho_fun_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrJ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrJ6; else goto cbrJ7;
       cbrJ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrJ7: // global
           (_cbrJ2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrJ2::I64 == 0) goto cbrJ4; else goto cbrJ3;
       cbrJ4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrJ3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrJ2::I64;
           R2 = GHC.IO.Handle.hGetEcho7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.424934925 UTC

[section ""data" . GHC.IO.Handle.hGetEcho6_closure" {
     GHC.IO.Handle.hGetEcho6_closure:
         const GHC.IO.Handle.hGetEcho6_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho6_entry() //  [R2]
         { info_tbl: [(cbrJm,
                       label: GHC.IO.Handle.hGetEcho6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrJm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbrJn; else goto cbrJo;
       cbrJn: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrJo: // global
           I64[Sp - 8] = block_cbrJj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrJM; else goto cbrJk;
       ubrJM: // global
           call _cbrJj(R1) args: 0, res: 0, upd: 0;
       cbrJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrJj() //  [R1]
         { info_tbl: [(cbrJj,
                       label: block_cbrJj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrJj: // global
           I64[Sp - 24] = block_cbrJr_info;
           _sbnZx::P64 = R1;
           _sbnZy::P64 = P64[R1 + 7];
           _sbnZB::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbnZy::P64;
           P64[Sp - 8] = _sbnZB::P64;
           P64[Sp] = _sbnZx::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubrJL; else goto cbrJt;
       ubrJL: // global
           call _cbrJr(R1) args: 0, res: 0, upd: 0;
       cbrJt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrJr() //  [R1]
         { info_tbl: [(cbrJr,
                       label: block_cbrJr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrJr: // global
           if (R1 & 7 == 1) goto cbrJJ; else goto cbrJC;
       cbrJJ: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbrJC: // global
           _sbnZB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbrJx_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbnZB::P64;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbrJx() //  [R1]
         { info_tbl: [(cbrJx,
                       label: block_cbrJx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrJx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrJF; else goto cbrJE;
       cbrJF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrJE: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.435095977 UTC

[section ""data" . GHC.IO.Handle.hGetEcho5_closure" {
     GHC.IO.Handle.hGetEcho5_closure:
         const GHC.IO.Handle.hGetEcho5_info;
         const 0;
 },
 io_sbo02_entry() //  [R1]
         { info_tbl: [(cbrKs,
                       label: io_sbo02_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrKw; else goto cbrKx;
       cbrKw: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrKx: // global
           I64[Sp - 16] = block_cbrKn_info;
           _sbnZY::P64 = P64[R1 + 15];
           R5 = _sbnZY::P64;
           R4 = GHC.IO.Handle.hGetEcho6_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho_fun_closure;
           P64[Sp - 8] = _sbnZY::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrKn() //  [R1]
         { info_tbl: [(cbrKn,
                       label: block_cbrKn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKn: // global
           I64[Sp] = block_cbrKp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrKC; else goto cbrKq;
       ubrKC: // global
           call _cbrKp(R1) args: 0, res: 0, upd: 0;
       cbrKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrKp() //  [R1]
         { info_tbl: [(cbrKp,
                       label: block_cbrKp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKp: // global
           I64[Sp] = block_cbrKv_info;
           R2 = P64[R1 + 7];
           _sbo09::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo09::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrKv() //  []
         { info_tbl: [(cbrKv,
                       label: block_cbrKv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbo0i_entry() //  [R1]
         { info_tbl: [(cbrKR,
                       label: io_sbo0i_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrKV; else goto cbrKW;
       cbrKV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrKW: // global
           I64[Sp - 16] = block_cbrKM_info;
           _sbo0d::P64 = P64[R1 + 15];
           R5 = _sbo0d::P64;
           R4 = GHC.IO.Handle.hGetEcho6_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho_fun_closure;
           P64[Sp - 8] = _sbo0d::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrKM() //  [R1]
         { info_tbl: [(cbrKM,
                       label: block_cbrKM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKM: // global
           I64[Sp] = block_cbrKO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrL1; else goto cbrKP;
       ubrL1: // global
           call _cbrKO(R1) args: 0, res: 0, upd: 0;
       cbrKP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrKO() //  [R1]
         { info_tbl: [(cbrKO,
                       label: block_cbrKO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKO: // global
           I64[Sp] = block_cbrKU_info;
           R2 = P64[R1 + 7];
           _sbo0p::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo0p::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrKU() //  []
         { info_tbl: [(cbrKU,
                       label: block_cbrKU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hGetEcho5_entry() //  [R2]
         { info_tbl: [(cbrL6,
                       label: GHC.IO.Handle.hGetEcho5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrL6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrL7; else goto cbrL8;
       cbrL7: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho5_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrL8: // global
           I64[Sp - 8] = block_cbrKb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrLp; else goto cbrKc;
       ubrLp: // global
           call _cbrKb(R1) args: 0, res: 0, upd: 0;
       cbrKc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrKb() //  [R1]
         { info_tbl: [(cbrKb,
                       label: block_cbrKb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKb: // global
           if (R1 & 7 == 1) goto cbrL3; else goto cbrL4;
       cbrL3: // global
           I64[Sp - 16] = block_cbrKg_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbrL4: // global
           I64[Sp - 16] = block_cbrKF_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbrKg() //  [R1]
         { info_tbl: [(cbrKg,
                       label: block_cbrKg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrLc; else goto cbrLb;
       cbrLc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrLb: // global
           I64[Hp - 16] = io_sbo02_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrKi::P64 = Hp - 15;
           if (R1 == 0) goto cbrLg; else goto cbrLf;
       cbrLg: // global
           R1 = _cbrKi::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrLf: // global
           R1 = _cbrKi::P64;
           Sp = Sp + 24;
           call io_sbo02_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrKF() //  [R1]
         { info_tbl: [(cbrKF,
                       label: block_cbrKF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrKF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrLk; else goto cbrLj;
       cbrLk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbrLj: // global
           I64[Hp - 16] = io_sbo0i_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbrKH::P64 = Hp - 15;
           if (R1 == 0) goto cbrLo; else goto cbrLn;
       cbrLo: // global
           R1 = _cbrKH::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbrLn: // global
           R1 = _cbrKH::P64;
           Sp = Sp + 24;
           call io_sbo0i_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.458519452 UTC

[section ""data" . GHC.IO.Handle.hIsTerminalDevice_closure" {
     GHC.IO.Handle.hIsTerminalDevice_closure:
         const GHC.IO.Handle.hIsTerminalDevice_info;
         const 0;
 },
 GHC.IO.Handle.hIsTerminalDevice_entry() //  [R2]
         { info_tbl: [(cbrMl,
                       label: GHC.IO.Handle.hIsTerminalDevice_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrMl: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.4620111 UTC

[section ""cstring" . lvl_rbnWB_bytes" {
     lvl_rbnWB_bytes:
         I8[] [104,68,117,112,108,105,99,97,116,101,84,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.463768636 UTC

[section ""data" . lvl1_rbnWC_closure" {
     lvl1_rbnWC_closure:
         const lvl1_rbnWC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbnWC_entry() //  [R1]
         { info_tbl: [(cbrMz,
                       label: lvl1_rbnWC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrMz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrMA; else goto cbrMB;
       cbrMA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrMB: // global
           (_cbrMw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrMw::I64 == 0) goto cbrMy; else goto cbrMx;
       cbrMy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrMx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrMw::I64;
           R2 = lvl_rbnWB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.467412297 UTC

[section ""cstring" . lvl2_rbnWD_bytes" {
     lvl2_rbnWD_bytes:
         I8[] [104,97,110,100,108,101,115,32,97,114,101,32,105,110,99,111,109,112,97,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.469178218 UTC

[section ""data" . lvl3_rbnWE_closure" {
     lvl3_rbnWE_closure:
         const lvl3_rbnWE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbnWE_entry() //  [R1]
         { info_tbl: [(cbrMQ,
                       label: lvl3_rbnWE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrMQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrMR; else goto cbrMS;
       cbrMR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrMS: // global
           (_cbrMN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrMN::I64 == 0) goto cbrMP; else goto cbrMO;
       cbrMP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrMO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrMN::I64;
           R2 = lvl2_rbnWD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.473191522 UTC

[section ""data" . ioe_dupHandlesNotCompatible_rbnWF_closure" {
     ioe_dupHandlesNotCompatible_rbnWF_closure:
         const ioe_dupHandlesNotCompatible_rbnWF_info;
         const 0;
 },
 sat_sbo0w_entry() //  [R1]
         { info_tbl: [(cbrNa,
                       label: sat_sbo0w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrNa: // global
           _sbo0w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbrNb; else goto cbrNc;
       cbrNc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbrNe; else goto cbrNd;
       cbrNe: // global
           HpAlloc = 72;
           goto cbrNb;
       cbrNb: // global
           R1 = _sbo0w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrNd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbo0w::P64;
           _sbo0s::P64 = P64[_sbo0w::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbo0s::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = lvl1_rbnWC_closure;
           P64[Hp - 16] = lvl3_rbnWE_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ioe_dupHandlesNotCompatible_rbnWF_entry() //  [R2]
         { info_tbl: [(cbrNf,
                       label: ioe_dupHandlesNotCompatible_rbnWF_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrNf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrNj; else goto cbrNi;
       cbrNj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = ioe_dupHandlesNotCompatible_rbnWF_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrNi: // global
           I64[Hp - 16] = sat_sbo0w_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.47938498 UTC

[section ""cstring" . GHC.IO.Handle.$trModule4_bytes" {
     GHC.IO.Handle.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.480958661 UTC

[section ""data" . GHC.IO.Handle.$trModule3_closure" {
     GHC.IO.Handle.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.483150734 UTC

[section ""cstring" . GHC.IO.Handle.$trModule2_bytes" {
     GHC.IO.Handle.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.4847388 UTC

[section ""data" . GHC.IO.Handle.$trModule1_closure" {
     GHC.IO.Handle.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.486699262 UTC

[section ""data" . GHC.IO.Handle.$trModule_closure" {
     GHC.IO.Handle.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.$trModule3_closure+1;
         const GHC.IO.Handle.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.488291933 UTC

[section ""data" . $krep_rbnWG_closure" {
     $krep_rbnWG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.489996045 UTC

[section ""data" . $krep1_rbnWH_closure" {
     $krep1_rbnWH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.491594811 UTC

[section ""cstring" . GHC.IO.Handle.$tcHandlePosn2_bytes" {
     GHC.IO.Handle.$tcHandlePosn2_bytes:
         I8[] [72,97,110,100,108,101,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.493187209 UTC

[section ""data" . GHC.IO.Handle.$tcHandlePosn1_closure" {
     GHC.IO.Handle.$tcHandlePosn1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$tcHandlePosn2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.494865767 UTC

[section ""data" . GHC.IO.Handle.$tcHandlePosn_closure" {
     GHC.IO.Handle.$tcHandlePosn_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.$trModule_closure+1;
         const GHC.IO.Handle.$tcHandlePosn1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14603627022044816180;
         const 6047646306417636971;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.49654873 UTC

[section ""data" . $krep2_rbnWI_closure" {
     $krep2_rbnWI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.$tcHandlePosn_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.498174992 UTC

[section ""data" . $krep3_rbnWJ_closure" {
     $krep3_rbnWJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbnWG_closure+1;
         const $krep2_rbnWI_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.499781487 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn1_closure" {
     GHC.IO.Handle.$tc'HandlePosn1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rbnWH_closure+1;
         const $krep3_rbnWJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.501426209 UTC

[section ""cstring" . GHC.IO.Handle.$tc'HandlePosn3_bytes" {
     GHC.IO.Handle.$tc'HandlePosn3_bytes:
         I8[] [39,72,97,110,100,108,101,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.50304385 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn2_closure" {
     GHC.IO.Handle.$tc'HandlePosn2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$tc'HandlePosn3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.504697191 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn_closure" {
     GHC.IO.Handle.$tc'HandlePosn_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.$trModule_closure+1;
         const GHC.IO.Handle.$tc'HandlePosn2_closure+1;
         const GHC.IO.Handle.$tc'HandlePosn1_closure+4;
         const 2346493220596692855;
         const 1604707260447826943;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.508331171 UTC

[section ""data" . dupHandle__rbnWK_closure" {
     dupHandle__rbnWK_closure:
         const dupHandle__rbnWK_info;
         const 0;
 },
 dupHandle__rbnWK_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrNK: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 dupHandle__rbnWK_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbrNR,
                       label: dupHandle__rbnWK_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrNR: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbrNS; else goto cbrNT;
       cbrNS: // global
           R1 = dupHandle__rbnWK_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cbrNT: // global
           I64[Sp - 40] = block_cbrNO_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubrOz; else goto cbrNP;
       ubrOz: // global
           call _cbrNO(R1) args: 0, res: 0, upd: 0;
       cbrNP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrNO() //  [R1]
         { info_tbl: [(cbrNO,
                       label: block_cbrNO_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrNO: // global
           I64[Sp - 24] = block_cbrNY_info;
           _sbo0L::P64 = P64[R1 + 39];
           _sbo0U::P64 = P64[R1 + 111];
           _sbo0V::P64 = P64[R1 + 119];
           R1 = P64[R1 + 87];
           P64[Sp - 16] = _sbo0U::P64;
           P64[Sp - 8] = _sbo0V::P64;
           P64[Sp] = _sbo0L::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubrOy; else goto cbrO6;
       ubrOy: // global
           call _cbrNY(R1) args: 0, res: 0, upd: 0;
       cbrO6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrNY() //  [R1]
         { info_tbl: [(cbrNY,
                       label: block_cbrNY_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrNY: // global
           if (R1 & 7 == 1) goto cbrOc; else goto cbrOh;
       cbrOc: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _cbrO1() args: 0, res: 0, upd: 0;
       cbrOh: // global
           I64[Sp] = block_cbrOf_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubrOA; else goto cbrOi;
       ubrOA: // global
           call _cbrOf(R1) args: 0, res: 0, upd: 0;
       cbrOi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrOf() //  [R1]
         { info_tbl: [(cbrOf,
                       label: block_cbrOf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrOf: // global
           I64[Sp] = block_cbrOm_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrOm() //  [R1]
         { info_tbl: [(cbrOm,
                       label: block_cbrOm_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrOm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbrOr; else goto cbrOq;
       cbrOr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrOq: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 6;
           call _cbrO1() args: 0, res: 0, upd: 0;
     }
 },
 _cbrO1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrO1: // global
           Hp = Hp + 24;
           _sbo0Z::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cbrO5; else goto cbrO4;
       cbrO5: // global
           HpAlloc = 24;
           I64[Sp] = block_cbrO0_info;
           R1 = _sbo0Z::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrO4: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 72];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = GHC.Types.True_closure+2;
           P64[Sp + 56] = _sbo0Z::P64;
           _sbo0C::P64 = P64[Sp + 64];
           P64[Sp + 64] = Hp - 15;
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sbo0C::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 },
 _cbrO0() //  [R1]
         { info_tbl: [(cbrO0,
                       label: block_cbrO0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrO0: // global
           P64[Sp] = R1;
           call _cbrO1() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.524085506 UTC

[section ""cstring" . lvl4_rbnWL_bytes" {
     lvl4_rbnWL_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,55,49,51,58,55,45,50,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.526068134 UTC

[section ""data" . lvl5_rbnWM_closure" {
     lvl5_rbnWM_closure:
         const lvl5_rbnWM_info;
         const 0;
 },
 lvl5_rbnWM_entry() //  []
         { info_tbl: [(cbrPk,
                       label: lvl5_rbnWM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrPk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbrPl; else goto cbrPm;
       cbrPl: // global
           R1 = lvl5_rbnWM_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbrPm: // global
           I64[Sp - 8] = block_cbrPi_info;
           R2 = lvl4_rbnWL_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrPi() //  [R1]
         { info_tbl: [(cbrPi,
                       label: block_cbrPi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrPi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.531815549 UTC

[section ""data" . dupHandleTo_rbnWN_closure" {
     dupHandleTo_rbnWN_closure:
         const dupHandleTo_rbnWN_info;
         const 0;
 },
 dupHandleTo_rbnWN_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbrPF,
                       label: dupHandleTo_rbnWN_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrPF: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cbrPJ; else goto cbrPK;
       cbrPJ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = dupHandleTo_rbnWN_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbrPK: // global
           I64[Sp - 40] = block_cbrPC_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubrQq; else goto cbrPD;
       ubrQq: // global
           call _cbrPC(R1) args: 0, res: 0, upd: 0;
       cbrPD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrPC() //  [R1]
         { info_tbl: [(cbrPC,
                       label: block_cbrPC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrPC: // global
           I64[Sp - 8] = block_cbrPI_info;
           _sbo1m::P64 = P64[R1 + 23];
           _sbo1n::P64 = P64[R1 + 31];
           R1 = P64[Sp + 32];
           P64[Sp] = _sbo1n::P64;
           P64[Sp + 32] = _sbo1m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubrQp; else goto cbrPM;
       ubrQp: // global
           call _cbrPI(R1) args: 0, res: 0, upd: 0;
       cbrPM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrPI() //  [R1]
         { info_tbl: [(cbrPI,
                       label: block_cbrPI_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrPI: // global
           I64[Sp - 40] = block_cbrPQ_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrPQ() //  []
         { info_tbl: [(cbrPQ,
                       label: block_cbrPQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrPQ: // global
           I64[Sp] = block_cbrPS_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 80];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrPS() //  [R1]
         { info_tbl: [(cbrPS,
                       label: block_cbrPS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrPS: // global
           if (R1 & 7 == 1) goto cbrQ0; else goto cbrQ9;
       cbrQ0: // global
           R2 = P64[Sp + 64];
           Sp = Sp + 96;
           call ioe_dupHandlesNotCompatible_rbnWF_entry(R2) args: 8, res: 0, upd: 8;
       cbrQ9: // global
           I64[Sp] = block_cbrQ3_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 48];
           Sp = Sp - 24;
           call GHC.IO.Device.dup2_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbrQ3() //  []
         { info_tbl: [(cbrQ3,
                       label: block_cbrQ3_info
                       rep:StackRep [False, False, False, True, False, False, False, True,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrQ3: // global
           _sbo1h::P64 = P64[Sp + 88];
           I64[Sp + 88] = block_cbrQ5_info;
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 64] = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 40];
           P64[Sp + 80] = _sbo1h::P64;
           Sp = Sp + 64;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbrQ5() //  [R1]
         { info_tbl: [(cbrQ5,
                       label: block_cbrQ5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrQ5: // global
           I64[Sp] = block_cbrQ7_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubrQr; else goto cbrQc;
       ubrQr: // global
           call _cbrQ7(R1) args: 0, res: 0, upd: 0;
       cbrQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrQ7() //  [R1]
         { info_tbl: [(cbrQ7,
                       label: block_cbrQ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrQ7: // global
           if (R1 & 7 == 1) goto cbrQi; else goto cbrQm;
       cbrQi: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
       cbrQm: // global
           Sp = Sp + 8;
           call lvl5_rbnWM_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.548791758 UTC

[section ""cstring" . lvl6_rbnWO_bytes" {
     lvl6_rbnWO_bytes:
         I8[] [100,117,112,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.550784628 UTC

[section ""data" . lvl7_rbnWP_closure" {
     lvl7_rbnWP_closure:
         const lvl7_rbnWP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rbnWP_entry() //  [R1]
         { info_tbl: [(cbrRe,
                       label: lvl7_rbnWP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrRe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrRf; else goto cbrRg;
       cbrRf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrRg: // global
           (_cbrRb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrRb::I64 == 0) goto cbrRd; else goto cbrRc;
       cbrRd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrRc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrRb::I64;
           R2 = lvl6_rbnWO_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.554573379 UTC

[section ""cstring" . GHC.IO.Handle.hSetNewlineMode3_bytes" {
     GHC.IO.Handle.hSetNewlineMode3_bytes:
         I8[] [104,83,101,116,78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.556401634 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode2_closure" {
     GHC.IO.Handle.hSetNewlineMode2_closure:
         const GHC.IO.Handle.hSetNewlineMode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode2_entry() //  [R1]
         { info_tbl: [(cbrRv,
                       label: GHC.IO.Handle.hSetNewlineMode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrRv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrRw; else goto cbrRx;
       cbrRw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrRx: // global
           (_cbrRs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrRs::I64 == 0) goto cbrRu; else goto cbrRt;
       cbrRu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrRt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrRs::I64;
           R2 = GHC.IO.Handle.hSetNewlineMode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.561314559 UTC

[section ""data" . GHC.IO.Handle.$whSetNewlineMode_closure" {
     GHC.IO.Handle.$whSetNewlineMode_closure:
         const GHC.IO.Handle.$whSetNewlineMode_info;
         const 0;
 },
 sat_sbo2y_entry() //  [R1, R2]
         { info_tbl: [(cbrRR,
                       label: sat_sbo2y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrRR: // global
           if ((Sp + -136) < SpLim) (likely: False) goto cbrRX; else goto cbrRY;
       cbrRX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrRY: // global
           I64[Sp - 24] = block_cbrRO_info;
           _sbo28::P64 = P64[R1 + 6];
           _sbo29::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbo28::P64;
           P64[Sp - 8] = _sbo29::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubrS3; else goto cbrRP;
       ubrS3: // global
           call _cbrRO(R1) args: 0, res: 0, upd: 0;
       cbrRP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrRO() //  [R1]
         { info_tbl: [(cbrRO,
                       label: block_cbrRO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrRO: // global
           I64[Sp - 112] = block_cbrRU_info;
           R2 = R1;
           P64[Sp - 104] = P64[R1 + 15];
           P64[Sp - 96] = P64[R1 + 23];
           P64[Sp - 88] = P64[R1 + 31];
           P64[Sp - 80] = P64[R1 + 39];
           P64[Sp - 72] = P64[R1 + 47];
           P64[Sp - 64] = P64[R1 + 55];
           P64[Sp - 56] = P64[R1 + 63];
           P64[Sp - 48] = P64[R1 + 71];
           P64[Sp - 40] = P64[R1 + 79];
           P64[Sp - 32] = P64[R1 + 87];
           P64[Sp - 24] = P64[R1 + 95];
           P64[Sp - 16] = P64[R1 + 103];
           P64[Sp - 8] = P64[R1 + 127];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 112;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbrRU() //  [R1]
         { info_tbl: [(cbrRU,
                       label: block_cbrRU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrRU: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbrS2; else goto cbrS1;
       cbrS2: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrS1: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 112];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 56];
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = P64[Sp + 104];
           R1 = Hp - 127;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.$whSetNewlineMode_entry() //  [R2, R3, R4]
         { info_tbl: [(cbrS4,
                       label: GHC.IO.Handle.$whSetNewlineMode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrS4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrS8; else goto cbrS7;
       cbrS8: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$whSetNewlineMode_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrS7: // global
           I64[Hp - 16] = sat_sbo2y_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.hSetNewlineMode2_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.572227746 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode1_closure" {
     GHC.IO.Handle.hSetNewlineMode1_closure:
         const GHC.IO.Handle.hSetNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(cbrT0,
                       label: GHC.IO.Handle.hSetNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrT0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrT1; else goto cbrT2;
       cbrT1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetNewlineMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbrT2: // global
           I64[Sp - 16] = block_cbrSX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubrT6; else goto cbrSY;
       ubrT6: // global
           call _cbrSX(R1) args: 0, res: 0, upd: 0;
       cbrSY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrSX() //  [R1]
         { info_tbl: [(cbrSX,
                       label: block_cbrSX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrSX: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$whSetNewlineMode_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.577669973 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode_closure" {
     GHC.IO.Handle.hSetNewlineMode_closure:
         const GHC.IO.Handle.hSetNewlineMode_info;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode_entry() //  [R2, R3]
         { info_tbl: [(cbrTk,
                       label: GHC.IO.Handle.hSetNewlineMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrTk: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetNewlineMode1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.581369929 UTC

[section ""cstring" . lvl8_rbnWQ_bytes" {
     lvl8_rbnWQ_bytes:
         I8[] [104,83,101,116,66,105,110,97,114,121,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.583220294 UTC

[section ""data" . lvl9_rbnWR_closure" {
     lvl9_rbnWR_closure:
         const lvl9_rbnWR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rbnWR_entry() //  [R1]
         { info_tbl: [(cbrTy,
                       label: lvl9_rbnWR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrTy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbrTz; else goto cbrTA;
       cbrTz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrTA: // global
           (_cbrTv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrTv::I64 == 0) goto cbrTx; else goto cbrTw;
       cbrTx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrTw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrTv::I64;
           R2 = lvl8_rbnWQ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.586941093 UTC

[section ""cstring" . lvl10_rbnWS_bytes" {
     lvl10_rbnWS_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.58868943 UTC

[section ""data" . lvl11_rbnWT_closure" {
     lvl11_rbnWT_closure:
         const lvl11_rbnWT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rbnWT_entry() //  [R1]
         { info_tbl: [(cbrTR,
                       label: lvl11_rbnWT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrTR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrTS; else goto cbrTT;
       cbrTS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrTT: // global
           (_cbrTM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbrTM::I64 == 0) goto cbrTO; else goto cbrTN;
       cbrTO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbrTN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbrTM::I64;
           I64[Sp - 24] = block_cbrTP_info;
           R2 = lvl10_rbnWS_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbrTP() //  [R1]
         { info_tbl: [(cbrTP,
                       label: block_cbrTP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrTP: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.601956595 UTC

[section ""data" . GHC.IO.Handle.hSetBinaryMode1_closure" {
     GHC.IO.Handle.hSetBinaryMode1_closure:
         const GHC.IO.Handle.hSetBinaryMode1_info;
         const 0;
 },
 lvl48_sbo2J_entry() //  [R1]
         { info_tbl: [(cbrUi,
                       label: lvl48_sbo2J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrUi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrUj; else goto cbrUk;
       cbrUj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrUk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbrUf_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubrUo; else goto cbrUg;
       ubrUo: // global
           call _cbrUf() args: 0, res: 0, upd: 0;
       cbrUg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrUf() //  []
         { info_tbl: [(cbrUf,
                       label: block_cbrUf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrUf: // global
           R1 = GHC.IO.Handle.Types.LF_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo5C_entry() //  [R1]
         { info_tbl: [(cbrVa,
                       label: sat_sbo5C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrVa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbrVe; else goto cbrVf;
       cbrVe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrVf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbrV7_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubrVj; else goto cbrV8;
       ubrVj: // global
           call _cbrV7(R1) args: 0, res: 0, upd: 0;
       cbrV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrV7() //  [R1]
         { info_tbl: [(cbrV7,
                       label: block_cbrV7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrV7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbrVi; else goto cbrVh;
       cbrVi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbrVh: // global
           _sbo5x::P64 = P64[R1 + 7];
           _sbo5y::P64 = P64[R1 + 15];
           _sbo5w::I64 = I64[R1 + 23];
           _sbo5z::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo5x::P64;
           P64[Hp - 32] = _sbo5y::P64;
           I64[Hp - 24] = _sbo5w::I64;
           I64[Hp - 16] = _sbo5z::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo5V_entry() //  [R1]
         { info_tbl: [(cbrVG,
                       label: sat_sbo5V_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrVG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbrVN; else goto cbrVO;
       cbrVN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbrVO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbrVD_info;
           _sbo5L::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbo5L::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubrVS; else goto cbrVE;
       ubrVS: // global
           call _cbrVD(R1) args: 0, res: 0, upd: 0;
       cbrVE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbrVD() //  [R1]
         { info_tbl: [(cbrVD,
                       label: block_cbrVD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrVD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbrVR; else goto cbrVQ;
       cbrVR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbrVQ: // global
           _sbo5P::P64 = P64[R1 + 7];
           _sbo5Q::P64 = P64[R1 + 15];
           _sbo5O::I64 = I64[R1 + 23];
           _sbo5R::I64 = I64[R1 + 31];
           _sbo5T::I64 = I64[R1 + 47];
           _sbo5U::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo5P::P64;
           P64[Hp - 32] = _sbo5Q::P64;
           I64[Hp - 24] = _sbo5O::I64;
           I64[Hp - 16] = _sbo5R::I64;
           I64[Hp - 8] = _sbo5U::I64;
           I64[Hp] = _sbo5T::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo6i_entry() //  [R1, R2]
         { info_tbl: [(cbrVT,
                       label: sat_sbo6i_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrVT: // global
           if ((Sp + -176) < SpLim) (likely: False) goto cbrVU; else goto cbrVV;
       cbrVU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbrVV: // global
           I64[Sp - 24] = block_cbrUu_info;
           _sbo2H::P64 = P64[R1 + 6];
           _sbo2J::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbo2H::P64;
           P64[Sp - 8] = _sbo2J::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubs1v; else goto cbrUv;
       ubs1v: // global
           call _cbrUu(R1) args: 0, res: 0, upd: 0;
       cbrUv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrUu() //  [R1]
         { info_tbl: [(cbrUu,
                       label: block_cbrUu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrUu: // global
           I64[Sp - 104] = block_cbrUz_info;
           _sbo2O::P64 = P64[R1 + 7];
           _sbo2P::P64 = P64[R1 + 15];
           _sbo2Q::P64 = P64[R1 + 23];
           _sbo2R::P64 = P64[R1 + 31];
           _sbo2S::P64 = P64[R1 + 39];
           _sbo2T::P64 = P64[R1 + 47];
           _sbo2U::P64 = P64[R1 + 55];
           _sbo2V::P64 = P64[R1 + 63];
           _sbo2W::P64 = P64[R1 + 71];
           _sbo2X::P64 = P64[R1 + 79];
           _sbo2Y::P64 = P64[R1 + 87];
           _sbo2Z::P64 = P64[R1 + 95];
           _sbo33::P64 = P64[R1 + 127];
           R1 = P64[_sbo2W::P64 + 8];
           P64[Sp - 96] = _sbo2P::P64;
           P64[Sp - 88] = _sbo2Q::P64;
           P64[Sp - 80] = _sbo2R::P64;
           P64[Sp - 72] = _sbo2S::P64;
           P64[Sp - 64] = _sbo2T::P64;
           P64[Sp - 56] = _sbo2U::P64;
           P64[Sp - 48] = _sbo2V::P64;
           P64[Sp - 40] = _sbo2W::P64;
           P64[Sp - 32] = _sbo2X::P64;
           P64[Sp - 24] = _sbo2Y::P64;
           P64[Sp - 16] = _sbo2Z::P64;
           P64[Sp - 8] = _sbo33::P64;
           P64[Sp] = _sbo2O::P64;
           Sp = Sp - 104;
           if (R1 & 7 != 0) goto ubs1i; else goto cbrUA;
       ubs1i: // global
           call _cbrUz(R1) args: 0, res: 0, upd: 0;
       cbrUA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrUz() //  [R1]
         { info_tbl: [(cbrUz,
                       label: block_cbrUz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrUz: // global
           I64[Sp - 16] = block_cbrUG_info;
           _sbo3c::I64 = I64[R1 + 39];
           _sbo3d::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo3d::I64;
           I64[Sp] = _sbo3c::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubs1j; else goto cbrUH;
       ubs1j: // global
           call _cbrUG(R1) args: 0, res: 0, upd: 0;
       cbrUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrUG() //  [R1]
         { info_tbl: [(cbrUG,
                       label: block_cbrUG_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrUG: // global
           if (R1 & 7 == 1) goto cbrZH; else goto cbs0C;
       cbrZH: // global
           _sbo5c::P64 = P64[P64[Sp + 80] + 8];
           I64[Sp + 16] = block_cbrUL_info;
           R1 = _sbo5c::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubs1k; else goto cbrUM;
       ubs1k: // global
           call _cbrUL(R1) args: 0, res: 0, upd: 0;
       cbrUM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbs0C: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubs13; else goto cbs0A;
       ubs13: // global
           Sp = Sp + 24;
           call _sbo3e() args: 0, res: 0, upd: 0;
       cbs0A: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 144;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrUL() //  [R1]
         { info_tbl: [(cbrUL,
                       label: block_cbrUL_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrUL: // global
           I64[Sp - 16] = block_cbrUQ_info;
           _sbo5i::I64 = I64[R1 + 39];
           _sbo5j::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo5j::I64;
           I64[Sp] = _sbo5i::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubs1m; else goto cbrUR;
       ubs1m: // global
           call _cbrUQ(R1) args: 0, res: 0, upd: 0;
       cbrUR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrUQ() //  [R1]
         { info_tbl: [(cbrUQ,
                       label: block_cbrUQ_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrUQ: // global
           if (R1 & 7 == 1) goto cbs0p; else goto ubs14;
       cbs0p: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubs15; else goto cbrZL;
       ubs15: // global
           Sp = Sp + 24;
           goto ubs1p;
       cbrZL: // global
           _sbo5o::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cbrUY_info;
           R1 = _sbo5o::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubs1n; else goto cbrUZ;
       ubs1n: // global
           call _cbrUY(R1) args: 0, res: 0, upd: 0;
       cbrUZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubs14: // global
           Sp = Sp + 24;
           goto ubs1p;
       ubs1p: // global
           call _sbo3e() args: 0, res: 0, upd: 0;
     }
 },
 _cbrUY() //  [R1]
         { info_tbl: [(cbrUY,
                       label: block_cbrUY_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrUY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrZO; else goto cbrZN;
       cbrZO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrZN: // global
           _sbo2W::P64 = P64[Sp + 64];
           _sbo5q::P64 = P64[R1 + 7];
           _sbo5r::P64 = P64[R1 + 15];
           _sbo5u::P64 = P64[_sbo2W::P64 + 8];
           I64[Hp - 16] = sat_sbo5C_info;
           P64[Hp] = _sbo5u::P64;
           call MO_WriteBarrier();
           P64[_sbo2W::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2W::P64);
           I64[Sp - 8] = block_cbrVn_info;
           R1 = _sbo5u::P64;
           P64[Sp] = _sbo5r::P64;
           P64[Sp + 56] = _sbo5q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubs1q; else goto cbrVo;
       ubs1q: // global
           call _cbrVn(R1) args: 0, res: 0, upd: 0;
       cbrVo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrVn() //  [R1]
         { info_tbl: [(cbrVn,
                       label: block_cbrVn_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrVn: // global
           _sbo5L::I64 = I64[R1 + 39];
           if (_sbo5L::I64 != 0) goto cbrZR; else goto cbs0m;
       cbrZR: // global
           I64[Sp - 32] = block_cbrVu_info;
           _sbo5G::P64 = P64[R1 + 7];
           _sbo5H::P64 = P64[R1 + 15];
           _sbo5F::I64 = I64[R1 + 23];
           R1 = P64[Sp + 96];
           P64[Sp - 24] = _sbo5G::P64;
           P64[Sp - 16] = _sbo5H::P64;
           I64[Sp - 8] = _sbo5L::I64;
           I64[Sp] = _sbo5F::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubs1r; else goto cbrVv;
       ubs1r: // global
           call _cbrVu(R1) args: 0, res: 0, upd: 0;
       cbrVv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbs0m: // global
           _sbo2T::P64 = P64[Sp + 48];
           _sbo5r::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbo2T::P64 + 8] = _sbo5r::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2T::P64);
           Sp = Sp + 16;
           call _sbo3e() args: 0, res: 0, upd: 0;
     }
 },
 _cbrVu() //  [R1]
         { info_tbl: [(cbrVu,
                       label: block_cbrVu_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrVu: // global
           if (R1 & 7 == 1) goto cbrZT; else goto cbs0b;
       cbrZT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbrZW; else goto cbrZV;
       cbrZW: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrZV: // global
           I64[Hp - 24] = sat_sbo5V_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 24];
           _sbo2T::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sbo2T::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2T::P64);
           Sp = Sp + 48;
           call _sbo3e() args: 0, res: 0, upd: 0;
       cbs0b: // global
           I64[Sp] = block_cbrZZ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubs1t; else goto cbs00;
       ubs1t: // global
           call _cbrZZ(R1) args: 0, res: 0, upd: 0;
       cbs00: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrZZ() //  [R1]
         { info_tbl: [(cbrZZ,
                       label: block_cbrZZ_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrZZ: // global
           I64[Sp - 8] = block_cbs04_info;
           R2 = P64[Sp + 96];
           _sbo5Z::P64 = P64[R1 + 7];
           _sbo60::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbo60::P64;
           P64[Sp + 96] = _sbo5Z::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbs04() //  [R1]
         { info_tbl: [(cbs04,
                       label: block_cbs04_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs04: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbs0f; else goto cbs0e;
       cbs0f: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbs0e: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbo5r::P64 = P64[Sp + 48];
           I64[Sp + 48] = block_cbs07_info;
           R5 = Hp - 47;
           R4 = _sbo5r::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 104];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbs07() //  [R1]
         { info_tbl: [(cbs07,
                       label: block_cbs07_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs07: // global
           I64[Sp] = block_cbs09_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubs1N; else goto cbs0h;
       ubs1N: // global
           call _cbs09(R1) args: 0, res: 0, upd: 0;
       cbs0h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbs09() //  [R1]
         { info_tbl: [(cbs09,
                       label: block_cbs09_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs09: // global
           _sbo2T::P64 = P64[Sp + 40];
           _sbo6c::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbo2T::P64 + 8] = _sbo6c::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo2T::P64);
           Sp = Sp + 8;
           call _sbo3e() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3e() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3e: // global
           I64[Sp - 8] = block_cbrW3_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubs1P; else goto cbrYF;
       ubs1P: // global
           call _cbrW3(R1) args: 0, res: 0, upd: 0;
       cbrYF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrW3() //  [R1]
         { info_tbl: [(cbrW3,
                       label: block_cbrW3_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrW3: // global
           if (R1 & 7 == 1) goto cbrYM; else goto cbrZb;
       cbrYM: // global
           I64[Sp] = block_cbrYJ_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubs1w; else goto cbrYN;
       ubs1w: // global
           call _cbrYJ(R1) args: 0, res: 0, upd: 0;
       cbrYN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbrZb: // global
           I64[Sp] = block_cbrZ9_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubs1x; else goto cbrZc;
       ubs1x: // global
           call _cbrZ9(R1) args: 0, res: 0, upd: 0;
       cbrZc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrYJ() //  [R1]
         { info_tbl: [(cbrYJ,
                       label: block_cbrYJ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrYJ: // global
           if (R1 & 7 == 1) goto ubs1b; else goto cbrZ3;
       ubs1b: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
       cbrZ3: // global
           I64[Sp] = block_cbrYW_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubs1G; else goto cbrYX;
       ubs1G: // global
           call _cbrYW(R1) args: 0, res: 0, upd: 0;
       cbrYX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrYW() //  [R1]
         { info_tbl: [(cbrYW,
                       label: block_cbrYW_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrYW: // global
           I64[Sp] = block_cbrZ1_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrZ1() //  []
         { info_tbl: [(cbrZ1,
                       label: block_cbrZ1_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrZ1: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
     }
 },
 _cbrZ9() //  [R1]
         { info_tbl: [(cbrZ9,
                       label: block_cbrZ9_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrZ9: // global
           I64[Sp] = block_cbrZg_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrZg() //  []
         { info_tbl: [(cbrZg,
                       label: block_cbrZg_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrZg: // global
           I64[Sp] = block_cbrZi_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubs1J; else goto cbrZl;
       ubs1J: // global
           call _cbrZi(R1) args: 0, res: 0, upd: 0;
       cbrZl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrZi() //  [R1]
         { info_tbl: [(cbrZi,
                       label: block_cbrZi_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrZi: // global
           if (R1 & 7 == 1) goto ubs19; else goto cbrZB;
       ubs19: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
       cbrZB: // global
           I64[Sp] = block_cbrZu_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubs1K; else goto cbrZv;
       ubs1K: // global
           call _cbrZu(R1) args: 0, res: 0, upd: 0;
       cbrZv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrZu() //  [R1]
         { info_tbl: [(cbrZu,
                       label: block_cbrZu_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrZu: // global
           I64[Sp] = block_cbrZz_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrZz() //  []
         { info_tbl: [(cbrZz,
                       label: block_cbrZz_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrZz: // global
           Sp = Sp + 8;
           call _sbo3g() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3g: // global
           I64[Sp - 8] = block_cbrWa_info;
           R1 = P64[Sp + 104];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubs1Q; else goto cbrYj;
       ubs1Q: // global
           call _cbrWa(R1) args: 0, res: 0, upd: 0;
       cbrYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrWa() //  [R1]
         { info_tbl: [(cbrWa,
                       label: block_cbrWa_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrWa: // global
           if (R1 & 7 == 1) goto cbrYq; else goto cbrYE;
       cbrYq: // global
           I64[Sp] = block_cbrYn_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubs1y; else goto cbrYr;
       ubs1y: // global
           call _cbrYn(R1) args: 0, res: 0, upd: 0;
       cbrYr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbrYE: // global
           P64[Sp + 112] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbo3i() args: 0, res: 0, upd: 0;
     }
 },
 _cbrYn() //  [R1]
         { info_tbl: [(cbrYn,
                       label: block_cbrYn_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrYn: // global
           I64[Sp] = block_cbrYv_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrYv() //  [R1]
         { info_tbl: [(cbrYv,
                       label: block_cbrYv_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrYv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbrYA; else goto cbrYz;
       cbrYA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrYz: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 112] = Hp - 6;
           Sp = Sp + 8;
           call _sbo3i() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3i() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3i: // global
           I64[Sp - 8] = block_cbrWf_info;
           R1 = P64[Sp + 104];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubs1R; else goto cbrWh;
       ubs1R: // global
           call _cbrWf(R1) args: 0, res: 0, upd: 0;
       cbrWh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrWf() //  [R1]
         { info_tbl: [(cbrWf,
                       label: block_cbrWf_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrWf: // global
           if (R1 & 7 == 1) goto cbrWq; else goto cbrWB;
       cbrWq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrWt; else goto cbrWs;
       cbrWt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrWs: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbrWm_info;
           R1 = Hp - 15;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbrWB: // global
           I64[Sp] = block_cbrWz_info;
           _sbo3l::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 112] = _sbo3l::P64;
           if (R1 & 7 != 0) goto ubs1A; else goto cbrWC;
       ubs1A: // global
           call _cbrWz(R1) args: 0, res: 0, upd: 0;
       cbrWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrWm() //  [R1]
         { info_tbl: [(cbrWm,
                       label: block_cbrWm_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrWm: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbrWw; else goto cbrWv;
       cbrWw: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrWv: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrWz() //  [R1]
         { info_tbl: [(cbrWz,
                       label: block_cbrWz_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrWz: // global
           I64[Sp] = block_cbrWI_info;
           _sbo3x::P64 = P64[R1 + 15];
           _sbo3y::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp + 80] = _sbo3y::P64;
           P64[Sp + 88] = _sbo3x::P64;
           if (R1 & 7 != 0) goto ubs1B; else goto cbrXU;
       ubs1B: // global
           call _cbrWI(R1) args: 0, res: 0, upd: 0;
       cbrXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrWI() //  [R1]
         { info_tbl: [(cbrWI,
                       label: block_cbrWI_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrWI: // global
           _sbo3x::P64 = P64[Sp + 88];
           _cbs0W::P64 = R1 & 7;
           if (_cbs0W::P64 != 3) goto ubs10; else goto cbrY5;
       ubs10: // global
           if (_cbs0W::P64 != 6) goto cbrY0; else goto cbrYe;
       cbrY0: // global
           P64[Sp + 88] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbo3z() args: 0, res: 0, upd: 0;
       cbrYe: // global
           I64[Sp] = block_cbrYc_info;
           R1 = _sbo3x::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbrY5: // global
           I64[Sp] = block_cbrY3_info;
           R1 = _sbo3x::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrYc() //  [R1]
         { info_tbl: [(cbrYc,
                       label: block_cbrYc_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrYc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbrYi; else goto cbrYh;
       cbrYi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrYh: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 88] = Hp - 6;
           Sp = Sp + 8;
           call _sbo3z() args: 0, res: 0, upd: 0;
     }
 },
 _cbrY3() //  [R1]
         { info_tbl: [(cbrY3,
                       label: block_cbrY3_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrY3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbrY9; else goto cbrY8;
       cbrY9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrY8: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 88] = Hp - 6;
           Sp = Sp + 8;
           call _sbo3z() args: 0, res: 0, upd: 0;
     }
 },
 _sbo3z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo3z: // global
           I64[Sp - 8] = block_cbrWN_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubs1S; else goto cbrWP;
       ubs1S: // global
           call _cbrWN(R1) args: 0, res: 0, upd: 0;
       cbrWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrWN() //  [R1]
         { info_tbl: [(cbrWN,
                       label: block_cbrWN_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrWN: // global
           _sbo3y::P64 = P64[Sp + 80];
           _cbs0Z::P64 = R1 & 7;
           if (_cbs0Z::P64 < 5) goto ubs11; else goto ubs12;
       ubs11: // global
           if (_cbs0Z::P64 < 4) goto cbrWY; else goto cbrXf;
       cbrWY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrX1; else goto cbrX0;
       cbrX1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrX0: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbrWU_info;
           _sbo3C::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo3C::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbrXf: // global
           I64[Sp] = block_cbrX7_info;
           R1 = _sbo3y::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ubs12: // global
           if (_cbs0Z::P64 < 6) goto cbrXw; else goto cbrXN;
       cbrXw: // global
           I64[Sp] = block_cbrXo_info;
           R1 = _sbo3y::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbrXN: // global
           I64[Sp] = block_cbrXF_info;
           R1 = _sbo3y::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrWU() //  [R1]
         { info_tbl: [(cbrWU,
                       label: block_cbrWU_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrWU: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbrX4; else goto cbrX3;
       cbrX4: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrX3: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrX7() //  [R1]
         { info_tbl: [(cbrX7,
                       label: block_cbrX7_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrX7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrXi; else goto cbrXh;
       cbrXi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrXh: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbrXa_info;
           _sbo3N::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo3N::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrXa() //  [R1]
         { info_tbl: [(cbrXa,
                       label: block_cbrXa_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrXa: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbrXl; else goto cbrXk;
       cbrXl: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrXk: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrXo() //  [R1]
         { info_tbl: [(cbrXo,
                       label: block_cbrXo_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrXo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrXz; else goto cbrXy;
       cbrXz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrXy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbrXr_info;
           _sbo3Z::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo3Z::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrXr() //  [R1]
         { info_tbl: [(cbrXr,
                       label: block_cbrXr_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrXr: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbrXC; else goto cbrXB;
       cbrXC: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrXB: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.AppendHandle_closure+5;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbrXF() //  [R1]
         { info_tbl: [(cbrXF,
                       label: block_cbrXF_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrXF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbrXQ; else goto cbrXP;
       cbrXQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrXP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbrXI_info;
           _sbo4b::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbo4b::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbrXI() //  [R1]
         { info_tbl: [(cbrXI,
                       label: block_cbrXI_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbrXI: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbrXT; else goto cbrXS;
       cbrXT: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbrXS: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbo2J::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbo2J::P64;
           P64[Hp - 8] = _sbo2J::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetBinaryMode1_entry() //  [R2, R3]
         { info_tbl: [(cbs1T,
                       label: GHC.IO.Handle.hSetBinaryMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs1T: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbs1X; else goto cbs1W;
       cbs1X: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetBinaryMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbs1W: // global
           I64[Hp - 40] = lvl48_sbo2J_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbo6i_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = R2;
           R2 = lvl9_rbnWR_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.700629036 UTC

[section ""data" . GHC.IO.Handle.hSetBinaryMode_closure" {
     GHC.IO.Handle.hSetBinaryMode_closure:
         const GHC.IO.Handle.hSetBinaryMode_info;
         const 0;
 },
 GHC.IO.Handle.hSetBinaryMode_entry() //  [R2, R3]
         { info_tbl: [(cbs6M,
                       label: GHC.IO.Handle.hSetBinaryMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs6M: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetBinaryMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.703928342 UTC

[section ""cstring" . GHC.IO.Handle.hIsSeekable4_bytes" {
     GHC.IO.Handle.hIsSeekable4_bytes:
         I8[] [104,73,115,83,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.705823448 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable3_closure" {
     GHC.IO.Handle.hIsSeekable3_closure:
         const GHC.IO.Handle.hIsSeekable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable3_entry() //  [R1]
         { info_tbl: [(cbs70,
                       label: GHC.IO.Handle.hIsSeekable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbs71; else goto cbs72;
       cbs71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbs72: // global
           (_cbs6X::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbs6X::I64 == 0) goto cbs6Z; else goto cbs6Y;
       cbs6Z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbs6Y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbs6X::I64;
           R2 = GHC.IO.Handle.hIsSeekable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.711177402 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable2_closure" {
     GHC.IO.Handle.hIsSeekable2_closure:
         const GHC.IO.Handle.hIsSeekable2_info;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable2_entry() //  [R2]
         { info_tbl: [(cbs7h,
                       label: GHC.IO.Handle.hIsSeekable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs7h: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbs7i; else goto cbs7j;
       cbs7i: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsSeekable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbs7j: // global
           I64[Sp - 8] = block_cbs7e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubs7U; else goto cbs7f;
       ubs7U: // global
           call _cbs7e(R1) args: 0, res: 0, upd: 0;
       cbs7f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbs7e() //  [R1]
         { info_tbl: [(cbs7e,
                       label: block_cbs7e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs7e: // global
           I64[Sp - 24] = block_cbs7m_info;
           _sbo6l::P64 = R1;
           _sbo6m::P64 = P64[R1 + 7];
           _sbo6p::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbo6m::P64;
           P64[Sp - 8] = _sbo6p::P64;
           P64[Sp] = _sbo6l::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubs7T; else goto cbs7o;
       ubs7T: // global
           call _cbs7m(R1) args: 0, res: 0, upd: 0;
       cbs7o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbs7m() //  [R1]
         { info_tbl: [(cbs7m,
                       label: block_cbs7m_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs7m: // global
           _cbs7Q::P64 = R1 & 7;
           if (_cbs7Q::P64 < 3) goto ubs7R; else goto ubs7S;
       ubs7R: // global
           if (_cbs7Q::P64 < 2) goto cbs7E; else goto cbs7I;
       cbs7E: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbs7I: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       ubs7S: // global
           if (_cbs7Q::P64 == 5) goto cbs7M; else goto cbs7x;
       cbs7M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbs7P; else goto cbs7O;
       cbs7P: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbs7O: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbs7x: // global
           _sbo6p::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbs7s_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbo6p::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbs7s() //  [R1]
         { info_tbl: [(cbs7s,
                       label: block_cbs7s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs7s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbs7A; else goto cbs7z;
       cbs7A: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbs7z: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.722514538 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable1_closure" {
     GHC.IO.Handle.hIsSeekable1_closure:
         const GHC.IO.Handle.hIsSeekable1_info;
         const 0;
 },
 io_sbo6S_entry() //  [R1]
         { info_tbl: [(cbs8B,
                       label: io_sbo6S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs8B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbs8F; else goto cbs8G;
       cbs8F: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbs8G: // global
           I64[Sp - 16] = block_cbs8w_info;
           _sbo6O::P64 = P64[R1 + 15];
           R5 = _sbo6O::P64;
           R4 = GHC.IO.Handle.hIsSeekable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsSeekable3_closure;
           P64[Sp - 8] = _sbo6O::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbs8w() //  [R1]
         { info_tbl: [(cbs8w,
                       label: block_cbs8w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs8w: // global
           I64[Sp] = block_cbs8y_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubs8L; else goto cbs8z;
       ubs8L: // global
           call _cbs8y(R1) args: 0, res: 0, upd: 0;
       cbs8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbs8y() //  [R1]
         { info_tbl: [(cbs8y,
                       label: block_cbs8y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs8y: // global
           I64[Sp] = block_cbs8E_info;
           R2 = P64[R1 + 7];
           _sbo6Z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo6Z::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbs8E() //  []
         { info_tbl: [(cbs8E,
                       label: block_cbs8E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs8E: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbo78_entry() //  [R1]
         { info_tbl: [(cbs90,
                       label: io_sbo78_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs90: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbs94; else goto cbs95;
       cbs94: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbs95: // global
           I64[Sp - 16] = block_cbs8V_info;
           _sbo73::P64 = P64[R1 + 15];
           R5 = _sbo73::P64;
           R4 = GHC.IO.Handle.hIsSeekable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsSeekable3_closure;
           P64[Sp - 8] = _sbo73::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbs8V() //  [R1]
         { info_tbl: [(cbs8V,
                       label: block_cbs8V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs8V: // global
           I64[Sp] = block_cbs8X_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubs9a; else goto cbs8Y;
       ubs9a: // global
           call _cbs8X(R1) args: 0, res: 0, upd: 0;
       cbs8Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbs8X() //  [R1]
         { info_tbl: [(cbs8X,
                       label: block_cbs8X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs8X: // global
           I64[Sp] = block_cbs93_info;
           R2 = P64[R1 + 7];
           _sbo7f::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbo7f::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbs93() //  []
         { info_tbl: [(cbs93,
                       label: block_cbs93_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs93: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsSeekable1_entry() //  [R2]
         { info_tbl: [(cbs9f,
                       label: GHC.IO.Handle.hIsSeekable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs9f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbs9g; else goto cbs9h;
       cbs9g: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsSeekable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbs9h: // global
           I64[Sp - 8] = block_cbs8k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubs9y; else goto cbs8l;
       ubs9y: // global
           call _cbs8k(R1) args: 0, res: 0, upd: 0;
       cbs8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbs8k() //  [R1]
         { info_tbl: [(cbs8k,
                       label: block_cbs8k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs8k: // global
           if (R1 & 7 == 1) goto cbs9c; else goto cbs9d;
       cbs9c: // global
           I64[Sp - 16] = block_cbs8p_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbs9d: // global
           I64[Sp - 16] = block_cbs8O_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbs8p() //  [R1]
         { info_tbl: [(cbs8p,
                       label: block_cbs8p_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs8p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbs9l; else goto cbs9k;
       cbs9l: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbs9k: // global
           I64[Hp - 16] = io_sbo6S_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbs8r::P64 = Hp - 15;
           if (R1 == 0) goto cbs9p; else goto cbs9o;
       cbs9p: // global
           R1 = _cbs8r::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbs9o: // global
           R1 = _cbs8r::P64;
           Sp = Sp + 24;
           call io_sbo6S_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbs8O() //  [R1]
         { info_tbl: [(cbs8O,
                       label: block_cbs8O_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbs8O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbs9t; else goto cbs9s;
       cbs9t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbs9s: // global
           I64[Hp - 16] = io_sbo78_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbs8Q::P64 = Hp - 15;
           if (R1 == 0) goto cbs9x; else goto cbs9w;
       cbs9x: // global
           R1 = _cbs8Q::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbs9w: // global
           R1 = _cbs8Q::P64;
           Sp = Sp + 24;
           call io_sbo78_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.745592455 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable_closure" {
     GHC.IO.Handle.hIsSeekable_closure:
         const GHC.IO.Handle.hIsSeekable_info;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable_entry() //  [R2]
         { info_tbl: [(cbsau,
                       label: GHC.IO.Handle.hIsSeekable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsau: // global
           R2 = R2;
           call GHC.IO.Handle.hIsSeekable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.749547731 UTC

[section ""cstring" . GHC.IO.Handle.hGetPosn4_bytes" {
     GHC.IO.Handle.hGetPosn4_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.75135263 UTC

[section ""data" . GHC.IO.Handle.hGetPosn3_closure" {
     GHC.IO.Handle.hGetPosn3_closure:
         const GHC.IO.Handle.hGetPosn3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetPosn3_entry() //  [R1]
         { info_tbl: [(cbsaI,
                       label: GHC.IO.Handle.hGetPosn3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsaI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsaJ; else goto cbsaK;
       cbsaJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsaK: // global
           (_cbsaF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsaF::I64 == 0) goto cbsaH; else goto cbsaG;
       cbsaH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsaG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsaF::I64;
           R2 = GHC.IO.Handle.hGetPosn4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.758239083 UTC

[section ""data" . GHC.IO.Handle.hGetPosn2_closure" {
     GHC.IO.Handle.hGetPosn2_closure:
         const GHC.IO.Handle.hGetPosn2_info;
         const 0;
 },
 sat_sbo88_entry() //  [R1]
         { info_tbl: [(cbsbk,
                       label: sat_sbo88_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsbk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbsbl; else goto cbsbm;
       cbsbl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsbm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbsbh_info;
           _sbo7D::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbo7D::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubsbU; else goto cbsbi;
       ubsbU: // global
           call _cbsbh(R1) args: 0, res: 0, upd: 0;
       cbsbi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbsbh() //  [R1]
         { info_tbl: [(cbsbh,
                       label: block_cbsbh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsbh: // global
           I64[Sp - 16] = block_cbsbp_info;
           _sbo81::I64 = I64[R1 + 39];
           _sbo82::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo82::I64;
           I64[Sp] = _sbo81::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubsbT; else goto cbsbr;
       ubsbT: // global
           call _cbsbp(R1) args: 0, res: 0, upd: 0;
       cbsbr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbsbp() //  [R1]
         { info_tbl: [(cbsbp,
                       label: block_cbsbp_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsbp: // global
           _sbo81::I64 = I64[Sp + 16];
           _sbo82::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbsbB; else goto cbsbN;
       cbsbB: // global
           I64[Sp + 16] = block_cbsby_info;
           R2 = _sbo82::I64 - _sbo81::I64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
       cbsbN: // global
           I64[Sp + 16] = block_cbsbL_info;
           R2 = _sbo82::I64 - _sbo81::I64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbsby() //  [R1]
         { info_tbl: [(cbsby,
                       label: block_cbsby_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsby: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 _cbsbL() //  [R1]
         { info_tbl: [(cbsbL,
                       label: block_cbsbL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsbL: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo8C_entry() //  [R1]
         { info_tbl: [(cbscp,
                       label: sat_sbo8C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbscp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbsct; else goto cbscu;
       cbsct: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbscu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbscm_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubscy; else goto cbscn;
       ubscy: // global
           call _cbscm(R1) args: 0, res: 0, upd: 0;
       cbscn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbscm() //  [R1]
         { info_tbl: [(cbscm,
                       label: block_cbscm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbscm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbscx; else goto cbscw;
       cbscx: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbscw: // global
           _sbo8x::P64 = P64[R1 + 7];
           _sbo8y::P64 = P64[R1 + 15];
           _sbo8w::I64 = I64[R1 + 23];
           _sbo8z::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo8x::P64;
           P64[Hp - 32] = _sbo8y::P64;
           I64[Hp - 24] = _sbo8w::I64;
           I64[Hp - 16] = _sbo8z::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbo8V_entry() //  [R1]
         { info_tbl: [(cbscV,
                       label: sat_sbo8V_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbscV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbsd2; else goto cbsd3;
       cbsd2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsd3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbscS_info;
           _sbo8L::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbo8L::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubsd7; else goto cbscT;
       ubsd7: // global
           call _cbscS(R1) args: 0, res: 0, upd: 0;
       cbscT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbscS() //  [R1]
         { info_tbl: [(cbscS,
                       label: block_cbscS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbscS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbsd6; else goto cbsd5;
       cbsd6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbsd5: // global
           _sbo8P::P64 = P64[R1 + 7];
           _sbo8Q::P64 = P64[R1 + 15];
           _sbo8O::I64 = I64[R1 + 23];
           _sbo8R::I64 = I64[R1 + 31];
           _sbo8T::I64 = I64[R1 + 47];
           _sbo8U::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbo8P::P64;
           P64[Hp - 32] = _sbo8Q::P64;
           I64[Hp - 24] = _sbo8O::I64;
           I64[Hp - 16] = _sbo8R::I64;
           I64[Hp - 8] = _sbo8U::I64;
           I64[Hp] = _sbo8T::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.hGetPosn2_entry() //  [R2]
         { info_tbl: [(cbsd8,
                       label: GHC.IO.Handle.hGetPosn2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsd8: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbsd9; else goto cbsda;
       cbsd9: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetPosn2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsda: // global
           I64[Sp - 8] = block_cbsaW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubseK; else goto cbsaX;
       ubseK: // global
           call _cbsaW(R1) args: 0, res: 0, upd: 0;
       cbsaX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsaW() //  [R1]
         { info_tbl: [(cbsaW,
                       label: block_cbsaW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsaW: // global
           I64[Sp - 32] = block_cbsb1_info;
           R2 = P64[R1 + 7];
           I64[Sp - 48] = stg_ap_pv_info;
           P64[Sp - 40] = P64[R1 + 31];
           P64[Sp - 24] = P64[R1 + 63];
           P64[Sp - 16] = P64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 95];
           P64[Sp] = P64[R1 + 47];
           Sp = Sp - 48;
           call GHC.IO.Device.tell_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbsb1() //  [R1]
         { info_tbl: [(cbsb1,
                       label: block_cbsb1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsb1: // global
           _sbo7G::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp - 8] = block_cbsb3_info;
           _sbo7D::P64 = R1;
           R1 = _sbo7G::P64;
           P64[Sp] = _sbo7D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsex; else goto cbsb4;
       ubsex: // global
           call _cbsb3(R1) args: 0, res: 0, upd: 0;
       cbsb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsb3() //  [R1]
         { info_tbl: [(cbsb3,
                       label: block_cbsb3_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsb3: // global
           I64[Sp - 16] = block_cbsbV_info;
           _sbo7M::I64 = I64[R1 + 39];
           _sbo7N::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo7N::I64;
           I64[Sp] = _sbo7M::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubsey; else goto cbsbW;
       ubsey: // global
           call _cbsbV(R1) args: 0, res: 0, upd: 0;
       cbsbW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsbV() //  [R1]
         { info_tbl: [(cbsbV,
                       label: block_cbsbV_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsbV: // global
           if (R1 & 7 == 1) goto cbsdj; else goto cbsee;
       cbsdj: // global
           _sbo8c::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_cbsc0_info;
           R1 = _sbo8c::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubsez; else goto cbsc1;
       ubsez: // global
           call _cbsc0(R1) args: 0, res: 0, upd: 0;
       cbsc1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsee: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubses; else goto cbsec;
       ubses: // global
           Sp = Sp + 16;
           call _cbsbb() args: 0, res: 0, upd: 0;
       cbsec: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsc0() //  [R1]
         { info_tbl: [(cbsc0,
                       label: block_cbsc0_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsc0: // global
           I64[Sp - 16] = block_cbsc5_info;
           _sbo8i::I64 = I64[R1 + 39];
           _sbo8j::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbo8j::I64;
           I64[Sp] = _sbo8i::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubseB; else goto cbsc6;
       ubseB: // global
           call _cbsc5(R1) args: 0, res: 0, upd: 0;
       cbsc6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsc5() //  [R1]
         { info_tbl: [(cbsc5,
                       label: block_cbsc5_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsc5: // global
           if (R1 & 7 == 1) goto cbse1; else goto ubset;
       cbse1: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubseu; else goto cbsdn;
       ubseu: // global
           Sp = Sp + 16;
           goto ubseE;
       cbsdn: // global
           _sbo8o::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cbscd_info;
           R1 = _sbo8o::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubseC; else goto cbsce;
       ubseC: // global
           call _cbscd(R1) args: 0, res: 0, upd: 0;
       cbsce: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubset: // global
           Sp = Sp + 16;
           goto ubseE;
       ubseE: // global
           call _cbsbb() args: 0, res: 0, upd: 0;
     }
 },
 _cbscd() //  [R1]
         { info_tbl: [(cbscd,
                       label: block_cbscd_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbscd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbsdq; else goto cbsdp;
       cbsdq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsdp: // global
           _sbo7t::P64 = P64[Sp + 24];
           _sbo8q::P64 = P64[R1 + 7];
           _sbo8r::P64 = P64[R1 + 15];
           _sbo8u::P64 = P64[_sbo7t::P64 + 8];
           I64[Hp - 16] = sat_sbo8C_info;
           P64[Hp] = _sbo8u::P64;
           call MO_WriteBarrier();
           P64[_sbo7t::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7t::P64);
           I64[Sp - 8] = block_cbscC_info;
           R1 = _sbo8u::P64;
           P64[Sp] = _sbo8r::P64;
           P64[Sp + 16] = _sbo8q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubseF; else goto cbscD;
       ubseF: // global
           call _cbscC(R1) args: 0, res: 0, upd: 0;
       cbscD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbscC() //  [R1]
         { info_tbl: [(cbscC,
                       label: block_cbscC_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbscC: // global
           _sbo8L::I64 = I64[R1 + 39];
           if (_sbo8L::I64 != 0) goto cbsdt; else goto cbsdY;
       cbsdt: // global
           I64[Sp - 24] = block_cbscJ_info;
           _sbo8G::P64 = P64[R1 + 7];
           _sbo8H::P64 = P64[R1 + 15];
           _sbo8F::I64 = I64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _sbo8H::P64;
           I64[Sp - 8] = _sbo8L::I64;
           P64[Sp] = _sbo8G::P64;
           I64[Sp + 40] = _sbo8F::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubseG; else goto cbscK;
       ubseG: // global
           call _cbscJ(R1) args: 0, res: 0, upd: 0;
       cbscK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsdY: // global
           _sbo7q::P64 = P64[Sp + 48];
           _sbo8r::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbo7q::P64 + 8] = _sbo8r::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7q::P64);
           Sp = Sp + 8;
           call _cbsbb() args: 0, res: 0, upd: 0;
     }
 },
 _cbscJ() //  [R1]
         { info_tbl: [(cbscJ,
                       label: block_cbscJ_info
                       rep:StackRep [False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbscJ: // global
           if (R1 & 7 == 1) goto cbsdv; else goto cbsdN;
       cbsdv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbsdy; else goto cbsdx;
       cbsdy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsdx: // global
           I64[Hp - 24] = sat_sbo8V_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sbo7q::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sbo7q::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7q::P64);
           Sp = Sp + 32;
           call _cbsbb() args: 0, res: 0, upd: 0;
       cbsdN: // global
           I64[Sp] = block_cbsdB_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubseI; else goto cbsdC;
       ubseI: // global
           call _cbsdB(R1) args: 0, res: 0, upd: 0;
       cbsdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsdB() //  [R1]
         { info_tbl: [(cbsdB,
                       label: block_cbsdB_info
                       rep:StackRep [False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsdB: // global
           I64[Sp - 8] = block_cbsdG_info;
           R2 = P64[Sp + 48];
           _sbo8Z::P64 = P64[R1 + 7];
           _sbo90::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbo90::P64;
           P64[Sp + 48] = _sbo8Z::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsdG() //  [R1]
         { info_tbl: [(cbsdG,
                       label: block_cbsdG_info
                       rep:StackRep [False, False, True, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsdG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbsdR; else goto cbsdQ;
       cbsdR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsdQ: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbo8r::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbsdJ_info;
           R5 = Hp - 47;
           R4 = _sbo8r::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbsdJ() //  [R1]
         { info_tbl: [(cbsdJ,
                       label: block_cbsdJ_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsdJ: // global
           I64[Sp] = block_cbsdL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubseL; else goto cbsdT;
       ubseL: // global
           call _cbsdL(R1) args: 0, res: 0, upd: 0;
       cbsdT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsdL() //  [R1]
         { info_tbl: [(cbsdL,
                       label: block_cbsdL_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsdL: // global
           _sbo7q::P64 = P64[Sp + 40];
           _sbo9c::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbo7q::P64 + 8] = _sbo9c::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo7q::P64);
           call _cbsbb() args: 0, res: 0, upd: 0;
     }
 },
 _cbsbb() //  []
         { info_tbl: [(cbsbb,
                       label: block_cbsbb_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsbb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbsdg; else goto cbsdf;
       cbsdg: // global
           HpAlloc = 32;
           I64[Sp] = block_cbsbb_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbsdf: // global
           I64[Hp - 24] = sat_sbo88_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[P64[Sp + 40] + 8];
           R1 = Hp - 24;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.807100946 UTC

[section ""data" . GHC.IO.Handle.hTell1_closure" {
     GHC.IO.Handle.hTell1_closure:
         const GHC.IO.Handle.hTell1_info;
         const 0;
 },
 GHC.IO.Handle.hTell1_entry() //  [R2]
         { info_tbl: [(cbsgX,
                       label: GHC.IO.Handle.hTell1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsgX: // global
           R4 = GHC.IO.Handle.hGetPosn2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hGetPosn3_closure;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.810893736 UTC

[section ""data" . GHC.IO.Handle.hTell_closure" {
     GHC.IO.Handle.hTell_closure:
         const GHC.IO.Handle.hTell_info;
         const 0;
 },
 GHC.IO.Handle.hTell_entry() //  [R2]
         { info_tbl: [(cbsh8,
                       label: GHC.IO.Handle.hTell_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsh8: // global
           R2 = R2;
           call GHC.IO.Handle.hTell1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.813992388 UTC

[section ""cstring" . lvl12_rbnWU_bytes" {
     lvl12_rbnWU_bytes:
         I8[] [104,83,101,101,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.815848319 UTC

[section ""data" . lvl13_rbnWV_closure" {
     lvl13_rbnWV_closure:
         const lvl13_rbnWV_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rbnWV_entry() //  [R1]
         { info_tbl: [(cbshm,
                       label: lvl13_rbnWV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbshm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbshn; else goto cbsho;
       cbshn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsho: // global
           (_cbshj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbshj::I64 == 0) goto cbshl; else goto cbshk;
       cbshl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbshk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbshj::I64;
           R2 = lvl12_rbnWU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.819886449 UTC

[section ""data" . lvl14_rbnWW_closure" {
     lvl14_rbnWW_closure:
         const lvl14_rbnWW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_rbnWW_entry() //  [R1]
         { info_tbl: [(cbshC,
                       label: lvl14_rbnWW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbshC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbshD; else goto cbshE;
       cbshD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbshE: // global
           (_cbshz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbshz::I64 == 0) goto cbshB; else goto cbshA;
       cbshB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbshA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbshz::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.829274652 UTC

[section ""data" . GHC.IO.Handle.hSeek1_closure" {
     GHC.IO.Handle.hSeek1_closure:
         const GHC.IO.Handle.hSeek1_info;
         const 0;
 },
 lvl48_sbo9n_entry() //  [R1]
         { info_tbl: [(cbshW,
                       label: lvl48_sbo9n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbshW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbsi0; else goto cbsi1;
       cbsi0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsi1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbshU_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbshU() //  [R1]
         { info_tbl: [(cbshU,
                       label: block_cbshU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbshU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbsi4; else goto cbsi3;
       cbsi4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cbsi3: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl49_sbo9p_entry() //  [R1]
         { info_tbl: [(cbsib,
                       label: lvl49_sbo9p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsib: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbsif; else goto cbsig;
       cbsif: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsig: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbsi9_info;
           R3 = lvl14_rbnWW_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbsi9() //  [R1]
         { info_tbl: [(cbsi9,
                       label: block_cbsi9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsi9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbsij; else goto cbsii;
       cbsij: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cbsii: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboao_entry() //  [R1]
         { info_tbl: [(cbsj8,
                       label: sat_sboao_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsj8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbsjc; else goto cbsjd;
       cbsjc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsjd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbsj5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubsjh; else goto cbsj6;
       ubsjh: // global
           call _cbsj5(R1) args: 0, res: 0, upd: 0;
       cbsj6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbsj5() //  [R1]
         { info_tbl: [(cbsj5,
                       label: block_cbsj5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsj5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbsjg; else goto cbsjf;
       cbsjg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbsjf: // global
           _sboaj::P64 = P64[R1 + 7];
           _sboak::P64 = P64[R1 + 15];
           _sboai::I64 = I64[R1 + 23];
           _sboal::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sboaj::P64;
           P64[Hp - 32] = _sboak::P64;
           I64[Hp - 24] = _sboai::I64;
           I64[Hp - 16] = _sboal::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboaH_entry() //  [R1]
         { info_tbl: [(cbsjE,
                       label: sat_sboaH_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsjE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbsjL; else goto cbsjM;
       cbsjL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsjM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbsjB_info;
           _sboax::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sboax::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubsjQ; else goto cbsjC;
       ubsjQ: // global
           call _cbsjB(R1) args: 0, res: 0, upd: 0;
       cbsjC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbsjB() //  [R1]
         { info_tbl: [(cbsjB,
                       label: block_cbsjB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsjB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbsjP; else goto cbsjO;
       cbsjP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbsjO: // global
           _sboaB::P64 = P64[R1 + 7];
           _sboaC::P64 = P64[R1 + 15];
           _sboaA::I64 = I64[R1 + 23];
           _sboaD::I64 = I64[R1 + 31];
           _sboaF::I64 = I64[R1 + 47];
           _sboaG::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sboaB::P64;
           P64[Hp - 32] = _sboaC::P64;
           I64[Hp - 24] = _sboaA::I64;
           I64[Hp - 16] = _sboaD::I64;
           I64[Hp - 8] = _sboaG::I64;
           I64[Hp] = _sboaF::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbobs_entry() //  [R1]
         { info_tbl: [(cbskt,
                       label: sat_sbobs_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbskt: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbskA; else goto cbskB;
       cbskA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbskB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cbskq_info;
           _sbo9P::P64 = P64[R1 + 24];
           _sbo9O::I64 = I64[R1 + 32];
           _sbo9R::I64 = I64[R1 + 40];
           _sbo9S::I64 = I64[R1 + 48];
           _sbo9T::I64 = I64[R1 + 56];
           R1 = P64[R1 + 16];
           I64[Sp - 56] = _sbo9O::I64;
           P64[Sp - 48] = _sbo9P::P64;
           I64[Sp - 40] = _sbo9R::I64;
           I64[Sp - 32] = _sbo9S::I64;
           I64[Sp - 24] = _sbo9T::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubskF; else goto cbskr;
       ubskF: // global
           call _cbskq(R1) args: 0, res: 0, upd: 0;
       cbskr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbskq() //  [R1]
         { info_tbl: [(cbskq,
                       label: block_cbskq_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbskq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbskE; else goto cbskD;
       cbskE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbskD: // global
           _sbobr::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = _sbobr::I64;
           I64[Hp] = I64[Sp + 40];
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbobV_entry() //  [R1, R2]
         { info_tbl: [(cbskG,
                       label: sat_sbobV_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbskG: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cbskH; else goto cbskI;
       cbskH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbskI: // global
           I64[Sp - 40] = block_cbsip_info;
           _sbo9k::P64 = P64[R1 + 6];
           _sbo9l::P64 = P64[R1 + 14];
           _sbo9n::P64 = P64[R1 + 22];
           _sbo9p::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 32] = _sbo9k::P64;
           P64[Sp - 24] = _sbo9l::P64;
           P64[Sp - 16] = _sbo9n::P64;
           P64[Sp - 8] = _sbo9p::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubsnz; else goto cbsiq;
       ubsnz: // global
           call _cbsip(R1) args: 0, res: 0, upd: 0;
       cbsiq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsip() //  [R1]
         { info_tbl: [(cbsip,
                       label: block_cbsip_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsip: // global
           I64[Sp - 64] = block_cbsiu_info;
           _sbo9t::P64 = R1;
           _sbo9u::P64 = P64[R1 + 7];
           _sbo9v::P64 = P64[R1 + 15];
           _sbo9x::P64 = P64[R1 + 31];
           _sbo9z::P64 = P64[R1 + 47];
           _sbo9B::P64 = P64[R1 + 63];
           _sbo9C::P64 = P64[R1 + 71];
           _sbo9F::P64 = P64[R1 + 95];
           R1 = P64[_sbo9C::P64 + 8];
           P64[Sp - 56] = _sbo9u::P64;
           P64[Sp - 48] = _sbo9v::P64;
           P64[Sp - 40] = _sbo9x::P64;
           P64[Sp - 32] = _sbo9z::P64;
           P64[Sp - 24] = _sbo9B::P64;
           P64[Sp - 16] = _sbo9C::P64;
           P64[Sp - 8] = _sbo9F::P64;
           P64[Sp] = _sbo9t::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubsnk; else goto cbsiv;
       ubsnk: // global
           call _cbsiu(R1) args: 0, res: 0, upd: 0;
       cbsiv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsiu() //  [R1]
         { info_tbl: [(cbsiu,
                       label: block_cbsiu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsiu: // global
           I64[Sp - 40] = block_cbsiz_info;
           _sbo9P::P64 = P64[R1 + 7];
           _sbo9O::I64 = I64[R1 + 23];
           _sbo9R::I64 = I64[R1 + 31];
           _sbo9S::I64 = I64[R1 + 39];
           _sbo9T::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _sbo9P::P64;
           I64[Sp - 24] = _sbo9R::I64;
           I64[Sp - 16] = _sbo9S::I64;
           I64[Sp - 8] = _sbo9T::I64;
           I64[Sp] = _sbo9O::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubsnl; else goto cbsiA;
       ubsnl: // global
           call _cbsiz(R1) args: 0, res: 0, upd: 0;
       cbsiA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsiz() //  [R1]
         { info_tbl: [(cbsiz,
                       label: block_cbsiz_info
                       rep:StackRep [False, True, True, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsiz: // global
           if (R1 & 7 == 1) goto cbsm0; else goto cbsmv;
       cbsm0: // global
           I64[Sp] = block_cbsjR_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto ubsnm; else goto cbsjS;
       ubsnm: // global
           call _cbsjR(R1) args: 0, res: 0, upd: 0;
       cbsjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsmv: // global
           _sbobx::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 40] = block_cbsmt_info;
           R1 = _sbobx::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ubsnn; else goto cbsmw;
       ubsnn: // global
           call _cbsmt(R1) args: 0, res: 0, upd: 0;
       cbsmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsjR() //  [R1]
         { info_tbl: [(cbsjR,
                       label: block_cbsjR_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsjR: // global
           if (R1 & 7 == 2) goto cbsm6; else goto ubsng;
       cbsm6: // global
           I64[Sp] = block_cbsjX_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto ubsnt; else goto cbsjY;
       ubsnt: // global
           call _cbsjX(R1) args: 0, res: 0, upd: 0;
       cbsjY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubsng: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _cbsjX() //  [R1]
         { info_tbl: [(cbsjX,
                       label: block_cbsjX_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsjX: // global
           if (R1 & 7 == 1) goto cbsm9; else goto ubsnh;
       cbsm9: // global
           I64[Sp] = block_cbsk2_info;
           R1 = P64[Sp + 136];
           if (R1 & 7 != 0) goto ubsnv; else goto cbsk3;
       ubsnv: // global
           call _cbsk2(R1) args: 0, res: 0, upd: 0;
       cbsk3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubsnh: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _cbsk2() //  [R1]
         { info_tbl: [(cbsk2,
                       label: block_cbsk2_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsk2: // global
           if (I64[R1 + 7] == 1) goto cbsmd; else goto ubsni;
       cbsmd: // global
           _sbobm::I64 = I64[Sp + 32] - I64[Sp + 24];
           I64[Sp] = block_cbskd_info;
           R2 = _sbobm::I64;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       ubsni: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _cbskd() //  [R1]
         { info_tbl: [(cbskd,
                       label: block_cbskd_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbskd: // global
           I64[Sp] = block_cbskh_info;
           R3 = R1;
           R2 = P64[Sp + 120];
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbskh() //  [R1]
         { info_tbl: [(cbskh,
                       label: block_cbskh_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbskh: // global
           if (R1 == 1) goto cbsmj; else goto ubsnj;
       cbsmj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbsmm; else goto cbsml;
       cbsmm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbsml: // global
           I64[Hp - 56] = sat_sbobs_info;
           P64[Hp - 40] = P64[Sp + 128];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 32];
           _sbo9C::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sbo9C::P64 + 8] = Hp - 56;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9C::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ubsnj: // global
           Sp = Sp + 48;
           call _sbo9V() args: 0, res: 0, upd: 0;
     }
 },
 _sbo9V() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbo9V: // global
           _sbo9Y::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 8] = block_cbsiJ_info;
           R1 = _sbo9Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsnF; else goto cbsiK;
       ubsnF: // global
           call _cbsiJ(R1) args: 0, res: 0, upd: 0;
       cbsiK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsiJ() //  [R1]
         { info_tbl: [(cbsiJ,
                       label: block_cbsiJ_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsiJ: // global
           I64[Sp] = block_cbsiO_info;
           _sboa4::I64 = I64[R1 + 39];
           _sboa5::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp + 88] = _sboa5::I64;
           I64[Sp + 96] = _sboa4::I64;
           if (R1 & 7 != 0) goto ubsno; else goto cbsiP;
       ubsno: // global
           call _cbsiO(R1) args: 0, res: 0, upd: 0;
       cbsiP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsiO() //  [R1]
         { info_tbl: [(cbsiO,
                       label: block_cbsiO_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsiO: // global
           _sbo9t::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto cbslR; else goto cbslW;
       cbslR: // global
           if (I64[Sp + 96] == I64[Sp + 88]) goto cbslN; else goto cbskQ;
       cbslN: // global
           I64[Sp] = block_cbslM_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
       cbskQ: // global
           _sboaa::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbsiW_info;
           R1 = _sboaa::P64;
           if (R1 & 7 != 0) goto ubsnp; else goto cbsiX;
       ubsnp: // global
           call _cbsiW(R1) args: 0, res: 0, upd: 0;
       cbsiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbslW: // global
           I64[Sp] = block_cbslU_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbslM() //  []
         { info_tbl: [(cbslM,
                       label: block_cbslM_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbslM: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbsiW() //  [R1]
         { info_tbl: [(cbsiW,
                       label: block_cbsiW_info
                       rep:StackRep [False, True, False, False, True, False, False, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsiW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbskT; else goto cbskS;
       cbskT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbskS: // global
           _sbo9C::P64 = P64[Sp + 48];
           _sboac::P64 = P64[R1 + 7];
           _sboad::P64 = P64[R1 + 15];
           _sboag::P64 = P64[_sbo9C::P64 + 8];
           I64[Hp - 16] = sat_sboao_info;
           P64[Hp] = _sboag::P64;
           call MO_WriteBarrier();
           P64[_sbo9C::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9C::P64);
           I64[Sp] = block_cbsjl_info;
           R1 = _sboag::P64;
           P64[Sp + 88] = _sboad::P64;
           P64[Sp + 96] = _sboac::P64;
           if (R1 & 7 != 0) goto ubsnq; else goto cbsjm;
       ubsnq: // global
           call _cbsjl(R1) args: 0, res: 0, upd: 0;
       cbsjm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsjl() //  [R1]
         { info_tbl: [(cbsjl,
                       label: block_cbsjl_info
                       rep:StackRep [False, True, False, False, True, True, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsjl: // global
           _sboax::I64 = I64[R1 + 39];
           if (_sboax::I64 != 0) goto cbskW; else goto cbslI;
       cbskW: // global
           I64[Sp] = block_cbsjs_info;
           _sboas::P64 = P64[R1 + 7];
           _sboat::P64 = P64[R1 + 15];
           _sboar::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           I64[Sp + 16] = _sboax::I64;
           P64[Sp + 40] = _sboat::P64;
           P64[Sp + 48] = _sboas::P64;
           I64[Sp + 56] = _sboar::I64;
           if (R1 & 7 != 0) goto ubsnr; else goto cbsjt;
       ubsnr: // global
           call _cbsjs(R1) args: 0, res: 0, upd: 0;
       cbsjt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbslI: // global
           _sbo9t::P64 = P64[Sp + 64];
           _sbo9z::P64 = P64[Sp + 32];
           _sboad::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = _sboad::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           I64[Sp] = block_cbslH_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbsjs() //  [R1]
         { info_tbl: [(cbsjs,
                       label: block_cbsjs_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsjs: // global
           if (R1 & 7 == 1) goto cbsl2; else goto cbslu;
       cbsl2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbsl5; else goto cbsl4;
       cbsl5: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsl4: // global
           I64[Hp - 24] = sat_sboaH_info;
           P64[Hp - 8] = P64[Sp + 88];
           I64[Hp] = I64[Sp + 16];
           _sbo9t::P64 = P64[Sp + 64];
           _sbo9z::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           I64[Sp] = block_cbsl0_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
       cbslu: // global
           I64[Sp] = block_cbsla_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubsns; else goto cbslb;
       ubsns: // global
           call _cbsla(R1) args: 0, res: 0, upd: 0;
       cbslb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsl0() //  []
         { info_tbl: [(cbsl0,
                       label: block_cbsl0_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsl0: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbsla() //  [R1]
         { info_tbl: [(cbsla,
                       label: block_cbsla_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsla: // global
           I64[Sp - 8] = block_cbslf_info;
           R2 = P64[Sp + 96];
           _sboaO::P64 = P64[R1 + 7];
           _sboaP::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sboaP::P64;
           P64[Sp + 96] = _sboaO::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbslf() //  [R1]
         { info_tbl: [(cbslf,
                       label: block_cbslf_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbslf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbsly; else goto cbslx;
       cbsly: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbslx: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 48];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sboaP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbsli_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 96];
           R3 = _sboaP::P64;
           R2 = P64[Sp + 104];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbsli() //  [R1]
         { info_tbl: [(cbsli,
                       label: block_cbsli_info
                       rep:StackRep [False, True, False, False, True, True, True, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsli: // global
           I64[Sp] = block_cbslk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubsnA; else goto cbsll;
       ubsnA: // global
           call _cbslk(R1) args: 0, res: 0, upd: 0;
       cbsll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbslk() //  [R1]
         { info_tbl: [(cbslk,
                       label: block_cbslk_info
                       rep:StackRep [False, True, False, False, True, True, True, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbslk: // global
           _sbo9t::P64 = P64[Sp + 64];
           _sbo9z::P64 = P64[Sp + 32];
           _sbob1::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = _sbob1::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           I64[Sp] = block_cbsls_info;
           R2 = _sbo9t::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbsls() //  []
         { info_tbl: [(cbsls,
                       label: block_cbsls_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsls: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbslH() //  []
         { info_tbl: [(cbslH,
                       label: block_cbslH_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbslH: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbslU() //  []
         { info_tbl: [(cbslU,
                       label: block_cbslU_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbslU: // global
           R2 = P64[Sp + 8];
           _sbo9k::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbsmt() //  [R1]
         { info_tbl: [(cbsmt,
                       label: block_cbsmt_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsmt: // global
           I64[Sp] = block_cbsmA_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubsnB; else goto cbsmC;
       ubsnB: // global
           call _cbsmA(R1) args: 0, res: 0, upd: 0;
       cbsmC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsmA() //  [R1]
         { info_tbl: [(cbsmA,
                       label: block_cbsmA_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsmA: // global
           if (R1 & 7 == 1) goto ubsne; else goto cbsmN;
       ubsne: // global
           Sp = Sp + 8;
           call _cbsn1() args: 0, res: 0, upd: 0;
       cbsmN: // global
           _sbobI::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp] = block_cbsmL_info;
           R1 = _sbobI::P64;
           if (R1 & 7 != 0) goto ubsnC; else goto cbsmO;
       ubsnC: // global
           call _cbsmL(R1) args: 0, res: 0, upd: 0;
       cbsmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsmL() //  [R1]
         { info_tbl: [(cbsmL,
                       label: block_cbsmL_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsmL: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubsnf; else goto cbsmY;
       ubsnf: // global
           Sp = Sp + 8;
           call _cbsn1() args: 0, res: 0, upd: 0;
       cbsmY: // global
           I64[Sp] = block_cbsmW_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbsn1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsn1: // global
           R2 = P64[Sp];
           _sbo9k::P64 = P64[Sp + 64];
           I64[Sp + 64] = stg_ap_pppv_info;
           _sbo9l::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 16];
           P64[Sp + 80] = _sbo9k::P64;
           P64[Sp + 88] = _sbo9l::P64;
           Sp = Sp + 64;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbsmW() //  [R1]
         { info_tbl: [(cbsmW,
                       label: block_cbsmW_info
                       rep:StackRep [False, True, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsmW: // global
           _sbo9k::P64 = P64[Sp + 72];
           _sbo9l::P64 = P64[Sp + 80];
           _sbo9u::P64 = P64[Sp + 8];
           _sbo9x::P64 = P64[Sp + 24];
           _sbo9z::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbo9z::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbo9z::P64);
           R2 = _sbo9u::P64;
           I64[Sp + 72] = stg_ap_pppv_info;
           P64[Sp + 80] = _sbo9x::P64;
           P64[Sp + 88] = _sbo9k::P64;
           P64[Sp + 96] = _sbo9l::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSeek1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbsnG,
                       label: GHC.IO.Handle.hSeek1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsnG: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbsnK; else goto cbsnJ;
       cbsnK: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSeek1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbsnJ: // global
           I64[Hp - 80] = lvl48_sbo9n_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl49_sbo9p_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sbobV_info;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = Hp - 30;
           R3 = R2;
           R2 = lvl13_rbnWV_closure;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.909602252 UTC

[section ""data" . GHC.IO.Handle.hSeek_closure" {
     GHC.IO.Handle.hSeek_closure:
         const GHC.IO.Handle.hSeek_info;
         const 0;
 },
 GHC.IO.Handle.hSeek_entry() //  [R2, R3, R4]
         { info_tbl: [(cbsr9,
                       label: GHC.IO.Handle.hSeek_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsr9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSeek1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.913058462 UTC

[section ""data" . GHC.IO.Handle.hSetPosn1_closure" {
     GHC.IO.Handle.hSetPosn1_closure:
         const GHC.IO.Handle.hSetPosn1_info;
         const 0;
 },
 GHC.IO.Handle.hSetPosn1_entry() //  [R2]
         { info_tbl: [(cbsrn,
                       label: GHC.IO.Handle.hSetPosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsrn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbsro; else goto cbsrp;
       cbsro: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hSetPosn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsrp: // global
           I64[Sp - 8] = block_cbsrk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsrt; else goto cbsrl;
       ubsrt: // global
           call _cbsrk(R1) args: 0, res: 0, upd: 0;
       cbsrl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsrk() //  [R1]
         { info_tbl: [(cbsrk,
                       label: block_cbsrk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsrk: // global
           R4 = P64[R1 + 15];
           R3 = GHC.IO.Device.AbsoluteSeek_closure+1;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.hSeek1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.919133179 UTC

[section ""data" . GHC.IO.Handle.hSetPosn_closure" {
     GHC.IO.Handle.hSetPosn_closure:
         const GHC.IO.Handle.hSetPosn_info;
         const 0;
 },
 GHC.IO.Handle.hSetPosn_entry() //  [R2]
         { info_tbl: [(cbsrH,
                       label: GHC.IO.Handle.hSetPosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsrH: // global
           R2 = R2;
           call GHC.IO.Handle.hSetPosn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.922267492 UTC

[section ""cstring" . GHC.IO.Handle.hGetEncoding4_bytes" {
     GHC.IO.Handle.hGetEncoding4_bytes:
         I8[] [104,71,101,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.924017608 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding3_closure" {
     GHC.IO.Handle.hGetEncoding3_closure:
         const GHC.IO.Handle.hGetEncoding3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEncoding3_entry() //  [R1]
         { info_tbl: [(cbsrV,
                       label: GHC.IO.Handle.hGetEncoding3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsrV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsrW; else goto cbsrX;
       cbsrW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsrX: // global
           (_cbsrS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsrS::I64 == 0) goto cbsrU; else goto cbsrT;
       cbsrU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsrT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsrS::I64;
           R2 = GHC.IO.Handle.hGetEncoding4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.928136376 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding2_closure" {
     GHC.IO.Handle.hGetEncoding2_closure:
         const GHC.IO.Handle.hGetEncoding2_info;
 },
 GHC.IO.Handle.hGetEncoding2_entry() //  [R2]
         { info_tbl: [(cbssc,
                       label: GHC.IO.Handle.hGetEncoding2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbssc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbssg; else goto cbssh;
       cbssg: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEncoding2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbssh: // global
           I64[Sp - 8] = block_cbss9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubssl; else goto cbssa;
       ubssl: // global
           call _cbss9(R1) args: 0, res: 0, upd: 0;
       cbssa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbss9() //  [R1]
         { info_tbl: [(cbss9,
                       label: block_cbss9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbss9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbssk; else goto cbssj;
       cbssk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbssj: // global
           _sbocg::P64 = P64[R1 + 103];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sbocg::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.934854424 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding1_closure" {
     GHC.IO.Handle.hGetEncoding1_closure:
         const GHC.IO.Handle.hGetEncoding1_info;
         const 0;
 },
 io_sboct_entry() //  [R1]
         { info_tbl: [(cbssR,
                       label: io_sboct_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbssR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbssV; else goto cbssW;
       cbssV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbssW: // global
           I64[Sp - 16] = block_cbssM_info;
           _sbocp::P64 = P64[R1 + 15];
           R5 = _sbocp::P64;
           R4 = GHC.IO.Handle.hGetEncoding2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEncoding3_closure;
           P64[Sp - 8] = _sbocp::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbssM() //  [R1]
         { info_tbl: [(cbssM,
                       label: block_cbssM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbssM: // global
           I64[Sp] = block_cbssO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubst1; else goto cbssP;
       ubst1: // global
           call _cbssO(R1) args: 0, res: 0, upd: 0;
       cbssP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbssO() //  [R1]
         { info_tbl: [(cbssO,
                       label: block_cbssO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbssO: // global
           I64[Sp] = block_cbssU_info;
           R2 = P64[R1 + 7];
           _sbocA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbocA::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbssU() //  []
         { info_tbl: [(cbssU,
                       label: block_cbssU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbssU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbocJ_entry() //  [R1]
         { info_tbl: [(cbstg,
                       label: io_sbocJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbstg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbstk; else goto cbstl;
       cbstk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbstl: // global
           I64[Sp - 16] = block_cbstb_info;
           _sbocE::P64 = P64[R1 + 15];
           R5 = _sbocE::P64;
           R4 = GHC.IO.Handle.hGetEncoding2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEncoding3_closure;
           P64[Sp - 8] = _sbocE::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbstb() //  [R1]
         { info_tbl: [(cbstb,
                       label: block_cbstb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbstb: // global
           I64[Sp] = block_cbstd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubstq; else goto cbste;
       ubstq: // global
           call _cbstd(R1) args: 0, res: 0, upd: 0;
       cbste: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbstd() //  [R1]
         { info_tbl: [(cbstd,
                       label: block_cbstd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbstd: // global
           I64[Sp] = block_cbstj_info;
           R2 = P64[R1 + 7];
           _sbocQ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbocQ::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbstj() //  []
         { info_tbl: [(cbstj,
                       label: block_cbstj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbstj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hGetEncoding1_entry() //  [R2]
         { info_tbl: [(cbstv,
                       label: GHC.IO.Handle.hGetEncoding1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbstv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbstw; else goto cbstx;
       cbstw: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEncoding1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbstx: // global
           I64[Sp - 8] = block_cbssA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubstO; else goto cbssB;
       ubstO: // global
           call _cbssA(R1) args: 0, res: 0, upd: 0;
       cbssB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbssA() //  [R1]
         { info_tbl: [(cbssA,
                       label: block_cbssA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbssA: // global
           if (R1 & 7 == 1) goto cbsts; else goto cbstt;
       cbsts: // global
           I64[Sp - 16] = block_cbssF_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbstt: // global
           I64[Sp - 16] = block_cbst4_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbssF() //  [R1]
         { info_tbl: [(cbssF,
                       label: block_cbssF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbssF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbstB; else goto cbstA;
       cbstB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbstA: // global
           I64[Hp - 16] = io_sboct_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbssH::P64 = Hp - 15;
           if (R1 == 0) goto cbstF; else goto cbstE;
       cbstF: // global
           R1 = _cbssH::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbstE: // global
           R1 = _cbssH::P64;
           Sp = Sp + 24;
           call io_sboct_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbst4() //  [R1]
         { info_tbl: [(cbst4,
                       label: block_cbst4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbst4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbstJ; else goto cbstI;
       cbstJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbstI: // global
           I64[Hp - 16] = io_sbocJ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbst6::P64 = Hp - 15;
           if (R1 == 0) goto cbstN; else goto cbstM;
       cbstN: // global
           R1 = _cbst6::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbstM: // global
           R1 = _cbst6::P64;
           Sp = Sp + 24;
           call io_sbocJ_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.958310919 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding_closure" {
     GHC.IO.Handle.hGetEncoding_closure:
         const GHC.IO.Handle.hGetEncoding_info;
         const 0;
 },
 GHC.IO.Handle.hGetEncoding_entry() //  [R2]
         { info_tbl: [(cbsuK,
                       label: GHC.IO.Handle.hGetEncoding_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsuK: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.961691572 UTC

[section ""cstring" . lvl15_rbnWX_bytes" {
     lvl15_rbnWX_bytes:
         I8[] [104,83,101,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.963459304 UTC

[section ""data" . lvl16_rbnWY_closure" {
     lvl16_rbnWY_closure:
         const lvl16_rbnWY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_rbnWY_entry() //  [R1]
         { info_tbl: [(cbsuY,
                       label: lvl16_rbnWY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsuY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsuZ; else goto cbsv0;
       cbsuZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsv0: // global
           (_cbsuV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsuV::I64 == 0) goto cbsuX; else goto cbsuW;
       cbsuX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsuW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsuV::I64;
           R2 = lvl15_rbnWX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.967164528 UTC

[section ""cstring" . lvl17_rbnWZ_bytes" {
     lvl17_rbnWZ_bytes:
         I8[] [108,97,115,116,95,100,101,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.968994279 UTC

[section ""data" . lvl18_rbnX0_closure" {
     lvl18_rbnX0_closure:
         const lvl18_rbnX0_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rbnX0_entry() //  [R1]
         { info_tbl: [(cbsvh,
                       label: lvl18_rbnX0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsvh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbsvi; else goto cbsvj;
       cbsvi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsvj: // global
           (_cbsvc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsvc::I64 == 0) goto cbsve; else goto cbsvd;
       cbsve: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsvd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsvc::I64;
           I64[Sp - 24] = block_cbsvf_info;
           R2 = lvl17_rbnWZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbsvf() //  [R1]
         { info_tbl: [(cbsvf,
                       label: block_cbsvf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsvf: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:17.980373937 UTC

[section ""data" . GHC.IO.Handle.hSetEncoding1_closure" {
     GHC.IO.Handle.hSetEncoding1_closure:
         const GHC.IO.Handle.hSetEncoding1_info;
         const 0;
 },
 sat_sbofq_entry() //  [R1]
         { info_tbl: [(cbswn,
                       label: sat_sbofq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbswn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbswr; else goto cbsws;
       cbswr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsws: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbswk_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubsww; else goto cbswl;
       ubsww: // global
           call _cbswk(R1) args: 0, res: 0, upd: 0;
       cbswl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbswk() //  [R1]
         { info_tbl: [(cbswk,
                       label: block_cbswk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbswk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbswv; else goto cbswu;
       cbswv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbswu: // global
           _sbofl::P64 = P64[R1 + 7];
           _sbofm::P64 = P64[R1 + 15];
           _sbofk::I64 = I64[R1 + 23];
           _sbofn::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbofl::P64;
           P64[Hp - 32] = _sbofm::P64;
           I64[Hp - 24] = _sbofk::I64;
           I64[Hp - 16] = _sbofn::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbofJ_entry() //  [R1]
         { info_tbl: [(cbswT,
                       label: sat_sbofJ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbswT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbsx0; else goto cbsx1;
       cbsx0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsx1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbswQ_info;
           _sbofz::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbofz::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubsx5; else goto cbswR;
       ubsx5: // global
           call _cbswQ(R1) args: 0, res: 0, upd: 0;
       cbswR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbswQ() //  [R1]
         { info_tbl: [(cbswQ,
                       label: block_cbswQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbswQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbsx4; else goto cbsx3;
       cbsx4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbsx3: // global
           _sbofD::P64 = P64[R1 + 7];
           _sbofE::P64 = P64[R1 + 15];
           _sbofC::I64 = I64[R1 + 23];
           _sbofF::I64 = I64[R1 + 31];
           _sbofH::I64 = I64[R1 + 47];
           _sbofI::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbofD::P64;
           P64[Hp - 32] = _sbofE::P64;
           I64[Hp - 24] = _sbofC::I64;
           I64[Hp - 16] = _sbofF::I64;
           I64[Hp - 8] = _sbofI::I64;
           I64[Hp] = _sbofH::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbog6_entry() //  [R1, R2]
         { info_tbl: [(cbsx6,
                       label: sat_sbog6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsx6: // global
           if ((Sp + -192) < SpLim) (likely: False) goto cbsx7; else goto cbsx8;
       cbsx7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsx8: // global
           I64[Sp - 24] = block_cbsvH_info;
           _sbocV::P64 = P64[R1 + 6];
           _sbocX::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbocV::P64;
           P64[Sp - 8] = _sbocX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubsBD; else goto cbsvI;
       ubsBD: // global
           call _cbsvH(R1) args: 0, res: 0, upd: 0;
       cbsvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsvH() //  [R1]
         { info_tbl: [(cbsvH,
                       label: block_cbsvH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsvH: // global
           I64[Sp - 120] = block_cbsvM_info;
           _sbod1::P64 = P64[R1 + 7];
           _sbod2::P64 = P64[R1 + 15];
           _sbod3::P64 = P64[R1 + 23];
           _sbod4::P64 = P64[R1 + 31];
           _sbod5::P64 = P64[R1 + 39];
           _sbod6::P64 = P64[R1 + 47];
           _sbod7::P64 = P64[R1 + 55];
           _sbod8::P64 = P64[R1 + 63];
           _sbod9::P64 = P64[R1 + 71];
           _sboda::P64 = P64[R1 + 79];
           _sbodb::P64 = P64[R1 + 87];
           _sbodc::P64 = P64[R1 + 95];
           _sbode::P64 = P64[R1 + 111];
           _sbodf::P64 = P64[R1 + 119];
           _sbodg::P64 = P64[R1 + 127];
           R1 = P64[_sbod9::P64 + 8];
           P64[Sp - 112] = _sbod2::P64;
           P64[Sp - 104] = _sbod3::P64;
           P64[Sp - 96] = _sbod4::P64;
           P64[Sp - 88] = _sbod5::P64;
           P64[Sp - 80] = _sbod6::P64;
           P64[Sp - 72] = _sbod7::P64;
           P64[Sp - 64] = _sbod8::P64;
           P64[Sp - 56] = _sbod9::P64;
           P64[Sp - 48] = _sboda::P64;
           P64[Sp - 40] = _sbodb::P64;
           P64[Sp - 32] = _sbodc::P64;
           P64[Sp - 24] = _sbode::P64;
           P64[Sp - 16] = _sbodf::P64;
           P64[Sp - 8] = _sbodg::P64;
           P64[Sp] = _sbod1::P64;
           Sp = Sp - 120;
           if (R1 & 7 != 0) goto ubsBq; else goto cbsvN;
       ubsBq: // global
           call _cbsvM(R1) args: 0, res: 0, upd: 0;
       cbsvN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsvM() //  [R1]
         { info_tbl: [(cbsvM,
                       label: block_cbsvM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsvM: // global
           I64[Sp - 16] = block_cbsvT_info;
           _sbodp::I64 = I64[R1 + 39];
           _sbodq::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbodq::I64;
           I64[Sp] = _sbodp::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubsBr; else goto cbsvU;
       ubsBr: // global
           call _cbsvT(R1) args: 0, res: 0, upd: 0;
       cbsvU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsvT() //  [R1]
         { info_tbl: [(cbsvT,
                       label: block_cbsvT_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsvT: // global
           if (R1 & 7 == 1) goto cbszU; else goto cbsAP;
       cbszU: // global
           _sbof0::P64 = P64[P64[Sp + 80] + 8];
           I64[Sp + 16] = block_cbsvY_info;
           R1 = _sbof0::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubsBs; else goto cbsvZ;
       ubsBs: // global
           call _cbsvY(R1) args: 0, res: 0, upd: 0;
       cbsvZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsAP: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubsBd; else goto cbsAN;
       ubsBd: // global
           Sp = Sp + 24;
           call _sbodr() args: 0, res: 0, upd: 0;
       cbsAN: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 160;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsvY() //  [R1]
         { info_tbl: [(cbsvY,
                       label: block_cbsvY_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsvY: // global
           I64[Sp - 16] = block_cbsw3_info;
           _sbof6::I64 = I64[R1 + 39];
           _sbof7::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbof7::I64;
           I64[Sp] = _sbof6::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubsBu; else goto cbsw4;
       ubsBu: // global
           call _cbsw3(R1) args: 0, res: 0, upd: 0;
       cbsw4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsw3() //  [R1]
         { info_tbl: [(cbsw3,
                       label: block_cbsw3_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsw3: // global
           if (R1 & 7 == 1) goto cbsAC; else goto ubsBe;
       cbsAC: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubsBf; else goto cbszY;
       ubsBf: // global
           Sp = Sp + 24;
           goto ubsBx;
       cbszY: // global
           _sbofc::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cbswb_info;
           R1 = _sbofc::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubsBv; else goto cbswc;
       ubsBv: // global
           call _cbswb(R1) args: 0, res: 0, upd: 0;
       cbswc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubsBe: // global
           Sp = Sp + 24;
           goto ubsBx;
       ubsBx: // global
           call _sbodr() args: 0, res: 0, upd: 0;
     }
 },
 _cbswb() //  [R1]
         { info_tbl: [(cbswb,
                       label: block_cbswb_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbswb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbsA1; else goto cbsA0;
       cbsA1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsA0: // global
           _sbod9::P64 = P64[Sp + 64];
           _sbofe::P64 = P64[R1 + 7];
           _sboff::P64 = P64[R1 + 15];
           _sbofi::P64 = P64[_sbod9::P64 + 8];
           I64[Hp - 16] = sat_sbofq_info;
           P64[Hp] = _sbofi::P64;
           call MO_WriteBarrier();
           P64[_sbod9::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod9::P64);
           I64[Sp - 8] = block_cbswA_info;
           R1 = _sbofi::P64;
           P64[Sp] = _sboff::P64;
           P64[Sp + 56] = _sbofe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsBy; else goto cbswB;
       ubsBy: // global
           call _cbswA(R1) args: 0, res: 0, upd: 0;
       cbswB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbswA() //  [R1]
         { info_tbl: [(cbswA,
                       label: block_cbswA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbswA: // global
           _sbofz::I64 = I64[R1 + 39];
           if (_sbofz::I64 != 0) goto cbsA4; else goto cbsAz;
       cbsA4: // global
           I64[Sp - 32] = block_cbswH_info;
           _sbofu::P64 = P64[R1 + 7];
           _sbofv::P64 = P64[R1 + 15];
           _sboft::I64 = I64[R1 + 23];
           R1 = P64[Sp + 96];
           P64[Sp - 24] = _sbofu::P64;
           P64[Sp - 16] = _sbofv::P64;
           I64[Sp - 8] = _sbofz::I64;
           I64[Sp] = _sboft::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubsBz; else goto cbswI;
       ubsBz: // global
           call _cbswH(R1) args: 0, res: 0, upd: 0;
       cbswI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsAz: // global
           _sbod6::P64 = P64[Sp + 48];
           _sboff::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbod6::P64 + 8] = _sboff::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod6::P64);
           Sp = Sp + 16;
           call _sbodr() args: 0, res: 0, upd: 0;
     }
 },
 _cbswH() //  [R1]
         { info_tbl: [(cbswH,
                       label: block_cbswH_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbswH: // global
           if (R1 & 7 == 1) goto cbsA6; else goto cbsAo;
       cbsA6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbsA9; else goto cbsA8;
       cbsA9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsA8: // global
           I64[Hp - 24] = sat_sbofJ_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 24];
           _sbod6::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sbod6::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod6::P64);
           Sp = Sp + 48;
           call _sbodr() args: 0, res: 0, upd: 0;
       cbsAo: // global
           I64[Sp] = block_cbsAc_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubsBB; else goto cbsAd;
       ubsBB: // global
           call _cbsAc(R1) args: 0, res: 0, upd: 0;
       cbsAd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsAc() //  [R1]
         { info_tbl: [(cbsAc,
                       label: block_cbsAc_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsAc: // global
           I64[Sp - 8] = block_cbsAh_info;
           R2 = P64[Sp + 96];
           _sbofN::P64 = P64[R1 + 7];
           _sbofO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbofO::P64;
           P64[Sp + 96] = _sbofN::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsAh() //  [R1]
         { info_tbl: [(cbsAh,
                       label: block_cbsAh_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsAh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbsAs; else goto cbsAr;
       cbsAs: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsAr: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sboff::P64 = P64[Sp + 48];
           I64[Sp + 48] = block_cbsAk_info;
           R5 = Hp - 47;
           R4 = _sboff::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 104];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbsAk() //  [R1]
         { info_tbl: [(cbsAk,
                       label: block_cbsAk_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsAk: // global
           I64[Sp] = block_cbsAm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubsBR; else goto cbsAu;
       ubsBR: // global
           call _cbsAm(R1) args: 0, res: 0, upd: 0;
       cbsAu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsAm() //  [R1]
         { info_tbl: [(cbsAm,
                       label: block_cbsAm_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsAm: // global
           _sbod6::P64 = P64[Sp + 40];
           _sbog0::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbod6::P64 + 8] = _sbog0::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbod6::P64);
           Sp = Sp + 8;
           call _sbodr() args: 0, res: 0, upd: 0;
     }
 },
 _sbodr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbodr: // global
           I64[Sp - 8] = block_cbsxg_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsBT; else goto cbsyS;
       ubsBT: // global
           call _cbsxg(R1) args: 0, res: 0, upd: 0;
       cbsyS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsxg() //  [R1]
         { info_tbl: [(cbsxg,
                       label: block_cbsxg_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsxg: // global
           if (R1 & 7 == 1) goto cbsyZ; else goto cbszo;
       cbsyZ: // global
           I64[Sp] = block_cbsyW_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubsBE; else goto cbsz0;
       ubsBE: // global
           call _cbsyW(R1) args: 0, res: 0, upd: 0;
       cbsz0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbszo: // global
           I64[Sp] = block_cbszm_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubsBF; else goto cbszp;
       ubsBF: // global
           call _cbszm(R1) args: 0, res: 0, upd: 0;
       cbszp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsyW() //  [R1]
         { info_tbl: [(cbsyW,
                       label: block_cbsyW_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsyW: // global
           if (R1 & 7 == 1) goto ubsBl; else goto cbszg;
       ubsBl: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
       cbszg: // global
           I64[Sp] = block_cbsz9_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubsBK; else goto cbsza;
       ubsBK: // global
           call _cbsz9(R1) args: 0, res: 0, upd: 0;
       cbsza: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsz9() //  [R1]
         { info_tbl: [(cbsz9,
                       label: block_cbsz9_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsz9: // global
           I64[Sp] = block_cbsze_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsze() //  []
         { info_tbl: [(cbsze,
                       label: block_cbsze_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsze: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
     }
 },
 _cbszm() //  [R1]
         { info_tbl: [(cbszm,
                       label: block_cbszm_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbszm: // global
           I64[Sp] = block_cbszt_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbszt() //  []
         { info_tbl: [(cbszt,
                       label: block_cbszt_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbszt: // global
           I64[Sp] = block_cbszv_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubsBN; else goto cbszy;
       ubsBN: // global
           call _cbszv(R1) args: 0, res: 0, upd: 0;
       cbszy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbszv() //  [R1]
         { info_tbl: [(cbszv,
                       label: block_cbszv_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbszv: // global
           if (R1 & 7 == 1) goto ubsBj; else goto cbszO;
       ubsBj: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
       cbszO: // global
           I64[Sp] = block_cbszH_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubsBO; else goto cbszI;
       ubsBO: // global
           call _cbszH(R1) args: 0, res: 0, upd: 0;
       cbszI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbszH() //  [R1]
         { info_tbl: [(cbszH,
                       label: block_cbszH_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbszH: // global
           I64[Sp] = block_cbszM_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbszM() //  []
         { info_tbl: [(cbszM,
                       label: block_cbszM_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbszM: // global
           Sp = Sp + 8;
           call _sbodt() args: 0, res: 0, upd: 0;
     }
 },
 _sbodt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbodt: // global
           I64[Sp - 8] = block_cbsxl_info;
           R1 = P64[Sp + 120];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsBU; else goto cbsxn;
       ubsBU: // global
           call _cbsxl(R1) args: 0, res: 0, upd: 0;
       cbsxn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsxl() //  [R1]
         { info_tbl: [(cbsxl,
                       label: block_cbsxl_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsxl: // global
           I64[Sp] = block_cbsxt_info;
           _sbodx::P64 = P64[R1 + 15];
           _sbody::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp + 88] = _sbody::P64;
           P64[Sp + 128] = _sbodx::P64;
           if (R1 & 7 != 0) goto ubsBG; else goto cbsyt;
       ubsBG: // global
           call _cbsxt(R1) args: 0, res: 0, upd: 0;
       cbsyt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsxt() //  [R1]
         { info_tbl: [(cbsxt,
                       label: block_cbsxt_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsxt: // global
           _sbodx::P64 = P64[Sp + 128];
           _cbsB6::P64 = R1 & 7;
           if (_cbsB6::P64 != 3) goto ubsBa; else goto cbsyE;
       ubsBa: // global
           if (_cbsB6::P64 != 6) goto cbsyz; else goto cbsyN;
       cbsyz: // global
           P64[Sp + 128] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbodz() args: 0, res: 0, upd: 0;
       cbsyN: // global
           I64[Sp] = block_cbsyL_info;
           R1 = _sbodx::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbsyE: // global
           I64[Sp] = block_cbsyC_info;
           R1 = _sbodx::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsyL() //  [R1]
         { info_tbl: [(cbsyL,
                       label: block_cbsyL_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsyL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbsyR; else goto cbsyQ;
       cbsyR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsyQ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 128] = Hp - 6;
           Sp = Sp + 8;
           call _sbodz() args: 0, res: 0, upd: 0;
     }
 },
 _cbsyC() //  [R1]
         { info_tbl: [(cbsyC,
                       label: block_cbsyC_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsyC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbsyI; else goto cbsyH;
       cbsyI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsyH: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 128] = Hp - 6;
           Sp = Sp + 8;
           call _sbodz() args: 0, res: 0, upd: 0;
     }
 },
 _sbodz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbodz: // global
           I64[Sp - 8] = block_cbsxy_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsBV; else goto cbsxA;
       ubsBV: // global
           call _cbsxy(R1) args: 0, res: 0, upd: 0;
       cbsxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsxy() //  [R1]
         { info_tbl: [(cbsxy,
                       label: block_cbsxy_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsxy: // global
           _sbody::P64 = P64[Sp + 88];
           _cbsB9::P64 = R1 & 7;
           if (_cbsB9::P64 < 5) goto ubsBb; else goto ubsBc;
       ubsBb: // global
           if (_cbsB9::P64 < 4) goto cbsxJ; else goto cbsxW;
       cbsxJ: // global
           I64[Sp] = block_cbsxE_info;
           _sbodC::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbodC::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbsxW: // global
           I64[Sp] = block_cbsxP_info;
           R1 = _sbody::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ubsBc: // global
           if (_cbsB9::P64 < 6) goto cbsya; else goto cbsyo;
       cbsya: // global
           I64[Sp] = block_cbsy3_info;
           R1 = _sbody::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbsyo: // global
           I64[Sp] = block_cbsyh_info;
           R1 = _sbody::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsxE() //  [R1]
         { info_tbl: [(cbsxE,
                       label: block_cbsxE_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsxE: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbsxM; else goto cbsxL;
       cbsxM: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsxL: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 88];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsxP() //  [R1]
         { info_tbl: [(cbsxP,
                       label: block_cbsxP_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsxP: // global
           I64[Sp] = block_cbsxR_info;
           _sbodM::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbodM::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsxR() //  [R1]
         { info_tbl: [(cbsxR,
                       label: block_cbsxR_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsxR: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbsy0; else goto cbsxZ;
       cbsy0: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsxZ: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsy3() //  [R1]
         { info_tbl: [(cbsy3,
                       label: block_cbsy3_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsy3: // global
           I64[Sp] = block_cbsy5_info;
           _sbodX::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbodX::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsy5() //  [R1]
         { info_tbl: [(cbsy5,
                       label: block_cbsy5_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsy5: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbsye; else goto cbsyd;
       cbsye: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsyd: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.AppendHandle_closure+5;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsyh() //  [R1]
         { info_tbl: [(cbsyh,
                       label: block_cbsyh_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsyh: // global
           I64[Sp] = block_cbsyj_info;
           _sboe8::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sboe8::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsyj() //  [R1]
         { info_tbl: [(cbsyj,
                       label: block_cbsyj_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsyj: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbsys; else goto cbsyr;
       cbsys: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsyr: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetEncoding1_entry() //  [R2, R3]
         { info_tbl: [(cbsBW,
                       label: GHC.IO.Handle.hSetEncoding1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsBW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbsC0; else goto cbsBZ;
       cbsC0: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetEncoding1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbsBZ: // global
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbog6_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 30;
           R4 = Hp - 14;
           R3 = R2;
           R2 = lvl16_rbnWY_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.061827785 UTC

[section ""data" . GHC.IO.Handle.hSetEncoding_closure" {
     GHC.IO.Handle.hSetEncoding_closure:
         const GHC.IO.Handle.hSetEncoding_info;
         const 0;
 },
 GHC.IO.Handle.hSetEncoding_entry() //  [R2, R3]
         { info_tbl: [(cbsG4,
                       label: GHC.IO.Handle.hSetEncoding_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsG4: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetEncoding1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.065014665 UTC

[section ""cstring" . GHC.IO.Handle.hSetBuffering3_bytes" {
     GHC.IO.Handle.hSetBuffering3_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.06683075 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering2_closure" {
     GHC.IO.Handle.hSetBuffering2_closure:
         const GHC.IO.Handle.hSetBuffering2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetBuffering2_entry() //  [R1]
         { info_tbl: [(cbsGi,
                       label: GHC.IO.Handle.hSetBuffering2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsGi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsGj; else goto cbsGk;
       cbsGj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsGk: // global
           (_cbsGf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsGf::I64 == 0) goto cbsGh; else goto cbsGg;
       cbsGh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsGg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsGf::I64;
           R2 = GHC.IO.Handle.hSetBuffering3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.075281281 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering1_closure" {
     GHC.IO.Handle.hSetBuffering1_closure:
         const GHC.IO.Handle.hSetBuffering1_info;
         const 0;
 },
 sat_sbohh_entry() //  [R1, R2]
         { info_tbl: [(cbsGE,
                       label: sat_sbohh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsGE: // global
           if ((Sp + -176) < SpLim) (likely: False) goto cbsGF; else goto cbsGG;
       cbsGF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsGG: // global
           I64[Sp - 16] = block_cbsGB_info;
           _sbog8::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbog8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubsL8; else goto cbsGC;
       ubsL8: // global
           call _cbsGB(R1) args: 0, res: 0, upd: 0;
       cbsGC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsGB() //  [R1]
         { info_tbl: [(cbsGB,
                       label: block_cbsGB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsGB: // global
           I64[Sp - 128] = block_cbsGJ_info;
           _sbogc::P64 = R1;
           _sbogd::P64 = P64[R1 + 7];
           _sboge::P64 = P64[R1 + 15];
           _sbogf::P64 = P64[R1 + 23];
           _sbogg::P64 = P64[R1 + 31];
           _sbogi::P64 = P64[R1 + 47];
           _sbogj::P64 = P64[R1 + 55];
           _sbogk::P64 = P64[R1 + 63];
           _sbogl::P64 = P64[R1 + 71];
           _sbogm::P64 = P64[R1 + 79];
           _sbogn::P64 = P64[R1 + 87];
           _sbogo::P64 = P64[R1 + 95];
           _sbogp::P64 = P64[R1 + 103];
           _sbogq::P64 = P64[R1 + 111];
           _sbogr::P64 = P64[R1 + 119];
           _sbogs::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sbogd::P64;
           P64[Sp - 112] = _sboge::P64;
           P64[Sp - 104] = _sbogf::P64;
           P64[Sp - 96] = _sbogg::P64;
           P64[Sp - 88] = _sbogi::P64;
           P64[Sp - 80] = _sbogj::P64;
           P64[Sp - 72] = _sbogk::P64;
           P64[Sp - 64] = _sbogl::P64;
           P64[Sp - 56] = _sbogm::P64;
           P64[Sp - 48] = _sbogn::P64;
           P64[Sp - 40] = _sbogo::P64;
           P64[Sp - 32] = _sbogp::P64;
           P64[Sp - 24] = _sbogq::P64;
           P64[Sp - 16] = _sbogr::P64;
           P64[Sp - 8] = _sbogs::P64;
           P64[Sp] = _sbogc::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto ubsL7; else goto cbsGL;
       ubsL7: // global
           call _cbsGJ(R1) args: 0, res: 0, upd: 0;
       cbsGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsGJ() //  [R1]
         { info_tbl: [(cbsGJ,
                       label: block_cbsGJ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsGJ: // global
           if (R1 & 7 == 1) goto cbsKE; else goto cbsIU;
       cbsKE: // global
           Sp = Sp + 144;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbsIU: // global
           I64[Sp - 8] = block_cbsGR_info;
           _sbogt::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp] = _sbogt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsL9; else goto cbsIV;
       ubsL9: // global
           call _cbsGR(R1) args: 0, res: 0, upd: 0;
       cbsIV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsGR() //  [R1]
         { info_tbl: [(cbsGR,
                       label: block_cbsGR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsGR: // global
           _sbogj::P64 = P64[Sp + 56];
           _cbsKG::P64 = R1 & 7;
           if (_cbsKG::P64 < 3) goto ubsKS; else goto cbsJy;
       ubsKS: // global
           if (_cbsKG::P64 < 2) goto cbsJ2; else goto cbsJi;
       cbsJ2: // global
           I64[Sp] = block_cbsIZ_info;
           R1 = _sbogj::P64;
           if (R1 & 7 != 0) goto ubsLa; else goto cbsJ3;
       ubsLa: // global
           call _cbsIZ(R1) args: 0, res: 0, upd: 0;
       cbsJ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsJi: // global
           I64[Sp] = block_cbsJg_info;
           R1 = _sbogj::P64;
           if (R1 & 7 != 0) goto ubsLb; else goto cbsJj;
       ubsLb: // global
           call _cbsJg(R1) args: 0, res: 0, upd: 0;
       cbsJj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsJy: // global
           I64[Sp] = block_cbsJw_info;
           _sboh3::P64 = P64[R1 + 5];
           R1 = _sbogj::P64;
           P64[Sp + 56] = _sboh3::P64;
           if (R1 & 7 != 0) goto ubsLc; else goto cbsJz;
       ubsLc: // global
           call _cbsJw(R1) args: 0, res: 0, upd: 0;
       cbsJz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsIZ() //  [R1]
         { info_tbl: [(cbsIZ,
                       label: block_cbsIZ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsIZ: // global
           if (R1 & 7 == 1) goto ubsKU; else goto ubsKV;
       ubsKU: // global
           Sp = Sp + 136;
           call _cbsKA() args: 0, res: 0, upd: 0;
       ubsKV: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbsJg() //  [R1]
         { info_tbl: [(cbsJg,
                       label: block_cbsJg_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsJg: // global
           if (R1 & 7 == 2) goto ubsKW; else goto ubsKX;
       ubsKW: // global
           Sp = Sp + 136;
           call _cbsKA() args: 0, res: 0, upd: 0;
       ubsKX: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbsJw() //  [R1]
         { info_tbl: [(cbsJw,
                       label: block_cbsJw_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsJw: // global
           if (R1 & 7 == 3) goto cbsJK; else goto ubsKY;
       cbsJK: // global
           I64[Sp] = block_cbsJI_info;
           _sboh5::P64 = P64[R1 + 5];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _sboh5::P64;
           if (R1 & 7 != 0) goto ubsLp; else goto cbsJL;
       ubsLp: // global
           call _cbsJI(R1) args: 0, res: 0, upd: 0;
       cbsJL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubsKY: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbsJI() //  [R1]
         { info_tbl: [(cbsJI,
                       label: block_cbsJI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsJI: // global
           _sboh5::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cbsJS; else goto cbsK8;
       cbsJS: // global
           I64[Sp] = block_cbsJP_info;
           R1 = _sboh5::P64;
           if (R1 & 7 != 0) goto ubsLr; else goto cbsJT;
       ubsLr: // global
           call _cbsJP(R1) args: 0, res: 0, upd: 0;
       cbsJT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsK8: // global
           I64[Sp] = block_cbsK6_info;
           _sboh9::P64 = P64[R1 + 6];
           R1 = _sboh5::P64;
           P64[Sp + 56] = _sboh9::P64;
           if (R1 & 7 != 0) goto ubsLs; else goto cbsK9;
       ubsLs: // global
           call _cbsK6(R1) args: 0, res: 0, upd: 0;
       cbsK9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsJP() //  [R1]
         { info_tbl: [(cbsJP,
                       label: block_cbsJP_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsJP: // global
           if (R1 & 7 == 1) goto ubsL2; else goto ubsL3;
       ubsL2: // global
           Sp = Sp + 136;
           call _cbsKA() args: 0, res: 0, upd: 0;
       ubsL3: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbsK6() //  [R1]
         { info_tbl: [(cbsK6,
                       label: block_cbsK6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsK6: // global
           if (R1 & 7 == 1) goto ubsKZ; else goto cbsKp;
       ubsKZ: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
       cbsKp: // global
           I64[Sp] = block_cbsKi_info;
           _sbohb::P64 = P64[R1 + 6];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _sbohb::P64;
           if (R1 & 7 != 0) goto ubsLv; else goto cbsKj;
       ubsLv: // global
           call _cbsKi(R1) args: 0, res: 0, upd: 0;
       cbsKj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsKi() //  [R1]
         { info_tbl: [(cbsKi,
                       label: block_cbsKi_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsKi: // global
           I64[Sp] = block_cbsKn_info;
           _sbohd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp + 56] = _sbohd::I64;
           if (R1 & 7 != 0) goto ubsLx; else goto cbsKr;
       ubsLx: // global
           call _cbsKn(R1) args: 0, res: 0, upd: 0;
       cbsKr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsKn() //  [R1]
         { info_tbl: [(cbsKn,
                       label: block_cbsKn_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsKn: // global
           if (I64[Sp + 56] == I64[R1 + 7]) goto ubsL0; else goto ubsL1;
       ubsL0: // global
           Sp = Sp + 136;
           call _cbsKA() args: 0, res: 0, upd: 0;
       ubsL1: // global
           Sp = Sp + 8;
           call _sbogu() args: 0, res: 0, upd: 0;
     }
 },
 _cbsKA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsKA: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _sbogu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbogu: // global
           I64[Sp - 8] = block_cbsGY_info;
           R1 = P64[Sp + 136];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsLA; else goto cbsIl;
       ubsLA: // global
           call _cbsGY(R1) args: 0, res: 0, upd: 0;
       cbsIl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsGY() //  [R1]
         { info_tbl: [(cbsGY,
                       label: block_cbsGY_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsGY: // global
           if (R1 & 7 == 3) goto cbsIw; else goto ubsL4;
       cbsIw: // global
           I64[Sp] = block_cbsIu_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto ubsLd; else goto cbsIx;
       ubsLd: // global
           call _cbsIu(R1) args: 0, res: 0, upd: 0;
       cbsIx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubsL4: // global
           Sp = Sp + 8;
           call _sbogv() args: 0, res: 0, upd: 0;
     }
 },
 _cbsIu() //  [R1]
         { info_tbl: [(cbsIu,
                       label: block_cbsIu_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsIu: // global
           if (R1 & 7 == 1) goto ubsL5; else goto cbsII;
       ubsL5: // global
           Sp = Sp + 8;
           call _sbogv() args: 0, res: 0, upd: 0;
       cbsII: // global
           I64[Sp] = block_cbsIG_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubsLi; else goto cbsIJ;
       ubsLi: // global
           call _cbsIG(R1) args: 0, res: 0, upd: 0;
       cbsIJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsIG() //  [R1]
         { info_tbl: [(cbsIG,
                       label: block_cbsIG_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsIG: // global
           _sbogX::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sbogX::I64, 0)) goto ubsL6; else goto cbsIS;
       ubsL6: // global
           Sp = Sp + 8;
           call _sbogv() args: 0, res: 0, upd: 0;
       cbsIS: // global
           R2 = _sbogX::I64;
           Sp = Sp + 152;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _sbogv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbogv: // global
           I64[Sp - 8] = block_cbsH3_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbsH3() //  [R1]
         { info_tbl: [(cbsH3,
                       label: block_cbsH3_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsH3: // global
           I64[Sp] = block_cbsH5_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubsLf; else goto cbsH8;
       ubsLf: // global
           call _cbsH5(R1) args: 0, res: 0, upd: 0;
       cbsH8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsH5() //  [R1]
         { info_tbl: [(cbsH5,
                       label: block_cbsH5_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsH5: // global
           _sbogt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbsHh; else goto cbsHZ;
       cbsHh: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbsHk; else goto cbsHj;
       cbsHk: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsHj: // global
           _sbog8::P64 = P64[Sp + 144];
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = _sbogt::P64;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = _sbog8::P64;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbsHZ: // global
           I64[Sp] = block_cbsHp_info;
           R1 = _sbogt::P64;
           if (R1 & 7 != 0) goto ubsLg; else goto cbsI0;
       ubsLg: // global
           call _cbsHp(R1) args: 0, res: 0, upd: 0;
       cbsI0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsHp() //  [R1]
         { info_tbl: [(cbsHp,
                       label: block_cbsHp_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsHp: // global
           _sbog8::P64 = P64[Sp + 144];
           _cbsKQ::P64 = R1 & 7;
           if (_cbsKQ::P64 == 3) goto sbogD; else goto ubsKT;
       ubsKT: // global
           if (_cbsKQ::P64 == 6) goto sbogD; else goto cbsI9;
       sbogD: // global
           I64[Sp] = block_cbsHu_info;
           R1 = _sbog8::P64;
           if (R1 & 7 != 0) goto ubsLh; else goto cbsHw;
       ubsLh: // global
           call _cbsHu(R1) args: 0, res: 0, upd: 0;
       cbsHw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsI9: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbsIc; else goto cbsIb;
       cbsIc: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsIb: // global
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = R1;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = _sbog8::P64;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsHu() //  [R1]
         { info_tbl: [(cbsHu,
                       label: block_cbsHu_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsHu: // global
           _sbogd::P64 = P64[Sp + 16];
           _sbogg::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbsHV; else goto cbsHI;
       cbsHV: // global
           I64[Sp] = block_cbsHO_info;
           R2 = _sbogd::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sbogg::P64;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 24;
           call GHC.IO.Device.setRaw_entry(R2) args: 32, res: 8, upd: 8;
       cbsHI: // global
           I64[Sp] = block_cbsHA_info;
           R2 = _sbogd::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sbogg::P64;
           P64[Sp - 8] = GHC.Types.False_closure+1;
           P64[Sp + 144] = R1;
           Sp = Sp - 24;
           call GHC.IO.Device.setRaw_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbsHO() //  [R1]
         { info_tbl: [(cbsHO,
                       label: block_cbsHO_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsHO: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbsHY; else goto cbsHX;
       cbsHY: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsHX: // global
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           _sbogt::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = _sbogt::P64;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsHA() //  [R1]
         { info_tbl: [(cbsHA,
                       label: block_cbsHA_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsHA: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbsHL; else goto cbsHK;
       cbsHL: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsHK: // global
           _sbogd::P64 = P64[Sp + 16];
           _sboge::P64 = P64[Sp + 24];
           _sbogf::P64 = P64[Sp + 32];
           _sbogg::P64 = P64[Sp + 40];
           _sbogi::P64 = P64[Sp + 48];
           _sbogk::P64 = P64[Sp + 64];
           _sbogl::P64 = P64[Sp + 72];
           _sbogm::P64 = P64[Sp + 80];
           _sbogn::P64 = P64[Sp + 88];
           _sbogo::P64 = P64[Sp + 96];
           _sbogp::P64 = P64[Sp + 104];
           _sbogq::P64 = P64[Sp + 112];
           _sbogr::P64 = P64[Sp + 120];
           _sbogs::P64 = P64[Sp + 128];
           _sbogt::P64 = P64[Sp + 8];
           _sbogE::P64 = P64[Sp + 144];
           call MO_WriteBarrier();
           P64[_sbogm::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbogm::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbogd::P64;
           P64[Hp - 112] = _sboge::P64;
           P64[Hp - 104] = _sbogf::P64;
           P64[Hp - 96] = _sbogg::P64;
           P64[Hp - 88] = _sbogt::P64;
           P64[Hp - 80] = _sbogi::P64;
           P64[Hp - 72] = _sbogE::P64;
           P64[Hp - 64] = _sbogk::P64;
           P64[Hp - 56] = _sbogl::P64;
           P64[Hp - 48] = _sbogm::P64;
           P64[Hp - 40] = _sbogn::P64;
           P64[Hp - 32] = _sbogo::P64;
           P64[Hp - 24] = _sbogp::P64;
           P64[Hp - 16] = _sbogq::P64;
           P64[Hp - 8] = _sbogr::P64;
           P64[Hp] = _sbogs::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubsLG_srtd" {
     ubsLG_srtd:
         const SboCL_srt+256;
         const 34;
         const 16106127361;
 },
 GHC.IO.Handle.hSetBuffering1_entry() //  [R2, R3]
         { info_tbl: [(cbsLB,
                       label: GHC.IO.Handle.hSetBuffering1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsLB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbsLF; else goto cbsLE;
       cbsLF: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetBuffering1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbsLE: // global
           I64[Hp - 8] = sat_sbohh_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = R2;
           R2 = GHC.IO.Handle.hSetBuffering2_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.129562538 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering_closure" {
     GHC.IO.Handle.hSetBuffering_closure:
         const GHC.IO.Handle.hSetBuffering_info;
         const 0;
 },
 GHC.IO.Handle.hSetBuffering_entry() //  [R2, R3]
         { info_tbl: [(cbsNO,
                       label: GHC.IO.Handle.hSetBuffering_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsNO: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetBuffering1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.132785519 UTC

[section ""cstring" . GHC.IO.Handle.hIsEOF4_bytes" {
     GHC.IO.Handle.hIsEOF4_bytes:
         I8[] [104,73,115,69,79,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.134904249 UTC

[section ""data" . GHC.IO.Handle.hIsEOF3_closure" {
     GHC.IO.Handle.hIsEOF3_closure:
         const GHC.IO.Handle.hIsEOF3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsEOF3_entry() //  [R1]
         { info_tbl: [(cbsO2,
                       label: GHC.IO.Handle.hIsEOF3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsO2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsO3; else goto cbsO4;
       cbsO3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsO4: // global
           (_cbsNZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsNZ::I64 == 0) goto cbsO1; else goto cbsO0;
       cbsO1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsO0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsNZ::I64;
           R2 = GHC.IO.Handle.hIsEOF4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.139635238 UTC

[section ""data" . GHC.IO.Handle.hIsEOF2_closure" {
     GHC.IO.Handle.hIsEOF2_closure:
         const GHC.IO.Handle.hIsEOF2_info;
 },
 GHC.IO.Handle.hIsEOF2_entry() //  [R2]
         { info_tbl: [(cbsOj,
                       label: GHC.IO.Handle.hIsEOF2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsOj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbsOn; else goto cbsOo;
       cbsOn: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsEOF2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsOo: // global
           I64[Sp - 8] = block_cbsOg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsPf; else goto cbsOh;
       ubsPf: // global
           call _cbsOg(R1) args: 0, res: 0, upd: 0;
       cbsOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsOg() //  [R1]
         { info_tbl: [(cbsOg,
                       label: block_cbsOg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsOg: // global
           _sbohD::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 24] = block_cbsOm_info;
           _sbohm::P64 = P64[R1 + 15];
           _sboho::P64 = P64[R1 + 31];
           _sbohq::P64 = P64[R1 + 47];
           R1 = _sbohD::P64;
           P64[Sp - 16] = _sboho::P64;
           P64[Sp - 8] = _sbohq::P64;
           P64[Sp] = _sbohm::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubsPe; else goto cbsOq;
       ubsPe: // global
           call _cbsOm(R1) args: 0, res: 0, upd: 0;
       cbsOq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsOm() //  [R1]
         { info_tbl: [(cbsOm,
                       label: block_cbsOm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsOm: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbsOC; else goto ubsPc;
       cbsOC: // global
           _sbohO::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbsOB_info;
           R1 = _sbohO::P64;
           if (R1 & 7 != 0) goto ubsPg; else goto cbsOD;
       ubsPg: // global
           call _cbsOB(R1) args: 0, res: 0, upd: 0;
       cbsOD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubsPc: // global
           Sp = Sp + 32;
           call _cbsOL() args: 0, res: 0, upd: 0;
     }
 },
 _cbsOB() //  [R1]
         { info_tbl: [(cbsOB,
                       label: block_cbsOB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsOB: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbsOW; else goto ubsPd;
       cbsOW: // global
           _sboho::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbsOO_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sboho::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       ubsPd: // global
           Sp = Sp + 32;
           call _cbsOL() args: 0, res: 0, upd: 0;
     }
 },
 _cbsOO() //  [R1]
         { info_tbl: [(cbsOO,
                       label: block_cbsOO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsOO: // global
           I64[Sp] = block_cbsOQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubsPj; else goto cbsOR;
       ubsPj: // global
           call _cbsOQ(R1) args: 0, res: 0, upd: 0;
       cbsOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsOQ() //  [R1]
         { info_tbl: [(cbsOQ,
                       label: block_cbsOQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsOQ: // global
           I64[Sp] = block_cbsOV_info;
           _sboi2::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 16] = _sboi2::P64;
           if (R1 & 7 != 0) goto ubsPk; else goto cbsOZ;
       ubsPk: // global
           call _cbsOV(R1) args: 0, res: 0, upd: 0;
       cbsOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsOV() //  [R1]
         { info_tbl: [(cbsOV,
                       label: block_cbsOV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsOV: // global
           if (I64[R1 + 7] == 0) goto cbsP7; else goto cbsP6;
       cbsP7: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbsP6: // global
           _sbohq::P64 = P64[Sp + 8];
           _sboi2::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbohq::P64 + 8] = _sboi2::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbohq::P64);
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsOL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsOL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.155000015 UTC

[section ""data" . GHC.IO.Handle.hIsEOF1_closure" {
     GHC.IO.Handle.hIsEOF1_closure:
         const GHC.IO.Handle.hIsEOF1_info;
         const 0;
 },
 GHC.IO.Handle.hIsEOF1_entry() //  [R2]
         { info_tbl: [(cbsQ1,
                       label: GHC.IO.Handle.hIsEOF1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsQ1: // global
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.158911067 UTC

[section ""data" . GHC.IO.Handle.hIsEOF_closure" {
     GHC.IO.Handle.hIsEOF_closure:
         const GHC.IO.Handle.hIsEOF_info;
         const 0;
 },
 GHC.IO.Handle.hIsEOF_entry() //  [R2]
         { info_tbl: [(cbsQc,
                       label: GHC.IO.Handle.hIsEOF_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsQc: // global
           R2 = R2;
           call GHC.IO.Handle.hIsEOF1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.162154194 UTC

[section ""data" . GHC.IO.Handle.isEOF1_closure" {
     GHC.IO.Handle.isEOF1_closure:
         const GHC.IO.Handle.isEOF1_info;
         const 0;
 },
 GHC.IO.Handle.isEOF1_entry() //  []
         { info_tbl: [(cbsQn,
                       label: GHC.IO.Handle.isEOF1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsQn: // global
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.165747057 UTC

[section ""data" . GHC.IO.Handle.isEOF_closure" {
     GHC.IO.Handle.isEOF_closure:
         const GHC.IO.Handle.isEOF_info;
         const 0;
 },
 GHC.IO.Handle.isEOF_entry() //  []
         { info_tbl: [(cbsQy,
                       label: GHC.IO.Handle.isEOF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsQy: // global
           call GHC.IO.Handle.isEOF1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.168686557 UTC

[section ""cstring" . lvl19_rbnX1_bytes" {
     lvl19_rbnX1_bytes:
         I8[] [104,83,101,116,70,105,108,101,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.170503196 UTC

[section ""data" . lvl20_rbnX2_closure" {
     lvl20_rbnX2_closure:
         const lvl20_rbnX2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_rbnX2_entry() //  [R1]
         { info_tbl: [(cbsQM,
                       label: lvl20_rbnX2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsQM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsQN; else goto cbsQO;
       cbsQN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsQO: // global
           (_cbsQJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsQJ::I64 == 0) goto cbsQL; else goto cbsQK;
       cbsQL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsQK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsQJ::I64;
           R2 = lvl19_rbnX1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.177149175 UTC

[section ""data" . GHC.IO.Handle.hSetFileSize1_closure" {
     GHC.IO.Handle.hSetFileSize1_closure:
         const GHC.IO.Handle.hSetFileSize1_info;
         const 0;
 },
 act_sboib_entry() //  [R1, R2]
         { info_tbl: [(cbsR8,
                       label: act_sboib_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsR8: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbsR9; else goto cbsRa;
       cbsR9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsRa: // global
           I64[Sp - 16] = block_cbsR5_info;
           _sboi9::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sboi9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubsSi; else goto cbsR6;
       ubsSi: // global
           call _cbsR5(R1) args: 0, res: 0, upd: 0;
       cbsR6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsR5() //  [R1]
         { info_tbl: [(cbsR5,
                       label: block_cbsR5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsR5: // global
           I64[Sp - 32] = block_cbsRd_info;
           _sboif::P64 = P64[R1 + 7];
           _sboig::P64 = P64[R1 + 15];
           _sboii::P64 = P64[R1 + 31];
           _sboik::P64 = P64[R1 + 47];
           R1 = P64[R1 + 39];
           P64[Sp - 24] = _sboig::P64;
           P64[Sp - 16] = _sboii::P64;
           P64[Sp - 8] = _sboik::P64;
           P64[Sp] = _sboif::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubsSh; else goto cbsRf;
       ubsSh: // global
           call _cbsRd(R1) args: 0, res: 0, upd: 0;
       cbsRf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsRd() //  [R1]
         { info_tbl: [(cbsRd,
                       label: block_cbsRd_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsRd: // global
           _cbsSe::P64 = R1 & 7;
           if (_cbsSe::P64 != 1) goto ubsSg; else goto cbsS9;
       ubsSg: // global
           if (_cbsSe::P64 != 2) goto cbsRm; else goto cbsSd;
       cbsRm: // global
           _sboiy::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbsRj_info;
           R1 = _sboiy::P64;
           if (R1 & 7 != 0) goto ubsSj; else goto cbsRn;
       ubsSj: // global
           call _cbsRj(R1) args: 0, res: 0, upd: 0;
       cbsRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsSd: // global
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbsS9: // global
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbsRj() //  [R1]
         { info_tbl: [(cbsRj,
                       label: block_cbsRj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsRj: // global
           I64[Sp] = block_cbsRr_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubsSk; else goto cbsRt;
       ubsSk: // global
           call _cbsRr(R1) args: 0, res: 0, upd: 0;
       cbsRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsRr() //  [R1]
         { info_tbl: [(cbsRr,
                       label: block_cbsRr_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsRr: // global
           if (R1 & 7 == 1) goto cbsRA; else goto cbsRH;
       cbsRA: // global
           _sboi9::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbsRx_info;
           R2 = P64[Sp + 32];
           _sboii::P64 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_ppv_info;
           P64[Sp + 24] = _sboii::P64;
           P64[Sp + 32] = _sboi9::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
       cbsRH: // global
           _sboiM::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbsRF_info;
           R1 = _sboiM::P64;
           if (R1 & 7 != 0) goto ubsSl; else goto cbsRI;
       ubsSl: // global
           call _cbsRF(R1) args: 0, res: 0, upd: 0;
       cbsRI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsRx() //  []
         { info_tbl: [(cbsRx,
                       label: block_cbsRx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsRx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsRF() //  [R1]
         { info_tbl: [(cbsRF,
                       label: block_cbsRF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsRF: // global
           _sboii::P64 = P64[Sp + 16];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbsS3; else goto cbsRX;
       cbsS3: // global
           _sboi9::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbsS2_info;
           R2 = P64[Sp + 32];
           I64[Sp + 16] = stg_ap_ppv_info;
           P64[Sp + 24] = _sboii::P64;
           P64[Sp + 32] = _sboi9::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
       cbsRX: // global
           _sboig::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbsRQ_info;
           R2 = _sboig::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sboii::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbsS2() //  []
         { info_tbl: [(cbsS2,
                       label: block_cbsS2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsS2: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsRQ() //  [R1]
         { info_tbl: [(cbsRQ,
                       label: block_cbsRQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsRQ: // global
           _sboi9::P64 = P64[Sp + 32];
           _sboif::P64 = P64[Sp + 24];
           _sboii::P64 = P64[Sp + 8];
           _sboik::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sboik::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sboik::P64);
           I64[Sp + 32] = block_cbsRV_info;
           R2 = _sboif::P64;
           I64[Sp + 8] = stg_ap_ppv_info;
           P64[Sp + 16] = _sboii::P64;
           P64[Sp + 24] = _sboi9::P64;
           Sp = Sp + 8;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbsRV() //  []
         { info_tbl: [(cbsRV,
                       label: block_cbsRV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsRV: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbojj_entry() //  [R1, R2]
         { info_tbl: [(cbsSG,
                       label: sat_sbojj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsSG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsSH; else goto cbsSI;
       cbsSH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsSI: // global
           I64[Sp - 16] = block_cbsSD_info;
           _sbojd::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbojd::P64;
           Sp = Sp - 16;
           call act_sboib_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsSD() //  [R1]
         { info_tbl: [(cbsSD,
                       label: block_cbsSD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsSD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbsSL; else goto cbsSK;
       cbsSL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsSK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbojb_entry() //  [R1]
         { info_tbl: [(cbsSR,
                       label: io_sbojb_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsSR: // global
           _sbojb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbsSV; else goto cbsSW;
       cbsSW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbsSY; else goto cbsSX;
       cbsSY: // global
           HpAlloc = 16;
           goto cbsSV;
       cbsSV: // global
           R1 = _sbojb::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbsSX: // global
           _sboib::P64 = P64[_sbojb::P64 + 7];
           _sboj5::P64 = P64[_sbojb::P64 + 15];
           _sboj7::P64 = P64[_sbojb::P64 + 23];
           I64[Hp - 8] = sat_sbojj_info;
           P64[Hp] = _sboib::P64;
           I64[Sp - 16] = block_cbsSM_info;
           R5 = _sboj7::P64;
           R4 = Hp - 6;
           R3 = _sboj5::P64;
           R2 = lvl20_rbnX2_closure;
           P64[Sp - 8] = _sboj7::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbsSM() //  [R1]
         { info_tbl: [(cbsSM,
                       label: block_cbsSM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsSM: // global
           I64[Sp] = block_cbsSO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubsT3; else goto cbsSP;
       ubsT3: // global
           call _cbsSO(R1) args: 0, res: 0, upd: 0;
       cbsSP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsSO() //  [R1]
         { info_tbl: [(cbsSO,
                       label: block_cbsSO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsSO: // global
           I64[Sp] = block_cbsSU_info;
           R2 = P64[R1 + 7];
           _sbojp::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbojp::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsSU() //  []
         { info_tbl: [(cbsSU,
                       label: block_cbsSU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsSU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbojG_entry() //  [R1, R2]
         { info_tbl: [(cbsTl,
                       label: sat_sbojG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsTl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsTm; else goto cbsTn;
       cbsTm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsTn: // global
           I64[Sp - 16] = block_cbsTi_info;
           _sbojA::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbojA::P64;
           Sp = Sp - 16;
           call act_sboib_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsTi() //  [R1]
         { info_tbl: [(cbsTi,
                       label: block_cbsTi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsTi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbsTq; else goto cbsTp;
       cbsTq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsTp: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbojy_entry() //  [R1]
         { info_tbl: [(cbsTw,
                       label: io_sbojy_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsTw: // global
           _sbojy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbsTA; else goto cbsTB;
       cbsTB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbsTD; else goto cbsTC;
       cbsTD: // global
           HpAlloc = 16;
           goto cbsTA;
       cbsTA: // global
           R1 = _sbojy::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbsTC: // global
           _sboib::P64 = P64[_sbojy::P64 + 7];
           _sboj5::P64 = P64[_sbojy::P64 + 15];
           _sbojt::P64 = P64[_sbojy::P64 + 23];
           I64[Hp - 8] = sat_sbojG_info;
           P64[Hp] = _sboib::P64;
           I64[Sp - 16] = block_cbsTr_info;
           R5 = _sbojt::P64;
           R4 = Hp - 6;
           R3 = _sboj5::P64;
           R2 = lvl20_rbnX2_closure;
           P64[Sp - 8] = _sbojt::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbsTr() //  [R1]
         { info_tbl: [(cbsTr,
                       label: block_cbsTr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsTr: // global
           I64[Sp] = block_cbsTt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubsTI; else goto cbsTu;
       ubsTI: // global
           call _cbsTt(R1) args: 0, res: 0, upd: 0;
       cbsTu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsTt() //  [R1]
         { info_tbl: [(cbsTt,
                       label: block_cbsTt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsTt: // global
           I64[Sp] = block_cbsTz_info;
           R2 = P64[R1 + 7];
           _sbojM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbojM::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsTz() //  []
         { info_tbl: [(cbsTz,
                       label: block_cbsTz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsTz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetFileSize1_entry() //  [R2, R3]
         { info_tbl: [(cbsTN,
                       label: GHC.IO.Handle.hSetFileSize1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsTN: // global
           _sboi9::P64 = R3;
           _sboi8::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbsTO; else goto cbsTP;
       cbsTP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbsTR; else goto cbsTQ;
       cbsTR: // global
           HpAlloc = 16;
           goto cbsTO;
       cbsTO: // global
           R3 = _sboi9::P64;
           R2 = _sboi8::P64;
           R1 = GHC.IO.Handle.hSetFileSize1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbsTQ: // global
           I64[Hp - 8] = act_sboib_info;
           P64[Hp] = _sboi9::P64;
           I64[Sp - 16] = block_cbsSm_info;
           R1 = _sboi8::P64;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubsU8; else goto cbsSn;
       ubsU8: // global
           call _cbsSm(R1) args: 0, res: 0, upd: 0;
       cbsSn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsSm() //  [R1]
         { info_tbl: [(cbsSm,
                       label: block_cbsSm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsSm: // global
           if (R1 & 7 == 1) goto cbsTK; else goto cbsTL;
       cbsTK: // global
           I64[Sp - 16] = block_cbsSr_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbsTL: // global
           I64[Sp - 16] = block_cbsT6_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbsSr() //  [R1]
         { info_tbl: [(cbsSr,
                       label: block_cbsSr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsSr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbsTV; else goto cbsTU;
       cbsTV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbsTU: // global
           I64[Hp - 24] = io_sbojb_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbsSt::P64 = Hp - 23;
           if (R1 == 0) goto cbsTZ; else goto cbsTY;
       cbsTZ: // global
           R1 = _cbsSt::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbsTY: // global
           R1 = _cbsSt::P64;
           Sp = Sp + 32;
           call io_sbojb_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbsT6() //  [R1]
         { info_tbl: [(cbsT6,
                       label: block_cbsT6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsT6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbsU3; else goto cbsU2;
       cbsU3: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbsU2: // global
           I64[Hp - 24] = io_sbojy_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbsT8::P64 = Hp - 23;
           if (R1 == 0) goto cbsU7; else goto cbsU6;
       cbsU7: // global
           R1 = _cbsT8::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbsU6: // global
           R1 = _cbsT8::P64;
           Sp = Sp + 32;
           call io_sbojy_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.227014757 UTC

[section ""data" . GHC.IO.Handle.hSetFileSize_closure" {
     GHC.IO.Handle.hSetFileSize_closure:
         const GHC.IO.Handle.hSetFileSize_info;
         const 0;
 },
 GHC.IO.Handle.hSetFileSize_entry() //  [R2, R3]
         { info_tbl: [(cbsW9,
                       label: GHC.IO.Handle.hSetFileSize_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsW9: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetFileSize1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.231198619 UTC

[section ""cstring" . GHC.IO.Handle.hFileSize9_bytes" {
     GHC.IO.Handle.hFileSize9_bytes:
         I8[] [104,70,105,108,101,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.233020585 UTC

[section ""data" . GHC.IO.Handle.hFileSize8_closure" {
     GHC.IO.Handle.hFileSize8_closure:
         const GHC.IO.Handle.hFileSize8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize8_entry() //  [R1]
         { info_tbl: [(cbsWn,
                       label: GHC.IO.Handle.hFileSize8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsWn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsWo; else goto cbsWp;
       cbsWo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsWp: // global
           (_cbsWk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsWk::I64 == 0) goto cbsWm; else goto cbsWl;
       cbsWm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsWl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsWk::I64;
           R2 = GHC.IO.Handle.hFileSize9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.236736542 UTC

[section ""cstring" . GHC.IO.Handle.hFileSize7_bytes" {
     GHC.IO.Handle.hFileSize7_bytes:
         I8[] [110,111,116,32,97,32,114,101,103,117,108,97,114,32,102,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.238756364 UTC

[section ""data" . GHC.IO.Handle.hFileSize6_closure" {
     GHC.IO.Handle.hFileSize6_closure:
         const GHC.IO.Handle.hFileSize6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize6_entry() //  [R1]
         { info_tbl: [(cbsWE,
                       label: GHC.IO.Handle.hFileSize6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsWE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsWF; else goto cbsWG;
       cbsWF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsWG: // global
           (_cbsWB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsWB::I64 == 0) goto cbsWD; else goto cbsWC;
       cbsWD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsWC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsWB::I64;
           R2 = GHC.IO.Handle.hFileSize7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.242530552 UTC

[section ""data" . GHC.IO.Handle.hFileSize5_closure" {
     GHC.IO.Handle.hFileSize5_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Handle.hFileSize8_closure;
         const GHC.IO.Handle.hFileSize6_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.244420617 UTC

[section ""data" . GHC.IO.Handle.hFileSize4_closure" {
     GHC.IO.Handle.hFileSize4_closure:
         const GHC.IO.Handle.hFileSize4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize4_entry() //  [R1]
         { info_tbl: [(cbsWV,
                       label: GHC.IO.Handle.hFileSize4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsWV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsWW; else goto cbsWX;
       cbsWW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsWX: // global
           (_cbsWS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsWS::I64 == 0) goto cbsWU; else goto cbsWT;
       cbsWU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsWT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsWS::I64;
           R2 = GHC.IO.Handle.hFileSize5_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.24812621 UTC

[section ""data" . sat_sbojP_closure" {
     sat_sbojP_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.249785432 UTC

[section ""data" . sat_sbojQ_closure" {
     sat_sbojQ_closure:
         const :_con_info;
         const sat_sbojP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.251576516 UTC

[section ""data" . GHC.IO.Handle.hFileSize10_closure" {
     GHC.IO.Handle.hFileSize10_closure:
         const GHC.IO.Handle.hFileSize10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize10_entry() //  [R1]
         { info_tbl: [(cbsXd,
                       label: GHC.IO.Handle.hFileSize10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsXd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsXe; else goto cbsXf;
       cbsXe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbsXf: // global
           (_cbsXa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbsXa::I64 == 0) goto cbsXc; else goto cbsXb;
       cbsXc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbsXb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbsXa::I64;
           R3 = sat_sbojQ_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.256895445 UTC

[section ""data" . GHC.IO.Handle.hFileSize3_closure" {
     GHC.IO.Handle.hFileSize3_closure:
         const GHC.IO.Handle.hFileSize3_info;
         const 0;
 },
 section ""relreadonly" . ubsYY_srtd" {
     ubsYY_srtd:
         const SboCL_srt+328;
         const 38;
         const 240522362881;
 },
 GHC.IO.Handle.hFileSize3_entry() //  [R2]
         { info_tbl: [(cbsXu,
                       label: GHC.IO.Handle.hFileSize3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsXu: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbsXv; else goto cbsXw;
       cbsXv: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsXw: // global
           I64[Sp - 8] = block_cbsXr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubsYR; else goto cbsXs;
       ubsYR: // global
           call _cbsXr(R1) args: 0, res: 0, upd: 0;
       cbsXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubsYZ_srtd" {
     ubsYZ_srtd:
         const SboCL_srt+328;
         const 38;
         const 206162624513;
 },
 _cbsXr() //  [R1]
         { info_tbl: [(cbsXr,
                       label: block_cbsXr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsXr: // global
           I64[Sp - 32] = block_cbsXz_info;
           _sbojU::P64 = P64[R1 + 7];
           _sbojV::P64 = P64[R1 + 15];
           _sbojX::P64 = P64[R1 + 31];
           _sbojZ::P64 = P64[R1 + 47];
           R1 = P64[R1 + 39];
           P64[Sp - 24] = _sbojV::P64;
           P64[Sp - 16] = _sbojX::P64;
           P64[Sp - 8] = _sbojZ::P64;
           P64[Sp] = _sbojU::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubsYQ; else goto cbsXB;
       ubsYQ: // global
           call _cbsXz(R1) args: 0, res: 0, upd: 0;
       cbsXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubsZ0_srtd" {
     ubsZ0_srtd:
         const SboCL_srt+328;
         const 38;
         const 206162624513;
 },
 _cbsXz() //  [R1]
         { info_tbl: [(cbsXz,
                       label: block_cbsXz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsXz: // global
           _cbsYH::P64 = R1 & 7;
           if (_cbsYH::P64 != 1) goto ubsYM; else goto cbsYC;
       ubsYM: // global
           if (_cbsYH::P64 != 2) goto cbsXI; else goto cbsYG;
       cbsXI: // global
           _sbokd::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbsXF_info;
           R1 = _sbokd::P64;
           if (R1 & 7 != 0) goto ubsYS; else goto cbsXJ;
       ubsYS: // global
           call _cbsXF(R1) args: 0, res: 0, upd: 0;
       cbsXJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbsYG: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbsYC: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbsXF() //  [R1]
         { info_tbl: [(cbsXF,
                       label: block_cbsXF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsXF: // global
           I64[Sp] = block_cbsXP_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubsYT; else goto cbsY9;
       ubsYT: // global
           call _cbsXP(R1) args: 0, res: 0, upd: 0;
       cbsY9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsXP() //  [R1]
         { info_tbl: [(cbsXP,
                       label: block_cbsXP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsXP: // global
           if (R1 & 7 == 1) goto ubsYN; else goto cbsYk;
       ubsYN: // global
           Sp = Sp + 16;
           call _sbokl() args: 0, res: 0, upd: 0;
       cbsYk: // global
           _sboku::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbsYi_info;
           R1 = _sboku::P64;
           if (R1 & 7 != 0) goto ubsYU; else goto cbsYl;
       ubsYU: // global
           call _cbsYi(R1) args: 0, res: 0, upd: 0;
       cbsYl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbsYi() //  [R1]
         { info_tbl: [(cbsYi,
                       label: block_cbsYi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsYi: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubsYO; else goto cbsYv;
       ubsYO: // global
           Sp = Sp + 16;
           call _sbokl() args: 0, res: 0, upd: 0;
       cbsYv: // global
           _sbojV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbsYt_info;
           R2 = _sbojV::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbsYt() //  [R1]
         { info_tbl: [(cbsYt,
                       label: block_cbsYt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsYt: // global
           _sbojZ::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbojZ::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbojZ::P64);
           Sp = Sp + 8;
           call _sbokl() args: 0, res: 0, upd: 0;
     }
 },
 _sbokl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbokl: // global
           _sbojU::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbsXU_info;
           R2 = _sbojU::P64;
           _sbojX::P64 = P64[Sp];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbojX::P64;
           call GHC.IO.Device.getSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbsXU() //  [R1]
         { info_tbl: [(cbsXU,
                       label: block_cbsXU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsXU: // global
           I64[Sp - 8] = block_cbsXW_info;
           R3 = GHC.IO.Handle.hFileSize10_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbsXW() //  [R1]
         { info_tbl: [(cbsXW,
                       label: block_cbsXW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsXW: // global
           if (R1 == 1) goto cbsY8; else goto cbsY4;
       cbsY8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbsY4: // global
           R1 = GHC.IO.Handle.hFileSize4_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.278816223 UTC

[section ""data" . GHC.IO.Handle.hFileSize2_closure" {
     GHC.IO.Handle.hFileSize2_closure:
         const GHC.IO.Handle.hFileSize2_info;
         const 0;
 },
 GHC.IO.Handle.hFileSize2_entry() //  [R2]
         { info_tbl: [(cbsZU,
                       label: GHC.IO.Handle.hFileSize2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsZU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbsZV; else goto cbsZW;
       cbsZV: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsZW: // global
           I64[Sp - 16] = block_cbsZR_info;
           _sbokH::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbokH::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hFileSize3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbsZR() //  [R1]
         { info_tbl: [(cbsZR,
                       label: block_cbsZR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbsZR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbsZZ; else goto cbsZY;
       cbsZZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbsZY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.285381121 UTC

[section ""data" . GHC.IO.Handle.hFileSize1_closure" {
     GHC.IO.Handle.hFileSize1_closure:
         const GHC.IO.Handle.hFileSize1_info;
         const 0;
 },
 io_sbokV_entry() //  [R1]
         { info_tbl: [(cbt0v,
                       label: io_sbokV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbt0z; else goto cbt0A;
       cbt0z: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbt0A: // global
           I64[Sp - 16] = block_cbt0q_info;
           _sbokR::P64 = P64[R1 + 15];
           R5 = _sbokR::P64;
           R4 = GHC.IO.Handle.hFileSize2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFileSize8_closure;
           P64[Sp - 8] = _sbokR::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbt0q() //  [R1]
         { info_tbl: [(cbt0q,
                       label: block_cbt0q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0q: // global
           I64[Sp] = block_cbt0s_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubt0F; else goto cbt0t;
       ubt0F: // global
           call _cbt0s(R1) args: 0, res: 0, upd: 0;
       cbt0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbt0s() //  [R1]
         { info_tbl: [(cbt0s,
                       label: block_cbt0s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0s: // global
           I64[Sp] = block_cbt0y_info;
           R2 = P64[R1 + 7];
           _sbol2::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbol2::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbt0y() //  []
         { info_tbl: [(cbt0y,
                       label: block_cbt0y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0y: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbolb_entry() //  [R1]
         { info_tbl: [(cbt0U,
                       label: io_sbolb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbt0Y; else goto cbt0Z;
       cbt0Y: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbt0Z: // global
           I64[Sp - 16] = block_cbt0P_info;
           _sbol6::P64 = P64[R1 + 15];
           R5 = _sbol6::P64;
           R4 = GHC.IO.Handle.hFileSize2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFileSize8_closure;
           P64[Sp - 8] = _sbol6::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbt0P() //  [R1]
         { info_tbl: [(cbt0P,
                       label: block_cbt0P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0P: // global
           I64[Sp] = block_cbt0R_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubt14; else goto cbt0S;
       ubt14: // global
           call _cbt0R(R1) args: 0, res: 0, upd: 0;
       cbt0S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbt0R() //  [R1]
         { info_tbl: [(cbt0R,
                       label: block_cbt0R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0R: // global
           I64[Sp] = block_cbt0X_info;
           R2 = P64[R1 + 7];
           _sboli::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboli::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbt0X() //  []
         { info_tbl: [(cbt0X,
                       label: block_cbt0X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0X: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hFileSize1_entry() //  [R2]
         { info_tbl: [(cbt19,
                       label: GHC.IO.Handle.hFileSize1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt19: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbt1a; else goto cbt1b;
       cbt1a: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt1b: // global
           I64[Sp - 8] = block_cbt0e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubt1s; else goto cbt0f;
       ubt1s: // global
           call _cbt0e(R1) args: 0, res: 0, upd: 0;
       cbt0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbt0e() //  [R1]
         { info_tbl: [(cbt0e,
                       label: block_cbt0e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0e: // global
           if (R1 & 7 == 1) goto cbt16; else goto cbt17;
       cbt16: // global
           I64[Sp - 16] = block_cbt0j_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbt17: // global
           I64[Sp - 16] = block_cbt0I_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbt0j() //  [R1]
         { info_tbl: [(cbt0j,
                       label: block_cbt0j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbt1f; else goto cbt1e;
       cbt1f: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbt1e: // global
           I64[Hp - 16] = io_sbokV_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbt0l::P64 = Hp - 15;
           if (R1 == 0) goto cbt1j; else goto cbt1i;
       cbt1j: // global
           R1 = _cbt0l::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbt1i: // global
           R1 = _cbt0l::P64;
           Sp = Sp + 24;
           call io_sbokV_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbt0I() //  [R1]
         { info_tbl: [(cbt0I,
                       label: block_cbt0I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt0I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbt1n; else goto cbt1m;
       cbt1n: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbt1m: // global
           I64[Hp - 16] = io_sbolb_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbt0K::P64 = Hp - 15;
           if (R1 == 0) goto cbt1r; else goto cbt1q;
       cbt1r: // global
           R1 = _cbt0K::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbt1q: // global
           R1 = _cbt0K::P64;
           Sp = Sp + 24;
           call io_sbolb_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.308952208 UTC

[section ""data" . GHC.IO.Handle.hFileSize_closure" {
     GHC.IO.Handle.hFileSize_closure:
         const GHC.IO.Handle.hFileSize_info;
         const 0;
 },
 GHC.IO.Handle.hFileSize_entry() //  [R2]
         { info_tbl: [(cbt2o,
                       label: GHC.IO.Handle.hFileSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt2o: // global
           R2 = R2;
           call GHC.IO.Handle.hFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.312233853 UTC

[section ""data" . lvl21_rbnX3_closure" {
     lvl21_rbnX3_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.316908041 UTC

[section ""data" . GHC.IO.Handle.hDuplicateTo1_closure" {
     GHC.IO.Handle.hDuplicateTo1_closure:
         const GHC.IO.Handle.hDuplicateTo1_info;
         const 0;
 },
 sat_sbolF_entry() //  [R1, R2]
         { info_tbl: [(cbt2Z,
                       label: sat_sbolF_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt2Z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbt30; else goto cbt31;
       cbt30: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt31: // global
           I64[Sp - 16] = block_cbt2W_info;
           R6 = R2;
           R5 = P64[R1 + 22];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 6];
           _sbolz::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = lvl21_rbnX3_closure+2;
           P64[Sp - 8] = _sbolz::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbt2W() //  [R1]
         { info_tbl: [(cbt2W,
                       label: block_cbt2W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt2W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbt34; else goto cbt33;
       cbt34: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt33: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubt4R_srtd" {
     ubt4R_srtd:
         const SboCL_srt+176;
         const 64;
         const 17293822569102704641;
 },
 sat_sbolG_entry() //  [R1, R2]
         { info_tbl: [(cbt35,
                       label: sat_sbolG_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt35: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbt36; else goto cbt37;
       cbt36: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt37: // global
           I64[Sp - 40] = block_cbt2P_info;
           _sbolu::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 14];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _sbolu::P64;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubt4S_srtd" {
     ubt4S_srtd:
         const SboCL_srt+176;
         const 64;
         const 12682136550675316737;
 },
 _cbt2P() //  [R1]
         { info_tbl: [(cbt2P,
                       label: block_cbt2P_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt2P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbt3a; else goto cbt39;
       cbt3a: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt39: // global
           I64[Hp - 24] = sat_sbolF_info;
           _sbolo::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sbolo::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 32];
           R5 = Hp - 22;
           R4 = P64[Sp + 24];
           R3 = _sbolo::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbom4_entry() //  [R1, R2]
         { info_tbl: [(cbt3y,
                       label: sat_sbom4_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt3y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbt3z; else goto cbt3A;
       cbt3z: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt3A: // global
           I64[Sp - 16] = block_cbt3v_info;
           R6 = R2;
           R5 = P64[R1 + 22];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 6];
           _sbolY::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = lvl21_rbnX3_closure+2;
           P64[Sp - 8] = _sbolY::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbt3v() //  [R1]
         { info_tbl: [(cbt3v,
                       label: block_cbt3v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt3v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbt3D; else goto cbt3C;
       cbt3D: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt3C: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubt4T_srtd" {
     ubt4T_srtd:
         const SboCL_srt+176;
         const 64;
         const 17293822569102704641;
 },
 sat_sbom5_entry() //  [R1, R2]
         { info_tbl: [(cbt3E,
                       label: sat_sbom5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt3E: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbt3F; else goto cbt3G;
       cbt3F: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt3G: // global
           I64[Sp - 40] = block_cbt3o_info;
           _sbolT::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 14];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _sbolT::P64;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubt4U_srtd" {
     ubt4U_srtd:
         const SboCL_srt+176;
         const 64;
         const 12682136550675316737;
 },
 _cbt3o() //  [R1]
         { info_tbl: [(cbt3o,
                       label: block_cbt3o_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt3o: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbt3J; else goto cbt3I;
       cbt3J: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt3I: // global
           I64[Hp - 24] = sat_sbom4_info;
           _sbolo::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sbolo::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 32];
           R5 = Hp - 22;
           R4 = P64[Sp + 24];
           R3 = _sbolo::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbomm_entry() //  [R1, R2]
         { info_tbl: [(cbt43,
                       label: sat_sbomm_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt43: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbt44; else goto cbt45;
       cbt44: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt45: // global
           I64[Sp - 16] = block_cbt40_info;
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 6];
           _sbomg::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _sbomg::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbt40() //  [R1]
         { info_tbl: [(cbt40,
                       label: block_cbt40_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt40: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbt48; else goto cbt47;
       cbt48: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt47: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubt4V_srtd" {
     ubt4V_srtd:
         const SboCL_srt+176;
         const 64;
         const 16140901064495857665;
 },
 sat_sbomn_entry() //  [R1, R2]
         { info_tbl: [(cbt49,
                       label: sat_sbomn_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt49: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbt4a; else goto cbt4b;
       cbt4a: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt4b: // global
           I64[Sp - 48] = block_cbt3T_info;
           _sbomb::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = P64[R1 + 6];
           P64[Sp - 32] = P64[R1 + 14];
           P64[Sp - 24] = P64[R1 + 22];
           P64[Sp - 16] = P64[R1 + 30];
           P64[Sp - 8] = _sbomb::P64;
           Sp = Sp - 48;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubt4W_srtd" {
     ubt4W_srtd:
         const SboCL_srt+176;
         const 64;
         const 11529215046068469761;
 },
 _cbt3T() //  [R1]
         { info_tbl: [(cbt3T,
                       label: block_cbt3T_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt3T: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbt4e; else goto cbt4d;
       cbt4e: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt4d: // global
           I64[Hp - 32] = sat_sbomm_info;
           _sbolo::P64 = P64[Sp + 8];
           P64[Hp - 24] = _sbolo::P64;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R5 = Hp - 30;
           R4 = P64[Sp + 24];
           R3 = _sbolo::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubt4X_srtd" {
     ubt4X_srtd:
         const SboCL_srt+176;
         const 66;
         const 17293822569102704645;
         const 3;
 },
 GHC.IO.Handle.hDuplicateTo1_entry() //  [R2, R3]
         { info_tbl: [(cbt4j,
                       label: GHC.IO.Handle.hDuplicateTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt4j: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbt4k; else goto cbt4l;
       cbt4k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hDuplicateTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbt4l: // global
           I64[Sp - 16] = block_cbt2A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubt4Q; else goto cbt2B;
       ubt4Q: // global
           call _cbt2A(R1) args: 0, res: 0, upd: 0;
       cbt2B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubt4Y_srtd" {
     ubt4Y_srtd:
         const SboCL_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbt2A() //  [R1]
         { info_tbl: [(cbt2A,
                       label: block_cbt2A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt2A: // global
           _sbolm::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbt4g; else goto cbt4h;
       cbt4g: // global
           I64[Sp - 16] = block_cbt2F_info;
           _sbolo::P64 = R1;
           _sbolp::P64 = P64[R1 + 7];
           _sbolq::P64 = P64[R1 + 15];
           R1 = _sbolm::P64;
           P64[Sp - 8] = _sbolq::P64;
           P64[Sp] = _sbolp::P64;
           P64[Sp + 8] = _sbolo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubt4M; else goto cbt2G;
       ubt4M: // global
           call _cbt2F(R1) args: 0, res: 0, upd: 0;
       cbt2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbt4h: // global
           I64[Sp - 24] = block_cbt3d_info;
           _sbolo::P64 = R1;
           _sbolK::P64 = P64[R1 + 6];
           _sbolL::P64 = P64[R1 + 14];
           _sbolM::P64 = P64[R1 + 22];
           R1 = _sbolm::P64;
           P64[Sp - 16] = _sbolL::P64;
           P64[Sp - 8] = _sbolM::P64;
           P64[Sp] = _sbolK::P64;
           P64[Sp + 8] = _sbolo::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubt4N; else goto cbt3e;
       ubt4N: // global
           call _cbt3d(R1) args: 0, res: 0, upd: 0;
       cbt3e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubt4Z_srtd" {
     ubt4Z_srtd:
         const SboCL_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbt2F() //  [R1]
         { info_tbl: [(cbt2F,
                       label: block_cbt2F_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt2F: // global
           if (R1 & 7 == 1) goto cbt4o; else goto ubt4L;
       cbt4o: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbt4r; else goto cbt4q;
       cbt4r: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt4q: // global
           _sbolt::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sbolG_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R5 = Hp - 22;
           R4 = _sbolt::P64;
           R3 = R1;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       ubt4L: // global
           Sp = Sp + 24;
           call _cbt4A() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubt50_srtd" {
     ubt50_srtd:
         const SboCL_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbt3d() //  [R1]
         { info_tbl: [(cbt3d,
                       label: block_cbt3d_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt3d: // global
           if (R1 & 7 == 1) goto ubt4K; else goto cbt4B;
       ubt4K: // global
           Sp = Sp + 32;
           call _cbt4A() args: 0, res: 0, upd: 0;
       cbt4B: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbt4E; else goto cbt4D;
       cbt4E: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt4D: // global
           _sbolR::P64 = P64[R1 + 14];
           _sbolS::P64 = P64[R1 + 22];
           I64[Hp - 24] = sat_sbom5_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 16] = block_cbt3K_info;
           R5 = Hp - 22;
           R4 = _sbolS::P64;
           R3 = R1;
           R2 = lvl1_rbnWC_closure;
           P64[Sp - 8] = _sbolR::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbt4A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt4A: // global
           R2 = P64[Sp];
           Sp = Sp + 8;
           call ioe_dupHandlesNotCompatible_rbnWF_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubt51_srtd" {
     ubt51_srtd:
         const SboCL_srt+176;
         const 65;
         const 16140901064495857665;
         const 1;
 },
 _cbt3K() //  [R1]
         { info_tbl: [(cbt3K,
                       label: block_cbt3K_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt3K: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbt4H; else goto cbt4G;
       cbt4H: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt4G: // global
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = P64[Sp + 32];
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = sat_sbomn_info;
           P64[Hp - 24] = P64[Sp + 48];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           R5 = Hp - 30;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.362425662 UTC

[section ""data" . GHC.IO.Handle.hDuplicateTo_closure" {
     GHC.IO.Handle.hDuplicateTo_closure:
         const GHC.IO.Handle.hDuplicateTo_info;
         const 0;
 },
 GHC.IO.Handle.hDuplicateTo_entry() //  [R2, R3]
         { info_tbl: [(cbt6Y,
                       label: GHC.IO.Handle.hDuplicateTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt6Y: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hDuplicateTo1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.36608242 UTC

[section ""cstring" . lvl22_rbnX4_bytes" {
     lvl22_rbnX4_bytes:
         I8[] [104,68,117,112,108,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.367932491 UTC

[section ""data" . lvl23_rbnX5_closure" {
     lvl23_rbnX5_closure:
         const lvl23_rbnX5_info;
         const 0;
         const 0;
         const 0;
 },
 lvl23_rbnX5_entry() //  [R1]
         { info_tbl: [(cbt7c,
                       label: lvl23_rbnX5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt7c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbt7d; else goto cbt7e;
       cbt7d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbt7e: // global
           (_cbt79::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbt79::I64 == 0) goto cbt7b; else goto cbt7a;
       cbt7b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbt7a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbt79::I64;
           R2 = lvl22_rbnX4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.371787818 UTC

[section ""cstring" . lvl24_rbnX6_bytes" {
     lvl24_rbnX6_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,54,50,54,58,51,45,51,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.373662271 UTC

[section ""data" . lvl25_rbnX7_closure" {
     lvl25_rbnX7_closure:
         const lvl25_rbnX7_info;
         const 0;
 },
 lvl25_rbnX7_entry() //  []
         { info_tbl: [(cbt7t,
                       label: lvl25_rbnX7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt7t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbt7u; else goto cbt7v;
       cbt7u: // global
           R1 = lvl25_rbnX7_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbt7v: // global
           I64[Sp - 8] = block_cbt7r_info;
           R2 = lvl24_rbnX6_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbt7r() //  [R1]
         { info_tbl: [(cbt7r,
                       label: block_cbt7r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt7r: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.379573021 UTC

[section ""cstring" . lvl26_rbnX8_bytes" {
     lvl26_rbnX8_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,54,50,51,58,51,45,51,53]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.381494952 UTC

[section ""data" . lvl27_rbnX9_closure" {
     lvl27_rbnX9_closure:
         const lvl27_rbnX9_info;
         const 0;
 },
 lvl27_rbnX9_entry() //  []
         { info_tbl: [(cbt7O,
                       label: lvl27_rbnX9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt7O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbt7P; else goto cbt7Q;
       cbt7P: // global
           R1 = lvl27_rbnX9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbt7Q: // global
           I64[Sp - 8] = block_cbt7M_info;
           R2 = lvl26_rbnX8_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbt7M() //  [R1]
         { info_tbl: [(cbt7M,
                       label: block_cbt7M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt7M: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.389138295 UTC

[section ""data" . GHC.IO.Handle.hDuplicate1_closure" {
     GHC.IO.Handle.hDuplicate1_closure:
         const GHC.IO.Handle.hDuplicate1_info;
         const 0;
 },
 section ""relreadonly" . ubtaJ_srtd" {
     ubtaJ_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 sat_sbon0_entry() //  [R1, R2]
         { info_tbl: [(cbt8j,
                       label: sat_sbon0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8j: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbt8t; else goto cbt8u;
       cbt8t: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt8u: // global
           I64[Sp - 16] = block_cbt8g_info;
           _sbomv::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbomv::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubt8B; else goto cbt8h;
       ubt8B: // global
           call _cbt8g(R1) args: 0, res: 0, upd: 0;
       cbt8h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaK_srtd" {
     ubtaK_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 _cbt8g() //  [R1]
         { info_tbl: [(cbt8g,
                       label: block_cbt8g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8g: // global
           I64[Sp - 40] = block_cbt8m_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaL_srtd" {
     ubtaL_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbt8m() //  []
         { info_tbl: [(cbt8m,
                       label: block_cbt8m_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8m: // global
           I64[Sp] = block_cbt8o_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 16;
           call GHC.IO.Device.dup_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaM_srtd" {
     ubtaM_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbt8o() //  [R1]
         { info_tbl: [(cbt8o,
                       label: block_cbt8o_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8o: // global
           I64[Sp + 32] = block_cbt8q_info;
           R6 = P64[Sp + 48];
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = lvl21_rbnX3_closure+2;
           Sp = Sp + 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbt8q() //  [R1]
         { info_tbl: [(cbt8q,
                       label: block_cbt8q_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbt8A; else goto cbt8z;
       cbt8A: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt8z: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtaN_srtd" {
     ubtaN_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 sat_sbonx_entry() //  [R1, R2]
         { info_tbl: [(cbt8M,
                       label: sat_sbonx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8M: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbt8W; else goto cbt8X;
       cbt8W: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt8X: // global
           I64[Sp - 16] = block_cbt8J_info;
           _sbon1::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbon1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubt94; else goto cbt8K;
       ubt94: // global
           call _cbt8J(R1) args: 0, res: 0, upd: 0;
       cbt8K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaO_srtd" {
     ubtaO_srtd:
         const SboCL_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 _cbt8J() //  [R1]
         { info_tbl: [(cbt8J,
                       label: block_cbt8J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8J: // global
           I64[Sp - 40] = block_cbt8P_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaP_srtd" {
     ubtaP_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbt8P() //  []
         { info_tbl: [(cbt8P,
                       label: block_cbt8P_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8P: // global
           I64[Sp] = block_cbt8R_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 16;
           call GHC.IO.Device.dup_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaQ_srtd" {
     ubtaQ_srtd:
         const SboCL_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbt8R() //  [R1]
         { info_tbl: [(cbt8R,
                       label: block_cbt8R_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8R: // global
           I64[Sp + 32] = block_cbt8T_info;
           R6 = P64[Sp + 48];
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = lvl21_rbnX3_closure+2;
           Sp = Sp + 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbt8T() //  [R1]
         { info_tbl: [(cbt8T,
                       label: block_cbt8T_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt8T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbt93; else goto cbt92;
       cbt93: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt92: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sboop_entry() //  [R1, R2]
         { info_tbl: [(cbt9y,
                       label: sat_sboop_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt9y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbt9E; else goto cbt9F;
       cbt9E: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt9F: // global
           I64[Sp - 32] = block_cbt9v_info;
           _sbon1::P64 = P64[R1 + 6];
           _sbonF::P64 = P64[R1 + 14];
           _sbonI::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sbon1::P64;
           P64[Sp - 16] = _sbonF::P64;
           P64[Sp - 8] = _sbonI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubt9K; else goto cbt9w;
       ubt9K: // global
           call _cbt9v(R1) args: 0, res: 0, upd: 0;
       cbt9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbt9v() //  [R1]
         { info_tbl: [(cbt9v,
                       label: block_cbt9v_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt9v: // global
           _sbonF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbt9B_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sbonF::P64;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbt9B() //  [R1]
         { info_tbl: [(cbt9B,
                       label: block_cbt9B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt9B: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbt9J; else goto cbt9I;
       cbt9J: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt9I: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtaR_srtd" {
     ubtaR_srtd:
         const SboCL_srt+96;
         const 81;
         const 1;
         const 98816;
 },
 sat_sboou_entry() //  [R1, R2]
         { info_tbl: [(cbt9L,
                       label: sat_sboou_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt9L: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbt9P; else goto cbt9Q;
       cbt9P: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbt9Q: // global
           I64[Sp - 40] = block_cbt9j_info;
           _sbomu::P64 = P64[R1 + 6];
           _sbon1::P64 = P64[R1 + 14];
           _sbonD::P64 = P64[R1 + 22];
           _sbonF::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 32] = _sbomu::P64;
           P64[Sp - 24] = _sbon1::P64;
           P64[Sp - 16] = _sbonD::P64;
           P64[Sp - 8] = _sbonF::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubt9Y; else goto cbt9k;
       ubt9Y: // global
           call _cbt9j(R1) args: 0, res: 0, upd: 0;
       cbt9k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaS_srtd" {
     ubtaS_srtd:
         const SboCL_srt+96;
         const 81;
         const 1;
         const 98816;
 },
 _cbt9j() //  [R1]
         { info_tbl: [(cbt9j,
                       label: block_cbt9j_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt9j: // global
           I64[Sp - 8] = block_cbt9o_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbt9o() //  [R1]
         { info_tbl: [(cbt9o,
                       label: block_cbt9o_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt9o: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbt9U; else goto cbt9T;
       cbt9U: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt9T: // global
           I64[Hp - 24] = sat_sboop_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cbt9M_info;
           R5 = Hp - 22;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = lvl7_rbnWP_closure;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbt9M() //  [R1]
         { info_tbl: [(cbt9M,
                       label: block_cbt9M_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt9M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbt9X; else goto cbt9W;
       cbt9X: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbt9W: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtaT_srtd" {
     ubtaT_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 512576;
 },
 GHC.IO.Handle.hDuplicate1_entry() //  [R2]
         { info_tbl: [(cbta3,
                       label: GHC.IO.Handle.hDuplicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbta3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbta4; else goto cbta5;
       cbta4: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hDuplicate1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbta5: // global
           I64[Sp - 8] = block_cbt86_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtaH; else goto cbt87;
       ubtaH: // global
           call _cbt86(R1) args: 0, res: 0, upd: 0;
       cbt87: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaU_srtd" {
     ubtaU_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 381504;
 },
 _cbt86() //  [R1]
         { info_tbl: [(cbt86,
                       label: block_cbt86_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt86: // global
           if (R1 & 7 == 1) goto cbta0; else goto cbta1;
       cbta0: // global
           Hp = Hp + 16;
           _sbomu::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtab; else goto cbta7;
       cbta7: // global
           _sbomv::P64 = P64[_sbomu::P64 + 7];
           _sbomw::P64 = P64[_sbomu::P64 + 15];
           I64[Hp - 8] = sat_sbon0_info;
           P64[Hp] = _sbomv::P64;
           R5 = Hp - 6;
           R4 = _sbomw::P64;
           R3 = _sbomu::P64;
           R2 = lvl23_rbnX5_closure;
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cbta1: // global
           Hp = Hp + 16;
           _sbomu::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtab; else goto cbtaa;
       cbtab: // global
           HpAlloc = 16;
           R1 = _sbomu::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtaa: // global
           _sbon1::P64 = P64[_sbomu::P64 + 6];
           _sbon2::P64 = P64[_sbomu::P64 + 14];
           _sbon3::P64 = P64[_sbomu::P64 + 22];
           I64[Hp - 8] = sat_sbonx_info;
           P64[Hp] = _sbon1::P64;
           I64[Sp - 24] = block_cbt95_info;
           R5 = Hp - 6;
           R4 = _sbon3::P64;
           R3 = _sbomu::P64;
           R2 = lvl23_rbnX5_closure;
           P64[Sp - 16] = _sbon1::P64;
           P64[Sp - 8] = _sbon2::P64;
           P64[Sp] = _sbomu::P64;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaV_srtd" {
     ubtaV_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 381440;
 },
 _cbt95() //  [R1]
         { info_tbl: [(cbt95,
                       label: block_cbt95_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt95: // global
           I64[Sp] = block_cbt97_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtaG; else goto cbt98;
       ubtaG: // global
           call _cbt97(R1) args: 0, res: 0, upd: 0;
       cbt98: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtaW_srtd" {
     ubtaW_srtd:
         const SboCL_srt+96;
         const 83;
         const 1;
         const 381440;
 },
 _cbt97() //  [R1]
         { info_tbl: [(cbt97,
                       label: block_cbt97_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbt97: // global
           if (R1 & 7 == 1) goto cbtah; else goto cbtaD;
       cbtah: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbtak; else goto cbtaj;
       cbtak: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtaj: // global
           _sbonD::P64 = P64[R1 + 15];
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = _sbonD::P64;
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = sat_sboou_info;
           _sbomu::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sbomu::P64;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sbonD::P64;
           P64[Hp] = Hp - 46;
           I64[Sp] = block_cbtad_info;
           R5 = Hp - 30;
           R4 = P64[Sp + 16];
           R3 = _sbomu::P64;
           R2 = lvl23_rbnX5_closure;
           P64[Sp + 24] = _sbonD::P64;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
       cbtaD: // global
           Sp = Sp + 32;
           call lvl27_rbnX9_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbtad() //  [R1]
         { info_tbl: [(cbtad,
                       label: block_cbtad_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtad: // global
           I64[Sp] = block_cbtaf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtaI; else goto cbtam;
       ubtaI: // global
           call _cbtaf(R1) args: 0, res: 0, upd: 0;
       cbtam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtaf() //  [R1]
         { info_tbl: [(cbtaf,
                       label: block_cbtaf_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtaf: // global
           if (R1 & 7 == 1) goto cbtas; else goto cbtaz;
       cbtas: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbtav; else goto cbtau;
       cbtav: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtau: // global
           _sbooA::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sbooA::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbtaz: // global
           Sp = Sp + 32;
           call lvl25_rbnX7_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.44427624 UTC

[section ""data" . GHC.IO.Handle.hDuplicate_closure" {
     GHC.IO.Handle.hDuplicate_closure:
         const GHC.IO.Handle.hDuplicate_info;
         const 0;
 },
 GHC.IO.Handle.hDuplicate_entry() //  [R2]
         { info_tbl: [(cbtd9,
                       label: GHC.IO.Handle.hDuplicate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtd9: // global
           R2 = R2;
           call GHC.IO.Handle.hDuplicate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.447685474 UTC

[section ""cstring" . GHC.IO.Handle.hGetEcho4_bytes" {
     GHC.IO.Handle.hGetEcho4_bytes:
         I8[] [104,71,101,116,69,99,104,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.450036167 UTC

[section ""data" . GHC.IO.Handle.hGetEcho3_closure" {
     GHC.IO.Handle.hGetEcho3_closure:
         const GHC.IO.Handle.hGetEcho3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEcho3_entry() //  [R1]
         { info_tbl: [(cbtdn,
                       label: GHC.IO.Handle.hGetEcho3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtdn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtdo; else goto cbtdp;
       cbtdo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtdp: // global
           (_cbtdk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtdk::I64 == 0) goto cbtdm; else goto cbtdl;
       cbtdm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtdl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtdk::I64;
           R2 = GHC.IO.Handle.hGetEcho4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.454406358 UTC

[section ""data" . GHC.IO.Handle.hGetEcho2_closure" {
     GHC.IO.Handle.hGetEcho2_closure:
         const GHC.IO.Handle.hGetEcho2_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho2_entry() //  [R2]
         { info_tbl: [(cbtdE,
                       label: GHC.IO.Handle.hGetEcho2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtdE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbtdF; else goto cbtdG;
       cbtdF: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtdG: // global
           I64[Sp - 8] = block_cbtdB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubte4; else goto cbtdC;
       ubte4: // global
           call _cbtdB(R1) args: 0, res: 0, upd: 0;
       cbtdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtdB() //  [R1]
         { info_tbl: [(cbtdB,
                       label: block_cbtdB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtdB: // global
           I64[Sp - 24] = block_cbtdJ_info;
           _sbooK::P64 = R1;
           _sbooL::P64 = P64[R1 + 7];
           _sbooO::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbooL::P64;
           P64[Sp - 8] = _sbooO::P64;
           P64[Sp] = _sbooK::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubte3; else goto cbtdL;
       ubte3: // global
           call _cbtdJ(R1) args: 0, res: 0, upd: 0;
       cbtdL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtdJ() //  [R1]
         { info_tbl: [(cbtdJ,
                       label: block_cbtdJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtdJ: // global
           if (R1 & 7 == 1) goto cbte1; else goto cbtdU;
       cbte1: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbtdU: // global
           _sbooO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbtdP_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbooO::P64;
           call GHC.IO.Device.getEcho_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbtdP() //  [R1]
         { info_tbl: [(cbtdP,
                       label: block_cbtdP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtdP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtdX; else goto cbtdW;
       cbtdX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtdW: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.464963353 UTC

[section ""data" . GHC.IO.Handle.hGetEcho1_closure" {
     GHC.IO.Handle.hGetEcho1_closure:
         const GHC.IO.Handle.hGetEcho1_info;
         const 0;
 },
 section ""relreadonly" . ubtfZ_srtd" {
     ubtfZ_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 io_sbopj_entry() //  [R1]
         { info_tbl: [(cbteS,
                       label: io_sbopj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbteS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbteW; else goto cbteX;
       cbteW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbteX: // global
           I64[Sp - 16] = block_cbteN_info;
           _sbopf::P64 = P64[R1 + 15];
           R5 = _sbopf::P64;
           R4 = GHC.IO.Handle.hGetEcho2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho3_closure;
           P64[Sp - 8] = _sbopf::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbteN() //  [R1]
         { info_tbl: [(cbteN,
                       label: block_cbteN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbteN: // global
           I64[Sp] = block_cbteP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtf2; else goto cbteQ;
       ubtf2: // global
           call _cbteP(R1) args: 0, res: 0, upd: 0;
       cbteQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbteP() //  [R1]
         { info_tbl: [(cbteP,
                       label: block_cbteP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbteP: // global
           I64[Sp] = block_cbteV_info;
           R2 = P64[R1 + 7];
           _sbopq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbopq::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbteV() //  []
         { info_tbl: [(cbteV,
                       label: block_cbteV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbteV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtg0_srtd" {
     ubtg0_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 io_sbopz_entry() //  [R1]
         { info_tbl: [(cbtfh,
                       label: io_sbopz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtfh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtfl; else goto cbtfm;
       cbtfl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtfm: // global
           I64[Sp - 16] = block_cbtfc_info;
           _sbopu::P64 = P64[R1 + 15];
           R5 = _sbopu::P64;
           R4 = GHC.IO.Handle.hGetEcho2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho3_closure;
           P64[Sp - 8] = _sbopu::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtfc() //  [R1]
         { info_tbl: [(cbtfc,
                       label: block_cbtfc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtfc: // global
           I64[Sp] = block_cbtfe_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtfr; else goto cbtff;
       ubtfr: // global
           call _cbtfe(R1) args: 0, res: 0, upd: 0;
       cbtff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtfe() //  [R1]
         { info_tbl: [(cbtfe,
                       label: block_cbtfe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtfe: // global
           I64[Sp] = block_cbtfk_info;
           R2 = P64[R1 + 7];
           _sbopG::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbopG::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtfk() //  []
         { info_tbl: [(cbtfk,
                       label: block_cbtfk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtfk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtg1_srtd" {
     ubtg1_srtd:
         const SboCL_srt+160;
         const 79;
         const 137438953473;
         const 26624;
 },
 GHC.IO.Handle.hGetEcho1_entry() //  [R2]
         { info_tbl: [(cbtfw,
                       label: GHC.IO.Handle.hGetEcho1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtfw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtfx; else goto cbtfy;
       cbtfx: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtfy: // global
           I64[Sp - 16] = block_cbtet_info;
           _sbop7::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbop7::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtg2_srtd" {
     ubtg2_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbtet() //  [R1]
         { info_tbl: [(cbtet,
                       label: block_cbtet_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtet: // global
           I64[Sp] = block_cbtev_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtfX; else goto cbtew;
       ubtfX: // global
           call _cbtev(R1) args: 0, res: 0, upd: 0;
       cbtew: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtg3_srtd" {
     ubtg3_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbtev() //  [R1]
         { info_tbl: [(cbtev,
                       label: block_cbtev_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtev: // global
           if (R1 & 7 == 1) goto cbtft; else goto cbtfu;
       cbtft: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbtfu: // global
           _sbop7::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbteB_info;
           R1 = _sbop7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubtfY; else goto cbteC;
       ubtfY: // global
           call _cbteB(R1) args: 0, res: 0, upd: 0;
       cbteC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtg4_srtd" {
     ubtg4_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbteB() //  [R1]
         { info_tbl: [(cbteB,
                       label: block_cbteB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbteB: // global
           if (R1 & 7 == 1) goto cbtfF; else goto cbtfO;
       cbtfF: // global
           I64[Sp - 16] = block_cbteG_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbtfO: // global
           I64[Sp - 16] = block_cbtf5_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtg5_srtd" {
     ubtg5_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbteG() //  [R1]
         { info_tbl: [(cbteG,
                       label: block_cbteG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbteG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtfI; else goto cbtfH;
       cbtfI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtfH: // global
           I64[Hp - 16] = io_sbopj_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbteI::P64 = Hp - 15;
           if (R1 == 0) goto cbtfM; else goto cbtfL;
       cbtfM: // global
           R1 = _cbteI::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtfL: // global
           R1 = _cbteI::P64;
           Sp = Sp + 24;
           call io_sbopj_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtg6_srtd" {
     ubtg6_srtd:
         const SboCL_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbtf5() //  [R1]
         { info_tbl: [(cbtf5,
                       label: block_cbtf5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtf5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtfR; else goto cbtfQ;
       cbtfR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtfQ: // global
           I64[Hp - 16] = io_sbopz_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtf7::P64 = Hp - 15;
           if (R1 == 0) goto cbtfV; else goto cbtfU;
       cbtfV: // global
           R1 = _cbtf7::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtfU: // global
           R1 = _cbtf7::P64;
           Sp = Sp + 24;
           call io_sbopz_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.496431925 UTC

[section ""data" . GHC.IO.Handle.hGetEcho_closure" {
     GHC.IO.Handle.hGetEcho_closure:
         const GHC.IO.Handle.hGetEcho_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho_entry() //  [R2]
         { info_tbl: [(cbthk,
                       label: GHC.IO.Handle.hGetEcho_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbthk: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEcho1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.499813943 UTC

[section ""cstring" . GHC.IO.Handle.hSetEcho3_bytes" {
     GHC.IO.Handle.hSetEcho3_bytes:
         I8[] [104,83,101,116,69,99,104,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.501599013 UTC

[section ""data" . GHC.IO.Handle.hSetEcho2_closure" {
     GHC.IO.Handle.hSetEcho2_closure:
         const GHC.IO.Handle.hSetEcho2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetEcho2_entry() //  [R1]
         { info_tbl: [(cbthy,
                       label: GHC.IO.Handle.hSetEcho2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbthy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbthz; else goto cbthA;
       cbthz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbthA: // global
           (_cbthv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbthv::I64 == 0) goto cbthx; else goto cbthw;
       cbthx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbthw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbthv::I64;
           R2 = GHC.IO.Handle.hSetEcho3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.507730802 UTC

[section ""data" . GHC.IO.Handle.hSetEcho1_closure" {
     GHC.IO.Handle.hSetEcho1_closure:
         const GHC.IO.Handle.hSetEcho1_info;
         const 0;
 },
 sat_sboqn_entry() //  [R1, R2]
         { info_tbl: [(cbtie,
                       label: sat_sboqn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtie: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbtif; else goto cbtig;
       cbtif: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtig: // global
           I64[Sp - 16] = block_cbtib_info;
           _sbopK::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbopK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubtiE; else goto cbtic;
       ubtiE: // global
           call _cbtib(R1) args: 0, res: 0, upd: 0;
       cbtic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtib() //  [R1]
         { info_tbl: [(cbtib,
                       label: block_cbtib_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtib: // global
           I64[Sp - 24] = block_cbtij_info;
           _sboq0::P64 = R1;
           _sboq1::P64 = P64[R1 + 7];
           _sboq4::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sboq1::P64;
           P64[Sp - 8] = _sboq4::P64;
           P64[Sp] = _sboq0::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubtiD; else goto cbtil;
       ubtiD: // global
           call _cbtij(R1) args: 0, res: 0, upd: 0;
       cbtil: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtij() //  [R1]
         { info_tbl: [(cbtij,
                       label: block_cbtij_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtij: // global
           if (R1 & 7 == 1) goto cbtiB; else goto cbtiu;
       cbtiB: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbtiu: // global
           _sboq4::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbtip_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sboq4::P64;
           P64[Sp + 8] = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.IO.Device.setEcho_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbtip() //  [R1]
         { info_tbl: [(cbtip,
                       label: block_cbtip_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtip: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtix; else goto cbtiw;
       cbtix: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtiw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtku_srtd" {
     ubtku_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 io_sbopW_entry() //  [R1]
         { info_tbl: [(cbtiK,
                       label: io_sbopW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtiK: // global
           _sbopW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbtiO; else goto cbtiP;
       cbtiP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbtiR; else goto cbtiQ;
       cbtiR: // global
           HpAlloc = 16;
           goto cbtiO;
       cbtiO: // global
           R1 = _sbopW::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtiQ: // global
           _sbopK::P64 = P64[_sbopW::P64 + 7];
           _sbopQ::P64 = P64[_sbopW::P64 + 15];
           _sbopS::P64 = P64[_sbopW::P64 + 23];
           I64[Hp - 8] = sat_sboqn_info;
           P64[Hp] = _sbopK::P64;
           I64[Sp - 16] = block_cbtiF_info;
           R5 = _sbopS::P64;
           R4 = Hp - 6;
           R3 = _sbopQ::P64;
           R2 = GHC.IO.Handle.hSetEcho2_closure;
           P64[Sp - 8] = _sbopS::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtiF() //  [R1]
         { info_tbl: [(cbtiF,
                       label: block_cbtiF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtiF: // global
           I64[Sp] = block_cbtiH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtiW; else goto cbtiI;
       ubtiW: // global
           call _cbtiH(R1) args: 0, res: 0, upd: 0;
       cbtiI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtiH() //  [R1]
         { info_tbl: [(cbtiH,
                       label: block_cbtiH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtiH: // global
           I64[Sp] = block_cbtiN_info;
           R2 = P64[R1 + 7];
           _sboqt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboqt::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtiN() //  []
         { info_tbl: [(cbtiN,
                       label: block_cbtiN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtiN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbor3_entry() //  [R1, R2]
         { info_tbl: [(cbtje,
                       label: sat_sbor3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtje: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbtjf; else goto cbtjg;
       cbtjf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtjg: // global
           I64[Sp - 16] = block_cbtjb_info;
           _sbopK::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbopK::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubtjE; else goto cbtjc;
       ubtjE: // global
           call _cbtjb(R1) args: 0, res: 0, upd: 0;
       cbtjc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtjb() //  [R1]
         { info_tbl: [(cbtjb,
                       label: block_cbtjb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtjb: // global
           I64[Sp - 24] = block_cbtjj_info;
           _sboqG::P64 = R1;
           _sboqH::P64 = P64[R1 + 7];
           _sboqK::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sboqH::P64;
           P64[Sp - 8] = _sboqK::P64;
           P64[Sp] = _sboqG::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubtjD; else goto cbtjl;
       ubtjD: // global
           call _cbtjj(R1) args: 0, res: 0, upd: 0;
       cbtjl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtjj() //  [R1]
         { info_tbl: [(cbtjj,
                       label: block_cbtjj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtjj: // global
           if (R1 & 7 == 1) goto cbtjB; else goto cbtju;
       cbtjB: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbtju: // global
           _sboqK::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbtjp_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sboqK::P64;
           P64[Sp + 8] = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.IO.Device.setEcho_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbtjp() //  [R1]
         { info_tbl: [(cbtjp,
                       label: block_cbtjp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtjp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtjx; else goto cbtjw;
       cbtjx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtjw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtkv_srtd" {
     ubtkv_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 io_sboqC_entry() //  [R1]
         { info_tbl: [(cbtjK,
                       label: io_sboqC_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtjK: // global
           _sboqC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbtjO; else goto cbtjP;
       cbtjP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbtjR; else goto cbtjQ;
       cbtjR: // global
           HpAlloc = 16;
           goto cbtjO;
       cbtjO: // global
           R1 = _sboqC::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtjQ: // global
           _sbopK::P64 = P64[_sboqC::P64 + 7];
           _sbopQ::P64 = P64[_sboqC::P64 + 15];
           _sboqx::P64 = P64[_sboqC::P64 + 23];
           I64[Hp - 8] = sat_sbor3_info;
           P64[Hp] = _sbopK::P64;
           I64[Sp - 16] = block_cbtjF_info;
           R5 = _sboqx::P64;
           R4 = Hp - 6;
           R3 = _sbopQ::P64;
           R2 = GHC.IO.Handle.hSetEcho2_closure;
           P64[Sp - 8] = _sboqx::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtjF() //  [R1]
         { info_tbl: [(cbtjF,
                       label: block_cbtjF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtjF: // global
           I64[Sp] = block_cbtjH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtjW; else goto cbtjI;
       ubtjW: // global
           call _cbtjH(R1) args: 0, res: 0, upd: 0;
       cbtjI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtjH() //  [R1]
         { info_tbl: [(cbtjH,
                       label: block_cbtjH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtjH: // global
           I64[Sp] = block_cbtjN_info;
           R2 = P64[R1 + 7];
           _sbor9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbor9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtjN() //  []
         { info_tbl: [(cbtjN,
                       label: block_cbtjN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtjN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtkw_srtd" {
     ubtkw_srtd:
         const SboCL_srt+160;
         const 81;
         const 137438953473;
         const 102400;
 },
 GHC.IO.Handle.hSetEcho1_entry() //  [R2, R3]
         { info_tbl: [(cbtk1,
                       label: GHC.IO.Handle.hSetEcho1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtk1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbtk2; else goto cbtk3;
       cbtk2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetEcho1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbtk3: // global
           I64[Sp - 24] = block_cbthM_info;
           _sbopJ::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbopJ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtkx_srtd" {
     ubtkx_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbthM() //  [R1]
         { info_tbl: [(cbthM,
                       label: block_cbthM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbthM: // global
           I64[Sp] = block_cbthO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtks; else goto cbthP;
       ubtks: // global
           call _cbthO(R1) args: 0, res: 0, upd: 0;
       cbthP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtky_srtd" {
     ubtky_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbthO() //  [R1]
         { info_tbl: [(cbthO,
                       label: block_cbthO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbthO: // global
           if (R1 & 7 == 1) goto cbtjY; else goto cbtjZ;
       cbtjY: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbtjZ: // global
           _sbopJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbthU_info;
           R1 = _sbopJ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubtkt; else goto cbthV;
       ubtkt: // global
           call _cbthU(R1) args: 0, res: 0, upd: 0;
       cbthV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtkz_srtd" {
     ubtkz_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbthU() //  [R1]
         { info_tbl: [(cbthU,
                       label: block_cbthU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbthU: // global
           if (R1 & 7 == 1) goto cbtka; else goto cbtkj;
       cbtka: // global
           I64[Sp - 16] = block_cbthZ_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbtkj: // global
           I64[Sp - 16] = block_cbtiZ_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtkA_srtd" {
     ubtkA_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbthZ() //  [R1]
         { info_tbl: [(cbthZ,
                       label: block_cbthZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbthZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbtkd; else goto cbtkc;
       cbtkd: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtkc: // global
           I64[Hp - 24] = io_sbopW_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbti1::P64 = Hp - 23;
           if (R1 == 0) goto cbtkh; else goto cbtkg;
       cbtkh: // global
           R1 = _cbti1::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtkg: // global
           R1 = _cbti1::P64;
           Sp = Sp + 32;
           call io_sbopW_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtkB_srtd" {
     ubtkB_srtd:
         const SboCL_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbtiZ() //  [R1]
         { info_tbl: [(cbtiZ,
                       label: block_cbtiZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtiZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbtkm; else goto cbtkl;
       cbtkm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtkl: // global
           I64[Hp - 24] = io_sboqC_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtj1::P64 = Hp - 23;
           if (R1 == 0) goto cbtkq; else goto cbtkp;
       cbtkq: // global
           R1 = _cbtj1::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtkp: // global
           R1 = _cbtj1::P64;
           Sp = Sp + 32;
           call io_sboqC_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.555340316 UTC

[section ""data" . GHC.IO.Handle.hSetEcho_closure" {
     GHC.IO.Handle.hSetEcho_closure:
         const GHC.IO.Handle.hSetEcho_info;
         const 0;
 },
 GHC.IO.Handle.hSetEcho_entry() //  [R2, R3]
         { info_tbl: [(cbtmv,
                       label: GHC.IO.Handle.hSetEcho_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtmv: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetEcho1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.559485588 UTC

[section ""cstring" . GHC.IO.Handle.hGetBuffering3_bytes" {
     GHC.IO.Handle.hGetBuffering3_bytes:
         I8[] [104,71,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.561261727 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering_fun_closure" {
     GHC.IO.Handle.hGetBuffering_fun_closure:
         const GHC.IO.Handle.hGetBuffering_fun_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering_fun_entry() //  [R1]
         { info_tbl: [(cbtmJ,
                       label: GHC.IO.Handle.hGetBuffering_fun_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtmJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtmK; else goto cbtmL;
       cbtmK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtmL: // global
           (_cbtmG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtmG::I64 == 0) goto cbtmI; else goto cbtmH;
       cbtmI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtmH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtmG::I64;
           R2 = GHC.IO.Handle.hGetBuffering3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.565589129 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering2_closure" {
     GHC.IO.Handle.hGetBuffering2_closure:
         const GHC.IO.Handle.hGetBuffering2_info;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering2_entry() //  [R2]
         { info_tbl: [(cbtn0,
                       label: GHC.IO.Handle.hGetBuffering2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtn0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtn1; else goto cbtn2;
       cbtn1: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetBuffering2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtn2: // global
           I64[Sp - 8] = block_cbtmX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtnn; else goto cbtmY;
       ubtnn: // global
           call _cbtmX(R1) args: 0, res: 0, upd: 0;
       cbtmY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtmX() //  [R1]
         { info_tbl: [(cbtmX,
                       label: block_cbtmX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtmX: // global
           I64[Sp - 16] = block_cbtn5_info;
           _sbore::P64 = R1;
           _sborl::P64 = P64[R1 + 55];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _sborl::P64;
           P64[Sp] = _sbore::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubtnm; else goto cbtn7;
       ubtnm: // global
           call _cbtn5(R1) args: 0, res: 0, upd: 0;
       cbtn7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtn5() //  [R1]
         { info_tbl: [(cbtn5,
                       label: block_cbtn5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtn5: // global
           if (R1 & 7 == 1) goto cbtnk; else goto cbtnd;
       cbtnk: // global
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbtnd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtng; else goto cbtnf;
       cbtng: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtnf: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.574728814 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering1_closure" {
     GHC.IO.Handle.hGetBuffering1_closure:
         const GHC.IO.Handle.hGetBuffering1_info;
         const 0;
 },
 section ""relreadonly" . ubtoZ_srtd" {
     ubtoZ_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 io_sborG_entry() //  [R1]
         { info_tbl: [(cbto1,
                       label: io_sborG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbto1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbto5; else goto cbto6;
       cbto5: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbto6: // global
           I64[Sp - 16] = block_cbtnW_info;
           _sborC::P64 = P64[R1 + 15];
           R5 = _sborC::P64;
           R4 = GHC.IO.Handle.hGetBuffering2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetBuffering_fun_closure;
           P64[Sp - 8] = _sborC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtnW() //  [R1]
         { info_tbl: [(cbtnW,
                       label: block_cbtnW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtnW: // global
           I64[Sp] = block_cbtnY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtob; else goto cbtnZ;
       ubtob: // global
           call _cbtnY(R1) args: 0, res: 0, upd: 0;
       cbtnZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtnY() //  [R1]
         { info_tbl: [(cbtnY,
                       label: block_cbtnY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtnY: // global
           I64[Sp] = block_cbto4_info;
           R2 = P64[R1 + 7];
           _sborN::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sborN::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbto4() //  []
         { info_tbl: [(cbto4,
                       label: block_cbto4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbto4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtp0_srtd" {
     ubtp0_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 io_sborW_entry() //  [R1]
         { info_tbl: [(cbtoq,
                       label: io_sborW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtoq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtou; else goto cbtov;
       cbtou: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtov: // global
           I64[Sp - 16] = block_cbtol_info;
           _sborR::P64 = P64[R1 + 15];
           R5 = _sborR::P64;
           R4 = GHC.IO.Handle.hGetBuffering2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetBuffering_fun_closure;
           P64[Sp - 8] = _sborR::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtol() //  [R1]
         { info_tbl: [(cbtol,
                       label: block_cbtol_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtol: // global
           I64[Sp] = block_cbton_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtoA; else goto cbtoo;
       ubtoA: // global
           call _cbton(R1) args: 0, res: 0, upd: 0;
       cbtoo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbton() //  [R1]
         { info_tbl: [(cbton,
                       label: block_cbton_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbton: // global
           I64[Sp] = block_cbtot_info;
           R2 = P64[R1 + 7];
           _sbos3::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbos3::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtot() //  []
         { info_tbl: [(cbtot,
                       label: block_cbtot_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtot: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtp1_srtd" {
     ubtp1_srtd:
         const SboCL_srt+456;
         const 47;
         const 123145302310913;
 },
 GHC.IO.Handle.hGetBuffering1_entry() //  [R2]
         { info_tbl: [(cbtoF,
                       label: GHC.IO.Handle.hGetBuffering1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtoF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtoG; else goto cbtoH;
       cbtoG: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetBuffering1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtoH: // global
           I64[Sp - 8] = block_cbtnK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtoY; else goto cbtnL;
       ubtoY: // global
           call _cbtnK(R1) args: 0, res: 0, upd: 0;
       cbtnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtp2_srtd" {
     ubtp2_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbtnK() //  [R1]
         { info_tbl: [(cbtnK,
                       label: block_cbtnK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtnK: // global
           if (R1 & 7 == 1) goto cbtoC; else goto cbtoD;
       cbtoC: // global
           I64[Sp - 16] = block_cbtnP_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbtoD: // global
           I64[Sp - 16] = block_cbtoe_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtp3_srtd" {
     ubtp3_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbtnP() //  [R1]
         { info_tbl: [(cbtnP,
                       label: block_cbtnP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtnP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtoL; else goto cbtoK;
       cbtoL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtoK: // global
           I64[Hp - 16] = io_sborG_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtnR::P64 = Hp - 15;
           if (R1 == 0) goto cbtoP; else goto cbtoO;
       cbtoP: // global
           R1 = _cbtnR::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtoO: // global
           R1 = _cbtnR::P64;
           Sp = Sp + 24;
           call io_sborG_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtp4_srtd" {
     ubtp4_srtd:
         const SboCL_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbtoe() //  [R1]
         { info_tbl: [(cbtoe,
                       label: block_cbtoe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtoe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtoT; else goto cbtoS;
       cbtoT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtoS: // global
           I64[Hp - 16] = io_sborW_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtog::P64 = Hp - 15;
           if (R1 == 0) goto cbtoX; else goto cbtoW;
       cbtoX: // global
           R1 = _cbtog::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtoW: // global
           R1 = _cbtog::P64;
           Sp = Sp + 24;
           call io_sborW_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.602184891 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering_closure" {
     GHC.IO.Handle.hGetBuffering_closure:
         const GHC.IO.Handle.hGetBuffering_info;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering_entry() //  [R2]
         { info_tbl: [(cbtq6,
                       label: GHC.IO.Handle.hGetBuffering_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtq6: // global
           R2 = R2;
           call GHC.IO.Handle.hGetBuffering1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.605367717 UTC

[section ""cstring" . GHC.IO.Handle.hIsWritable4_bytes" {
     GHC.IO.Handle.hIsWritable4_bytes:
         I8[] [104,73,115,87,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.607248405 UTC

[section ""data" . GHC.IO.Handle.hIsWritable3_closure" {
     GHC.IO.Handle.hIsWritable3_closure:
         const GHC.IO.Handle.hIsWritable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsWritable3_entry() //  [R1]
         { info_tbl: [(cbtqk,
                       label: GHC.IO.Handle.hIsWritable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtqk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtql; else goto cbtqm;
       cbtql: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtqm: // global
           (_cbtqh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtqh::I64 == 0) goto cbtqj; else goto cbtqi;
       cbtqj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtqi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtqh::I64;
           R2 = GHC.IO.Handle.hIsWritable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.6119221 UTC

[section ""data" . GHC.IO.Handle.hIsWritable2_closure" {
     GHC.IO.Handle.hIsWritable2_closure:
         const GHC.IO.Handle.hIsWritable2_info;
         const 0;
 },
 sat_sbosr_entry() //  [R1]
         { info_tbl: [(cbtqV,
                       label: sat_sbosr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtqV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtqW; else goto cbtqX;
       cbtqW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtqX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbtqM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubtrb; else goto cbtqN;
       ubtrb: // global
           call _cbtqM(R1) args: 0, res: 0, upd: 0;
       cbtqN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtqM() //  [R1]
         { info_tbl: [(cbtqM,
                       label: block_cbtqM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtqM: // global
           _cbtqU::P64 = R1 & 7;
           if (_cbtqU::P64 < 4) goto cbtqQ; else goto ubtra;
       cbtqQ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ubtra: // global
           if (_cbtqU::P64 != 5) goto cbtqT; else goto cbtqT;
       cbtqT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubtry_srtd" {
     ubtry_srtd:
         const SboCL_srt+328;
         const 64;
         const 9259400833873739777;
 },
 GHC.IO.Handle.hIsWritable2_entry() //  [R2]
         { info_tbl: [(cbtrc,
                       label: GHC.IO.Handle.hIsWritable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtrc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtrd; else goto cbtre;
       cbtrd: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsWritable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtre: // global
           I64[Sp - 8] = block_cbtqy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtrx; else goto cbtqz;
       ubtrx: // global
           call _cbtqy(R1) args: 0, res: 0, upd: 0;
       cbtqz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtrz_srtd" {
     ubtrz_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbtqy() //  [R1]
         { info_tbl: [(cbtqy,
                       label: block_cbtqy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtqy: // global
           I64[Sp - 8] = block_cbtqD_info;
           _sbos8::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbos8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtrw; else goto cbtqE;
       ubtrw: // global
           call _cbtqD(R1) args: 0, res: 0, upd: 0;
       cbtqE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtrA_srtd" {
     ubtrA_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbtqD() //  [R1]
         { info_tbl: [(cbtqD,
                       label: block_cbtqD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtqD: // global
           _cbtru::P64 = R1 & 7;
           if (_cbtru::P64 == 1) goto cbtrp; else goto ubtrv;
       cbtrp: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       ubtrv: // global
           if (_cbtru::P64 == 2) goto cbtrt; else goto cbtri;
       cbtrt: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbtri: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbtrl; else goto cbtrk;
       cbtrl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtrk: // global
           I64[Hp - 40] = sat_sbosr_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.626389063 UTC

[section ""data" . GHC.IO.Handle.hIsWritable1_closure" {
     GHC.IO.Handle.hIsWritable1_closure:
         const GHC.IO.Handle.hIsWritable1_info;
         const 0;
 },
 section ""relreadonly" . ubtsV_srtd" {
     ubtsV_srtd:
         const SboCL_srt+456;
         const 49;
         const 422212465065985;
 },
 io_sbosD_entry() //  [R1]
         { info_tbl: [(cbtsr,
                       label: io_sbosD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtsr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtsv; else goto cbtsw;
       cbtsv: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtsw: // global
           I64[Sp - 16] = block_cbtsm_info;
           _sbosz::P64 = P64[R1 + 15];
           R5 = _sbosz::P64;
           R4 = GHC.IO.Handle.hIsWritable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsWritable3_closure;
           P64[Sp - 8] = _sbosz::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtsm() //  [R1]
         { info_tbl: [(cbtsm,
                       label: block_cbtsm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtsm: // global
           I64[Sp] = block_cbtso_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtsB; else goto cbtsp;
       ubtsB: // global
           call _cbtso(R1) args: 0, res: 0, upd: 0;
       cbtsp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtso() //  [R1]
         { info_tbl: [(cbtso,
                       label: block_cbtso_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtso: // global
           I64[Sp] = block_cbtsu_info;
           R2 = P64[R1 + 7];
           _sbosK::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbosK::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtsu() //  []
         { info_tbl: [(cbtsu,
                       label: block_cbtsu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtsu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtsW_srtd" {
     ubtsW_srtd:
         const SboCL_srt+456;
         const 50;
         const 985162418487297;
 },
 GHC.IO.Handle.hIsWritable1_entry() //  [R2]
         { info_tbl: [(cbtsG,
                       label: GHC.IO.Handle.hIsWritable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtsG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtsH; else goto cbtsI;
       cbtsH: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsWritable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtsI: // global
           I64[Sp - 8] = block_cbtsa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtsU; else goto cbtsb;
       ubtsU: // global
           call _cbtsa(R1) args: 0, res: 0, upd: 0;
       cbtsb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtsX_srtd" {
     ubtsX_srtd:
         const SboCL_srt+456;
         const 49;
         const 422212465065985;
 },
 _cbtsa() //  [R1]
         { info_tbl: [(cbtsa,
                       label: block_cbtsa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtsa: // global
           if (R1 & 7 == 1) goto cbtsD; else goto cbtsE;
       cbtsD: // global
           I64[Sp - 16] = block_cbtsf_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbtsE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtsY_srtd" {
     ubtsY_srtd:
         const SboCL_srt+456;
         const 49;
         const 422212465065985;
 },
 _cbtsf() //  [R1]
         { info_tbl: [(cbtsf,
                       label: block_cbtsf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtsf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtsM; else goto cbtsL;
       cbtsM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtsL: // global
           I64[Hp - 16] = io_sbosD_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtsh::P64 = Hp - 15;
           if (R1 == 0) goto cbtsQ; else goto cbtsP;
       cbtsQ: // global
           R1 = _cbtsh::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtsP: // global
           R1 = _cbtsh::P64;
           Sp = Sp + 24;
           call io_sbosD_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.644271235 UTC

[section ""data" . GHC.IO.Handle.hIsWritable_closure" {
     GHC.IO.Handle.hIsWritable_closure:
         const GHC.IO.Handle.hIsWritable_info;
         const 0;
 },
 GHC.IO.Handle.hIsWritable_entry() //  [R2]
         { info_tbl: [(cbttE,
                       label: GHC.IO.Handle.hIsWritable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbttE: // global
           R2 = R2;
           call GHC.IO.Handle.hIsWritable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.647503983 UTC

[section ""cstring" . GHC.IO.Handle.hIsReadable4_bytes" {
     GHC.IO.Handle.hIsReadable4_bytes:
         I8[] [104,73,115,82,101,97,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.649552418 UTC

[section ""data" . GHC.IO.Handle.hIsReadable3_closure" {
     GHC.IO.Handle.hIsReadable3_closure:
         const GHC.IO.Handle.hIsReadable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsReadable3_entry() //  [R1]
         { info_tbl: [(cbttS,
                       label: GHC.IO.Handle.hIsReadable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbttS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbttT; else goto cbttU;
       cbttT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbttU: // global
           (_cbttP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbttP::I64 == 0) goto cbttR; else goto cbttQ;
       cbttR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbttQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbttP::I64;
           R2 = GHC.IO.Handle.hIsReadable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.65429994 UTC

[section ""data" . GHC.IO.Handle.hIsReadable2_closure" {
     GHC.IO.Handle.hIsReadable2_closure:
         const GHC.IO.Handle.hIsReadable2_info;
         const 0;
 },
 sat_sbotb_entry() //  [R1]
         { info_tbl: [(cbtus,
                       label: sat_sbotb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtus: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtut; else goto cbtuu;
       cbtut: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtuu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbtuk_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubtuF; else goto cbtul;
       ubtuF: // global
           call _cbtuk(R1) args: 0, res: 0, upd: 0;
       cbtul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtuk() //  [R1]
         { info_tbl: [(cbtuk,
                       label: block_cbtuk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtuk: // global
           _cbtur::P64 = R1 & 7;
           if (_cbtur::P64 == 3) goto cbtuq; else goto ubtuE;
       ubtuE: // global
           if (_cbtur::P64 == 6) goto cbtuq; else goto cbtuo;
       cbtuq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbtuo: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubtv2_srtd" {
     ubtv2_srtd:
         const SboCL_srt+328;
         const 67;
         const 36028797018963969;
         const 4;
 },
 GHC.IO.Handle.hIsReadable2_entry() //  [R2]
         { info_tbl: [(cbtuG,
                       label: GHC.IO.Handle.hIsReadable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtuG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtuH; else goto cbtuI;
       cbtuH: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsReadable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtuI: // global
           I64[Sp - 8] = block_cbtu6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtv1; else goto cbtu7;
       ubtv1: // global
           call _cbtu6(R1) args: 0, res: 0, upd: 0;
       cbtu7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtv3_srtd" {
     ubtv3_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbtu6() //  [R1]
         { info_tbl: [(cbtu6,
                       label: block_cbtu6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtu6: // global
           I64[Sp - 8] = block_cbtub_info;
           _sbosS::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbosS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtv0; else goto cbtuc;
       ubtv0: // global
           call _cbtub(R1) args: 0, res: 0, upd: 0;
       cbtuc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtv4_srtd" {
     ubtv4_srtd:
         const SboCL_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbtub() //  [R1]
         { info_tbl: [(cbtub,
                       label: block_cbtub_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtub: // global
           _cbtuY::P64 = R1 & 7;
           if (_cbtuY::P64 == 1) goto cbtuT; else goto ubtuZ;
       cbtuT: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       ubtuZ: // global
           if (_cbtuY::P64 == 2) goto cbtuX; else goto cbtuM;
       cbtuX: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbtuM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbtuP; else goto cbtuO;
       cbtuP: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtuO: // global
           I64[Hp - 40] = sat_sbotb_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.669196973 UTC

[section ""data" . GHC.IO.Handle.hIsReadable1_closure" {
     GHC.IO.Handle.hIsReadable1_closure:
         const GHC.IO.Handle.hIsReadable1_info;
         const 0;
 },
 section ""relreadonly" . ubtwp_srtd" {
     ubtwp_srtd:
         const SboCL_srt+456;
         const 52;
         const 3377699720527873;
 },
 io_sbotn_entry() //  [R1]
         { info_tbl: [(cbtvV,
                       label: io_sbotn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtvV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtvZ; else goto cbtw0;
       cbtvZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtw0: // global
           I64[Sp - 16] = block_cbtvQ_info;
           _sbotj::P64 = P64[R1 + 15];
           R5 = _sbotj::P64;
           R4 = GHC.IO.Handle.hIsReadable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsReadable3_closure;
           P64[Sp - 8] = _sbotj::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtvQ() //  [R1]
         { info_tbl: [(cbtvQ,
                       label: block_cbtvQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtvQ: // global
           I64[Sp] = block_cbtvS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtw5; else goto cbtvT;
       ubtw5: // global
           call _cbtvS(R1) args: 0, res: 0, upd: 0;
       cbtvT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtvS() //  [R1]
         { info_tbl: [(cbtvS,
                       label: block_cbtvS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtvS: // global
           I64[Sp] = block_cbtvY_info;
           R2 = P64[R1 + 7];
           _sbotu::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbotu::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtvY() //  []
         { info_tbl: [(cbtvY,
                       label: block_cbtvY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtvY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtwq_srtd" {
     ubtwq_srtd:
         const SboCL_srt+456;
         const 53;
         const 7881299347898369;
 },
 GHC.IO.Handle.hIsReadable1_entry() //  [R2]
         { info_tbl: [(cbtwa,
                       label: GHC.IO.Handle.hIsReadable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtwa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtwb; else goto cbtwc;
       cbtwb: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsReadable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtwc: // global
           I64[Sp - 8] = block_cbtvE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtwo; else goto cbtvF;
       ubtwo: // global
           call _cbtvE(R1) args: 0, res: 0, upd: 0;
       cbtvF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtwr_srtd" {
     ubtwr_srtd:
         const SboCL_srt+456;
         const 52;
         const 3377699720527873;
 },
 _cbtvE() //  [R1]
         { info_tbl: [(cbtvE,
                       label: block_cbtvE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtvE: // global
           if (R1 & 7 == 1) goto cbtw7; else goto cbtw8;
       cbtw7: // global
           I64[Sp - 16] = block_cbtvJ_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbtw8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtws_srtd" {
     ubtws_srtd:
         const SboCL_srt+456;
         const 52;
         const 3377699720527873;
 },
 _cbtvJ() //  [R1]
         { info_tbl: [(cbtvJ,
                       label: block_cbtvJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtvJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtwg; else goto cbtwf;
       cbtwg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtwf: // global
           I64[Hp - 16] = io_sbotn_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtvL::P64 = Hp - 15;
           if (R1 == 0) goto cbtwk; else goto cbtwj;
       cbtwk: // global
           R1 = _cbtvL::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtwj: // global
           R1 = _cbtvL::P64;
           Sp = Sp + 24;
           call io_sbotn_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.686395174 UTC

[section ""data" . GHC.IO.Handle.hIsReadable_closure" {
     GHC.IO.Handle.hIsReadable_closure:
         const GHC.IO.Handle.hIsReadable_info;
         const 0;
 },
 GHC.IO.Handle.hIsReadable_entry() //  [R2]
         { info_tbl: [(cbtx8,
                       label: GHC.IO.Handle.hIsReadable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtx8: // global
           R2 = R2;
           call GHC.IO.Handle.hIsReadable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.689528159 UTC

[section ""cstring" . GHC.IO.Handle.hIsClosed4_bytes" {
     GHC.IO.Handle.hIsClosed4_bytes:
         I8[] [104,73,115,67,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.69134524 UTC

[section ""data" . GHC.IO.Handle.hIsClosed3_closure" {
     GHC.IO.Handle.hIsClosed3_closure:
         const GHC.IO.Handle.hIsClosed3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsClosed3_entry() //  [R1]
         { info_tbl: [(cbtxm,
                       label: GHC.IO.Handle.hIsClosed3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtxm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtxn; else goto cbtxo;
       cbtxn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtxo: // global
           (_cbtxj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtxj::I64 == 0) goto cbtxl; else goto cbtxk;
       cbtxl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtxk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtxj::I64;
           R2 = GHC.IO.Handle.hIsClosed4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.695780557 UTC

[section ""data" . GHC.IO.Handle.hIsClosed2_closure" {
     GHC.IO.Handle.hIsClosed2_closure:
         const GHC.IO.Handle.hIsClosed2_info;
 },
 GHC.IO.Handle.hIsClosed2_entry() //  [R2]
         { info_tbl: [(cbtxD,
                       label: GHC.IO.Handle.hIsClosed2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtxD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtxE; else goto cbtxF;
       cbtxE: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsClosed2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtxF: // global
           I64[Sp - 8] = block_cbtxA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubty3; else goto cbtxB;
       ubty3: // global
           call _cbtxA(R1) args: 0, res: 0, upd: 0;
       cbtxB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtxA() //  [R1]
         { info_tbl: [(cbtxA,
                       label: block_cbtxA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtxA: // global
           I64[Sp - 8] = block_cbtxI_info;
           _sbotC::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbotC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubty2; else goto cbtxK;
       ubty2: // global
           call _cbtxI(R1) args: 0, res: 0, upd: 0;
       cbtxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtxI() //  [R1]
         { info_tbl: [(cbtxI,
                       label: block_cbtxI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtxI: // global
           _sbotC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbtxX; else goto cbtxQ;
       cbtxX: // global
           Hp = Hp + 24;
           _sbotT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbty0; else goto cbtxZ;
       cbtxZ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbotC::P64;
           P64[Hp] = GHC.Types.True_closure+2;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbtxQ: // global
           Hp = Hp + 24;
           _sbotT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbty0; else goto cbtxS;
       cbty0: // global
           HpAlloc = 24;
           R1 = _sbotT::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtxS: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbotC::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.705517381 UTC

[section ""data" . GHC.IO.Handle.hIsClosed1_closure" {
     GHC.IO.Handle.hIsClosed1_closure:
         const GHC.IO.Handle.hIsClosed1_info;
         const 0;
 },
 io_sbou4_entry() //  [R1]
         { info_tbl: [(cbtyG,
                       label: io_sbou4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtyG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtyK; else goto cbtyL;
       cbtyK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtyL: // global
           I64[Sp - 16] = block_cbtyB_info;
           _sbou0::P64 = P64[R1 + 15];
           R5 = _sbou0::P64;
           R4 = GHC.IO.Handle.hIsClosed2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsClosed3_closure;
           P64[Sp - 8] = _sbou0::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtyB() //  [R1]
         { info_tbl: [(cbtyB,
                       label: block_cbtyB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtyB: // global
           I64[Sp] = block_cbtyD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtyQ; else goto cbtyE;
       ubtyQ: // global
           call _cbtyD(R1) args: 0, res: 0, upd: 0;
       cbtyE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtyD() //  [R1]
         { info_tbl: [(cbtyD,
                       label: block_cbtyD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtyD: // global
           I64[Sp] = block_cbtyJ_info;
           R2 = P64[R1 + 7];
           _sboub::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboub::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtyJ() //  []
         { info_tbl: [(cbtyJ,
                       label: block_cbtyJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtyJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbouk_entry() //  [R1]
         { info_tbl: [(cbtz5,
                       label: io_sbouk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtz5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtz9; else goto cbtza;
       cbtz9: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtza: // global
           I64[Sp - 16] = block_cbtz0_info;
           _sbouf::P64 = P64[R1 + 15];
           R5 = _sbouf::P64;
           R4 = GHC.IO.Handle.hIsClosed2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsClosed3_closure;
           P64[Sp - 8] = _sbouf::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtz0() //  [R1]
         { info_tbl: [(cbtz0,
                       label: block_cbtz0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtz0: // global
           I64[Sp] = block_cbtz2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtzf; else goto cbtz3;
       ubtzf: // global
           call _cbtz2(R1) args: 0, res: 0, upd: 0;
       cbtz3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtz2() //  [R1]
         { info_tbl: [(cbtz2,
                       label: block_cbtz2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtz2: // global
           I64[Sp] = block_cbtz8_info;
           R2 = P64[R1 + 7];
           _sbour::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbour::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtz8() //  []
         { info_tbl: [(cbtz8,
                       label: block_cbtz8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtz8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsClosed1_entry() //  [R2]
         { info_tbl: [(cbtzk,
                       label: GHC.IO.Handle.hIsClosed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtzk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtzl; else goto cbtzm;
       cbtzl: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsClosed1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtzm: // global
           I64[Sp - 8] = block_cbtyp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtzD; else goto cbtyq;
       ubtzD: // global
           call _cbtyp(R1) args: 0, res: 0, upd: 0;
       cbtyq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtyp() //  [R1]
         { info_tbl: [(cbtyp,
                       label: block_cbtyp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtyp: // global
           if (R1 & 7 == 1) goto cbtzh; else goto cbtzi;
       cbtzh: // global
           I64[Sp - 16] = block_cbtyu_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbtzi: // global
           I64[Sp - 16] = block_cbtyT_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbtyu() //  [R1]
         { info_tbl: [(cbtyu,
                       label: block_cbtyu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtyu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtzq; else goto cbtzp;
       cbtzq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtzp: // global
           I64[Hp - 16] = io_sbou4_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtyw::P64 = Hp - 15;
           if (R1 == 0) goto cbtzu; else goto cbtzt;
       cbtzu: // global
           R1 = _cbtyw::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtzt: // global
           R1 = _cbtyw::P64;
           Sp = Sp + 24;
           call io_sbou4_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbtyT() //  [R1]
         { info_tbl: [(cbtyT,
                       label: block_cbtyT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtyT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtzy; else goto cbtzx;
       cbtzy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtzx: // global
           I64[Hp - 16] = io_sbouk_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtyV::P64 = Hp - 15;
           if (R1 == 0) goto cbtzC; else goto cbtzB;
       cbtzC: // global
           R1 = _cbtyV::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtzB: // global
           R1 = _cbtyV::P64;
           Sp = Sp + 24;
           call io_sbouk_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.728284656 UTC

[section ""data" . GHC.IO.Handle.hIsClosed_closure" {
     GHC.IO.Handle.hIsClosed_closure:
         const GHC.IO.Handle.hIsClosed_info;
         const 0;
 },
 GHC.IO.Handle.hIsClosed_entry() //  [R2]
         { info_tbl: [(cbtAz,
                       label: GHC.IO.Handle.hIsClosed_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtAz: // global
           R2 = R2;
           call GHC.IO.Handle.hIsClosed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.731509712 UTC

[section ""cstring" . GHC.IO.Handle.hIsOpen4_bytes" {
     GHC.IO.Handle.hIsOpen4_bytes:
         I8[] [104,73,115,79,112,101,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.733716737 UTC

[section ""data" . GHC.IO.Handle.hIsOpen3_closure" {
     GHC.IO.Handle.hIsOpen3_closure:
         const GHC.IO.Handle.hIsOpen3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsOpen3_entry() //  [R1]
         { info_tbl: [(cbtAN,
                       label: GHC.IO.Handle.hIsOpen3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtAN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtAO; else goto cbtAP;
       cbtAO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtAP: // global
           (_cbtAK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtAK::I64 == 0) goto cbtAM; else goto cbtAL;
       cbtAM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtAL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtAK::I64;
           R2 = GHC.IO.Handle.hIsOpen4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.738738186 UTC

[section ""data" . GHC.IO.Handle.hIsOpen2_closure" {
     GHC.IO.Handle.hIsOpen2_closure:
         const GHC.IO.Handle.hIsOpen2_info;
 },
 GHC.IO.Handle.hIsOpen2_entry() //  [R2]
         { info_tbl: [(cbtB4,
                       label: GHC.IO.Handle.hIsOpen2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtB4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtB5; else goto cbtB6;
       cbtB5: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsOpen2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtB6: // global
           I64[Sp - 8] = block_cbtB1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtBC; else goto cbtB2;
       ubtBC: // global
           call _cbtB1(R1) args: 0, res: 0, upd: 0;
       cbtB2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtB1() //  [R1]
         { info_tbl: [(cbtB1,
                       label: block_cbtB1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtB1: // global
           I64[Sp - 8] = block_cbtB9_info;
           _sbouw::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbouw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtBB; else goto cbtBb;
       ubtBB: // global
           call _cbtB9(R1) args: 0, res: 0, upd: 0;
       cbtBb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtB9() //  [R1]
         { info_tbl: [(cbtB9,
                       label: block_cbtB9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtB9: // global
           _sbouw::P64 = P64[Sp + 8];
           _cbtBz::P64 = R1 & 7;
           if (_cbtBz::P64 == 1) goto cbtBo; else goto ubtBA;
       cbtBo: // global
           Hp = Hp + 24;
           _sbouN::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtBy; else goto cbtBq;
       cbtBq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbouw::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ubtBA: // global
           if (_cbtBz::P64 == 2) goto cbtBv; else goto cbtBh;
       cbtBv: // global
           Hp = Hp + 24;
           _sbouN::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtBy; else goto cbtBx;
       cbtBx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbouw::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbtBh: // global
           Hp = Hp + 24;
           _sbouN::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtBy; else goto cbtBj;
       cbtBy: // global
           HpAlloc = 24;
           R1 = _sbouN::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtBj: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbouw::P64;
           P64[Hp] = GHC.Types.True_closure+2;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.748176751 UTC

[section ""data" . GHC.IO.Handle.hIsOpen1_closure" {
     GHC.IO.Handle.hIsOpen1_closure:
         const GHC.IO.Handle.hIsOpen1_info;
         const 0;
 },
 io_sbouZ_entry() //  [R1]
         { info_tbl: [(cbtCf,
                       label: io_sbouZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtCj; else goto cbtCk;
       cbtCj: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtCk: // global
           I64[Sp - 16] = block_cbtCa_info;
           _sbouV::P64 = P64[R1 + 15];
           R5 = _sbouV::P64;
           R4 = GHC.IO.Handle.hIsOpen2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsOpen3_closure;
           P64[Sp - 8] = _sbouV::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtCa() //  [R1]
         { info_tbl: [(cbtCa,
                       label: block_cbtCa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCa: // global
           I64[Sp] = block_cbtCc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtCp; else goto cbtCd;
       ubtCp: // global
           call _cbtCc(R1) args: 0, res: 0, upd: 0;
       cbtCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtCc() //  [R1]
         { info_tbl: [(cbtCc,
                       label: block_cbtCc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCc: // global
           I64[Sp] = block_cbtCi_info;
           R2 = P64[R1 + 7];
           _sbov6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbov6::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtCi() //  []
         { info_tbl: [(cbtCi,
                       label: block_cbtCi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbovf_entry() //  [R1]
         { info_tbl: [(cbtCE,
                       label: io_sbovf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtCI; else goto cbtCJ;
       cbtCI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtCJ: // global
           I64[Sp - 16] = block_cbtCz_info;
           _sbova::P64 = P64[R1 + 15];
           R5 = _sbova::P64;
           R4 = GHC.IO.Handle.hIsOpen2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsOpen3_closure;
           P64[Sp - 8] = _sbova::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtCz() //  [R1]
         { info_tbl: [(cbtCz,
                       label: block_cbtCz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCz: // global
           I64[Sp] = block_cbtCB_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtCO; else goto cbtCC;
       ubtCO: // global
           call _cbtCB(R1) args: 0, res: 0, upd: 0;
       cbtCC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtCB() //  [R1]
         { info_tbl: [(cbtCB,
                       label: block_cbtCB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCB: // global
           I64[Sp] = block_cbtCH_info;
           R2 = P64[R1 + 7];
           _sbovm::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbovm::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtCH() //  []
         { info_tbl: [(cbtCH,
                       label: block_cbtCH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsOpen1_entry() //  [R2]
         { info_tbl: [(cbtCT,
                       label: GHC.IO.Handle.hIsOpen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtCU; else goto cbtCV;
       cbtCU: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsOpen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtCV: // global
           I64[Sp - 8] = block_cbtBY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtDc; else goto cbtBZ;
       ubtDc: // global
           call _cbtBY(R1) args: 0, res: 0, upd: 0;
       cbtBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtBY() //  [R1]
         { info_tbl: [(cbtBY,
                       label: block_cbtBY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtBY: // global
           if (R1 & 7 == 1) goto cbtCQ; else goto cbtCR;
       cbtCQ: // global
           I64[Sp - 16] = block_cbtC3_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbtCR: // global
           I64[Sp - 16] = block_cbtCs_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbtC3() //  [R1]
         { info_tbl: [(cbtC3,
                       label: block_cbtC3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtC3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtCZ; else goto cbtCY;
       cbtCZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtCY: // global
           I64[Hp - 16] = io_sbouZ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtC5::P64 = Hp - 15;
           if (R1 == 0) goto cbtD3; else goto cbtD2;
       cbtD3: // global
           R1 = _cbtC5::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtD2: // global
           R1 = _cbtC5::P64;
           Sp = Sp + 24;
           call io_sbouZ_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbtCs() //  [R1]
         { info_tbl: [(cbtCs,
                       label: block_cbtCs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtCs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtD7; else goto cbtD6;
       cbtD7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtD6: // global
           I64[Hp - 16] = io_sbovf_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtCu::P64 = Hp - 15;
           if (R1 == 0) goto cbtDb; else goto cbtDa;
       cbtDb: // global
           R1 = _cbtCu::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtDa: // global
           R1 = _cbtCu::P64;
           Sp = Sp + 24;
           call io_sbovf_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.770350079 UTC

[section ""data" . GHC.IO.Handle.hIsOpen_closure" {
     GHC.IO.Handle.hIsOpen_closure:
         const GHC.IO.Handle.hIsOpen_info;
         const 0;
 },
 GHC.IO.Handle.hIsOpen_entry() //  [R2]
         { info_tbl: [(cbtE8,
                       label: GHC.IO.Handle.hIsOpen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtE8: // global
           R2 = R2;
           call GHC.IO.Handle.hIsOpen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.774067852 UTC

[section ""data" . GHC.IO.Handle.hGetPosn1_closure" {
     GHC.IO.Handle.hGetPosn1_closure:
         const GHC.IO.Handle.hGetPosn1_info;
         const 0;
 },
 GHC.IO.Handle.hGetPosn1_entry() //  [R2]
         { info_tbl: [(cbtEm,
                       label: GHC.IO.Handle.hGetPosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtEm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtEn; else goto cbtEo;
       cbtEn: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetPosn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtEo: // global
           I64[Sp - 16] = block_cbtEj_info;
           R4 = GHC.IO.Handle.hGetPosn2_closure+2;
           R3 = R2;
           _sbovp::P64 = R2;
           R2 = GHC.IO.Handle.hGetPosn3_closure;
           P64[Sp - 8] = _sbovp::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtEj() //  [R1]
         { info_tbl: [(cbtEj,
                       label: block_cbtEj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtEj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtEr; else goto cbtEq;
       cbtEr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtEq: // global
           I64[Hp - 16] = GHC.IO.Handle.HandlePosn_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.780470533 UTC

[section ""data" . GHC.IO.Handle.hGetPosn_closure" {
     GHC.IO.Handle.hGetPosn_closure:
         const GHC.IO.Handle.hGetPosn_info;
         const 0;
 },
 GHC.IO.Handle.hGetPosn_entry() //  [R2]
         { info_tbl: [(cbtEG,
                       label: GHC.IO.Handle.hGetPosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtEG: // global
           R2 = R2;
           call GHC.IO.Handle.hGetPosn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.783746986 UTC

[section ""cstring" . GHC.IO.Handle.hClose3_bytes" {
     GHC.IO.Handle.hClose3_bytes:
         I8[] [104,67,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.785733215 UTC

[section ""data" . GHC.IO.Handle.hClose2_closure" {
     GHC.IO.Handle.hClose2_closure:
         const GHC.IO.Handle.hClose2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hClose2_entry() //  [R1]
         { info_tbl: [(cbtEU,
                       label: GHC.IO.Handle.hClose2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtEU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtEV; else goto cbtEW;
       cbtEV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtEW: // global
           (_cbtER::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtER::I64 == 0) goto cbtET; else goto cbtES;
       cbtET: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtES: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtER::I64;
           R2 = GHC.IO.Handle.hClose3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.79117581 UTC

[section ""data" . GHC.IO.Handle.$wlvl_closure" {
     GHC.IO.Handle.$wlvl_closure:
         const GHC.IO.Handle.$wlvl_info;
         const 0;
 },
 sat_sbovK_entry() //  [R1]
         { info_tbl: [(cbtFn,
                       label: sat_sbovK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtFn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbtFo; else goto cbtFp;
       cbtFo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtFp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbtFg_info;
           _sbovv::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbovv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubtFQ; else goto cbtFh;
       ubtFQ: // global
           call _cbtFg(R1) args: 0, res: 0, upd: 0;
       cbtFh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtFg() //  [R1]
         { info_tbl: [(cbtFg,
                       label: block_cbtFg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtFg: // global
           if (R1 & 7 == 1) goto cbtFk; else goto cbtFl;
       cbtFk: // global
           _sbovv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbtFs_info;
           R1 = _sbovv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubtFP; else goto cbtFu;
       ubtFP: // global
           call _cbtFs(R1) args: 0, res: 0, upd: 0;
       cbtFu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbtFl: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cbtFs() //  [R1]
         { info_tbl: [(cbtFs,
                       label: block_cbtFs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtFs: // global
           if (R1 & 7 == 1) goto cbtFA; else goto cbtFH;
       cbtFA: // global
           Hp = Hp + 16;
           _sbovD::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtFK; else goto cbtFC;
       cbtFC: // global
           _sbovE::P64 = P64[_sbovD::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbovE::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbtFH: // global
           Hp = Hp + 16;
           _sbovD::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtFK; else goto cbtFJ;
       cbtFK: // global
           HpAlloc = 16;
           R1 = _sbovD::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbtFJ: // global
           _sbovG::P64 = P64[_sbovD::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbovG::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbovM_entry() //  [R1]
         { info_tbl: [(cbtFT,
                       label: sat_sbovM_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtFT: // global
           _sbovM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbtFU; else goto cbtFV;
       cbtFV: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbtFX; else goto cbtFW;
       cbtFX: // global
           HpAlloc = 104;
           goto cbtFU;
       cbtFU: // global
           R1 = _sbovM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtFW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbovM::P64;
           _sbovv::P64 = P64[_sbovM::P64 + 16];
           _sbovw::P64 = P64[_sbovM::P64 + 24];
           _sbovx::P64 = P64[_sbovM::P64 + 32];
           _sbovy::P64 = P64[_sbovM::P64 + 40];
           _sbovz::P64 = P64[_sbovM::P64 + 48];
           I64[Hp - 96] = sat_sbovK_info;
           P64[Hp - 80] = _sbovv::P64;
           P64[Hp - 72] = _sbovz::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbovv::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sbovw::P64;
           P64[Hp - 24] = GHC.IO.Handle.hClose2_closure;
           P64[Hp - 16] = _sbovx::P64;
           P64[Hp - 8] = _sbovy::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.$wlvl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbtFY,
                       label: GHC.IO.Handle.$wlvl_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtFY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbtG2; else goto cbtG1;
       cbtG2: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$wlvl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbtG1: // global
           I64[Hp - 48] = sat_sbovM_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.805054092 UTC

[section ""data" . GHC.IO.Handle.hClose1_closure" {
     GHC.IO.Handle.hClose1_closure:
         const GHC.IO.Handle.hClose1_info;
         const 0;
 },
 section ""relreadonly" . ubtIv_srtd" {
     ubtIv_srtd:
         const SboCL_srt+240;
         const 94;
         const 54043195528445953;
         const 973078528;
 },
 GHC.IO.Handle.hClose1_entry() //  [R2]
         { info_tbl: [(cbtGI,
                       label: GHC.IO.Handle.hClose1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtGI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbtGJ; else goto cbtGK;
       cbtGJ: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hClose1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtGK: // global
           I64[Sp - 8] = block_cbtGB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtIp; else goto cbtGC;
       ubtIp: // global
           call _cbtGB(R1) args: 0, res: 0, upd: 0;
       cbtGC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtIw_srtd" {
     ubtIw_srtd:
         const SboCL_srt+240;
         const 93;
         const 54043195528445953;
         const 436207616;
 },
 _cbtGB() //  [R1]
         { info_tbl: [(cbtGB,
                       label: block_cbtGB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtGB: // global
           if (R1 & 7 == 1) goto cbtGF; else goto cbtGG;
       cbtGF: // global
           I64[Sp - 8] = block_cbtGN_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
       cbtGG: // global
           I64[Sp - 16] = block_cbtHw_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[R1 + 14];
           R3 = R1;
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtIx_srtd" {
     ubtIx_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbtGN() //  [R1]
         { info_tbl: [(cbtGN,
                       label: block_cbtGN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtGN: // global
           I64[Sp] = block_cbtGP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtIq; else goto cbtGS;
       ubtIq: // global
           call _cbtGP(R1) args: 0, res: 0, upd: 0;
       cbtGS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtIy_srtd" {
     ubtIy_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbtGP() //  [R1]
         { info_tbl: [(cbtGP,
                       label: block_cbtGP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtGP: // global
           if (R1 & 7 == 1) goto ubtIo; else goto cbtH8;
       ubtIo: // global
           Sp = Sp + 16;
           call _cbtHN() args: 0, res: 0, upd: 0;
       cbtH8: // global
           I64[Sp] = block_cbtH1_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubtIr; else goto cbtH2;
       ubtIr: // global
           call _cbtH1(R1) args: 0, res: 0, upd: 0;
       cbtH2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtIz_srtd" {
     ubtIz_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbtH1() //  [R1]
         { info_tbl: [(cbtH1,
                       label: block_cbtH1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtH1: // global
           I64[Sp - 16] = block_cbtH6_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtIA_srtd" {
     ubtIA_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbtH6() //  [R1]
         { info_tbl: [(cbtH6,
                       label: block_cbtH6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtH6: // global
           I64[Sp] = block_cbtHd_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtHd() //  [R1]
         { info_tbl: [(cbtHd,
                       label: block_cbtHd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtHd: // global
           if (R1 & 7 == 1) goto cbtHk; else goto cbtHp;
       cbtHk: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbtHp: // global
           I64[Sp + 16] = block_cbtHn_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtHn() //  [R1]
         { info_tbl: [(cbtHn,
                       label: block_cbtHn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtHn: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 39];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$wlvl_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtIB_srtd" {
     ubtIB_srtd:
         const SboCL_srt+240;
         const 93;
         const 54043195528445953;
         const 436207616;
 },
 _cbtHw() //  [R1]
         { info_tbl: [(cbtHw,
                       label: block_cbtHw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtHw: // global
           I64[Sp] = block_cbtHy_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtIC_srtd" {
     ubtIC_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbtHy() //  [R1]
         { info_tbl: [(cbtHy,
                       label: block_cbtHy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtHy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbtHH; else goto cbtHG;
       cbtHH: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtHG: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 38;
           I64[Sp + 8] = block_cbtHC_info;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call Data.Maybe.catMaybes1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtID_srtd" {
     ubtID_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbtHC() //  [R1]
         { info_tbl: [(cbtHC,
                       label: block_cbtHC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtHC: // global
           if (R1 & 7 == 1) goto ubtIn; else goto cbtHX;
       ubtIn: // global
           Sp = Sp + 16;
           call _cbtHN() args: 0, res: 0, upd: 0;
       cbtHX: // global
           I64[Sp] = block_cbtHQ_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubtIt; else goto cbtHR;
       ubtIt: // global
           call _cbtHQ(R1) args: 0, res: 0, upd: 0;
       cbtHR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtHN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtHN: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubtIE_srtd" {
     ubtIE_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbtHQ() //  [R1]
         { info_tbl: [(cbtHQ,
                       label: block_cbtHQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtHQ: // global
           I64[Sp - 16] = block_cbtHV_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubtIF_srtd" {
     ubtIF_srtd:
         const SboCL_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbtHV() //  [R1]
         { info_tbl: [(cbtHV,
                       label: block_cbtHV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtHV: // global
           I64[Sp] = block_cbtI2_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtI2() //  [R1]
         { info_tbl: [(cbtI2,
                       label: block_cbtI2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtI2: // global
           if (R1 & 7 == 1) goto cbtI9; else goto cbtIe;
       cbtI9: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbtIe: // global
           I64[Sp + 16] = block_cbtIc_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtIc() //  [R1]
         { info_tbl: [(cbtIc,
                       label: block_cbtIc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtIc: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 39];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$wlvl_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.841566549 UTC

[section ""data" . GHC.IO.Handle.hClose_closure" {
     GHC.IO.Handle.hClose_closure:
         const GHC.IO.Handle.hClose_info;
         const 0;
 },
 GHC.IO.Handle.hClose_entry() //  [R2]
         { info_tbl: [(cbtK2,
                       label: GHC.IO.Handle.hClose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtK2: // global
           R2 = R2;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.844677468 UTC

[section ""data" . lvl28_rbnXa_closure" {
     lvl28_rbnXa_closure:
         const GHC.Types.C#_con_info;
         const 123;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.846414064 UTC

[section ""data" . lvl29_rbnXb_closure" {
     lvl29_rbnXb_closure:
         const GHC.Types.C#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.848564302 UTC

[section ""cstring" . lvl30_rbnXc_bytes" {
     lvl30_rbnXc_bytes:
         I8[] [100,117,112,108,101,120,32,40,114,101,97,100,45,119,114,105,116,101,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.850987362 UTC

[section ""data" . lvl31_rbnXd_closure" {
     lvl31_rbnXd_closure:
         const lvl31_rbnXd_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_rbnXd_entry() //  [R1]
         { info_tbl: [(cbtKi,
                       label: lvl31_rbnXd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtKi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtKj; else goto cbtKk;
       cbtKj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtKk: // global
           (_cbtKf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtKf::I64 == 0) goto cbtKh; else goto cbtKg;
       cbtKh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtKg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtKf::I64;
           R2 = lvl30_rbnXc_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.854753003 UTC

[section ""cstring" . lvl32_rbnXe_bytes" {
     lvl32_rbnXe_bytes:
         I8[] [110,111,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.856463733 UTC

[section ""data" . lvl33_rbnXf_closure" {
     lvl33_rbnXf_closure:
         const lvl33_rbnXf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl33_rbnXf_entry() //  [R1]
         { info_tbl: [(cbtKz,
                       label: lvl33_rbnXf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtKz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtKA; else goto cbtKB;
       cbtKA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtKB: // global
           (_cbtKw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtKw::I64 == 0) goto cbtKy; else goto cbtKx;
       cbtKy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtKx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtKw::I64;
           R2 = lvl32_rbnXe_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.860047522 UTC

[section ""cstring" . lvl34_rbnXg_bytes" {
     lvl34_rbnXg_bytes:
         I8[] [108,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.861815572 UTC

[section ""data" . lvl35_rbnXh_closure" {
     lvl35_rbnXh_closure:
         const lvl35_rbnXh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_rbnXh_entry() //  [R1]
         { info_tbl: [(cbtKQ,
                       label: lvl35_rbnXh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtKQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtKR; else goto cbtKS;
       cbtKR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtKS: // global
           (_cbtKN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtKN::I64 == 0) goto cbtKP; else goto cbtKO;
       cbtKP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtKO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtKN::I64;
           R2 = lvl34_rbnXg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.865910923 UTC

[section ""cstring" . lvl36_rbnXi_bytes" {
     lvl36_rbnXi_bytes:
         I8[] [115,104,111,119,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.867651028 UTC

[section ""data" . lvl37_rbnXj_closure" {
     lvl37_rbnXj_closure:
         const lvl37_rbnXj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_rbnXj_entry() //  [R1]
         { info_tbl: [(cbtL7,
                       label: lvl37_rbnXj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtL7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtL8; else goto cbtL9;
       cbtL8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtL9: // global
           (_cbtL4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtL4::I64 == 0) goto cbtL6; else goto cbtL5;
       cbtL6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtL5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtL4::I64;
           R2 = lvl36_rbnXi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.871425653 UTC

[section ""cstring" . lvl38_rbnXk_bytes" {
     lvl38_rbnXk_bytes:
         I8[] [108,111,99,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.873110869 UTC

[section ""cstring" . lvl39_rbnXl_bytes" {
     lvl39_rbnXl_bytes:
         I8[] [116,121,112,101,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.874805476 UTC

[section ""cstring" . lvl40_rbnXm_bytes" {
     lvl40_rbnXm_bytes:
         I8[] [98,117,102,102,101,114,105,110,103,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.876877119 UTC

[section ""cstring" . lvl41_rbnXn_bytes" {
     lvl41_rbnXn_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.878873061 UTC

[section ""data" . lvl42_rbnXo_closure" {
     lvl42_rbnXo_closure:
         const lvl42_rbnXo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rbnXo_entry() //  [R1]
         { info_tbl: [(cbtLr,
                       label: lvl42_rbnXo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtLr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtLs; else goto cbtLt;
       cbtLs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtLt: // global
           (_cbtLo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtLo::I64 == 0) goto cbtLq; else goto cbtLp;
       cbtLq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtLp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtLo::I64;
           R2 = lvl41_rbnXn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.882887684 UTC

[section ""data" . lvl43_rbnXp_closure" {
     lvl43_rbnXp_closure:
         const lvl43_rbnXp_info;
         const 0;
         const 0;
         const 0;
 },
 lvl43_rbnXp_entry() //  [R1]
         { info_tbl: [(cbtLH,
                       label: lvl43_rbnXp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtLH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtLI; else goto cbtLJ;
       cbtLI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtLJ: // global
           (_cbtLE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtLE::I64 == 0) goto cbtLG; else goto cbtLF;
       cbtLG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtLF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtLE::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = lvl33_rbnXf_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.887346671 UTC

[section ""data" . lvl44_rbnXq_closure" {
     lvl44_rbnXq_closure:
         const lvl44_rbnXq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rbnXq_entry() //  [R1]
         { info_tbl: [(cbtLX,
                       label: lvl44_rbnXq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtLX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtLY; else goto cbtLZ;
       cbtLY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtLZ: // global
           (_cbtLU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtLU::I64 == 0) goto cbtLW; else goto cbtLV;
       cbtLW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtLV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtLU::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = lvl35_rbnXh_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.891057708 UTC

[section ""cstring" . lvl45_rbnXr_bytes" {
     lvl45_rbnXr_bytes:
         I8[] [98,108,111,99,107,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.892681747 UTC

[section ""data" . lvl46_rbnXs_closure" {
     lvl46_rbnXs_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const lvl42_rbnXo_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.894607767 UTC

[section ""data" . lvl47_rbnXt_closure" {
     lvl47_rbnXt_closure:
         const lvl47_rbnXt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl47_rbnXt_entry() //  [R1]
         { info_tbl: [(cbtMf,
                       label: lvl47_rbnXt_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtMf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtMg; else goto cbtMh;
       cbtMg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtMh: // global
           (_cbtMc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbtMc::I64 == 0) goto cbtMe; else goto cbtMd;
       cbtMe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbtMd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtMc::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.90387674 UTC

[section ""data" . GHC.IO.Handle.hShow2_closure" {
     GHC.IO.Handle.hShow2_closure:
         const GHC.IO.Handle.hShow2_info;
         const 0;
 },
 sat_sboxg_entry() //  [R1]
         { info_tbl: [(cbtNu,
                       label: sat_sboxg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtNu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbtNA; else goto cbtNB;
       cbtNA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtNB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbtNm_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _cbtNm() //  []
         { info_tbl: [(cbtNm,
                       label: block_cbtNm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtNm: // global
           _sbox5::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cbtNr_info;
           R1 = _sbox5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubtNI; else goto cbtNs;
       ubtNI: // global
           call _cbtNr(R1) args: 0, res: 0, upd: 0;
       cbtNs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtNr() //  [R1]
         { info_tbl: [(cbtNr,
                       label: block_cbtNr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtNr: // global
           I64[Sp] = block_cbtNx_info;
           R4 = lvl46_rbnXs_closure+2;
           R3 = I64[R1 + 31];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbtNx() //  [R1, R2]
         { info_tbl: [(cbtNx,
                       label: block_cbtNx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtNx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtNH; else goto cbtNG;
       cbtNH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbtNG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxo_entry() //  [R1]
         { info_tbl: [(cbtNS,
                       label: sat_sboxo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtNS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbtNY; else goto cbtNZ;
       cbtNY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtNZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbtNP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubtO4; else goto cbtNQ;
       ubtO4: // global
           call _cbtNP(R1) args: 0, res: 0, upd: 0;
       cbtNQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtNP() //  [R1]
         { info_tbl: [(cbtNP,
                       label: block_cbtNP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtNP: // global
           I64[Sp] = block_cbtNV_info;
           R4 = lvl46_rbnXs_closure+2;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbtNV() //  [R1, R2]
         { info_tbl: [(cbtNV,
                       label: block_cbtNV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtNV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtO3; else goto cbtO2;
       cbtO3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbtO2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxq_entry() //  [R1]
         { info_tbl: [(cbtOa,
                       label: sat_sboxq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtOa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbtOb; else goto cbtOc;
       cbtOb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtOc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbtN6_info;
           _sbowP::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbowP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubtOw; else goto cbtN7;
       ubtOw: // global
           call _cbtN6(R1) args: 0, res: 0, upd: 0;
       cbtN7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtN6() //  [R1]
         { info_tbl: [(cbtN6,
                       label: block_cbtN6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtN6: // global
           _cbtO9::P64 = R1 & 7;
           if (_cbtO9::P64 < 3) goto ubtOu; else goto cbtO8;
       ubtOu: // global
           if (_cbtO9::P64 < 2) goto cbtO6; else goto cbtO7;
       cbtO6: // global
           R1 = lvl43_rbnXp_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbtO7: // global
           R1 = lvl44_rbnXq_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbtO8: // global
           I64[Sp] = block_cbtNd_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto ubtOv; else goto cbtNe;
       ubtOv: // global
           call _cbtNd(R1) args: 0, res: 0, upd: 0;
       cbtNe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtNd() //  [R1]
         { info_tbl: [(cbtNd,
                       label: block_cbtNd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtNd: // global
           if (R1 & 7 == 1) goto cbtOk; else goto cbtOp;
       cbtOk: // global
           Hp = Hp + 48;
           _sbox1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtOs; else goto cbtOm;
       cbtOm: // global
           I64[Hp - 40] = sat_sboxg_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = lvl45_rbnXr_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cbtOp: // global
           Hp = Hp + 48;
           _sbox1::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtOs; else goto cbtOr;
       cbtOs: // global
           HpAlloc = 48;
           R1 = _sbox1::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbtOr: // global
           _sboxi::P64 = P64[_sbox1::P64 + 6];
           I64[Hp - 40] = sat_sboxo_info;
           P64[Hp - 24] = _sboxi::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = lvl45_rbnXr_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 karg_sbowY_entry() //  [R1]
         { info_tbl: [(cbtOx,
                       label: karg_sbowY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtOx: // global
           _sbowY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbtOy; else goto cbtOz;
       cbtOz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbtOB; else goto cbtOA;
       cbtOB: // global
           HpAlloc = 32;
           goto cbtOy;
       cbtOy: // global
           R1 = _sbowY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtOA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbowY::P64;
           _sbowN::P64 = P64[_sbowY::P64 + 16];
           _sbowP::P64 = P64[_sbowY::P64 + 24];
           I64[Hp - 24] = sat_sboxq_info;
           P64[Hp - 8] = _sbowN::P64;
           P64[Hp] = _sbowP::P64;
           R3 = Hp - 24;
           R2 = lvl40_rbnXm_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxz_entry() //  [R1]
         { info_tbl: [(cbtOJ,
                       label: sat_sboxz_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtOJ: // global
           _sboxz::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbtOK; else goto cbtOL;
       cbtOL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbtON; else goto cbtOM;
       cbtON: // global
           HpAlloc = 32;
           goto cbtOK;
       cbtOK: // global
           R1 = _sboxz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtOM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sboxz::P64;
           _sbowA::P64 = P64[_sboxz::P64 + 16];
           _sbowN::P64 = P64[_sboxz::P64 + 24];
           _sbowP::P64 = P64[_sboxz::P64 + 32];
           _sbowX::P64 = P64[_sboxz::P64 + 40];
           I64[Hp - 24] = karg_sbowY_info;
           P64[Hp - 8] = _sbowN::P64;
           P64[Hp] = _sbowP::P64;
           I64[Sp - 40] = block_cbtOC_info;
           R1 = _sbowA::P64;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sbowX::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubtPF; else goto cbtOD;
       ubtPF: // global
           call _cbtOC(R1) args: 0, res: 0, upd: 0;
       cbtOD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtOC() //  [R1]
         { info_tbl: [(cbtOC,
                       label: block_cbtOC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtOC: // global
           if (R1 & 7 == 1) goto cbtOG; else goto cbtOH;
       cbtOG: // global
           I64[Sp] = block_cbtOQ_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubtPE; else goto cbtOS;
       ubtPE: // global
           call _cbtOQ(R1) args: 0, res: 0, upd: 0;
       cbtOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbtOH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtPz; else goto cbtPy;
       cbtPz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbtPy: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 14;
           R2 = lvl31_rbnXd_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 _cbtOQ() //  [R1]
         { info_tbl: [(cbtOQ,
                       label: block_cbtOQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtOQ: // global
           _cbtMY::P64 = P64[Sp + 8];
           _cbtPA::P64 = R1 & 7;
           if (_cbtPA::P64 < 5) goto ubtPB; else goto ubtPD;
       ubtPB: // global
           if (_cbtPA::P64 < 4) goto ubtPC; else goto cbtPc;
       ubtPC: // global
           if (_cbtPA::P64 < 3) goto cbtOY; else goto cbtP5;
       cbtOY: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtPt; else goto cbtP0;
       cbtP0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbtMY::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbtP5: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtPt; else goto cbtP7;
       cbtP7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbtMY::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbtPc: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtPt; else goto cbtPe;
       cbtPe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbtMY::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       ubtPD: // global
           if (_cbtPA::P64 < 6) goto cbtPj; else goto cbtPq;
       cbtPj: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtPt; else goto cbtPl;
       cbtPl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbtMY::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbtPq: // global
           Hp = Hp + 24;
           _sboxs::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbtPt; else goto cbtPs;
       cbtPt: // global
           HpAlloc = 24;
           R1 = _sboxs::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbtPs: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbtMY::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxA_entry() //  [R1]
         { info_tbl: [(cbtPG,
                       label: sat_sboxA_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtPG: // global
           _sboxA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbtPH; else goto cbtPI;
       cbtPI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbtPK; else goto cbtPJ;
       cbtPK: // global
           HpAlloc = 48;
           goto cbtPH;
       cbtPH: // global
           R1 = _sboxA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtPJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sboxA::P64;
           _sbowA::P64 = P64[_sboxA::P64 + 16];
           _sbowN::P64 = P64[_sboxA::P64 + 24];
           _sbowP::P64 = P64[_sboxA::P64 + 32];
           _sbowX::P64 = P64[_sboxA::P64 + 40];
           I64[Hp - 40] = sat_sboxz_info;
           P64[Hp - 24] = _sbowA::P64;
           P64[Hp - 16] = _sbowN::P64;
           P64[Hp - 8] = _sbowP::P64;
           P64[Hp] = _sbowX::P64;
           R3 = Hp - 40;
           R2 = lvl39_rbnXl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxC_entry() //  [R1]
         { info_tbl: [(cbtPM,
                       label: sat_sboxC_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtPM: // global
           _sboxC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbtPN; else goto cbtPO;
       cbtPO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbtPQ; else goto cbtPP;
       cbtPQ: // global
           HpAlloc = 72;
           goto cbtPN;
       cbtPN: // global
           R1 = _sboxC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtPP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sboxC::P64;
           _sbowz::P64 = P64[_sboxC::P64 + 16];
           _sbowA::P64 = P64[_sboxC::P64 + 24];
           _sbowN::P64 = P64[_sboxC::P64 + 32];
           _sbowP::P64 = P64[_sboxC::P64 + 40];
           _sbowX::P64 = P64[_sboxC::P64 + 48];
           I64[Hp - 64] = sat_sboxA_info;
           P64[Hp - 48] = _sbowA::P64;
           P64[Hp - 40] = _sbowN::P64;
           P64[Hp - 32] = _sbowP::P64;
           P64[Hp - 24] = _sbowX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _sbowz::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sboxD_entry() //  [R1]
         { info_tbl: [(cbtPR,
                       label: sat_sboxD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtPR: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbtPS; else goto cbtPT;
       cbtPS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtPT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbtMC_info;
           _sbowz::P64 = P64[R1 + 16];
           _sbowA::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbowz::P64;
           P64[Sp - 24] = _sbowA::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubtQ6; else goto cbtMD;
       ubtQ6: // global
           call _cbtMC(R1) args: 0, res: 0, upd: 0;
       cbtMD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtMC() //  [R1]
         { info_tbl: [(cbtMC,
                       label: block_cbtMC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtMC: // global
           I64[Sp - 16] = block_cbtMH_info;
           _sbowN::P64 = P64[R1 + 55];
           _sbowP::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _sbowP::P64;
           P64[Sp] = _sbowN::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubtQ5; else goto cbtMI;
       ubtQ5: // global
           call _cbtMH(R1) args: 0, res: 0, upd: 0;
       cbtMI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbtMH() //  [R1]
         { info_tbl: [(cbtMH,
                       label: block_cbtMH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtMH: // global
           if (R1 & 7 == 1) goto cbtQ3; else goto cbtPW;
       cbtQ3: // global
           R1 = lvl47_rbnXt_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbtPW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbtPZ; else goto cbtPY;
       cbtPZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbtPY: // global
           I64[Hp - 48] = sat_sboxC_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R3 = Hp - 48;
           R2 = lvl38_rbnXk_bytes;
           Sp = Sp + 40;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 act_sbowD_entry() //  [R1, R2]
         { info_tbl: [(cbtQ8,
                       label: act_sbowD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQ8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbtQc; else goto cbtQb;
       cbtQc: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtQb: // global
           _sbowz::P64 = P64[R1 + 6];
           _sbowA::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sboxD_info;
           P64[Hp - 40] = _sbowz::P64;
           P64[Hp - 32] = _sbowA::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl28_rbnXa_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sboxT_entry() //  [R1, R2]
         { info_tbl: [(cbtQx,
                       label: sat_sboxT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtQy; else goto cbtQz;
       cbtQy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtQz: // global
           I64[Sp - 16] = block_cbtQu_info;
           _sboxN::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sboxN::P64;
           Sp = Sp - 16;
           call act_sbowD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtQu() //  [R1]
         { info_tbl: [(cbtQu,
                       label: block_cbtQu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtQC; else goto cbtQB;
       cbtQC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtQB: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sboxL_entry() //  [R1]
         { info_tbl: [(cbtQI,
                       label: io_sboxL_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQI: // global
           _sboxL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbtQM; else goto cbtQN;
       cbtQN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbtQP; else goto cbtQO;
       cbtQP: // global
           HpAlloc = 16;
           goto cbtQM;
       cbtQM: // global
           R1 = _sboxL::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtQO: // global
           _sbowD::P64 = P64[_sboxL::P64 + 7];
           _sboxF::P64 = P64[_sboxL::P64 + 15];
           _sboxH::P64 = P64[_sboxL::P64 + 23];
           I64[Hp - 8] = sat_sboxT_info;
           P64[Hp] = _sbowD::P64;
           I64[Sp - 16] = block_cbtQD_info;
           R5 = _sboxH::P64;
           R4 = Hp - 6;
           R3 = _sboxF::P64;
           R2 = lvl37_rbnXj_closure;
           P64[Sp - 8] = _sboxH::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtQD() //  [R1]
         { info_tbl: [(cbtQD,
                       label: block_cbtQD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQD: // global
           I64[Sp] = block_cbtQF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtQU; else goto cbtQG;
       ubtQU: // global
           call _cbtQF(R1) args: 0, res: 0, upd: 0;
       cbtQG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtQF() //  [R1]
         { info_tbl: [(cbtQF,
                       label: block_cbtQF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQF: // global
           I64[Sp] = block_cbtQL_info;
           R2 = P64[R1 + 7];
           _sboxZ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboxZ::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtQL() //  []
         { info_tbl: [(cbtQL,
                       label: block_cbtQL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sboyg_entry() //  [R1, R2]
         { info_tbl: [(cbtRc,
                       label: sat_sboyg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtRc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbtRd; else goto cbtRe;
       cbtRd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtRe: // global
           I64[Sp - 16] = block_cbtR9_info;
           _sboya::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sboya::P64;
           Sp = Sp - 16;
           call act_sbowD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtR9() //  [R1]
         { info_tbl: [(cbtR9,
                       label: block_cbtR9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtR9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtRh; else goto cbtRg;
       cbtRh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbtRg: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sboy8_entry() //  [R1]
         { info_tbl: [(cbtRn,
                       label: io_sboy8_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtRn: // global
           _sboy8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbtRr; else goto cbtRs;
       cbtRs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbtRu; else goto cbtRt;
       cbtRu: // global
           HpAlloc = 16;
           goto cbtRr;
       cbtRr: // global
           R1 = _sboy8::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtRt: // global
           _sbowD::P64 = P64[_sboy8::P64 + 7];
           _sboxF::P64 = P64[_sboy8::P64 + 15];
           _sboy3::P64 = P64[_sboy8::P64 + 23];
           I64[Hp - 8] = sat_sboyg_info;
           P64[Hp] = _sbowD::P64;
           I64[Sp - 16] = block_cbtRi_info;
           R5 = _sboy3::P64;
           R4 = Hp - 6;
           R3 = _sboxF::P64;
           R2 = lvl37_rbnXj_closure;
           P64[Sp - 8] = _sboy3::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbtRi() //  [R1]
         { info_tbl: [(cbtRi,
                       label: block_cbtRi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtRi: // global
           I64[Sp] = block_cbtRk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubtRz; else goto cbtRl;
       ubtRz: // global
           call _cbtRk(R1) args: 0, res: 0, upd: 0;
       cbtRl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtRk() //  [R1]
         { info_tbl: [(cbtRk,
                       label: block_cbtRk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtRk: // global
           I64[Sp] = block_cbtRq_info;
           R2 = P64[R1 + 7];
           _sboym::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sboym::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtRq() //  []
         { info_tbl: [(cbtRq,
                       label: block_cbtRq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtRq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hShow2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbtRE,
                       label: GHC.IO.Handle.hShow2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtRE: // global
           _sbowB::P64 = R4;
           _sbowA::P64 = R3;
           _sbowz::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbtRF; else goto cbtRG;
       cbtRG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtRI; else goto cbtRH;
       cbtRI: // global
           HpAlloc = 24;
           goto cbtRF;
       cbtRF: // global
           R4 = _sbowB::P64;
           R3 = _sbowA::P64;
           R2 = _sbowz::P64;
           R1 = GHC.IO.Handle.hShow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbtRH: // global
           I64[Hp - 16] = act_sbowD_info;
           P64[Hp - 8] = _sbowz::P64;
           P64[Hp] = _sbowA::P64;
           I64[Sp - 16] = block_cbtQd_info;
           R1 = _sbowB::P64;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubtRZ; else goto cbtQe;
       ubtRZ: // global
           call _cbtQd(R1) args: 0, res: 0, upd: 0;
       cbtQe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtQd() //  [R1]
         { info_tbl: [(cbtQd,
                       label: block_cbtQd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQd: // global
           if (R1 & 7 == 1) goto cbtRB; else goto cbtRC;
       cbtRB: // global
           I64[Sp - 16] = block_cbtQi_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbtRC: // global
           I64[Sp - 16] = block_cbtQX_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbtQi() //  [R1]
         { info_tbl: [(cbtQi,
                       label: block_cbtQi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbtRM; else goto cbtRL;
       cbtRM: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtRL: // global
           I64[Hp - 24] = io_sboxL_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtQk::P64 = Hp - 23;
           if (R1 == 0) goto cbtRQ; else goto cbtRP;
       cbtRQ: // global
           R1 = _cbtQk::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtRP: // global
           R1 = _cbtQk::P64;
           Sp = Sp + 32;
           call io_sboxL_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbtQX() //  [R1]
         { info_tbl: [(cbtQX,
                       label: block_cbtQX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtQX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbtRU; else goto cbtRT;
       cbtRU: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbtRT: // global
           I64[Hp - 24] = io_sboy8_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbtQZ::P64 = Hp - 23;
           if (R1 == 0) goto cbtRY; else goto cbtRX;
       cbtRY: // global
           R1 = _cbtQZ::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbtRX: // global
           R1 = _cbtQZ::P64;
           Sp = Sp + 32;
           call io_sboy8_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.978653591 UTC

[section ""data" . GHC.IO.Handle.hShow1_closure" {
     GHC.IO.Handle.hShow1_closure:
         const GHC.IO.Handle.hShow1_info;
         const 0;
 },
 GHC.IO.Handle.hShow1_entry() //  [R2]
         { info_tbl: [(cbtV2,
                       label: GHC.IO.Handle.hShow1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtV2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbtV3; else goto cbtV4;
       cbtV3: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hShow1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbtV4: // global
           I64[Sp - 8] = block_cbtUV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubtVb; else goto cbtUW;
       ubtVb: // global
           call _cbtUV(R1) args: 0, res: 0, upd: 0;
       cbtUW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbtUV() //  [R1]
         { info_tbl: [(cbtUV,
                       label: block_cbtUV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtUV: // global
           if (R1 & 7 == 1) goto cbtUZ; else goto cbtV0;
       cbtUZ: // global
           R4 = R1;
           R3 = GHC.Types.False_closure+1;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.hShow2_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cbtV0: // global
           R4 = R1;
           R3 = GHC.Types.True_closure+2;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.IO.Handle.hShow2_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.984664097 UTC

[section ""data" . GHC.IO.Handle.hShow_closure" {
     GHC.IO.Handle.hShow_closure:
         const GHC.IO.Handle.hShow_info;
         const 0;
 },
 GHC.IO.Handle.hShow_entry() //  [R2]
         { info_tbl: [(cbtVr,
                       label: GHC.IO.Handle.hShow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtVr: // global
           R2 = R2;
           call GHC.IO.Handle.hShow1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.987873364 UTC

[section ""data" . GHC.IO.Handle.HandlePosn_closure" {
     GHC.IO.Handle.HandlePosn_closure:
         const GHC.IO.Handle.HandlePosn_info;
 },
 GHC.IO.Handle.HandlePosn_entry() //  [R2, R3]
         { info_tbl: [(cbtVD,
                       label: GHC.IO.Handle.HandlePosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtVD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbtVH; else goto cbtVG;
       cbtVH: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.HandlePosn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbtVG: // global
           I64[Hp - 16] = GHC.IO.Handle.HandlePosn_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.991447542 UTC

[GHC.IO.Handle.HandlePosn_con_entry() //  [R1]
         { info_tbl: [(cbtVN,
                       label: GHC.IO.Handle.HandlePosn_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,72,97,110,100,108,101,80,111,115,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbtVN: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:18.994928784 UTC

[section ""relreadonly" . SboCL_srt" {
     SboCL_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.IO.Handle.$w$cshowsPrec_closure;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure;
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_closure;
         const GHC.IO.Handle.$fShowHandlePosn1_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.hLookAhead2_closure;
         const GHC.IO.Handle.hLookAhead1_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.hFlush2_closure;
         const GHC.IO.Handle.hFlush1_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const GHC.IO.Handle.hFlushAll2_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hFlushAll3_closure;
         const GHC.IO.Handle.hFlushAll1_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hGetEcho6_closure;
         const GHC.IO.Handle.hGetEcho_fun_closure;
         const GHC.IO.Handle.hGetEcho5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl1_rbnWC_closure;
         const lvl3_rbnWE_closure;
         const ioe_dupHandlesNotCompatible_rbnWF_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const dupHandle__rbnWK_closure;
         const GHC.IO.failIO1_closure;
         const lvl5_rbnWM_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const dupHandleTo_rbnWN_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.$whSetNewlineMode_closure;
         const GHC.IO.Handle.hSetNewlineMode2_closure;
         const GHC.IO.Handle.hSetNewlineMode1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const lvl11_rbnWT_closure;
         const GHC.IO.Handle.hSetBinaryMode1_closure;
         const lvl9_rbnWR_closure;
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure;
         const GHC.IO.Handle.hIsSeekable2_closure;
         const GHC.IO.Handle.hIsSeekable3_closure;
         const GHC.IO.Handle.hIsSeekable1_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.IO.Handle.hGetPosn2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.hGetPosn3_closure;
         const GHC.IO.Handle.hTell1_closure;
         const lvl14_rbnWW_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.hSeek1_closure;
         const lvl13_rbnWV_closure;
         const GHC.IO.Handle.hSetPosn1_closure;
         const GHC.IO.Handle.hGetEncoding3_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hGetEncoding1_closure;
         const lvl18_rbnX0_closure;
         const GHC.IO.Handle.hSetEncoding1_closure;
         const lvl16_rbnWY_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hSetBuffering1_closure;
         const GHC.IO.Handle.hSetBuffering2_closure;
         const GHC.IO.Handle.hIsEOF3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.hIsEOF1_closure;
         const GHC.IO.Handle.FD.stdin_closure;
         const GHC.IO.Handle.isEOF1_closure;
         const lvl20_rbnX2_closure;
         const GHC.IO.Handle.hSetFileSize1_closure;
         const GHC.IO.Handle.hFileSize5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const sat_sbojQ_closure;
         const GHC.IO.Handle.hFileSize3_closure;
         const GHC.IO.Handle.hFileSize4_closure;
         const GHC.IO.Handle.hFileSize10_closure;
         const GHC.IO.Handle.hFileSize2_closure;
         const GHC.IO.Handle.hFileSize8_closure;
         const GHC.IO.Handle.hFileSize1_closure;
         const lvl21_rbnX3_closure;
         const dupHandleTo_rbnWN_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.hDuplicateTo1_closure;
         const lvl25_rbnX7_closure;
         const GHC.IO.failIO1_closure;
         const lvl27_rbnX9_closure;
         const dupHandle__rbnWK_closure;
         const lvl7_rbnWP_closure;
         const GHC.IO.Handle.hDuplicate1_closure;
         const lvl23_rbnX5_closure;
         const GHC.IO.Handle.hGetEcho2_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hGetEcho3_closure;
         const GHC.IO.Handle.hGetEcho1_closure;
         const GHC.IO.Handle.hSetEcho2_closure;
         const GHC.IO.Handle.hSetEcho1_closure;
         const GHC.IO.Handle.hGetBuffering2_closure;
         const GHC.IO.Handle.hGetBuffering_fun_closure;
         const GHC.IO.Handle.hGetBuffering1_closure;
         const GHC.IO.Handle.hIsWritable2_closure;
         const GHC.IO.Handle.hIsWritable3_closure;
         const GHC.IO.Handle.hIsWritable1_closure;
         const GHC.IO.Handle.hIsReadable2_closure;
         const GHC.IO.Handle.hIsReadable3_closure;
         const GHC.IO.Handle.hIsReadable1_closure;
         const GHC.IO.Handle.hIsClosed3_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hIsClosed1_closure;
         const GHC.IO.Handle.hIsOpen3_closure;
         const GHC.IO.Handle.hIsOpen1_closure;
         const GHC.IO.Handle.hGetPosn1_closure;
         const GHC.IO.Handle.hGetPosn3_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.hGetPosn2_closure;
         const GHC.IO.Handle.hClose2_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.$wlvl_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.hClose1_closure;
         const lvl33_rbnXf_closure;
         const lvl42_rbnXo_closure;
         const lvl35_rbnXh_closure;
         const GHC.IO.Handle.Types.$fShowHandleType11_closure;
         const lvl46_rbnXs_closure;
         const lvl43_rbnXp_closure;
         const lvl44_rbnXq_closure;
         const GHC.IO.Handle.Types.$fShowHandleType1_closure;
         const GHC.IO.Handle.Types.$fShowHandleType3_closure;
         const GHC.IO.Handle.Types.$fShowHandleType5_closure;
         const GHC.IO.Handle.Types.$fShowHandleType7_closure;
         const GHC.IO.Handle.Types.$fShowHandleType9_closure;
         const lvl31_rbnXd_closure;
         const lvl47_rbnXt_closure;
         const lvl37_rbnXj_closure;
         const GHC.IO.Handle.hShow2_closure;
         const GHC.IO.Handle.hShow1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.855376427 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:27.856956463 UTC

[section ""data" . GHC.IO.Handle.$w$c==_closure" {
     GHC.IO.Handle.$w$c==_closure:
         const GHC.IO.Handle.$w$c==_info;
 },
 GHC.IO.Handle.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbux5,
                       label: GHC.IO.Handle.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbux5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbux6; else goto cbux7;
       cbux6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbux7: // global
           I64[Sp - 24] = block_cbux0_info;
           _sbtVV::P64 = R3;
           R3 = R5;
           _sbtVU::P64 = R2;
           R2 = _sbtVV::P64;
           P64[Sp - 16] = _sbtVU::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbux0() //  [R1]
         { info_tbl: [(cbux0,
                       label: block_cbux0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbux0: // global
           if (R1 == 1) goto cbux4; else goto cbux3;
       cbux4: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.IO.Handle.Types.$fEqHandle_$c==_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
       cbux3: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.863005188 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_$c==_closure" {
     GHC.IO.Handle.$fEqHandlePosn_$c==_closure:
         const GHC.IO.Handle.$fEqHandlePosn_$c==_info;
 },
 GHC.IO.Handle.$fEqHandlePosn_$c==_entry() //  [R2, R3]
         { info_tbl: [(cbuxw,
                       label: GHC.IO.Handle.$fEqHandlePosn_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuxw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuxA; else goto cbuxB;
       cbuxA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fEqHandlePosn_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbuxB: // global
           I64[Sp - 16] = block_cbuxt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubuxJ; else goto cbuxu;
       ubuxJ: // global
           call _cbuxt(R1) args: 0, res: 0, upd: 0;
       cbuxu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuxt() //  [R1]
         { info_tbl: [(cbuxt,
                       label: block_cbuxt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuxt: // global
           I64[Sp - 8] = block_cbuxz_info;
           _sbtW2::P64 = P64[R1 + 7];
           _sbtW3::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbtW3::P64;
           P64[Sp + 8] = _sbtW2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubuxI; else goto cbuxD;
       ubuxI: // global
           call _cbuxz(R1) args: 0, res: 0, upd: 0;
       cbuxD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuxz() //  [R1]
         { info_tbl: [(cbuxz,
                       label: block_cbuxz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuxz: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.IO.Handle.$w$c==_entry(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.87299098 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_$c/=_closure" {
     GHC.IO.Handle.$fEqHandlePosn_$c/=_closure:
         const GHC.IO.Handle.$fEqHandlePosn_$c/=_info;
 },
 GHC.IO.Handle.$fEqHandlePosn_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cbuy6,
                       label: GHC.IO.Handle.$fEqHandlePosn_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuy6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuya; else goto cbuyb;
       cbuya: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fEqHandlePosn_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbuyb: // global
           I64[Sp - 16] = block_cbuy3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubuzI; else goto cbuy4;
       ubuzI: // global
           call _cbuy3(R1) args: 0, res: 0, upd: 0;
       cbuy4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuy3() //  [R1]
         { info_tbl: [(cbuy3,
                       label: block_cbuy3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuy3: // global
           I64[Sp - 8] = block_cbuy9_info;
           _sbtWa::P64 = P64[R1 + 7];
           _sbtWb::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sbtWb::P64;
           P64[Sp + 8] = _sbtWa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubuzH; else goto cbuyd;
       ubuzH: // global
           call _cbuy9(R1) args: 0, res: 0, upd: 0;
       cbuyd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuy9() //  [R1]
         { info_tbl: [(cbuy9,
                       label: block_cbuy9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuy9: // global
           I64[Sp] = block_cbuyh_info;
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuyh() //  [R1]
         { info_tbl: [(cbuyh,
                       label: block_cbuyh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuyh: // global
           if (R1 == 1) goto cbuyt; else goto ubuzA;
       cbuyt: // global
           I64[Sp] = block_cbuyr_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubuzJ; else goto cbuyu;
       ubuzJ: // global
           call _cbuyr(R1) args: 0, res: 0, upd: 0;
       cbuyu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubuzA: // global
           Sp = Sp + 24;
           call _cbuzm() args: 0, res: 0, upd: 0;
     }
 },
 _cbuyr() //  [R1]
         { info_tbl: [(cbuyr,
                       label: block_cbuyr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuyr: // global
           _sbtWd::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbuyB; else goto cbuz6;
       cbuyB: // global
           I64[Sp + 8] = block_cbuyy_info;
           _sbtWi::P64 = P64[R1 + 15];
           R1 = _sbtWd::P64;
           P64[Sp + 16] = _sbtWi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubuzL; else goto cbuyC;
       ubuzL: // global
           call _cbuyy(R1) args: 0, res: 0, upd: 0;
       cbuyC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbuz6: // global
           I64[Sp + 8] = block_cbuz4_info;
           _sbtWr::P64 = P64[R1 + 14];
           R1 = _sbtWd::P64;
           P64[Sp + 16] = _sbtWr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubuzM; else goto cbuz7;
       ubuzM: // global
           call _cbuz4(R1) args: 0, res: 0, upd: 0;
       cbuz7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuyy() //  [R1]
         { info_tbl: [(cbuyy,
                       label: block_cbuyy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuyy: // global
           if (R1 & 7 == 1) goto cbuyX; else goto ubuzE;
       cbuyX: // global
           if (P64[Sp + 8] == P64[R1 + 15]) goto ubuzF; else goto ubuzG;
       ubuzF: // global
           Sp = Sp + 16;
           call _cbuzs() args: 0, res: 0, upd: 0;
       ubuzG: // global
           Sp = Sp + 16;
           goto ubuzP;
       ubuzE: // global
           Sp = Sp + 16;
           goto ubuzP;
       ubuzP: // global
           call _cbuzm() args: 0, res: 0, upd: 0;
     }
 },
 _cbuz4() //  [R1]
         { info_tbl: [(cbuz4,
                       label: block_cbuz4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuz4: // global
           if (R1 & 7 == 1) goto ubuzB; else goto cbuzw;
       ubuzB: // global
           Sp = Sp + 16;
           goto ubuzS;
       cbuzw: // global
           if (P64[Sp + 8] == P64[R1 + 14]) goto ubuzC; else goto ubuzD;
       ubuzC: // global
           Sp = Sp + 16;
           call _cbuzs() args: 0, res: 0, upd: 0;
       ubuzD: // global
           Sp = Sp + 16;
           goto ubuzS;
       ubuzS: // global
           call _cbuzm() args: 0, res: 0, upd: 0;
     }
 },
 _cbuzs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuzs: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbuzm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuzm: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.890254745 UTC

[section ""data" . GHC.IO.Handle.$fEqHandlePosn_closure" {
     GHC.IO.Handle.$fEqHandlePosn_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.Handle.$fEqHandlePosn_$c==_closure+2;
         const GHC.IO.Handle.$fEqHandlePosn_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.891949181 UTC

[section ""cstring" . GHC.IO.Handle.$fShowHandlePosn2_bytes" {
     GHC.IO.Handle.$fShowHandlePosn2_bytes:
         I8[] [32,97,116,32,112,111,115,105,116,105,111,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.895682731 UTC

[section ""data" . GHC.IO.Handle.$w$cshowsPrec_closure" {
     GHC.IO.Handle.$w$cshowsPrec_closure:
         const GHC.IO.Handle.$w$cshowsPrec_info;
         const 0;
 },
 sat_sbtWJ_entry() //  [R1]
         { info_tbl: [(cbuBc,
                       label: sat_sbtWJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuBc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuBd; else goto cbuBe;
       cbuBd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuBe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbuB9_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbuB9() //  [R1, R2]
         { info_tbl: [(cbuB9,
                       label: block_cbuB9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuB9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuBh; else goto cbuBg;
       cbuBh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbuBg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbtWK_entry() //  [R1]
         { info_tbl: [(cbuBi,
                       label: sat_sbtWK_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuBi: // global
           _sbtWK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbuBj; else goto cbuBk;
       cbuBk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbuBm; else goto cbuBl;
       cbuBm: // global
           HpAlloc = 32;
           goto cbuBj;
       cbuBj: // global
           R1 = _sbtWK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuBl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbtWK::P64;
           _sbtWB::P64 = P64[_sbtWK::P64 + 16];
           _sbtWC::P64 = P64[_sbtWK::P64 + 24];
           I64[Hp - 24] = sat_sbtWJ_info;
           P64[Hp - 8] = _sbtWB::P64;
           P64[Hp] = _sbtWC::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.$fShowHandlePosn2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbtWL_entry() //  [R1]
         { info_tbl: [(cbuBn,
                       label: sat_sbtWL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuBn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbuBr; else goto cbuBq;
       cbuBr: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuBq: // global
           _sbtWB::P64 = P64[R1 + 16];
           _sbtWC::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbtWK_info;
           P64[Hp - 8] = _sbtWB::P64;
           P64[Hp] = _sbtWC::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbtWM_entry() //  [R1]
         { info_tbl: [(cbuBs,
                       label: sat_sbtWM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuBs: // global
           _sbtWM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbuBt; else goto cbuBu;
       cbuBu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbuBw; else goto cbuBv;
       cbuBw: // global
           HpAlloc = 32;
           goto cbuBt;
       cbuBt: // global
           R1 = _sbtWM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuBv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbtWM::P64;
           _sbtWB::P64 = P64[_sbtWM::P64 + 16];
           _sbtWC::P64 = P64[_sbtWM::P64 + 24];
           _sbtWE::P64 = P64[_sbtWM::P64 + 32];
           I64[Hp - 24] = sat_sbtWL_info;
           P64[Hp - 8] = _sbtWB::P64;
           P64[Hp] = _sbtWC::P64;
           R3 = Hp - 24;
           R2 = _sbtWE::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbtWT_entry() //  [R1]
         { info_tbl: [(cbuBS,
                       label: sat_sbtWT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuBS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuBT; else goto cbuBU;
       cbuBT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuBU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbuBP_info;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbuBP() //  [R1, R2]
         { info_tbl: [(cbuBP,
                       label: block_cbuBP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuBP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuBX; else goto cbuBW;
       cbuBX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbuBW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbtWU_entry() //  [R1]
         { info_tbl: [(cbuBY,
                       label: sat_sbtWU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuBY: // global
           _sbtWU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbuBZ; else goto cbuC0;
       cbuC0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbuC2; else goto cbuC1;
       cbuC2: // global
           HpAlloc = 32;
           goto cbuBZ;
       cbuBZ: // global
           R1 = _sbtWU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuC1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbtWU::P64;
           _sbtWB::P64 = P64[_sbtWU::P64 + 16];
           _sbtWC::P64 = P64[_sbtWU::P64 + 24];
           I64[Hp - 24] = sat_sbtWT_info;
           P64[Hp - 8] = _sbtWB::P64;
           P64[Hp] = _sbtWC::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.$fShowHandlePosn2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbtWV_entry() //  [R1]
         { info_tbl: [(cbuC3,
                       label: sat_sbtWV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuC3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbuC7; else goto cbuC6;
       cbuC7: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuC6: // global
           _sbtWB::P64 = P64[R1 + 16];
           _sbtWC::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbtWU_info;
           P64[Hp - 8] = _sbtWB::P64;
           P64[Hp] = _sbtWC::P64;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.Types.$fReadNewlineMode5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbtWW_entry() //  [R1]
         { info_tbl: [(cbuC8,
                       label: sat_sbtWW_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuC8: // global
           _sbtWW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbuC9; else goto cbuCa;
       cbuCa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbuCc; else goto cbuCb;
       cbuCc: // global
           HpAlloc = 32;
           goto cbuC9;
       cbuC9: // global
           R1 = _sbtWW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuCb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbtWW::P64;
           _sbtWB::P64 = P64[_sbtWW::P64 + 16];
           _sbtWC::P64 = P64[_sbtWW::P64 + 24];
           _sbtWN::P64 = P64[_sbtWW::P64 + 32];
           I64[Hp - 24] = sat_sbtWV_info;
           P64[Hp - 8] = _sbtWB::P64;
           P64[Hp] = _sbtWC::P64;
           R3 = Hp - 24;
           R2 = _sbtWN::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbuCh,
                       label: GHC.IO.Handle.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuCh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuCi; else goto cbuCj;
       cbuCi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbuCj: // global
           I64[Sp - 24] = block_cbuAO_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubuCq; else goto cbuAP;
       ubuCq: // global
           call _cbuAO(R1) args: 0, res: 0, upd: 0;
       cbuAP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuAO() //  [R1]
         { info_tbl: [(cbuAO,
                       label: block_cbuAO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuAO: // global
           _sbtWB::P64 = P64[Sp + 8];
           _sbtWC::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cbuCe; else goto cbuCf;
       cbuCe: // global
           Hp = Hp + 40;
           _sbtWD::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbuCp; else goto cbuCl;
       cbuCl: // global
           _sbtWE::P64 = P64[_sbtWD::P64 + 7];
           I64[Hp - 32] = sat_sbtWM_info;
           P64[Hp - 16] = _sbtWB::P64;
           P64[Hp - 8] = _sbtWC::P64;
           P64[Hp] = _sbtWE::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
       cbuCf: // global
           Hp = Hp + 40;
           _sbtWD::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbuCp; else goto cbuCo;
       cbuCp: // global
           HpAlloc = 40;
           R1 = _sbtWD::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuCo: // global
           _sbtWN::P64 = P64[_sbtWD::P64 + 6];
           I64[Hp - 32] = sat_sbtWW_info;
           P64[Hp - 16] = _sbtWB::P64;
           P64[Hp - 8] = _sbtWC::P64;
           P64[Hp] = _sbtWN::P64;
           R3 = Hp - 32;
           R2 = GHC.IO.Handle.Types.showHandle1_bytes;
           Sp = Sp + 24;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.923705953 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cbuDF,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuDF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuDG; else goto cbuDH;
       cbuDG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbuDH: // global
           I64[Sp - 16] = block_cbuDC_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubuDL; else goto cbuDD;
       ubuDL: // global
           call _cbuDC(R1) args: 0, res: 0, upd: 0;
       cbuDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuDC() //  [R1]
         { info_tbl: [(cbuDC,
                       label: block_cbuDC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuDC: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.929452605 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn3_closure" {
     GHC.IO.Handle.$fShowHandlePosn3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.931314685 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshow_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshow_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshow_entry() //  [R2]
         { info_tbl: [(cbuE4,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuE4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbuE5; else goto cbuE6;
       cbuE5: // global
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuE6: // global
           I64[Sp - 8] = block_cbuE1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubuEa; else goto cbuE2;
       ubuEa: // global
           call _cbuE1(R1) args: 0, res: 0, upd: 0;
       cbuE2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuE1() //  [R1]
         { info_tbl: [(cbuE1,
                       label: block_cbuE1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuE1: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.936763303 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn1_closure" {
     GHC.IO.Handle.$fShowHandlePosn1_closure:
         const GHC.IO.Handle.$fShowHandlePosn1_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn1_entry() //  [R2, R3]
         { info_tbl: [(cbuEt,
                       label: GHC.IO.Handle.$fShowHandlePosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuEt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuEu; else goto cbuEv;
       cbuEu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$fShowHandlePosn1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbuEv: // global
           I64[Sp - 16] = block_cbuEq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubuEz; else goto cbuEr;
       ubuEz: // global
           call _cbuEq(R1) args: 0, res: 0, upd: 0;
       cbuEr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuEq() //  [R1]
         { info_tbl: [(cbuEq,
                       label: block_cbuEq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuEq: // global
           R4 = P64[Sp + 8];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.IO.Handle.$w$cshowsPrec_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.942547506 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure" {
     GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure:
         const GHC.IO.Handle.$fShowHandlePosn_$cshowList_info;
         const 0;
 },
 GHC.IO.Handle.$fShowHandlePosn_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cbuEO,
                       label: GHC.IO.Handle.$fShowHandlePosn_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuEO: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.Handle.$fShowHandlePosn1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.945827472 UTC

[section ""data" . GHC.IO.Handle.$fShowHandlePosn_closure" {
     GHC.IO.Handle.$fShowHandlePosn_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure+3;
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_closure+1;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.948053917 UTC

[section ""cstring" . GHC.IO.Handle.hLookAhead3_bytes" {
     GHC.IO.Handle.hLookAhead3_bytes:
         I8[] [104,76,111,111,107,65,104,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.94989961 UTC

[section ""data" . GHC.IO.Handle.hLookAhead2_closure" {
     GHC.IO.Handle.hLookAhead2_closure:
         const GHC.IO.Handle.hLookAhead2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hLookAhead2_entry() //  [R1]
         { info_tbl: [(cbuF3,
                       label: GHC.IO.Handle.hLookAhead2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuF3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuF4; else goto cbuF5;
       cbuF4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuF5: // global
           (_cbuF0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuF0::I64 == 0) goto cbuF2; else goto cbuF1;
       cbuF2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuF1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuF0::I64;
           R2 = GHC.IO.Handle.hLookAhead3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.954311378 UTC

[section ""data" . GHC.IO.Handle.hLookAhead1_closure" {
     GHC.IO.Handle.hLookAhead1_closure:
         const GHC.IO.Handle.hLookAhead1_info;
         const 0;
 },
 GHC.IO.Handle.hLookAhead1_entry() //  [R2]
         { info_tbl: [(cbuFi,
                       label: GHC.IO.Handle.hLookAhead1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuFi: // global
           R4 = GHC.IO.Handle.Internals.hLookAhead_1_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hLookAhead2_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.9576801 UTC

[section ""data" . GHC.IO.Handle.hLookAhead_closure" {
     GHC.IO.Handle.hLookAhead_closure:
         const GHC.IO.Handle.hLookAhead_info;
         const 0;
 },
 GHC.IO.Handle.hLookAhead_entry() //  [R2]
         { info_tbl: [(cbuFu,
                       label: GHC.IO.Handle.hLookAhead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuFu: // global
           R2 = R2;
           call GHC.IO.Handle.hLookAhead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.960710744 UTC

[section ""cstring" . GHC.IO.Handle.hFlush3_bytes" {
     GHC.IO.Handle.hFlush3_bytes:
         I8[] [104,70,108,117,115,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.962886619 UTC

[section ""data" . GHC.IO.Handle.hFlush2_closure" {
     GHC.IO.Handle.hFlush2_closure:
         const GHC.IO.Handle.hFlush2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFlush2_entry() //  [R1]
         { info_tbl: [(cbuFI,
                       label: GHC.IO.Handle.hFlush2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuFI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuFJ; else goto cbuFK;
       cbuFJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuFK: // global
           (_cbuFF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuFF::I64 == 0) goto cbuFH; else goto cbuFG;
       cbuFH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuFG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuFF::I64;
           R2 = GHC.IO.Handle.hFlush3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.966846851 UTC

[section ""data" . GHC.IO.Handle.hFlush1_closure" {
     GHC.IO.Handle.hFlush1_closure:
         const GHC.IO.Handle.hFlush1_info;
         const 0;
 },
 GHC.IO.Handle.hFlush1_entry() //  [R2]
         { info_tbl: [(cbuFX,
                       label: GHC.IO.Handle.hFlush1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuFX: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.970241721 UTC

[section ""data" . GHC.IO.Handle.hFlush_closure" {
     GHC.IO.Handle.hFlush_closure:
         const GHC.IO.Handle.hFlush_info;
         const 0;
 },
 GHC.IO.Handle.hFlush_entry() //  [R2]
         { info_tbl: [(cbuG9,
                       label: GHC.IO.Handle.hFlush_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuG9: // global
           R2 = R2;
           call GHC.IO.Handle.hFlush1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.9734487 UTC

[section ""cstring" . GHC.IO.Handle.hFlushAll4_bytes" {
     GHC.IO.Handle.hFlushAll4_bytes:
         I8[] [104,70,108,117,115,104,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.975165944 UTC

[section ""data" . GHC.IO.Handle.hFlushAll3_closure" {
     GHC.IO.Handle.hFlushAll3_closure:
         const GHC.IO.Handle.hFlushAll3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFlushAll3_entry() //  [R1]
         { info_tbl: [(cbuGn,
                       label: GHC.IO.Handle.hFlushAll3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuGn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuGo; else goto cbuGp;
       cbuGo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuGp: // global
           (_cbuGk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuGk::I64 == 0) goto cbuGm; else goto cbuGl;
       cbuGm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuGl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuGk::I64;
           R2 = GHC.IO.Handle.hFlushAll4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.979918344 UTC

[section ""data" . GHC.IO.Handle.hFlushAll2_closure" {
     GHC.IO.Handle.hFlushAll2_closure:
         const GHC.IO.Handle.hFlushAll2_info;
         const 0;
 },
 GHC.IO.Handle.hFlushAll2_entry() //  [R2]
         { info_tbl: [(cbuGF,
                       label: GHC.IO.Handle.hFlushAll2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuGF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuGG; else goto cbuGH;
       cbuGG: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFlushAll2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuGH: // global
           I64[Sp - 16] = block_cbuGC_info;
           _sbtXg::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbtXg::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuGC() //  [R1]
         { info_tbl: [(cbuGC,
                       label: block_cbuGC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuGC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuGK; else goto cbuGJ;
       cbuGK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuGJ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:27.989884049 UTC

[section ""data" . GHC.IO.Handle.hFlushAll1_closure" {
     GHC.IO.Handle.hFlushAll1_closure:
         const GHC.IO.Handle.hFlushAll1_info;
         const 0;
 },
 io_sbtXu_entry() //  [R1]
         { info_tbl: [(cbuHi,
                       label: io_sbtXu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuHm; else goto cbuHn;
       cbuHm: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbuHn: // global
           I64[Sp - 16] = block_cbuHd_info;
           _sbtXq::P64 = P64[R1 + 15];
           R5 = _sbtXq::P64;
           R4 = GHC.IO.Handle.hFlushAll2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFlushAll3_closure;
           P64[Sp - 8] = _sbtXq::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuHd() //  [R1]
         { info_tbl: [(cbuHd,
                       label: block_cbuHd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHd: // global
           I64[Sp] = block_cbuHf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubuHs; else goto cbuHg;
       ubuHs: // global
           call _cbuHf(R1) args: 0, res: 0, upd: 0;
       cbuHg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuHf() //  [R1]
         { info_tbl: [(cbuHf,
                       label: block_cbuHf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHf: // global
           I64[Sp] = block_cbuHl_info;
           R2 = P64[R1 + 7];
           _sbtXB::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbtXB::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuHl() //  []
         { info_tbl: [(cbuHl,
                       label: block_cbuHl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbtXK_entry() //  [R1]
         { info_tbl: [(cbuHH,
                       label: io_sbtXK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuHL; else goto cbuHM;
       cbuHL: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbuHM: // global
           I64[Sp - 16] = block_cbuHC_info;
           _sbtXF::P64 = P64[R1 + 15];
           R5 = _sbtXF::P64;
           R4 = GHC.IO.Handle.hFlushAll2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFlushAll3_closure;
           P64[Sp - 8] = _sbtXF::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuHC() //  [R1]
         { info_tbl: [(cbuHC,
                       label: block_cbuHC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHC: // global
           I64[Sp] = block_cbuHE_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubuHR; else goto cbuHF;
       ubuHR: // global
           call _cbuHE(R1) args: 0, res: 0, upd: 0;
       cbuHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuHE() //  [R1]
         { info_tbl: [(cbuHE,
                       label: block_cbuHE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHE: // global
           I64[Sp] = block_cbuHK_info;
           R2 = P64[R1 + 7];
           _sbtXR::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbtXR::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuHK() //  []
         { info_tbl: [(cbuHK,
                       label: block_cbuHK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hFlushAll1_entry() //  [R2]
         { info_tbl: [(cbuHW,
                       label: GHC.IO.Handle.hFlushAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuHX; else goto cbuHY;
       cbuHX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFlushAll1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuHY: // global
           I64[Sp - 8] = block_cbuH1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubuIf; else goto cbuH2;
       ubuIf: // global
           call _cbuH1(R1) args: 0, res: 0, upd: 0;
       cbuH2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuH1() //  [R1]
         { info_tbl: [(cbuH1,
                       label: block_cbuH1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuH1: // global
           if (R1 & 7 == 1) goto cbuHT; else goto cbuHU;
       cbuHT: // global
           I64[Sp - 16] = block_cbuH6_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbuHU: // global
           I64[Sp - 16] = block_cbuHv_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbuH6() //  [R1]
         { info_tbl: [(cbuH6,
                       label: block_cbuH6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuH6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuI2; else goto cbuI1;
       cbuI2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbuI1: // global
           I64[Hp - 16] = io_sbtXu_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbuH8::P64 = Hp - 15;
           if (R1 == 0) goto cbuI6; else goto cbuI5;
       cbuI6: // global
           R1 = _cbuH8::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbuI5: // global
           R1 = _cbuH8::P64;
           Sp = Sp + 24;
           call io_sbtXu_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbuHv() //  [R1]
         { info_tbl: [(cbuHv,
                       label: block_cbuHv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuHv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuIa; else goto cbuI9;
       cbuIa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbuI9: // global
           I64[Hp - 16] = io_sbtXK_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbuHx::P64 = Hp - 15;
           if (R1 == 0) goto cbuIe; else goto cbuId;
       cbuIe: // global
           R1 = _cbuHx::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbuId: // global
           R1 = _cbuHx::P64;
           Sp = Sp + 24;
           call io_sbtXK_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.01685568 UTC

[section ""data" . GHC.IO.Handle.hFlushAll_closure" {
     GHC.IO.Handle.hFlushAll_closure:
         const GHC.IO.Handle.hFlushAll_info;
         const 0;
 },
 GHC.IO.Handle.hFlushAll_entry() //  [R2]
         { info_tbl: [(cbuJm,
                       label: GHC.IO.Handle.hFlushAll_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuJm: // global
           R2 = R2;
           call GHC.IO.Handle.hFlushAll1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.021056419 UTC

[section ""cstring" . GHC.IO.Handle.hGetEcho7_bytes" {
     GHC.IO.Handle.hGetEcho7_bytes:
         I8[] [104,73,115,84,101,114,109,105,110,97,108,68,101,118,105,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.023774499 UTC

[section ""data" . GHC.IO.Handle.hGetEcho_fun_closure" {
     GHC.IO.Handle.hGetEcho_fun_closure:
         const GHC.IO.Handle.hGetEcho_fun_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEcho_fun_entry() //  [R1]
         { info_tbl: [(cbuJA,
                       label: GHC.IO.Handle.hGetEcho_fun_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuJA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuJB; else goto cbuJC;
       cbuJB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuJC: // global
           (_cbuJx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuJx::I64 == 0) goto cbuJz; else goto cbuJy;
       cbuJz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuJy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuJx::I64;
           R2 = GHC.IO.Handle.hGetEcho7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.028270844 UTC

[section ""data" . GHC.IO.Handle.hGetEcho6_closure" {
     GHC.IO.Handle.hGetEcho6_closure:
         const GHC.IO.Handle.hGetEcho6_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho6_entry() //  [R2]
         { info_tbl: [(cbuJS,
                       label: GHC.IO.Handle.hGetEcho6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuJS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbuJT; else goto cbuJU;
       cbuJT: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuJU: // global
           I64[Sp - 8] = block_cbuJP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubuKi; else goto cbuJQ;
       ubuKi: // global
           call _cbuJP(R1) args: 0, res: 0, upd: 0;
       cbuJQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuJP() //  [R1]
         { info_tbl: [(cbuJP,
                       label: block_cbuJP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuJP: // global
           I64[Sp - 24] = block_cbuJX_info;
           _sbtXW::P64 = R1;
           _sbtXX::P64 = P64[R1 + 7];
           _sbtY0::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbtXX::P64;
           P64[Sp - 8] = _sbtY0::P64;
           P64[Sp] = _sbtXW::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubuKh; else goto cbuJZ;
       ubuKh: // global
           call _cbuJX(R1) args: 0, res: 0, upd: 0;
       cbuJZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuJX() //  [R1]
         { info_tbl: [(cbuJX,
                       label: block_cbuJX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuJX: // global
           if (R1 & 7 == 1) goto cbuKf; else goto cbuK8;
       cbuKf: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbuK8: // global
           _sbtY0::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbuK3_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbtY0::P64;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbuK3() //  [R1]
         { info_tbl: [(cbuK3,
                       label: block_cbuK3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuK3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuKb; else goto cbuKa;
       cbuKb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuKa: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.038850752 UTC

[section ""data" . GHC.IO.Handle.hGetEcho5_closure" {
     GHC.IO.Handle.hGetEcho5_closure:
         const GHC.IO.Handle.hGetEcho5_info;
         const 0;
 },
 io_sbtYr_entry() //  [R1]
         { info_tbl: [(cbuL3,
                       label: io_sbtYr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuL3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuL7; else goto cbuL8;
       cbuL7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbuL8: // global
           I64[Sp - 16] = block_cbuKY_info;
           _sbtYn::P64 = P64[R1 + 15];
           R5 = _sbtYn::P64;
           R4 = GHC.IO.Handle.hGetEcho6_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho_fun_closure;
           P64[Sp - 8] = _sbtYn::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuKY() //  [R1]
         { info_tbl: [(cbuKY,
                       label: block_cbuKY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuKY: // global
           I64[Sp] = block_cbuL0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubuLd; else goto cbuL1;
       ubuLd: // global
           call _cbuL0(R1) args: 0, res: 0, upd: 0;
       cbuL1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuL0() //  [R1]
         { info_tbl: [(cbuL0,
                       label: block_cbuL0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuL0: // global
           I64[Sp] = block_cbuL6_info;
           R2 = P64[R1 + 7];
           _sbtYy::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbtYy::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuL6() //  []
         { info_tbl: [(cbuL6,
                       label: block_cbuL6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuL6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbtYH_entry() //  [R1]
         { info_tbl: [(cbuLs,
                       label: io_sbtYH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuLs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuLw; else goto cbuLx;
       cbuLw: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbuLx: // global
           I64[Sp - 16] = block_cbuLn_info;
           _sbtYC::P64 = P64[R1 + 15];
           R5 = _sbtYC::P64;
           R4 = GHC.IO.Handle.hGetEcho6_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho_fun_closure;
           P64[Sp - 8] = _sbtYC::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuLn() //  [R1]
         { info_tbl: [(cbuLn,
                       label: block_cbuLn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuLn: // global
           I64[Sp] = block_cbuLp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubuLC; else goto cbuLq;
       ubuLC: // global
           call _cbuLp(R1) args: 0, res: 0, upd: 0;
       cbuLq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuLp() //  [R1]
         { info_tbl: [(cbuLp,
                       label: block_cbuLp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuLp: // global
           I64[Sp] = block_cbuLv_info;
           R2 = P64[R1 + 7];
           _sbtYO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbtYO::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuLv() //  []
         { info_tbl: [(cbuLv,
                       label: block_cbuLv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuLv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hGetEcho5_entry() //  [R2]
         { info_tbl: [(cbuLH,
                       label: GHC.IO.Handle.hGetEcho5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuLH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuLI; else goto cbuLJ;
       cbuLI: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho5_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuLJ: // global
           I64[Sp - 8] = block_cbuKM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubuM0; else goto cbuKN;
       ubuM0: // global
           call _cbuKM(R1) args: 0, res: 0, upd: 0;
       cbuKN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuKM() //  [R1]
         { info_tbl: [(cbuKM,
                       label: block_cbuKM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuKM: // global
           if (R1 & 7 == 1) goto cbuLE; else goto cbuLF;
       cbuLE: // global
           I64[Sp - 16] = block_cbuKR_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbuLF: // global
           I64[Sp - 16] = block_cbuLg_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbuKR() //  [R1]
         { info_tbl: [(cbuKR,
                       label: block_cbuKR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuKR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuLN; else goto cbuLM;
       cbuLN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbuLM: // global
           I64[Hp - 16] = io_sbtYr_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbuKT::P64 = Hp - 15;
           if (R1 == 0) goto cbuLR; else goto cbuLQ;
       cbuLR: // global
           R1 = _cbuKT::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbuLQ: // global
           R1 = _cbuKT::P64;
           Sp = Sp + 24;
           call io_sbtYr_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbuLg() //  [R1]
         { info_tbl: [(cbuLg,
                       label: block_cbuLg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuLg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuLV; else goto cbuLU;
       cbuLV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbuLU: // global
           I64[Hp - 16] = io_sbtYH_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbuLi::P64 = Hp - 15;
           if (R1 == 0) goto cbuLZ; else goto cbuLY;
       cbuLZ: // global
           R1 = _cbuLi::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbuLY: // global
           R1 = _cbuLi::P64;
           Sp = Sp + 24;
           call io_sbtYH_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.063487794 UTC

[section ""data" . GHC.IO.Handle.hIsTerminalDevice_closure" {
     GHC.IO.Handle.hIsTerminalDevice_closure:
         const GHC.IO.Handle.hIsTerminalDevice_info;
         const 0;
 },
 GHC.IO.Handle.hIsTerminalDevice_entry() //  [R2]
         { info_tbl: [(cbuN7,
                       label: GHC.IO.Handle.hIsTerminalDevice_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuN7: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.066580894 UTC

[section ""cstring" . lvl_rbnWB_bytes" {
     lvl_rbnWB_bytes:
         I8[] [104,68,117,112,108,105,99,97,116,101,84,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.068291713 UTC

[section ""data" . lvl1_rbnWC_closure" {
     lvl1_rbnWC_closure:
         const lvl1_rbnWC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbnWC_entry() //  [R1]
         { info_tbl: [(cbuNl,
                       label: lvl1_rbnWC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuNm; else goto cbuNn;
       cbuNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuNn: // global
           (_cbuNi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuNi::I64 == 0) goto cbuNk; else goto cbuNj;
       cbuNk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuNj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuNi::I64;
           R2 = lvl_rbnWB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.072430206 UTC

[section ""cstring" . lvl2_rbnWD_bytes" {
     lvl2_rbnWD_bytes:
         I8[] [104,97,110,100,108,101,115,32,97,114,101,32,105,110,99,111,109,112,97,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.074239163 UTC

[section ""data" . lvl3_rbnWE_closure" {
     lvl3_rbnWE_closure:
         const lvl3_rbnWE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbnWE_entry() //  [R1]
         { info_tbl: [(cbuND,
                       label: lvl3_rbnWE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuND: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuNE; else goto cbuNF;
       cbuNE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuNF: // global
           (_cbuNA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuNA::I64 == 0) goto cbuNC; else goto cbuNB;
       cbuNC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuNB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuNA::I64;
           R2 = lvl2_rbnWD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.078424005 UTC

[section ""data" . ioe_dupHandlesNotCompatible_rbnWF_closure" {
     ioe_dupHandlesNotCompatible_rbnWF_closure:
         const ioe_dupHandlesNotCompatible_rbnWF_info;
         const 0;
 },
 sat_sbtYV_entry() //  [R1]
         { info_tbl: [(cbuNY,
                       label: sat_sbtYV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuNY: // global
           _sbtYV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbuNZ; else goto cbuO0;
       cbuO0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbuO2; else goto cbuO1;
       cbuO2: // global
           HpAlloc = 72;
           goto cbuNZ;
       cbuNZ: // global
           R1 = _sbtYV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuO1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbtYV::P64;
           _sbtYR::P64 = P64[_sbtYV::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbtYR::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = GHC.IO.Exception.IllegalOperation_closure+1;
           P64[Hp - 24] = lvl1_rbnWC_closure;
           P64[Hp - 16] = lvl3_rbnWE_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ioe_dupHandlesNotCompatible_rbnWF_entry() //  [R2]
         { info_tbl: [(cbuO3,
                       label: ioe_dupHandlesNotCompatible_rbnWF_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuO3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuO7; else goto cbuO6;
       cbuO7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = ioe_dupHandlesNotCompatible_rbnWF_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuO6: // global
           I64[Hp - 16] = sat_sbtYV_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.084780732 UTC

[section ""cstring" . GHC.IO.Handle.$trModule4_bytes" {
     GHC.IO.Handle.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.086519868 UTC

[section ""data" . GHC.IO.Handle.$trModule3_closure" {
     GHC.IO.Handle.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.088151093 UTC

[section ""cstring" . GHC.IO.Handle.$trModule2_bytes" {
     GHC.IO.Handle.$trModule2_bytes:
         I8[] [71,72,67,46,73,79,46,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.089840897 UTC

[section ""data" . GHC.IO.Handle.$trModule1_closure" {
     GHC.IO.Handle.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.091493472 UTC

[section ""data" . GHC.IO.Handle.$trModule_closure" {
     GHC.IO.Handle.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.Handle.$trModule3_closure+1;
         const GHC.IO.Handle.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.09414488 UTC

[section ""data" . $krep_rbnWG_closure" {
     $krep_rbnWG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.095810621 UTC

[section ""data" . $krep1_rbnWH_closure" {
     $krep1_rbnWH_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.Types.$tcHandle_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.097618274 UTC

[section ""cstring" . GHC.IO.Handle.$tcHandlePosn2_bytes" {
     GHC.IO.Handle.$tcHandlePosn2_bytes:
         I8[] [72,97,110,100,108,101,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.099195261 UTC

[section ""data" . GHC.IO.Handle.$tcHandlePosn1_closure" {
     GHC.IO.Handle.$tcHandlePosn1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$tcHandlePosn2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.100795624 UTC

[section ""data" . GHC.IO.Handle.$tcHandlePosn_closure" {
     GHC.IO.Handle.$tcHandlePosn_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.$trModule_closure+1;
         const GHC.IO.Handle.$tcHandlePosn1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14603627022044816180;
         const 6047646306417636971;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.102647817 UTC

[section ""data" . $krep2_rbnWI_closure" {
     $krep2_rbnWI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.Handle.$tcHandlePosn_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.104369963 UTC

[section ""data" . $krep3_rbnWJ_closure" {
     $krep3_rbnWJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbnWG_closure+1;
         const $krep2_rbnWI_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.10660354 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn1_closure" {
     GHC.IO.Handle.$tc'HandlePosn1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rbnWH_closure+1;
         const $krep3_rbnWJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.108270018 UTC

[section ""cstring" . GHC.IO.Handle.$tc'HandlePosn3_bytes" {
     GHC.IO.Handle.$tc'HandlePosn3_bytes:
         I8[] [39,72,97,110,100,108,101,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.109997984 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn2_closure" {
     GHC.IO.Handle.$tc'HandlePosn2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.Handle.$tc'HandlePosn3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.111622403 UTC

[section ""data" . GHC.IO.Handle.$tc'HandlePosn_closure" {
     GHC.IO.Handle.$tc'HandlePosn_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.Handle.$trModule_closure+1;
         const GHC.IO.Handle.$tc'HandlePosn2_closure+1;
         const GHC.IO.Handle.$tc'HandlePosn1_closure+4;
         const 2346493220596692855;
         const 1604707260447826943;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.114702638 UTC

[section ""data" . dupHandle__rbnWK_closure" {
     dupHandle__rbnWK_closure:
         const dupHandle__rbnWK_info;
         const 0;
 },
 dupHandle__rbnWK_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuOK: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 dupHandle__rbnWK_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbuOR,
                       label: dupHandle__rbnWK_info
                       rep:HeapRep static {
                             Fun {arity: 9
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuOR: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbuOS; else goto cbuOT;
       cbuOS: // global
           R1 = dupHandle__rbnWK_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cbuOT: // global
           I64[Sp - 40] = block_cbuOO_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubuPz; else goto cbuOP;
       ubuPz: // global
           call _cbuOO(R1) args: 0, res: 0, upd: 0;
       cbuOP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuOO() //  [R1]
         { info_tbl: [(cbuOO,
                       label: block_cbuOO_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuOO: // global
           I64[Sp - 24] = block_cbuOY_info;
           _sbtZa::P64 = P64[R1 + 39];
           _sbtZj::P64 = P64[R1 + 111];
           _sbtZk::P64 = P64[R1 + 119];
           R1 = P64[R1 + 87];
           P64[Sp - 16] = _sbtZj::P64;
           P64[Sp - 8] = _sbtZk::P64;
           P64[Sp] = _sbtZa::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubuPy; else goto cbuP6;
       ubuPy: // global
           call _cbuOY(R1) args: 0, res: 0, upd: 0;
       cbuP6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuOY() //  [R1]
         { info_tbl: [(cbuOY,
                       label: block_cbuOY_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuOY: // global
           if (R1 & 7 == 1) goto cbuPc; else goto cbuPh;
       cbuPc: // global
           P64[Sp] = GHC.Base.Nothing_closure+1;
           call _cbuP1() args: 0, res: 0, upd: 0;
       cbuPh: // global
           I64[Sp] = block_cbuPf_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubuPA; else goto cbuPi;
       ubuPA: // global
           call _cbuPf(R1) args: 0, res: 0, upd: 0;
       cbuPi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuPf() //  [R1]
         { info_tbl: [(cbuPf,
                       label: block_cbuPf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuPf: // global
           I64[Sp] = block_cbuPm_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuPm() //  [R1]
         { info_tbl: [(cbuPm,
                       label: block_cbuPm_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuPm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbuPr; else goto cbuPq;
       cbuPr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuPq: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 6;
           call _cbuP1() args: 0, res: 0, upd: 0;
     }
 },
 _cbuP1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuP1: // global
           Hp = Hp + 24;
           _sbtZo::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cbuP5; else goto cbuP4;
       cbuP5: // global
           HpAlloc = 24;
           I64[Sp] = block_cbuP0_info;
           R1 = _sbtZo::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuP4: // global
           I64[Hp - 16] = GHC.IO.Handle.Types.NewlineMode_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 40];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 72];
           P64[Sp + 40] = P64[Sp + 24];
           P64[Sp + 48] = GHC.Types.True_closure+2;
           P64[Sp + 56] = _sbtZo::P64;
           _sbtZ1::P64 = P64[Sp + 64];
           P64[Sp + 64] = Hp - 15;
           P64[Sp + 72] = P64[Sp + 80];
           P64[Sp + 80] = _sbtZ1::P64;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.mkDuplexHandle5_entry(R6,
                                                              R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 56, res: 0, upd: 8;
     }
 },
 _cbuP0() //  [R1]
         { info_tbl: [(cbuP0,
                       label: block_cbuP0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuP0: // global
           P64[Sp] = R1;
           call _cbuP1() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.130948091 UTC

[section ""cstring" . lvl4_rbnWL_bytes" {
     lvl4_rbnWL_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,55,49,51,58,55,45,50,48]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.13290007 UTC

[section ""data" . lvl5_rbnWM_closure" {
     lvl5_rbnWM_closure:
         const lvl5_rbnWM_info;
         const 0;
 },
 lvl5_rbnWM_entry() //  []
         { info_tbl: [(cbuQv,
                       label: lvl5_rbnWM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuQv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbuQw; else goto cbuQx;
       cbuQw: // global
           R1 = lvl5_rbnWM_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbuQx: // global
           I64[Sp - 8] = block_cbuQt_info;
           R2 = lvl4_rbnWL_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuQt() //  [R1]
         { info_tbl: [(cbuQt,
                       label: block_cbuQt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuQt: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.139246807 UTC

[section ""data" . dupHandleTo_rbnWN_closure" {
     dupHandleTo_rbnWN_closure:
         const dupHandleTo_rbnWN_info;
         const 0;
 },
 dupHandleTo_rbnWN_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbuQR,
                       label: dupHandleTo_rbnWN_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuQR: // global
           if ((Sp + -112) < SpLim) (likely: False) goto cbuQV; else goto cbuQW;
       cbuQV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = dupHandleTo_rbnWN_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbuQW: // global
           I64[Sp - 40] = block_cbuQO_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubuRC; else goto cbuQP;
       ubuRC: // global
           call _cbuQO(R1) args: 0, res: 0, upd: 0;
       cbuQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuQO() //  [R1]
         { info_tbl: [(cbuQO,
                       label: block_cbuQO_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuQO: // global
           I64[Sp - 8] = block_cbuQU_info;
           _sbtZL::P64 = P64[R1 + 23];
           _sbtZM::P64 = P64[R1 + 31];
           R1 = P64[Sp + 32];
           P64[Sp] = _sbtZM::P64;
           P64[Sp + 32] = _sbtZL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubuRB; else goto cbuQY;
       ubuRB: // global
           call _cbuQU(R1) args: 0, res: 0, upd: 0;
       cbuQY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuQU() //  [R1]
         { info_tbl: [(cbuQU,
                       label: block_cbuQU_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuQU: // global
           I64[Sp - 40] = block_cbuR2_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuR2() //  []
         { info_tbl: [(cbuR2,
                       label: block_cbuR2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuR2: // global
           I64[Sp] = block_cbuR4_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 80];
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuR4() //  [R1]
         { info_tbl: [(cbuR4,
                       label: block_cbuR4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuR4: // global
           if (R1 & 7 == 1) goto cbuRc; else goto cbuRl;
       cbuRc: // global
           R2 = P64[Sp + 64];
           Sp = Sp + 96;
           call ioe_dupHandlesNotCompatible_rbnWF_entry(R2) args: 8, res: 0, upd: 8;
       cbuRl: // global
           I64[Sp] = block_cbuRf_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 32];
           P64[Sp - 8] = P64[Sp + 48];
           Sp = Sp - 24;
           call GHC.IO.Device.dup2_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbuRf() //  []
         { info_tbl: [(cbuRf,
                       label: block_cbuRf_info
                       rep:StackRep [False, False, False, True, False, False, False, True,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuRf: // global
           _sbtZG::P64 = P64[Sp + 88];
           I64[Sp + 88] = block_cbuRh_info;
           R6 = P64[Sp + 56];
           R5 = P64[Sp + 48];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 64] = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 40];
           P64[Sp + 80] = _sbtZG::P64;
           Sp = Sp + 64;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbuRh() //  [R1]
         { info_tbl: [(cbuRh,
                       label: block_cbuRh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuRh: // global
           I64[Sp] = block_cbuRj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubuRD; else goto cbuRo;
       ubuRD: // global
           call _cbuRj(R1) args: 0, res: 0, upd: 0;
       cbuRo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuRj() //  [R1]
         { info_tbl: [(cbuRj,
                       label: block_cbuRj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuRj: // global
           if (R1 & 7 == 1) goto cbuRu; else goto cbuRy;
       cbuRu: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_takeMVar#(R1) args: 8, res: 0, upd: 8;
       cbuRy: // global
           Sp = Sp + 8;
           call lvl5_rbnWM_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.155802475 UTC

[section ""cstring" . lvl6_rbnWO_bytes" {
     lvl6_rbnWO_bytes:
         I8[] [100,117,112,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.157759525 UTC

[section ""data" . lvl7_rbnWP_closure" {
     lvl7_rbnWP_closure:
         const lvl7_rbnWP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rbnWP_entry() //  [R1]
         { info_tbl: [(cbuSy,
                       label: lvl7_rbnWP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuSy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuSz; else goto cbuSA;
       cbuSz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuSA: // global
           (_cbuSv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuSv::I64 == 0) goto cbuSx; else goto cbuSw;
       cbuSx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuSw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuSv::I64;
           R2 = lvl6_rbnWO_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.162269682 UTC

[section ""cstring" . GHC.IO.Handle.hSetNewlineMode3_bytes" {
     GHC.IO.Handle.hSetNewlineMode3_bytes:
         I8[] [104,83,101,116,78,101,119,108,105,110,101,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.164078061 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode2_closure" {
     GHC.IO.Handle.hSetNewlineMode2_closure:
         const GHC.IO.Handle.hSetNewlineMode2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode2_entry() //  [R1]
         { info_tbl: [(cbuSQ,
                       label: GHC.IO.Handle.hSetNewlineMode2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuSQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuSR; else goto cbuSS;
       cbuSR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuSS: // global
           (_cbuSN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuSN::I64 == 0) goto cbuSP; else goto cbuSO;
       cbuSP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuSO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuSN::I64;
           R2 = GHC.IO.Handle.hSetNewlineMode3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.168718047 UTC

[section ""data" . GHC.IO.Handle.$whSetNewlineMode_closure" {
     GHC.IO.Handle.$whSetNewlineMode_closure:
         const GHC.IO.Handle.$whSetNewlineMode_info;
         const 0;
 },
 sat_sbu0X_entry() //  [R1, R2]
         { info_tbl: [(cbuTd,
                       label: sat_sbu0X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuTd: // global
           if ((Sp + -136) < SpLim) (likely: False) goto cbuTj; else goto cbuTk;
       cbuTj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuTk: // global
           I64[Sp - 24] = block_cbuTa_info;
           _sbu0x::P64 = P64[R1 + 6];
           _sbu0y::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbu0x::P64;
           P64[Sp - 8] = _sbu0y::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubuTp; else goto cbuTb;
       ubuTp: // global
           call _cbuTa(R1) args: 0, res: 0, upd: 0;
       cbuTb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuTa() //  [R1]
         { info_tbl: [(cbuTa,
                       label: block_cbuTa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuTa: // global
           I64[Sp - 112] = block_cbuTg_info;
           R2 = R1;
           P64[Sp - 104] = P64[R1 + 15];
           P64[Sp - 96] = P64[R1 + 23];
           P64[Sp - 88] = P64[R1 + 31];
           P64[Sp - 80] = P64[R1 + 39];
           P64[Sp - 72] = P64[R1 + 47];
           P64[Sp - 64] = P64[R1 + 55];
           P64[Sp - 56] = P64[R1 + 63];
           P64[Sp - 48] = P64[R1 + 71];
           P64[Sp - 40] = P64[R1 + 79];
           P64[Sp - 32] = P64[R1 + 87];
           P64[Sp - 24] = P64[R1 + 95];
           P64[Sp - 16] = P64[R1 + 103];
           P64[Sp - 8] = P64[R1 + 127];
           P64[Sp] = P64[R1 + 7];
           Sp = Sp - 112;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbuTg() //  [R1]
         { info_tbl: [(cbuTg,
                       label: block_cbuTg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuTg: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbuTo; else goto cbuTn;
       cbuTo: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuTn: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 112];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = P64[Sp + 56];
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = P64[Sp + 80];
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 96];
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = P64[Sp + 104];
           R1 = Hp - 127;
           Sp = Sp + 136;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.$whSetNewlineMode_entry() //  [R2, R3, R4]
         { info_tbl: [(cbuTq,
                       label: GHC.IO.Handle.$whSetNewlineMode_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuTq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuTu; else goto cbuTt;
       cbuTu: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$whSetNewlineMode_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbuTt: // global
           I64[Hp - 16] = sat_sbu0X_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R4 = Hp - 14;
           R3 = R2;
           R2 = GHC.IO.Handle.hSetNewlineMode2_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.180186928 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode1_closure" {
     GHC.IO.Handle.hSetNewlineMode1_closure:
         const GHC.IO.Handle.hSetNewlineMode1_info;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode1_entry() //  [R2, R3]
         { info_tbl: [(cbuUq,
                       label: GHC.IO.Handle.hSetNewlineMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuUq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuUr; else goto cbuUs;
       cbuUr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetNewlineMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbuUs: // global
           I64[Sp - 16] = block_cbuUn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubuUw; else goto cbuUo;
       ubuUw: // global
           call _cbuUn(R1) args: 0, res: 0, upd: 0;
       cbuUo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuUn() //  [R1]
         { info_tbl: [(cbuUn,
                       label: block_cbuUn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuUn: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$whSetNewlineMode_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.185938631 UTC

[section ""data" . GHC.IO.Handle.hSetNewlineMode_closure" {
     GHC.IO.Handle.hSetNewlineMode_closure:
         const GHC.IO.Handle.hSetNewlineMode_info;
         const 0;
 },
 GHC.IO.Handle.hSetNewlineMode_entry() //  [R2, R3]
         { info_tbl: [(cbuUL,
                       label: GHC.IO.Handle.hSetNewlineMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuUL: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetNewlineMode1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.189028846 UTC

[section ""cstring" . lvl8_rbnWQ_bytes" {
     lvl8_rbnWQ_bytes:
         I8[] [104,83,101,116,66,105,110,97,114,121,77,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.190968016 UTC

[section ""data" . lvl9_rbnWR_closure" {
     lvl9_rbnWR_closure:
         const lvl9_rbnWR_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_rbnWR_entry() //  [R1]
         { info_tbl: [(cbuUZ,
                       label: lvl9_rbnWR_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuUZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbuV0; else goto cbuV1;
       cbuV0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuV1: // global
           (_cbuUW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuUW::I64 == 0) goto cbuUY; else goto cbuUX;
       cbuUY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuUX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuUW::I64;
           R2 = lvl8_rbnWQ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.195312717 UTC

[section ""cstring" . lvl10_rbnWS_bytes" {
     lvl10_rbnWS_bytes:
         I8[] [99,111,100,101,99,95,115,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.197154432 UTC

[section ""data" . lvl11_rbnWT_closure" {
     lvl11_rbnWT_closure:
         const lvl11_rbnWT_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_rbnWT_entry() //  [R1]
         { info_tbl: [(cbuVj,
                       label: lvl11_rbnWT_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuVj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuVk; else goto cbuVl;
       cbuVk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuVl: // global
           (_cbuVe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbuVe::I64 == 0) goto cbuVg; else goto cbuVf;
       cbuVg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbuVf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuVe::I64;
           I64[Sp - 24] = block_cbuVh_info;
           R2 = lvl10_rbnWS_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbuVh() //  [R1]
         { info_tbl: [(cbuVh,
                       label: block_cbuVh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuVh: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.210297735 UTC

[section ""data" . GHC.IO.Handle.hSetBinaryMode1_closure" {
     GHC.IO.Handle.hSetBinaryMode1_closure:
         const GHC.IO.Handle.hSetBinaryMode1_info;
         const 0;
 },
 lvl48_sbu18_entry() //  [R1]
         { info_tbl: [(cbuVM,
                       label: lvl48_sbu18_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuVM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuVN; else goto cbuVO;
       cbuVN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuVO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbuVJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubuVS; else goto cbuVK;
       ubuVS: // global
           call _cbuVJ() args: 0, res: 0, upd: 0;
       cbuVK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbuVJ() //  []
         { info_tbl: [(cbuVJ,
                       label: block_cbuVJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuVJ: // global
           R1 = GHC.IO.Handle.Types.LF_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbu41_entry() //  [R1]
         { info_tbl: [(cbuWE,
                       label: sat_sbu41_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuWE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbuWI; else goto cbuWJ;
       cbuWI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuWJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbuWB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubuWN; else goto cbuWC;
       ubuWN: // global
           call _cbuWB(R1) args: 0, res: 0, upd: 0;
       cbuWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbuWB() //  [R1]
         { info_tbl: [(cbuWB,
                       label: block_cbuWB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuWB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbuWM; else goto cbuWL;
       cbuWM: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbuWL: // global
           _sbu3W::P64 = P64[R1 + 7];
           _sbu3X::P64 = P64[R1 + 15];
           _sbu3V::I64 = I64[R1 + 23];
           _sbu3Y::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbu3W::P64;
           P64[Hp - 32] = _sbu3X::P64;
           I64[Hp - 24] = _sbu3V::I64;
           I64[Hp - 16] = _sbu3Y::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbu4k_entry() //  [R1]
         { info_tbl: [(cbuXa,
                       label: sat_sbu4k_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuXa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbuXh; else goto cbuXi;
       cbuXh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbuXi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbuX7_info;
           _sbu4a::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbu4a::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubuXm; else goto cbuX8;
       ubuXm: // global
           call _cbuX7(R1) args: 0, res: 0, upd: 0;
       cbuX8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbuX7() //  [R1]
         { info_tbl: [(cbuX7,
                       label: block_cbuX7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuX7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbuXl; else goto cbuXk;
       cbuXl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbuXk: // global
           _sbu4e::P64 = P64[R1 + 7];
           _sbu4f::P64 = P64[R1 + 15];
           _sbu4d::I64 = I64[R1 + 23];
           _sbu4g::I64 = I64[R1 + 31];
           _sbu4i::I64 = I64[R1 + 47];
           _sbu4j::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbu4e::P64;
           P64[Hp - 32] = _sbu4f::P64;
           I64[Hp - 24] = _sbu4d::I64;
           I64[Hp - 16] = _sbu4g::I64;
           I64[Hp - 8] = _sbu4j::I64;
           I64[Hp] = _sbu4i::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbu4H_entry() //  [R1, R2]
         { info_tbl: [(cbuXn,
                       label: sat_sbu4H_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuXn: // global
           if ((Sp + -176) < SpLim) (likely: False) goto cbuXo; else goto cbuXp;
       cbuXo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuXp: // global
           I64[Sp - 24] = block_cbuVY_info;
           _sbu16::P64 = P64[R1 + 6];
           _sbu18::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbu16::P64;
           P64[Sp - 8] = _sbu18::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubv2Z; else goto cbuVZ;
       ubv2Z: // global
           call _cbuVY(R1) args: 0, res: 0, upd: 0;
       cbuVZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuVY() //  [R1]
         { info_tbl: [(cbuVY,
                       label: block_cbuVY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuVY: // global
           I64[Sp - 104] = block_cbuW3_info;
           _sbu1d::P64 = P64[R1 + 7];
           _sbu1e::P64 = P64[R1 + 15];
           _sbu1f::P64 = P64[R1 + 23];
           _sbu1g::P64 = P64[R1 + 31];
           _sbu1h::P64 = P64[R1 + 39];
           _sbu1i::P64 = P64[R1 + 47];
           _sbu1j::P64 = P64[R1 + 55];
           _sbu1k::P64 = P64[R1 + 63];
           _sbu1l::P64 = P64[R1 + 71];
           _sbu1m::P64 = P64[R1 + 79];
           _sbu1n::P64 = P64[R1 + 87];
           _sbu1o::P64 = P64[R1 + 95];
           _sbu1s::P64 = P64[R1 + 127];
           R1 = P64[_sbu1l::P64 + 8];
           P64[Sp - 96] = _sbu1e::P64;
           P64[Sp - 88] = _sbu1f::P64;
           P64[Sp - 80] = _sbu1g::P64;
           P64[Sp - 72] = _sbu1h::P64;
           P64[Sp - 64] = _sbu1i::P64;
           P64[Sp - 56] = _sbu1j::P64;
           P64[Sp - 48] = _sbu1k::P64;
           P64[Sp - 40] = _sbu1l::P64;
           P64[Sp - 32] = _sbu1m::P64;
           P64[Sp - 24] = _sbu1n::P64;
           P64[Sp - 16] = _sbu1o::P64;
           P64[Sp - 8] = _sbu1s::P64;
           P64[Sp] = _sbu1d::P64;
           Sp = Sp - 104;
           if (R1 & 7 != 0) goto ubv2M; else goto cbuW4;
       ubv2M: // global
           call _cbuW3(R1) args: 0, res: 0, upd: 0;
       cbuW4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuW3() //  [R1]
         { info_tbl: [(cbuW3,
                       label: block_cbuW3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuW3: // global
           I64[Sp - 16] = block_cbuWa_info;
           _sbu1B::I64 = I64[R1 + 39];
           _sbu1C::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbu1C::I64;
           I64[Sp] = _sbu1B::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubv2N; else goto cbuWb;
       ubv2N: // global
           call _cbuWa(R1) args: 0, res: 0, upd: 0;
       cbuWb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuWa() //  [R1]
         { info_tbl: [(cbuWa,
                       label: block_cbuWa_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuWa: // global
           if (R1 & 7 == 1) goto cbv1b; else goto cbv26;
       cbv1b: // global
           _sbu3B::P64 = P64[P64[Sp + 80] + 8];
           I64[Sp + 16] = block_cbuWf_info;
           R1 = _sbu3B::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubv2O; else goto cbuWg;
       ubv2O: // global
           call _cbuWf(R1) args: 0, res: 0, upd: 0;
       cbuWg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbv26: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubv2x; else goto cbv24;
       ubv2x: // global
           Sp = Sp + 24;
           call _sbu1D() args: 0, res: 0, upd: 0;
       cbv24: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 144;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbuWf() //  [R1]
         { info_tbl: [(cbuWf,
                       label: block_cbuWf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuWf: // global
           I64[Sp - 16] = block_cbuWk_info;
           _sbu3H::I64 = I64[R1 + 39];
           _sbu3I::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbu3I::I64;
           I64[Sp] = _sbu3H::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubv2Q; else goto cbuWl;
       ubv2Q: // global
           call _cbuWk(R1) args: 0, res: 0, upd: 0;
       cbuWl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuWk() //  [R1]
         { info_tbl: [(cbuWk,
                       label: block_cbuWk_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuWk: // global
           if (R1 & 7 == 1) goto cbv1T; else goto ubv2y;
       cbv1T: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubv2z; else goto cbv1f;
       ubv2z: // global
           Sp = Sp + 24;
           goto ubv2T;
       cbv1f: // global
           _sbu3N::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cbuWs_info;
           R1 = _sbu3N::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubv2R; else goto cbuWt;
       ubv2R: // global
           call _cbuWs(R1) args: 0, res: 0, upd: 0;
       cbuWt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubv2y: // global
           Sp = Sp + 24;
           goto ubv2T;
       ubv2T: // global
           call _sbu1D() args: 0, res: 0, upd: 0;
     }
 },
 _cbuWs() //  [R1]
         { info_tbl: [(cbuWs,
                       label: block_cbuWs_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuWs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbv1i; else goto cbv1h;
       cbv1i: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbv1h: // global
           _sbu1l::P64 = P64[Sp + 64];
           _sbu3P::P64 = P64[R1 + 7];
           _sbu3Q::P64 = P64[R1 + 15];
           _sbu3T::P64 = P64[_sbu1l::P64 + 8];
           I64[Hp - 16] = sat_sbu41_info;
           P64[Hp] = _sbu3T::P64;
           call MO_WriteBarrier();
           P64[_sbu1l::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu1l::P64);
           I64[Sp - 8] = block_cbuWR_info;
           R1 = _sbu3T::P64;
           P64[Sp] = _sbu3Q::P64;
           P64[Sp + 56] = _sbu3P::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubv2U; else goto cbuWS;
       ubv2U: // global
           call _cbuWR(R1) args: 0, res: 0, upd: 0;
       cbuWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuWR() //  [R1]
         { info_tbl: [(cbuWR,
                       label: block_cbuWR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuWR: // global
           _sbu4a::I64 = I64[R1 + 39];
           if (_sbu4a::I64 != 0) goto cbv1l; else goto cbv1Q;
       cbv1l: // global
           I64[Sp - 32] = block_cbuWY_info;
           _sbu45::P64 = P64[R1 + 7];
           _sbu46::P64 = P64[R1 + 15];
           _sbu44::I64 = I64[R1 + 23];
           R1 = P64[Sp + 96];
           P64[Sp - 24] = _sbu45::P64;
           P64[Sp - 16] = _sbu46::P64;
           I64[Sp - 8] = _sbu4a::I64;
           I64[Sp] = _sbu44::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubv2V; else goto cbuWZ;
       ubv2V: // global
           call _cbuWY(R1) args: 0, res: 0, upd: 0;
       cbuWZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbv1Q: // global
           _sbu1i::P64 = P64[Sp + 48];
           _sbu3Q::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbu1i::P64 + 8] = _sbu3Q::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu1i::P64);
           Sp = Sp + 16;
           call _sbu1D() args: 0, res: 0, upd: 0;
     }
 },
 _cbuWY() //  [R1]
         { info_tbl: [(cbuWY,
                       label: block_cbuWY_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuWY: // global
           if (R1 & 7 == 1) goto cbv1n; else goto cbv1F;
       cbv1n: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbv1q; else goto cbv1p;
       cbv1q: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbv1p: // global
           I64[Hp - 24] = sat_sbu4k_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 24];
           _sbu1i::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sbu1i::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu1i::P64);
           Sp = Sp + 48;
           call _sbu1D() args: 0, res: 0, upd: 0;
       cbv1F: // global
           I64[Sp] = block_cbv1t_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubv2X; else goto cbv1u;
       ubv2X: // global
           call _cbv1t(R1) args: 0, res: 0, upd: 0;
       cbv1u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv1t() //  [R1]
         { info_tbl: [(cbv1t,
                       label: block_cbv1t_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv1t: // global
           I64[Sp - 8] = block_cbv1y_info;
           R2 = P64[Sp + 96];
           _sbu4o::P64 = P64[R1 + 7];
           _sbu4p::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbu4p::P64;
           P64[Sp + 96] = _sbu4o::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv1y() //  [R1]
         { info_tbl: [(cbv1y,
                       label: block_cbv1y_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv1y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbv1J; else goto cbv1I;
       cbv1J: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbv1I: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbu3Q::P64 = P64[Sp + 48];
           I64[Sp + 48] = block_cbv1B_info;
           R5 = Hp - 47;
           R4 = _sbu3Q::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 104];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbv1B() //  [R1]
         { info_tbl: [(cbv1B,
                       label: block_cbv1B_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv1B: // global
           I64[Sp] = block_cbv1D_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubv3h; else goto cbv1L;
       ubv3h: // global
           call _cbv1D(R1) args: 0, res: 0, upd: 0;
       cbv1L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv1D() //  [R1]
         { info_tbl: [(cbv1D,
                       label: block_cbv1D_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv1D: // global
           _sbu1i::P64 = P64[Sp + 40];
           _sbu4B::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbu1i::P64 + 8] = _sbu4B::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu1i::P64);
           Sp = Sp + 8;
           call _sbu1D() args: 0, res: 0, upd: 0;
     }
 },
 _sbu1D() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbu1D: // global
           I64[Sp - 8] = block_cbuXx_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubv3j; else goto cbv09;
       ubv3j: // global
           call _cbuXx(R1) args: 0, res: 0, upd: 0;
       cbv09: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuXx() //  [R1]
         { info_tbl: [(cbuXx,
                       label: block_cbuXx_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuXx: // global
           if (R1 & 7 == 1) goto cbv0g; else goto cbv0F;
       cbv0g: // global
           I64[Sp] = block_cbv0d_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubv30; else goto cbv0h;
       ubv30: // global
           call _cbv0d(R1) args: 0, res: 0, upd: 0;
       cbv0h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbv0F: // global
           I64[Sp] = block_cbv0D_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubv31; else goto cbv0G;
       ubv31: // global
           call _cbv0D(R1) args: 0, res: 0, upd: 0;
       cbv0G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv0d() //  [R1]
         { info_tbl: [(cbv0d,
                       label: block_cbv0d_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv0d: // global
           if (R1 & 7 == 1) goto ubv2F; else goto cbv0x;
       ubv2F: // global
           Sp = Sp + 8;
           call _sbu1F() args: 0, res: 0, upd: 0;
       cbv0x: // global
           I64[Sp] = block_cbv0q_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubv3a; else goto cbv0r;
       ubv3a: // global
           call _cbv0q(R1) args: 0, res: 0, upd: 0;
       cbv0r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv0q() //  [R1]
         { info_tbl: [(cbv0q,
                       label: block_cbv0q_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv0q: // global
           I64[Sp] = block_cbv0v_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv0v() //  []
         { info_tbl: [(cbv0v,
                       label: block_cbv0v_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv0v: // global
           Sp = Sp + 8;
           call _sbu1F() args: 0, res: 0, upd: 0;
     }
 },
 _cbv0D() //  [R1]
         { info_tbl: [(cbv0D,
                       label: block_cbv0D_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv0D: // global
           I64[Sp] = block_cbv0K_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv0K() //  []
         { info_tbl: [(cbv0K,
                       label: block_cbv0K_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv0K: // global
           I64[Sp] = block_cbv0M_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubv3d; else goto cbv0P;
       ubv3d: // global
           call _cbv0M(R1) args: 0, res: 0, upd: 0;
       cbv0P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv0M() //  [R1]
         { info_tbl: [(cbv0M,
                       label: block_cbv0M_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv0M: // global
           if (R1 & 7 == 1) goto ubv2D; else goto cbv15;
       ubv2D: // global
           Sp = Sp + 8;
           call _sbu1F() args: 0, res: 0, upd: 0;
       cbv15: // global
           I64[Sp] = block_cbv0Y_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubv3e; else goto cbv0Z;
       ubv3e: // global
           call _cbv0Y(R1) args: 0, res: 0, upd: 0;
       cbv0Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv0Y() //  [R1]
         { info_tbl: [(cbv0Y,
                       label: block_cbv0Y_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv0Y: // global
           I64[Sp] = block_cbv13_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbv13() //  []
         { info_tbl: [(cbv13,
                       label: block_cbv13_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv13: // global
           Sp = Sp + 8;
           call _sbu1F() args: 0, res: 0, upd: 0;
     }
 },
 _sbu1F() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbu1F: // global
           I64[Sp - 8] = block_cbuXE_info;
           R1 = P64[Sp + 104];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubv3k; else goto cbuZN;
       ubv3k: // global
           call _cbuXE(R1) args: 0, res: 0, upd: 0;
       cbuZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuXE() //  [R1]
         { info_tbl: [(cbuXE,
                       label: block_cbuXE_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuXE: // global
           if (R1 & 7 == 1) goto cbuZU; else goto cbv08;
       cbuZU: // global
           I64[Sp] = block_cbuZR_info;
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           if (R1 & 7 != 0) goto ubv32; else goto cbuZV;
       ubv32: // global
           call _cbuZR(R1) args: 0, res: 0, upd: 0;
       cbuZV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbv08: // global
           P64[Sp + 112] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbu1H() args: 0, res: 0, upd: 0;
     }
 },
 _cbuZR() //  [R1]
         { info_tbl: [(cbuZR,
                       label: block_cbuZR_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuZR: // global
           I64[Sp] = block_cbuZZ_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuZZ() //  [R1]
         { info_tbl: [(cbuZZ,
                       label: block_cbuZZ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuZZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbv04; else goto cbv03;
       cbv04: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbv03: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 112] = Hp - 6;
           Sp = Sp + 8;
           call _sbu1H() args: 0, res: 0, upd: 0;
     }
 },
 _sbu1H() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbu1H: // global
           I64[Sp - 8] = block_cbuXJ_info;
           R1 = P64[Sp + 104];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubv3l; else goto cbuXL;
       ubv3l: // global
           call _cbuXJ(R1) args: 0, res: 0, upd: 0;
       cbuXL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuXJ() //  [R1]
         { info_tbl: [(cbuXJ,
                       label: block_cbuXJ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuXJ: // global
           if (R1 & 7 == 1) goto cbuXU; else goto cbuY5;
       cbuXU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuXX; else goto cbuXW;
       cbuXX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuXW: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbuXQ_info;
           R1 = Hp - 15;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbuY5: // global
           I64[Sp] = block_cbuY3_info;
           _sbu1K::P64 = R1;
           R1 = P64[R1 + 6];
           P64[Sp + 112] = _sbu1K::P64;
           if (R1 & 7 != 0) goto ubv34; else goto cbuY6;
       ubv34: // global
           call _cbuY3(R1) args: 0, res: 0, upd: 0;
       cbuY6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuXQ() //  [R1]
         { info_tbl: [(cbuXQ,
                       label: block_cbuXQ_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuXQ: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbuY0; else goto cbuXZ;
       cbuY0: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuXZ: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.Base.Nothing_closure+1;
           P64[Hp - 24] = GHC.Base.Nothing_closure+1;
           _sbu18::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbu18::P64;
           P64[Hp - 8] = _sbu18::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbuY3() //  [R1]
         { info_tbl: [(cbuY3,
                       label: block_cbuY3_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuY3: // global
           I64[Sp] = block_cbuYc_info;
           _sbu1W::P64 = P64[R1 + 15];
           _sbu1X::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp + 80] = _sbu1X::P64;
           P64[Sp + 88] = _sbu1W::P64;
           if (R1 & 7 != 0) goto ubv35; else goto cbuZo;
       ubv35: // global
           call _cbuYc(R1) args: 0, res: 0, upd: 0;
       cbuZo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuYc() //  [R1]
         { info_tbl: [(cbuYc,
                       label: block_cbuYc_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuYc: // global
           _sbu1W::P64 = P64[Sp + 88];
           _cbv2q::P64 = R1 & 7;
           if (_cbv2q::P64 != 3) goto ubv2u; else goto cbuZz;
       ubv2u: // global
           if (_cbv2q::P64 != 6) goto cbuZu; else goto cbuZI;
       cbuZu: // global
           P64[Sp + 88] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbu1Y() args: 0, res: 0, upd: 0;
       cbuZI: // global
           I64[Sp] = block_cbuZG_info;
           R1 = _sbu1W::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbuZz: // global
           I64[Sp] = block_cbuZx_info;
           R1 = _sbu1W::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuZG() //  [R1]
         { info_tbl: [(cbuZG,
                       label: block_cbuZG_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuZG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbuZM; else goto cbuZL;
       cbuZM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuZL: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 88] = Hp - 6;
           Sp = Sp + 8;
           call _sbu1Y() args: 0, res: 0, upd: 0;
     }
 },
 _cbuZx() //  [R1]
         { info_tbl: [(cbuZx,
                       label: block_cbuZx_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuZx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbuZD; else goto cbuZC;
       cbuZD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuZC: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 88] = Hp - 6;
           Sp = Sp + 8;
           call _sbu1Y() args: 0, res: 0, upd: 0;
     }
 },
 _sbu1Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbu1Y: // global
           I64[Sp - 8] = block_cbuYh_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubv3m; else goto cbuYj;
       ubv3m: // global
           call _cbuYh(R1) args: 0, res: 0, upd: 0;
       cbuYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuYh() //  [R1]
         { info_tbl: [(cbuYh,
                       label: block_cbuYh_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuYh: // global
           _sbu1X::P64 = P64[Sp + 80];
           _cbv2t::P64 = R1 & 7;
           if (_cbv2t::P64 < 5) goto ubv2v; else goto ubv2w;
       ubv2v: // global
           if (_cbv2t::P64 < 4) goto cbuYs; else goto cbuYJ;
       cbuYs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuYv; else goto cbuYu;
       cbuYv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuYu: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbuYo_info;
           _sbu21::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbu21::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbuYJ: // global
           I64[Sp] = block_cbuYB_info;
           R1 = _sbu1X::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ubv2w: // global
           if (_cbv2t::P64 < 6) goto cbuZ0; else goto cbuZh;
       cbuZ0: // global
           I64[Sp] = block_cbuYS_info;
           R1 = _sbu1X::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbuZh: // global
           I64[Sp] = block_cbuZ9_info;
           R1 = _sbu1X::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuYo() //  [R1]
         { info_tbl: [(cbuYo,
                       label: block_cbuYo_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuYo: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbuYy; else goto cbuYx;
       cbuYy: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuYx: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 80];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbu18::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbu18::P64;
           P64[Hp - 8] = _sbu18::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbuYB() //  [R1]
         { info_tbl: [(cbuYB,
                       label: block_cbuYB_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuYB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuYM; else goto cbuYL;
       cbuYM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuYL: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbuYE_info;
           _sbu2c::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbu2c::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuYE() //  [R1]
         { info_tbl: [(cbuYE,
                       label: block_cbuYE_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuYE: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbuYP; else goto cbuYO;
       cbuYP: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuYO: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbu18::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbu18::P64;
           P64[Hp - 8] = _sbu18::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbuYS() //  [R1]
         { info_tbl: [(cbuYS,
                       label: block_cbuYS_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuYS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuZ3; else goto cbuZ2;
       cbuZ3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuZ2: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbuYV_info;
           _sbu2o::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbu2o::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuYV() //  [R1]
         { info_tbl: [(cbuYV,
                       label: block_cbuYV_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuYV: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbuZ6; else goto cbuZ5;
       cbuZ6: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuZ5: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.AppendHandle_closure+5;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbu18::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbu18::P64;
           P64[Hp - 8] = _sbu18::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbuZ9() //  [R1]
         { info_tbl: [(cbuZ9,
                       label: block_cbuZ9_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuZ9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbuZk; else goto cbuZj;
       cbuZk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuZj: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = lvl11_rbnWT_closure;
           P64[Hp] = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbuZc_info;
           _sbu2A::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 80] = _sbu2A::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbuZc() //  [R1]
         { info_tbl: [(cbuZc,
                       label: block_cbuZc_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbuZc: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbuZn; else goto cbuZm;
       cbuZn: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbuZm: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 80];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 104];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 88];
           P64[Hp - 24] = P64[Sp + 112];
           _sbu18::P64 = P64[Sp + 120];
           P64[Hp - 16] = _sbu18::P64;
           P64[Hp - 8] = _sbu18::P64;
           P64[Hp] = P64[Sp + 96];
           R1 = Hp - 127;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetBinaryMode1_entry() //  [R2, R3]
         { info_tbl: [(cbv3n,
                       label: GHC.IO.Handle.hSetBinaryMode1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv3n: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbv3r; else goto cbv3q;
       cbv3r: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetBinaryMode1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbv3q: // global
           I64[Hp - 40] = lvl48_sbu18_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbu4H_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = R2;
           R2 = lvl9_rbnWR_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.320304412 UTC

[section ""data" . GHC.IO.Handle.hSetBinaryMode_closure" {
     GHC.IO.Handle.hSetBinaryMode_closure:
         const GHC.IO.Handle.hSetBinaryMode_info;
         const 0;
 },
 GHC.IO.Handle.hSetBinaryMode_entry() //  [R2, R3]
         { info_tbl: [(cbv9J,
                       label: GHC.IO.Handle.hSetBinaryMode_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv9J: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetBinaryMode1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.323646778 UTC

[section ""cstring" . GHC.IO.Handle.hIsSeekable4_bytes" {
     GHC.IO.Handle.hIsSeekable4_bytes:
         I8[] [104,73,115,83,101,101,107,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.325496092 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable3_closure" {
     GHC.IO.Handle.hIsSeekable3_closure:
         const GHC.IO.Handle.hIsSeekable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable3_entry() //  [R1]
         { info_tbl: [(cbv9X,
                       label: GHC.IO.Handle.hIsSeekable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbv9X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbv9Y; else goto cbv9Z;
       cbv9Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbv9Z: // global
           (_cbv9U::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbv9U::I64 == 0) goto cbv9W; else goto cbv9V;
       cbv9W: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbv9V: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbv9U::I64;
           R2 = GHC.IO.Handle.hIsSeekable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.330131063 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable2_closure" {
     GHC.IO.Handle.hIsSeekable2_closure:
         const GHC.IO.Handle.hIsSeekable2_info;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable2_entry() //  [R2]
         { info_tbl: [(cbvaf,
                       label: GHC.IO.Handle.hIsSeekable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvaf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbvag; else goto cbvah;
       cbvag: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsSeekable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvah: // global
           I64[Sp - 8] = block_cbvac_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvaS; else goto cbvad;
       ubvaS: // global
           call _cbvac(R1) args: 0, res: 0, upd: 0;
       cbvad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvac() //  [R1]
         { info_tbl: [(cbvac,
                       label: block_cbvac_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvac: // global
           I64[Sp - 24] = block_cbvak_info;
           _sbu4K::P64 = R1;
           _sbu4L::P64 = P64[R1 + 7];
           _sbu4O::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbu4L::P64;
           P64[Sp - 8] = _sbu4O::P64;
           P64[Sp] = _sbu4K::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubvaR; else goto cbvam;
       ubvaR: // global
           call _cbvak(R1) args: 0, res: 0, upd: 0;
       cbvam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvak() //  [R1]
         { info_tbl: [(cbvak,
                       label: block_cbvak_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvak: // global
           _cbvaO::P64 = R1 & 7;
           if (_cbvaO::P64 < 3) goto ubvaP; else goto ubvaQ;
       ubvaP: // global
           if (_cbvaO::P64 < 2) goto cbvaC; else goto cbvaG;
       cbvaC: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbvaG: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       ubvaQ: // global
           if (_cbvaO::P64 == 5) goto cbvaK; else goto cbvav;
       cbvaK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvaN; else goto cbvaM;
       cbvaN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvaM: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbvav: // global
           _sbu4O::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbvaq_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbu4O::P64;
           call GHC.IO.Device.isSeekable_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbvaq() //  [R1]
         { info_tbl: [(cbvaq,
                       label: block_cbvaq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvaq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvay; else goto cbvax;
       cbvay: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvax: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.342429561 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable1_closure" {
     GHC.IO.Handle.hIsSeekable1_closure:
         const GHC.IO.Handle.hIsSeekable1_info;
         const 0;
 },
 io_sbu5h_entry() //  [R1]
         { info_tbl: [(cbvbH,
                       label: io_sbu5h_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvbH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvbL; else goto cbvbM;
       cbvbL: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbvbM: // global
           I64[Sp - 16] = block_cbvbC_info;
           _sbu5d::P64 = P64[R1 + 15];
           R5 = _sbu5d::P64;
           R4 = GHC.IO.Handle.hIsSeekable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsSeekable3_closure;
           P64[Sp - 8] = _sbu5d::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvbC() //  [R1]
         { info_tbl: [(cbvbC,
                       label: block_cbvbC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvbC: // global
           I64[Sp] = block_cbvbE_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubvbR; else goto cbvbF;
       ubvbR: // global
           call _cbvbE(R1) args: 0, res: 0, upd: 0;
       cbvbF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvbE() //  [R1]
         { info_tbl: [(cbvbE,
                       label: block_cbvbE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvbE: // global
           I64[Sp] = block_cbvbK_info;
           R2 = P64[R1 + 7];
           _sbu5o::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbu5o::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvbK() //  []
         { info_tbl: [(cbvbK,
                       label: block_cbvbK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvbK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbu5x_entry() //  [R1]
         { info_tbl: [(cbvc6,
                       label: io_sbu5x_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvc6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvca; else goto cbvcb;
       cbvca: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbvcb: // global
           I64[Sp - 16] = block_cbvc1_info;
           _sbu5s::P64 = P64[R1 + 15];
           R5 = _sbu5s::P64;
           R4 = GHC.IO.Handle.hIsSeekable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsSeekable3_closure;
           P64[Sp - 8] = _sbu5s::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvc1() //  [R1]
         { info_tbl: [(cbvc1,
                       label: block_cbvc1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvc1: // global
           I64[Sp] = block_cbvc3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubvcg; else goto cbvc4;
       ubvcg: // global
           call _cbvc3(R1) args: 0, res: 0, upd: 0;
       cbvc4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvc3() //  [R1]
         { info_tbl: [(cbvc3,
                       label: block_cbvc3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvc3: // global
           I64[Sp] = block_cbvc9_info;
           R2 = P64[R1 + 7];
           _sbu5E::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbu5E::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvc9() //  []
         { info_tbl: [(cbvc9,
                       label: block_cbvc9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvc9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsSeekable1_entry() //  [R2]
         { info_tbl: [(cbvcl,
                       label: GHC.IO.Handle.hIsSeekable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvcl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbvcm; else goto cbvcn;
       cbvcm: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsSeekable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvcn: // global
           I64[Sp - 8] = block_cbvbq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvcE; else goto cbvbr;
       ubvcE: // global
           call _cbvbq(R1) args: 0, res: 0, upd: 0;
       cbvbr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvbq() //  [R1]
         { info_tbl: [(cbvbq,
                       label: block_cbvbq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvbq: // global
           if (R1 & 7 == 1) goto cbvci; else goto cbvcj;
       cbvci: // global
           I64[Sp - 16] = block_cbvbv_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbvcj: // global
           I64[Sp - 16] = block_cbvbU_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbvbv() //  [R1]
         { info_tbl: [(cbvbv,
                       label: block_cbvbv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvbv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvcr; else goto cbvcq;
       cbvcr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbvcq: // global
           I64[Hp - 16] = io_sbu5h_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbvbx::P64 = Hp - 15;
           if (R1 == 0) goto cbvcv; else goto cbvcu;
       cbvcv: // global
           R1 = _cbvbx::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbvcu: // global
           R1 = _cbvbx::P64;
           Sp = Sp + 24;
           call io_sbu5h_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvbU() //  [R1]
         { info_tbl: [(cbvbU,
                       label: block_cbvbU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvbU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvcz; else goto cbvcy;
       cbvcz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbvcy: // global
           I64[Hp - 16] = io_sbu5x_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbvbW::P64 = Hp - 15;
           if (R1 == 0) goto cbvcD; else goto cbvcC;
       cbvcD: // global
           R1 = _cbvbW::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbvcC: // global
           R1 = _cbvbW::P64;
           Sp = Sp + 24;
           call io_sbu5x_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.365935217 UTC

[section ""data" . GHC.IO.Handle.hIsSeekable_closure" {
     GHC.IO.Handle.hIsSeekable_closure:
         const GHC.IO.Handle.hIsSeekable_info;
         const 0;
 },
 GHC.IO.Handle.hIsSeekable_entry() //  [R2]
         { info_tbl: [(cbvdL,
                       label: GHC.IO.Handle.hIsSeekable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvdL: // global
           R2 = R2;
           call GHC.IO.Handle.hIsSeekable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.369621491 UTC

[section ""cstring" . GHC.IO.Handle.hGetPosn4_bytes" {
     GHC.IO.Handle.hGetPosn4_bytes:
         I8[] [104,71,101,116,80,111,115,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.371627433 UTC

[section ""data" . GHC.IO.Handle.hGetPosn3_closure" {
     GHC.IO.Handle.hGetPosn3_closure:
         const GHC.IO.Handle.hGetPosn3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetPosn3_entry() //  [R1]
         { info_tbl: [(cbvdZ,
                       label: GHC.IO.Handle.hGetPosn3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvdZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbve0; else goto cbve1;
       cbve0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbve1: // global
           (_cbvdW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbvdW::I64 == 0) goto cbvdY; else goto cbvdX;
       cbvdY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbvdX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvdW::I64;
           R2 = GHC.IO.Handle.hGetPosn4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.379764603 UTC

[section ""data" . GHC.IO.Handle.hGetPosn2_closure" {
     GHC.IO.Handle.hGetPosn2_closure:
         const GHC.IO.Handle.hGetPosn2_info;
         const 0;
 },
 sat_sbu6x_entry() //  [R1]
         { info_tbl: [(cbveC,
                       label: sat_sbu6x_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbveC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbveD; else goto cbveE;
       cbveD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbveE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbvez_info;
           _sbu62::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbu62::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubvfc; else goto cbveA;
       ubvfc: // global
           call _cbvez(R1) args: 0, res: 0, upd: 0;
       cbveA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbvez() //  [R1]
         { info_tbl: [(cbvez,
                       label: block_cbvez_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvez: // global
           I64[Sp - 16] = block_cbveH_info;
           _sbu6q::I64 = I64[R1 + 39];
           _sbu6r::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbu6r::I64;
           I64[Sp] = _sbu6q::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubvfb; else goto cbveJ;
       ubvfb: // global
           call _cbveH(R1) args: 0, res: 0, upd: 0;
       cbveJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbveH() //  [R1]
         { info_tbl: [(cbveH,
                       label: block_cbveH_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbveH: // global
           _sbu6q::I64 = I64[Sp + 16];
           _sbu6r::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cbveT; else goto cbvf5;
       cbveT: // global
           I64[Sp + 16] = block_cbveQ_info;
           R2 = _sbu6r::I64 - _sbu6q::I64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
       cbvf5: // global
           I64[Sp + 16] = block_cbvf3_info;
           R2 = _sbu6r::I64 - _sbu6q::I64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbveQ() //  [R1]
         { info_tbl: [(cbveQ,
                       label: block_cbveQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbveQ: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 _cbvf3() //  [R1]
         { info_tbl: [(cbvf3,
                       label: block_cbvf3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvf3: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbu71_entry() //  [R1]
         { info_tbl: [(cbvfH,
                       label: sat_sbu71_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvfH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbvfL; else goto cbvfM;
       cbvfL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvfM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbvfE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubvfQ; else goto cbvfF;
       ubvfQ: // global
           call _cbvfE(R1) args: 0, res: 0, upd: 0;
       cbvfF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbvfE() //  [R1]
         { info_tbl: [(cbvfE,
                       label: block_cbvfE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvfE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvfP; else goto cbvfO;
       cbvfP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbvfO: // global
           _sbu6W::P64 = P64[R1 + 7];
           _sbu6X::P64 = P64[R1 + 15];
           _sbu6V::I64 = I64[R1 + 23];
           _sbu6Y::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbu6W::P64;
           P64[Hp - 32] = _sbu6X::P64;
           I64[Hp - 24] = _sbu6V::I64;
           I64[Hp - 16] = _sbu6Y::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbu7k_entry() //  [R1]
         { info_tbl: [(cbvgd,
                       label: sat_sbu7k_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvgd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbvgk; else goto cbvgl;
       cbvgk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvgl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbvga_info;
           _sbu7a::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbu7a::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubvgp; else goto cbvgb;
       ubvgp: // global
           call _cbvga(R1) args: 0, res: 0, upd: 0;
       cbvgb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbvga() //  [R1]
         { info_tbl: [(cbvga,
                       label: block_cbvga_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvga: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvgo; else goto cbvgn;
       cbvgo: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbvgn: // global
           _sbu7e::P64 = P64[R1 + 7];
           _sbu7f::P64 = P64[R1 + 15];
           _sbu7d::I64 = I64[R1 + 23];
           _sbu7g::I64 = I64[R1 + 31];
           _sbu7i::I64 = I64[R1 + 47];
           _sbu7j::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbu7e::P64;
           P64[Hp - 32] = _sbu7f::P64;
           I64[Hp - 24] = _sbu7d::I64;
           I64[Hp - 16] = _sbu7g::I64;
           I64[Hp - 8] = _sbu7j::I64;
           I64[Hp] = _sbu7i::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.hGetPosn2_entry() //  [R2]
         { info_tbl: [(cbvgq,
                       label: GHC.IO.Handle.hGetPosn2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvgq: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cbvgr; else goto cbvgs;
       cbvgr: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetPosn2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvgs: // global
           I64[Sp - 8] = block_cbvee_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvi2; else goto cbvef;
       ubvi2: // global
           call _cbvee(R1) args: 0, res: 0, upd: 0;
       cbvef: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvee() //  [R1]
         { info_tbl: [(cbvee,
                       label: block_cbvee_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvee: // global
           I64[Sp - 32] = block_cbvej_info;
           R2 = P64[R1 + 7];
           I64[Sp - 48] = stg_ap_pv_info;
           P64[Sp - 40] = P64[R1 + 31];
           P64[Sp - 24] = P64[R1 + 63];
           P64[Sp - 16] = P64[R1 + 71];
           P64[Sp - 8] = P64[R1 + 95];
           P64[Sp] = P64[R1 + 47];
           Sp = Sp - 48;
           call GHC.IO.Device.tell_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbvej() //  [R1]
         { info_tbl: [(cbvej,
                       label: block_cbvej_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvej: // global
           _sbu65::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp - 8] = block_cbvel_info;
           _sbu62::P64 = R1;
           R1 = _sbu65::P64;
           P64[Sp] = _sbu62::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvhP; else goto cbvem;
       ubvhP: // global
           call _cbvel(R1) args: 0, res: 0, upd: 0;
       cbvem: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvel() //  [R1]
         { info_tbl: [(cbvel,
                       label: block_cbvel_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvel: // global
           I64[Sp - 16] = block_cbvfd_info;
           _sbu6b::I64 = I64[R1 + 39];
           _sbu6c::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbu6c::I64;
           I64[Sp] = _sbu6b::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubvhQ; else goto cbvfe;
       ubvhQ: // global
           call _cbvfd(R1) args: 0, res: 0, upd: 0;
       cbvfe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvfd() //  [R1]
         { info_tbl: [(cbvfd,
                       label: block_cbvfd_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvfd: // global
           if (R1 & 7 == 1) goto cbvgB; else goto cbvhw;
       cbvgB: // global
           _sbu6B::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp + 16] = block_cbvfi_info;
           R1 = _sbu6B::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubvhR; else goto cbvfj;
       ubvhR: // global
           call _cbvfi(R1) args: 0, res: 0, upd: 0;
       cbvfj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvhw: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubvhK; else goto cbvhu;
       ubvhK: // global
           Sp = Sp + 16;
           call _cbvet() args: 0, res: 0, upd: 0;
       cbvhu: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvfi() //  [R1]
         { info_tbl: [(cbvfi,
                       label: block_cbvfi_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvfi: // global
           I64[Sp - 16] = block_cbvfn_info;
           _sbu6H::I64 = I64[R1 + 39];
           _sbu6I::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbu6I::I64;
           I64[Sp] = _sbu6H::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubvhT; else goto cbvfo;
       ubvhT: // global
           call _cbvfn(R1) args: 0, res: 0, upd: 0;
       cbvfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvfn() //  [R1]
         { info_tbl: [(cbvfn,
                       label: block_cbvfn_info
                       rep:StackRep [True, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvfn: // global
           if (R1 & 7 == 1) goto cbvhj; else goto ubvhL;
       cbvhj: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubvhM; else goto cbvgF;
       ubvhM: // global
           Sp = Sp + 16;
           goto ubvhW;
       cbvgF: // global
           _sbu6N::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp + 16] = block_cbvfv_info;
           R1 = _sbu6N::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubvhU; else goto cbvfw;
       ubvhU: // global
           call _cbvfv(R1) args: 0, res: 0, upd: 0;
       cbvfw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubvhL: // global
           Sp = Sp + 16;
           goto ubvhW;
       ubvhW: // global
           call _cbvet() args: 0, res: 0, upd: 0;
     }
 },
 _cbvfv() //  [R1]
         { info_tbl: [(cbvfv,
                       label: block_cbvfv_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvfv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvgI; else goto cbvgH;
       cbvgI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvgH: // global
           _sbu5S::P64 = P64[Sp + 24];
           _sbu6P::P64 = P64[R1 + 7];
           _sbu6Q::P64 = P64[R1 + 15];
           _sbu6T::P64 = P64[_sbu5S::P64 + 8];
           I64[Hp - 16] = sat_sbu71_info;
           P64[Hp] = _sbu6T::P64;
           call MO_WriteBarrier();
           P64[_sbu5S::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu5S::P64);
           I64[Sp - 8] = block_cbvfU_info;
           R1 = _sbu6T::P64;
           P64[Sp] = _sbu6Q::P64;
           P64[Sp + 16] = _sbu6P::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvhX; else goto cbvfV;
       ubvhX: // global
           call _cbvfU(R1) args: 0, res: 0, upd: 0;
       cbvfV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvfU() //  [R1]
         { info_tbl: [(cbvfU,
                       label: block_cbvfU_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvfU: // global
           _sbu7a::I64 = I64[R1 + 39];
           if (_sbu7a::I64 != 0) goto cbvgL; else goto cbvhg;
       cbvgL: // global
           I64[Sp - 24] = block_cbvg1_info;
           _sbu75::P64 = P64[R1 + 7];
           _sbu76::P64 = P64[R1 + 15];
           _sbu74::I64 = I64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _sbu76::P64;
           I64[Sp - 8] = _sbu7a::I64;
           P64[Sp] = _sbu75::P64;
           I64[Sp + 40] = _sbu74::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubvhY; else goto cbvg2;
       ubvhY: // global
           call _cbvg1(R1) args: 0, res: 0, upd: 0;
       cbvg2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvhg: // global
           _sbu5P::P64 = P64[Sp + 48];
           _sbu6Q::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbu5P::P64 + 8] = _sbu6Q::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu5P::P64);
           Sp = Sp + 8;
           call _cbvet() args: 0, res: 0, upd: 0;
     }
 },
 _cbvg1() //  [R1]
         { info_tbl: [(cbvg1,
                       label: block_cbvg1_info
                       rep:StackRep [False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvg1: // global
           if (R1 & 7 == 1) goto cbvgN; else goto cbvh5;
       cbvgN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbvgQ; else goto cbvgP;
       cbvgQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvgP: // global
           I64[Hp - 24] = sat_sbu7k_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = I64[Sp + 16];
           _sbu5P::P64 = P64[Sp + 72];
           call MO_WriteBarrier();
           P64[_sbu5P::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu5P::P64);
           Sp = Sp + 32;
           call _cbvet() args: 0, res: 0, upd: 0;
       cbvh5: // global
           I64[Sp] = block_cbvgT_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubvi0; else goto cbvgU;
       ubvi0: // global
           call _cbvgT(R1) args: 0, res: 0, upd: 0;
       cbvgU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvgT() //  [R1]
         { info_tbl: [(cbvgT,
                       label: block_cbvgT_info
                       rep:StackRep [False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvgT: // global
           I64[Sp - 8] = block_cbvgY_info;
           R2 = P64[Sp + 48];
           _sbu7o::P64 = P64[R1 + 7];
           _sbu7p::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbu7p::P64;
           P64[Sp + 48] = _sbu7o::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvgY() //  [R1]
         { info_tbl: [(cbvgY,
                       label: block_cbvgY_info
                       rep:StackRep [False, False, True, False, False, False, False,
                                     False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvgY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvh9; else goto cbvh8;
       cbvh9: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvh8: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 72];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbu6Q::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbvh1_info;
           R5 = Hp - 47;
           R4 = _sbu6Q::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 56];
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvh1() //  [R1]
         { info_tbl: [(cbvh1,
                       label: block_cbvh1_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvh1: // global
           I64[Sp] = block_cbvh3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubvi3; else goto cbvhb;
       ubvi3: // global
           call _cbvh3(R1) args: 0, res: 0, upd: 0;
       cbvhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvh3() //  [R1]
         { info_tbl: [(cbvh3,
                       label: block_cbvh3_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvh3: // global
           _sbu5P::P64 = P64[Sp + 40];
           _sbu7B::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbu5P::P64 + 8] = _sbu7B::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu5P::P64);
           call _cbvet() args: 0, res: 0, upd: 0;
     }
 },
 _cbvet() //  []
         { info_tbl: [(cbvet,
                       label: block_cbvet_info
                       rep:StackRep [False, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvet: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbvgy; else goto cbvgx;
       cbvgy: // global
           HpAlloc = 32;
           I64[Sp] = block_cbvet_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cbvgx: // global
           I64[Hp - 24] = sat_sbu6x_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[P64[Sp + 40] + 8];
           R1 = Hp - 24;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.440129841 UTC

[section ""data" . GHC.IO.Handle.hTell1_closure" {
     GHC.IO.Handle.hTell1_closure:
         const GHC.IO.Handle.hTell1_info;
         const 0;
 },
 GHC.IO.Handle.hTell1_entry() //  [R2]
         { info_tbl: [(cbvkJ,
                       label: GHC.IO.Handle.hTell1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvkJ: // global
           R4 = GHC.IO.Handle.hGetPosn2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hGetPosn3_closure;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.44404152 UTC

[section ""data" . GHC.IO.Handle.hTell_closure" {
     GHC.IO.Handle.hTell_closure:
         const GHC.IO.Handle.hTell_info;
         const 0;
 },
 GHC.IO.Handle.hTell_entry() //  [R2]
         { info_tbl: [(cbvkU,
                       label: GHC.IO.Handle.hTell_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvkU: // global
           R2 = R2;
           call GHC.IO.Handle.hTell1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.447195608 UTC

[section ""cstring" . lvl12_rbnWU_bytes" {
     lvl12_rbnWU_bytes:
         I8[] [104,83,101,101,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.448983748 UTC

[section ""data" . lvl13_rbnWV_closure" {
     lvl13_rbnWV_closure:
         const lvl13_rbnWV_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_rbnWV_entry() //  [R1]
         { info_tbl: [(cbvl8,
                       label: lvl13_rbnWV_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvl8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvl9; else goto cbvla;
       cbvl9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvla: // global
           (_cbvl5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbvl5::I64 == 0) goto cbvl7; else goto cbvl6;
       cbvl7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbvl6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvl5::I64;
           R2 = lvl12_rbnWU_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.453016487 UTC

[section ""data" . lvl14_rbnWW_closure" {
     lvl14_rbnWW_closure:
         const lvl14_rbnWW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_rbnWW_entry() //  [R1]
         { info_tbl: [(cbvlp,
                       label: lvl14_rbnWW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvlp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvlq; else goto cbvlr;
       cbvlq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvlr: // global
           (_cbvlm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbvlm::I64 == 0) goto cbvlo; else goto cbvln;
       cbvlo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbvln: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvlm::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.462631373 UTC

[section ""data" . GHC.IO.Handle.hSeek1_closure" {
     GHC.IO.Handle.hSeek1_closure:
         const GHC.IO.Handle.hSeek1_info;
         const 0;
 },
 lvl48_sbu7M_entry() //  [R1]
         { info_tbl: [(cbvlM,
                       label: lvl48_sbu7M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvlM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbvlQ; else goto cbvlR;
       cbvlQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvlR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbvlK_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbvlK() //  [R1]
         { info_tbl: [(cbvlK,
                       label: block_cbvlK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvlK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbvlU; else goto cbvlT;
       cbvlU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cbvlT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl49_sbu7O_entry() //  [R1]
         { info_tbl: [(cbvm1,
                       label: lvl49_sbu7O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvm1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbvm5; else goto cbvm6;
       cbvm5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvm6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbvlZ_info;
           R3 = lvl14_rbnWW_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbvlZ() //  [R1]
         { info_tbl: [(cbvlZ,
                       label: block_cbvlZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvlZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbvm9; else goto cbvm8;
       cbvm9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cbvm8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbu8N_entry() //  [R1]
         { info_tbl: [(cbvmY,
                       label: sat_sbu8N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvmY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbvn2; else goto cbvn3;
       cbvn2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvn3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbvmV_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubvn7; else goto cbvmW;
       ubvn7: // global
           call _cbvmV(R1) args: 0, res: 0, upd: 0;
       cbvmW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbvmV() //  [R1]
         { info_tbl: [(cbvmV,
                       label: block_cbvmV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvmV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvn6; else goto cbvn5;
       cbvn6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbvn5: // global
           _sbu8I::P64 = P64[R1 + 7];
           _sbu8J::P64 = P64[R1 + 15];
           _sbu8H::I64 = I64[R1 + 23];
           _sbu8K::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbu8I::P64;
           P64[Hp - 32] = _sbu8J::P64;
           I64[Hp - 24] = _sbu8H::I64;
           I64[Hp - 16] = _sbu8K::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbu96_entry() //  [R1]
         { info_tbl: [(cbvnu,
                       label: sat_sbu96_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvnu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbvnB; else goto cbvnC;
       cbvnB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvnC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbvnr_info;
           _sbu8W::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbu8W::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubvnG; else goto cbvns;
       ubvnG: // global
           call _cbvnr(R1) args: 0, res: 0, upd: 0;
       cbvns: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbvnr() //  [R1]
         { info_tbl: [(cbvnr,
                       label: block_cbvnr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvnr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvnF; else goto cbvnE;
       cbvnF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbvnE: // global
           _sbu90::P64 = P64[R1 + 7];
           _sbu91::P64 = P64[R1 + 15];
           _sbu8Z::I64 = I64[R1 + 23];
           _sbu92::I64 = I64[R1 + 31];
           _sbu94::I64 = I64[R1 + 47];
           _sbu95::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbu90::P64;
           P64[Hp - 32] = _sbu91::P64;
           I64[Hp - 24] = _sbu8Z::I64;
           I64[Hp - 16] = _sbu92::I64;
           I64[Hp - 8] = _sbu95::I64;
           I64[Hp] = _sbu94::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbu9R_entry() //  [R1]
         { info_tbl: [(cbvoj,
                       label: sat_sbu9R_info
                       rep:HeapRep 2 ptrs 4 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvoj: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbvoq; else goto cbvor;
       cbvoq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvor: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_cbvog_info;
           _sbu8e::P64 = P64[R1 + 24];
           _sbu8d::I64 = I64[R1 + 32];
           _sbu8g::I64 = I64[R1 + 40];
           _sbu8h::I64 = I64[R1 + 48];
           _sbu8i::I64 = I64[R1 + 56];
           R1 = P64[R1 + 16];
           I64[Sp - 56] = _sbu8d::I64;
           P64[Sp - 48] = _sbu8e::P64;
           I64[Sp - 40] = _sbu8g::I64;
           I64[Sp - 32] = _sbu8h::I64;
           I64[Sp - 24] = _sbu8i::I64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubvov; else goto cbvoh;
       ubvov: // global
           call _cbvog(R1) args: 0, res: 0, upd: 0;
       cbvoh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbvog() //  [R1]
         { info_tbl: [(cbvog,
                       label: block_cbvog_info
                       rep:StackRep [True, False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvog: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvou; else goto cbvot;
       cbvou: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbvot: // global
           _sbu9Q::I64 = I64[Sp + 32] + I64[R1 + 7];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = _sbu9Q::I64;
           I64[Hp] = I64[Sp + 40];
           R1 = Hp - 47;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbuak_entry() //  [R1, R2]
         { info_tbl: [(cbvow,
                       label: sat_sbuak_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvow: // global
           if ((Sp + -144) < SpLim) (likely: False) goto cbvox; else goto cbvoy;
       cbvox: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvoy: // global
           I64[Sp - 40] = block_cbvmf_info;
           _sbu7J::P64 = P64[R1 + 6];
           _sbu7K::P64 = P64[R1 + 14];
           _sbu7M::P64 = P64[R1 + 22];
           _sbu7O::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 32] = _sbu7J::P64;
           P64[Sp - 24] = _sbu7K::P64;
           P64[Sp - 16] = _sbu7M::P64;
           P64[Sp - 8] = _sbu7O::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubvrp; else goto cbvmg;
       ubvrp: // global
           call _cbvmf(R1) args: 0, res: 0, upd: 0;
       cbvmg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvmf() //  [R1]
         { info_tbl: [(cbvmf,
                       label: block_cbvmf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvmf: // global
           I64[Sp - 64] = block_cbvmk_info;
           _sbu7S::P64 = R1;
           _sbu7T::P64 = P64[R1 + 7];
           _sbu7U::P64 = P64[R1 + 15];
           _sbu7W::P64 = P64[R1 + 31];
           _sbu7Y::P64 = P64[R1 + 47];
           _sbu80::P64 = P64[R1 + 63];
           _sbu81::P64 = P64[R1 + 71];
           _sbu84::P64 = P64[R1 + 95];
           R1 = P64[_sbu81::P64 + 8];
           P64[Sp - 56] = _sbu7T::P64;
           P64[Sp - 48] = _sbu7U::P64;
           P64[Sp - 40] = _sbu7W::P64;
           P64[Sp - 32] = _sbu7Y::P64;
           P64[Sp - 24] = _sbu80::P64;
           P64[Sp - 16] = _sbu81::P64;
           P64[Sp - 8] = _sbu84::P64;
           P64[Sp] = _sbu7S::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ubvra; else goto cbvml;
       ubvra: // global
           call _cbvmk(R1) args: 0, res: 0, upd: 0;
       cbvml: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvmk() //  [R1]
         { info_tbl: [(cbvmk,
                       label: block_cbvmk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvmk: // global
           I64[Sp - 40] = block_cbvmp_info;
           _sbu8e::P64 = P64[R1 + 7];
           _sbu8d::I64 = I64[R1 + 23];
           _sbu8g::I64 = I64[R1 + 31];
           _sbu8h::I64 = I64[R1 + 39];
           _sbu8i::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _sbu8e::P64;
           I64[Sp - 24] = _sbu8g::I64;
           I64[Sp - 16] = _sbu8h::I64;
           I64[Sp - 8] = _sbu8i::I64;
           I64[Sp] = _sbu8d::I64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubvrb; else goto cbvmq;
       ubvrb: // global
           call _cbvmp(R1) args: 0, res: 0, upd: 0;
       cbvmq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvmp() //  [R1]
         { info_tbl: [(cbvmp,
                       label: block_cbvmp_info
                       rep:StackRep [False, True, True, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvmp: // global
           if (R1 & 7 == 1) goto cbvpQ; else goto cbvql;
       cbvpQ: // global
           I64[Sp] = block_cbvnH_info;
           R1 = P64[Sp + 112];
           if (R1 & 7 != 0) goto ubvrc; else goto cbvnI;
       ubvrc: // global
           call _cbvnH(R1) args: 0, res: 0, upd: 0;
       cbvnI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvql: // global
           _sbu9W::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 40] = block_cbvqj_info;
           R1 = _sbu9W::P64;
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ubvrd; else goto cbvqm;
       ubvrd: // global
           call _cbvqj(R1) args: 0, res: 0, upd: 0;
       cbvqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvnH() //  [R1]
         { info_tbl: [(cbvnH,
                       label: block_cbvnH_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvnH: // global
           if (R1 & 7 == 2) goto cbvpW; else goto ubvr6;
       cbvpW: // global
           I64[Sp] = block_cbvnN_info;
           R1 = P64[Sp + 96];
           if (R1 & 7 != 0) goto ubvrj; else goto cbvnO;
       ubvrj: // global
           call _cbvnN(R1) args: 0, res: 0, upd: 0;
       cbvnO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubvr6: // global
           Sp = Sp + 48;
           call _sbu8k() args: 0, res: 0, upd: 0;
     }
 },
 _cbvnN() //  [R1]
         { info_tbl: [(cbvnN,
                       label: block_cbvnN_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvnN: // global
           if (R1 & 7 == 1) goto cbvpZ; else goto ubvr7;
       cbvpZ: // global
           I64[Sp] = block_cbvnS_info;
           R1 = P64[Sp + 136];
           if (R1 & 7 != 0) goto ubvrl; else goto cbvnT;
       ubvrl: // global
           call _cbvnS(R1) args: 0, res: 0, upd: 0;
       cbvnT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubvr7: // global
           Sp = Sp + 48;
           call _sbu8k() args: 0, res: 0, upd: 0;
     }
 },
 _cbvnS() //  [R1]
         { info_tbl: [(cbvnS,
                       label: block_cbvnS_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvnS: // global
           if (I64[R1 + 7] == 1) goto cbvq3; else goto ubvr8;
       cbvq3: // global
           _sbu9L::I64 = I64[Sp + 32] - I64[Sp + 24];
           I64[Sp] = block_cbvo3_info;
           R2 = _sbu9L::I64;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       ubvr8: // global
           Sp = Sp + 48;
           call _sbu8k() args: 0, res: 0, upd: 0;
     }
 },
 _cbvo3() //  [R1]
         { info_tbl: [(cbvo3,
                       label: block_cbvo3_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvo3: // global
           I64[Sp] = block_cbvo7_info;
           R3 = R1;
           R2 = P64[Sp + 120];
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvo7() //  [R1]
         { info_tbl: [(cbvo7,
                       label: block_cbvo7_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False, False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvo7: // global
           if (R1 == 1) goto cbvq9; else goto ubvr9;
       cbvq9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbvqc; else goto cbvqb;
       cbvqc: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbvqb: // global
           I64[Hp - 56] = sat_sbu9R_info;
           P64[Hp - 40] = P64[Sp + 128];
           P64[Hp - 32] = P64[Sp + 8];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = I64[Sp + 24];
           I64[Hp] = I64[Sp + 32];
           _sbu81::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sbu81::P64 + 8] = Hp - 56;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu81::P64);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ubvr9: // global
           Sp = Sp + 48;
           call _sbu8k() args: 0, res: 0, upd: 0;
     }
 },
 _sbu8k() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbu8k: // global
           _sbu8n::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp - 8] = block_cbvmz_info;
           R1 = _sbu8n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvrv; else goto cbvmA;
       ubvrv: // global
           call _cbvmz(R1) args: 0, res: 0, upd: 0;
       cbvmA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvmz() //  [R1]
         { info_tbl: [(cbvmz,
                       label: block_cbvmz_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvmz: // global
           I64[Sp] = block_cbvmE_info;
           _sbu8t::I64 = I64[R1 + 39];
           _sbu8u::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp + 88] = _sbu8u::I64;
           I64[Sp + 96] = _sbu8t::I64;
           if (R1 & 7 != 0) goto ubvre; else goto cbvmF;
       ubvre: // global
           call _cbvmE(R1) args: 0, res: 0, upd: 0;
       cbvmF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvmE() //  [R1]
         { info_tbl: [(cbvmE,
                       label: block_cbvmE_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvmE: // global
           _sbu7S::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto cbvpH; else goto cbvpM;
       cbvpH: // global
           if (I64[Sp + 96] == I64[Sp + 88]) goto cbvpD; else goto cbvoG;
       cbvpD: // global
           I64[Sp] = block_cbvpC_info;
           R2 = _sbu7S::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
       cbvoG: // global
           _sbu8z::P64 = P64[P64[Sp + 40] + 8];
           I64[Sp] = block_cbvmM_info;
           R1 = _sbu8z::P64;
           if (R1 & 7 != 0) goto ubvrf; else goto cbvmN;
       ubvrf: // global
           call _cbvmM(R1) args: 0, res: 0, upd: 0;
       cbvmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvpM: // global
           I64[Sp] = block_cbvpK_info;
           R2 = _sbu7S::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvpC() //  []
         { info_tbl: [(cbvpC,
                       label: block_cbvpC_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvpC: // global
           R2 = P64[Sp + 8];
           _sbu7J::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbu7K::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbu7J::P64;
           P64[Sp + 96] = _sbu7K::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbvmM() //  [R1]
         { info_tbl: [(cbvmM,
                       label: block_cbvmM_info
                       rep:StackRep [False, True, False, False, True, False, False, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvmM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvoJ; else goto cbvoI;
       cbvoJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvoI: // global
           _sbu81::P64 = P64[Sp + 48];
           _sbu8B::P64 = P64[R1 + 7];
           _sbu8C::P64 = P64[R1 + 15];
           _sbu8F::P64 = P64[_sbu81::P64 + 8];
           I64[Hp - 16] = sat_sbu8N_info;
           P64[Hp] = _sbu8F::P64;
           call MO_WriteBarrier();
           P64[_sbu81::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu81::P64);
           I64[Sp] = block_cbvnb_info;
           R1 = _sbu8F::P64;
           P64[Sp + 88] = _sbu8C::P64;
           P64[Sp + 96] = _sbu8B::P64;
           if (R1 & 7 != 0) goto ubvrg; else goto cbvnc;
       ubvrg: // global
           call _cbvnb(R1) args: 0, res: 0, upd: 0;
       cbvnc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvnb() //  [R1]
         { info_tbl: [(cbvnb,
                       label: block_cbvnb_info
                       rep:StackRep [False, True, False, False, True, True, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvnb: // global
           _sbu8W::I64 = I64[R1 + 39];
           if (_sbu8W::I64 != 0) goto cbvoM; else goto cbvpy;
       cbvoM: // global
           I64[Sp] = block_cbvni_info;
           _sbu8R::P64 = P64[R1 + 7];
           _sbu8S::P64 = P64[R1 + 15];
           _sbu8Q::I64 = I64[R1 + 23];
           R1 = P64[Sp + 56];
           I64[Sp + 16] = _sbu8W::I64;
           P64[Sp + 40] = _sbu8S::P64;
           P64[Sp + 48] = _sbu8R::P64;
           I64[Sp + 56] = _sbu8Q::I64;
           if (R1 & 7 != 0) goto ubvrh; else goto cbvnj;
       ubvrh: // global
           call _cbvni(R1) args: 0, res: 0, upd: 0;
       cbvnj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvpy: // global
           _sbu7S::P64 = P64[Sp + 64];
           _sbu7Y::P64 = P64[Sp + 32];
           _sbu8C::P64 = P64[Sp + 88];
           call MO_WriteBarrier();
           P64[_sbu7Y::P64 + 8] = _sbu8C::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu7Y::P64);
           I64[Sp] = block_cbvpx_info;
           R2 = _sbu7S::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvni() //  [R1]
         { info_tbl: [(cbvni,
                       label: block_cbvni_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvni: // global
           if (R1 & 7 == 1) goto cbvoS; else goto cbvpk;
       cbvoS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbvoV; else goto cbvoU;
       cbvoV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvoU: // global
           I64[Hp - 24] = sat_sbu96_info;
           P64[Hp - 8] = P64[Sp + 88];
           I64[Hp] = I64[Sp + 16];
           _sbu7S::P64 = P64[Sp + 64];
           _sbu7Y::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbu7Y::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu7Y::P64);
           I64[Sp] = block_cbvoQ_info;
           R2 = _sbu7S::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
       cbvpk: // global
           I64[Sp] = block_cbvp0_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubvri; else goto cbvp1;
       ubvri: // global
           call _cbvp0(R1) args: 0, res: 0, upd: 0;
       cbvp1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvoQ() //  []
         { info_tbl: [(cbvoQ,
                       label: block_cbvoQ_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvoQ: // global
           R2 = P64[Sp + 8];
           _sbu7J::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbu7K::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbu7J::P64;
           P64[Sp + 96] = _sbu7K::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbvp0() //  [R1]
         { info_tbl: [(cbvp0,
                       label: block_cbvp0_info
                       rep:StackRep [False, True, False, False, False, False, True, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvp0: // global
           I64[Sp - 8] = block_cbvp5_info;
           R2 = P64[Sp + 96];
           _sbu9d::P64 = P64[R1 + 7];
           _sbu9e::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbu9e::P64;
           P64[Sp + 96] = _sbu9d::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvp5() //  [R1]
         { info_tbl: [(cbvp5,
                       label: block_cbvp5_info
                       rep:StackRep [False, False, True, False, False, False, False, True,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvp5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvpo; else goto cbvpn;
       cbvpo: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvpn: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 48];
           I64[Hp - 24] = I64[Sp + 64];
           I64[Hp - 16] = I64[Sp + 24];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbu9e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbvp8_info;
           R5 = Hp - 47;
           R4 = P64[Sp + 96];
           R3 = _sbu9e::P64;
           R2 = P64[Sp + 104];
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvp8() //  [R1]
         { info_tbl: [(cbvp8,
                       label: block_cbvp8_info
                       rep:StackRep [False, True, False, False, True, True, True, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvp8: // global
           I64[Sp] = block_cbvpa_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubvrq; else goto cbvpb;
       ubvrq: // global
           call _cbvpa(R1) args: 0, res: 0, upd: 0;
       cbvpb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvpa() //  [R1]
         { info_tbl: [(cbvpa,
                       label: block_cbvpa_info
                       rep:StackRep [False, True, False, False, True, True, True, False,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvpa: // global
           _sbu7S::P64 = P64[Sp + 64];
           _sbu7Y::P64 = P64[Sp + 32];
           _sbu9q::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbu7Y::P64 + 8] = _sbu9q::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu7Y::P64);
           I64[Sp] = block_cbvpi_info;
           R2 = _sbu7S::P64;
           call GHC.IO.Handle.Internals.flushBuffer2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvpi() //  []
         { info_tbl: [(cbvpi,
                       label: block_cbvpi_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvpi: // global
           R2 = P64[Sp + 8];
           _sbu7J::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbu7K::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbu7J::P64;
           P64[Sp + 96] = _sbu7K::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbvpx() //  []
         { info_tbl: [(cbvpx,
                       label: block_cbvpx_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvpx: // global
           R2 = P64[Sp + 8];
           _sbu7J::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbu7K::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbu7J::P64;
           P64[Sp + 96] = _sbu7K::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbvpK() //  []
         { info_tbl: [(cbvpK,
                       label: block_cbvpK_info
                       rep:StackRep [False, True, False, True, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvpK: // global
           R2 = P64[Sp + 8];
           _sbu7J::P64 = P64[Sp + 72];
           I64[Sp + 72] = stg_ap_pppv_info;
           _sbu7K::P64 = P64[Sp + 80];
           P64[Sp + 80] = P64[Sp + 24];
           P64[Sp + 88] = _sbu7J::P64;
           P64[Sp + 96] = _sbu7K::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbvqj() //  [R1]
         { info_tbl: [(cbvqj,
                       label: block_cbvqj_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvqj: // global
           I64[Sp] = block_cbvqq_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubvrr; else goto cbvqs;
       ubvrr: // global
           call _cbvqq(R1) args: 0, res: 0, upd: 0;
       cbvqs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvqq() //  [R1]
         { info_tbl: [(cbvqq,
                       label: block_cbvqq_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvqq: // global
           if (R1 & 7 == 1) goto ubvr4; else goto cbvqD;
       ubvr4: // global
           Sp = Sp + 8;
           call _cbvqR() args: 0, res: 0, upd: 0;
       cbvqD: // global
           _sbua7::P64 = P64[P64[Sp + 32] + 8];
           I64[Sp] = block_cbvqB_info;
           R1 = _sbua7::P64;
           if (R1 & 7 != 0) goto ubvrs; else goto cbvqE;
       ubvrs: // global
           call _cbvqB(R1) args: 0, res: 0, upd: 0;
       cbvqE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvqB() //  [R1]
         { info_tbl: [(cbvqB,
                       label: block_cbvqB_info
                       rep:StackRep [False, False, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvqB: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubvr5; else goto cbvqO;
       ubvr5: // global
           Sp = Sp + 8;
           call _cbvqR() args: 0, res: 0, upd: 0;
       cbvqO: // global
           I64[Sp] = block_cbvqM_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = R1;
           Sp = Sp - 24;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbvqR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvqR: // global
           R2 = P64[Sp];
           _sbu7J::P64 = P64[Sp + 64];
           I64[Sp + 64] = stg_ap_pppv_info;
           _sbu7K::P64 = P64[Sp + 72];
           P64[Sp + 72] = P64[Sp + 16];
           P64[Sp + 80] = _sbu7J::P64;
           P64[Sp + 88] = _sbu7K::P64;
           Sp = Sp + 64;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _cbvqM() //  [R1]
         { info_tbl: [(cbvqM,
                       label: block_cbvqM_info
                       rep:StackRep [False, True, False, False, True, True, True, True,
                                     False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvqM: // global
           _sbu7J::P64 = P64[Sp + 72];
           _sbu7K::P64 = P64[Sp + 80];
           _sbu7T::P64 = P64[Sp + 8];
           _sbu7W::P64 = P64[Sp + 24];
           _sbu7Y::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_sbu7Y::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbu7Y::P64);
           R2 = _sbu7T::P64;
           I64[Sp + 72] = stg_ap_pppv_info;
           P64[Sp + 80] = _sbu7W::P64;
           P64[Sp + 88] = _sbu7J::P64;
           P64[Sp + 96] = _sbu7K::P64;
           Sp = Sp + 72;
           call GHC.IO.Device.seek_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSeek1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbvrw,
                       label: GHC.IO.Handle.hSeek1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvrw: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbvrA; else goto cbvrz;
       cbvrA: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSeek1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbvrz: // global
           I64[Hp - 80] = lvl48_sbu7M_info;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = lvl49_sbu7O_info;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = sat_sbuak_info;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 56;
           R4 = Hp - 30;
           R3 = R2;
           R2 = lvl13_rbnWV_closure;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.546707002 UTC

[section ""data" . GHC.IO.Handle.hSeek_closure" {
     GHC.IO.Handle.hSeek_closure:
         const GHC.IO.Handle.hSeek_info;
         const 0;
 },
 GHC.IO.Handle.hSeek_entry() //  [R2, R3, R4]
         { info_tbl: [(cbvvW,
                       label: GHC.IO.Handle.hSeek_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvvW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSeek1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.550380409 UTC

[section ""data" . GHC.IO.Handle.hSetPosn1_closure" {
     GHC.IO.Handle.hSetPosn1_closure:
         const GHC.IO.Handle.hSetPosn1_info;
         const 0;
 },
 GHC.IO.Handle.hSetPosn1_entry() //  [R2]
         { info_tbl: [(cbvwa,
                       label: GHC.IO.Handle.hSetPosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvwa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbvwb; else goto cbvwc;
       cbvwb: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hSetPosn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvwc: // global
           I64[Sp - 8] = block_cbvw7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvwg; else goto cbvw8;
       ubvwg: // global
           call _cbvw7(R1) args: 0, res: 0, upd: 0;
       cbvw8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvw7() //  [R1]
         { info_tbl: [(cbvw7,
                       label: block_cbvw7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvw7: // global
           R4 = P64[R1 + 15];
           R3 = GHC.IO.Device.AbsoluteSeek_closure+1;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.hSeek1_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.55589382 UTC

[section ""data" . GHC.IO.Handle.hSetPosn_closure" {
     GHC.IO.Handle.hSetPosn_closure:
         const GHC.IO.Handle.hSetPosn_info;
         const 0;
 },
 GHC.IO.Handle.hSetPosn_entry() //  [R2]
         { info_tbl: [(cbvww,
                       label: GHC.IO.Handle.hSetPosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvww: // global
           R2 = R2;
           call GHC.IO.Handle.hSetPosn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.559727856 UTC

[section ""cstring" . GHC.IO.Handle.hGetEncoding4_bytes" {
     GHC.IO.Handle.hGetEncoding4_bytes:
         I8[] [104,71,101,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.562079761 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding3_closure" {
     GHC.IO.Handle.hGetEncoding3_closure:
         const GHC.IO.Handle.hGetEncoding3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEncoding3_entry() //  [R1]
         { info_tbl: [(cbvwK,
                       label: GHC.IO.Handle.hGetEncoding3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvwK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvwL; else goto cbvwM;
       cbvwL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvwM: // global
           (_cbvwH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbvwH::I64 == 0) goto cbvwJ; else goto cbvwI;
       cbvwJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbvwI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvwH::I64;
           R2 = GHC.IO.Handle.hGetEncoding4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.566321564 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding2_closure" {
     GHC.IO.Handle.hGetEncoding2_closure:
         const GHC.IO.Handle.hGetEncoding2_info;
 },
 GHC.IO.Handle.hGetEncoding2_entry() //  [R2]
         { info_tbl: [(cbvx2,
                       label: GHC.IO.Handle.hGetEncoding2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvx2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbvx6; else goto cbvx7;
       cbvx6: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEncoding2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvx7: // global
           I64[Sp - 8] = block_cbvwZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvxb; else goto cbvx0;
       ubvxb: // global
           call _cbvwZ(R1) args: 0, res: 0, upd: 0;
       cbvx0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvwZ() //  [R1]
         { info_tbl: [(cbvwZ,
                       label: block_cbvwZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvwZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvxa; else goto cbvx9;
       cbvxa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvx9: // global
           _sbuaF::P64 = P64[R1 + 103];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sbuaF::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.572981913 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding1_closure" {
     GHC.IO.Handle.hGetEncoding1_closure:
         const GHC.IO.Handle.hGetEncoding1_info;
         const 0;
 },
 io_sbuaS_entry() //  [R1]
         { info_tbl: [(cbvxJ,
                       label: io_sbuaS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvxJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvxN; else goto cbvxO;
       cbvxN: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbvxO: // global
           I64[Sp - 16] = block_cbvxE_info;
           _sbuaO::P64 = P64[R1 + 15];
           R5 = _sbuaO::P64;
           R4 = GHC.IO.Handle.hGetEncoding2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEncoding3_closure;
           P64[Sp - 8] = _sbuaO::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvxE() //  [R1]
         { info_tbl: [(cbvxE,
                       label: block_cbvxE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvxE: // global
           I64[Sp] = block_cbvxG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubvxT; else goto cbvxH;
       ubvxT: // global
           call _cbvxG(R1) args: 0, res: 0, upd: 0;
       cbvxH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvxG() //  [R1]
         { info_tbl: [(cbvxG,
                       label: block_cbvxG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvxG: // global
           I64[Sp] = block_cbvxM_info;
           R2 = P64[R1 + 7];
           _sbuaZ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbuaZ::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvxM() //  []
         { info_tbl: [(cbvxM,
                       label: block_cbvxM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvxM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbub8_entry() //  [R1]
         { info_tbl: [(cbvy8,
                       label: io_sbub8_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvy8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvyc; else goto cbvyd;
       cbvyc: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbvyd: // global
           I64[Sp - 16] = block_cbvy3_info;
           _sbub3::P64 = P64[R1 + 15];
           R5 = _sbub3::P64;
           R4 = GHC.IO.Handle.hGetEncoding2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEncoding3_closure;
           P64[Sp - 8] = _sbub3::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvy3() //  [R1]
         { info_tbl: [(cbvy3,
                       label: block_cbvy3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvy3: // global
           I64[Sp] = block_cbvy5_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubvyi; else goto cbvy6;
       ubvyi: // global
           call _cbvy5(R1) args: 0, res: 0, upd: 0;
       cbvy6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvy5() //  [R1]
         { info_tbl: [(cbvy5,
                       label: block_cbvy5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvy5: // global
           I64[Sp] = block_cbvyb_info;
           R2 = P64[R1 + 7];
           _sbubf::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbubf::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvyb() //  []
         { info_tbl: [(cbvyb,
                       label: block_cbvyb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvyb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hGetEncoding1_entry() //  [R2]
         { info_tbl: [(cbvyn,
                       label: GHC.IO.Handle.hGetEncoding1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvyn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbvyo; else goto cbvyp;
       cbvyo: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEncoding1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvyp: // global
           I64[Sp - 8] = block_cbvxs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvyG; else goto cbvxt;
       ubvyG: // global
           call _cbvxs(R1) args: 0, res: 0, upd: 0;
       cbvxt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvxs() //  [R1]
         { info_tbl: [(cbvxs,
                       label: block_cbvxs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvxs: // global
           if (R1 & 7 == 1) goto cbvyk; else goto cbvyl;
       cbvyk: // global
           I64[Sp - 16] = block_cbvxx_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbvyl: // global
           I64[Sp - 16] = block_cbvxW_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbvxx() //  [R1]
         { info_tbl: [(cbvxx,
                       label: block_cbvxx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvxx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvyt; else goto cbvys;
       cbvyt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbvys: // global
           I64[Hp - 16] = io_sbuaS_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbvxz::P64 = Hp - 15;
           if (R1 == 0) goto cbvyx; else goto cbvyw;
       cbvyx: // global
           R1 = _cbvxz::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbvyw: // global
           R1 = _cbvxz::P64;
           Sp = Sp + 24;
           call io_sbuaS_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvxW() //  [R1]
         { info_tbl: [(cbvxW,
                       label: block_cbvxW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvxW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvyB; else goto cbvyA;
       cbvyB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbvyA: // global
           I64[Hp - 16] = io_sbub8_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbvxY::P64 = Hp - 15;
           if (R1 == 0) goto cbvyF; else goto cbvyE;
       cbvyF: // global
           R1 = _cbvxY::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbvyE: // global
           R1 = _cbvxY::P64;
           Sp = Sp + 24;
           call io_sbub8_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.597572052 UTC

[section ""data" . GHC.IO.Handle.hGetEncoding_closure" {
     GHC.IO.Handle.hGetEncoding_closure:
         const GHC.IO.Handle.hGetEncoding_info;
         const 0;
 },
 GHC.IO.Handle.hGetEncoding_entry() //  [R2]
         { info_tbl: [(cbvzN,
                       label: GHC.IO.Handle.hGetEncoding_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvzN: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEncoding1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.600628609 UTC

[section ""cstring" . lvl15_rbnWX_bytes" {
     lvl15_rbnWX_bytes:
         I8[] [104,83,101,116,69,110,99,111,100,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.60266435 UTC

[section ""data" . lvl16_rbnWY_closure" {
     lvl16_rbnWY_closure:
         const lvl16_rbnWY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_rbnWY_entry() //  [R1]
         { info_tbl: [(cbvA1,
                       label: lvl16_rbnWY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvA1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvA2; else goto cbvA3;
       cbvA2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvA3: // global
           (_cbvzY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbvzY::I64 == 0) goto cbvA0; else goto cbvzZ;
       cbvA0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbvzZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvzY::I64;
           R2 = lvl15_rbnWX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.606474931 UTC

[section ""cstring" . lvl17_rbnWZ_bytes" {
     lvl17_rbnWZ_bytes:
         I8[] [108,97,115,116,95,100,101,99,111,100,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.608396204 UTC

[section ""data" . lvl18_rbnX0_closure" {
     lvl18_rbnX0_closure:
         const lvl18_rbnX0_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rbnX0_entry() //  [R1]
         { info_tbl: [(cbvAl,
                       label: lvl18_rbnX0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvAl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbvAm; else goto cbvAn;
       cbvAm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvAn: // global
           (_cbvAg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbvAg::I64 == 0) goto cbvAi; else goto cbvAh;
       cbvAi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbvAh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvAg::I64;
           I64[Sp - 24] = block_cbvAj_info;
           R2 = lvl17_rbnWZ_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbvAj() //  [R1]
         { info_tbl: [(cbvAj,
                       label: block_cbvAj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvAj: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.619961362 UTC

[section ""data" . GHC.IO.Handle.hSetEncoding1_closure" {
     GHC.IO.Handle.hSetEncoding1_closure:
         const GHC.IO.Handle.hSetEncoding1_info;
         const 0;
 },
 sat_sbudP_entry() //  [R1]
         { info_tbl: [(cbvBt,
                       label: sat_sbudP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvBt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbvBx; else goto cbvBy;
       cbvBx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvBy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbvBq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubvBC; else goto cbvBr;
       ubvBC: // global
           call _cbvBq(R1) args: 0, res: 0, upd: 0;
       cbvBr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbvBq() //  [R1]
         { info_tbl: [(cbvBq,
                       label: block_cbvBq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvBq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvBB; else goto cbvBA;
       cbvBB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbvBA: // global
           _sbudK::P64 = P64[R1 + 7];
           _sbudL::P64 = P64[R1 + 15];
           _sbudJ::I64 = I64[R1 + 23];
           _sbudM::I64 = I64[R1 + 31];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbudK::P64;
           P64[Hp - 32] = _sbudL::P64;
           I64[Hp - 24] = _sbudJ::I64;
           I64[Hp - 16] = _sbudM::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbue8_entry() //  [R1]
         { info_tbl: [(cbvBZ,
                       label: sat_sbue8_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvBZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbvC6; else goto cbvC7;
       cbvC6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvC7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbvBW_info;
           _sbudY::I64 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           I64[Sp - 24] = _sbudY::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubvCb; else goto cbvBX;
       ubvCb: // global
           call _cbvBW(R1) args: 0, res: 0, upd: 0;
       cbvBX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbvBW() //  [R1]
         { info_tbl: [(cbvBW,
                       label: block_cbvBW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvBW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvCa; else goto cbvC9;
       cbvCa: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbvC9: // global
           _sbue2::P64 = P64[R1 + 7];
           _sbue3::P64 = P64[R1 + 15];
           _sbue1::I64 = I64[R1 + 23];
           _sbue4::I64 = I64[R1 + 31];
           _sbue6::I64 = I64[R1 + 47];
           _sbue7::I64 = I64[R1 + 39] + I64[Sp + 8];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = _sbue2::P64;
           P64[Hp - 32] = _sbue3::P64;
           I64[Hp - 24] = _sbue1::I64;
           I64[Hp - 16] = _sbue4::I64;
           I64[Hp - 8] = _sbue7::I64;
           I64[Hp] = _sbue6::I64;
           R1 = Hp - 47;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbuev_entry() //  [R1, R2]
         { info_tbl: [(cbvCc,
                       label: sat_sbuev_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvCc: // global
           if ((Sp + -192) < SpLim) (likely: False) goto cbvCd; else goto cbvCe;
       cbvCd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvCe: // global
           I64[Sp - 24] = block_cbvAN_info;
           _sbubk::P64 = P64[R1 + 6];
           _sbubm::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbubk::P64;
           P64[Sp - 8] = _sbubm::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubvGJ; else goto cbvAO;
       ubvGJ: // global
           call _cbvAN(R1) args: 0, res: 0, upd: 0;
       cbvAO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvAN() //  [R1]
         { info_tbl: [(cbvAN,
                       label: block_cbvAN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvAN: // global
           I64[Sp - 120] = block_cbvAS_info;
           _sbubq::P64 = P64[R1 + 7];
           _sbubr::P64 = P64[R1 + 15];
           _sbubs::P64 = P64[R1 + 23];
           _sbubt::P64 = P64[R1 + 31];
           _sbubu::P64 = P64[R1 + 39];
           _sbubv::P64 = P64[R1 + 47];
           _sbubw::P64 = P64[R1 + 55];
           _sbubx::P64 = P64[R1 + 63];
           _sbuby::P64 = P64[R1 + 71];
           _sbubz::P64 = P64[R1 + 79];
           _sbubA::P64 = P64[R1 + 87];
           _sbubB::P64 = P64[R1 + 95];
           _sbubD::P64 = P64[R1 + 111];
           _sbubE::P64 = P64[R1 + 119];
           _sbubF::P64 = P64[R1 + 127];
           R1 = P64[_sbuby::P64 + 8];
           P64[Sp - 112] = _sbubr::P64;
           P64[Sp - 104] = _sbubs::P64;
           P64[Sp - 96] = _sbubt::P64;
           P64[Sp - 88] = _sbubu::P64;
           P64[Sp - 80] = _sbubv::P64;
           P64[Sp - 72] = _sbubw::P64;
           P64[Sp - 64] = _sbubx::P64;
           P64[Sp - 56] = _sbuby::P64;
           P64[Sp - 48] = _sbubz::P64;
           P64[Sp - 40] = _sbubA::P64;
           P64[Sp - 32] = _sbubB::P64;
           P64[Sp - 24] = _sbubD::P64;
           P64[Sp - 16] = _sbubE::P64;
           P64[Sp - 8] = _sbubF::P64;
           P64[Sp] = _sbubq::P64;
           Sp = Sp - 120;
           if (R1 & 7 != 0) goto ubvGw; else goto cbvAT;
       ubvGw: // global
           call _cbvAS(R1) args: 0, res: 0, upd: 0;
       cbvAT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvAS() //  [R1]
         { info_tbl: [(cbvAS,
                       label: block_cbvAS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvAS: // global
           I64[Sp - 16] = block_cbvAZ_info;
           _sbubO::I64 = I64[R1 + 39];
           _sbubP::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbubP::I64;
           I64[Sp] = _sbubO::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubvGx; else goto cbvB0;
       ubvGx: // global
           call _cbvAZ(R1) args: 0, res: 0, upd: 0;
       cbvB0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvAZ() //  [R1]
         { info_tbl: [(cbvAZ,
                       label: block_cbvAZ_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvAZ: // global
           if (R1 & 7 == 1) goto cbvF0; else goto cbvFV;
       cbvF0: // global
           _sbudp::P64 = P64[P64[Sp + 80] + 8];
           I64[Sp + 16] = block_cbvB4_info;
           R1 = _sbudp::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubvGy; else goto cbvB5;
       ubvGy: // global
           call _cbvB4(R1) args: 0, res: 0, upd: 0;
       cbvB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvFV: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubvGj; else goto cbvFT;
       ubvGj: // global
           Sp = Sp + 24;
           call _sbubQ() args: 0, res: 0, upd: 0;
       cbvFT: // global
           R1 = GHC.IO.Handle.Internals.flushCharBuffer2_closure;
           Sp = Sp + 160;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvB4() //  [R1]
         { info_tbl: [(cbvB4,
                       label: block_cbvB4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvB4: // global
           I64[Sp - 16] = block_cbvB9_info;
           _sbudv::I64 = I64[R1 + 39];
           _sbudw::I64 = I64[R1 + 47];
           R1 = P64[R1 + 15];
           I64[Sp - 8] = _sbudw::I64;
           I64[Sp] = _sbudv::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubvGA; else goto cbvBa;
       ubvGA: // global
           call _cbvB9(R1) args: 0, res: 0, upd: 0;
       cbvBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvB9() //  [R1]
         { info_tbl: [(cbvB9,
                       label: block_cbvB9_info
                       rep:StackRep [True, True, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvB9: // global
           if (R1 & 7 == 1) goto cbvFI; else goto ubvGk;
       cbvFI: // global
           if (I64[Sp + 16] == I64[Sp + 8]) goto ubvGl; else goto cbvF4;
       ubvGl: // global
           Sp = Sp + 24;
           goto ubvGD;
       cbvF4: // global
           _sbudB::P64 = P64[P64[Sp + 72] + 8];
           I64[Sp + 16] = block_cbvBh_info;
           R1 = _sbudB::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ubvGB; else goto cbvBi;
       ubvGB: // global
           call _cbvBh(R1) args: 0, res: 0, upd: 0;
       cbvBi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubvGk: // global
           Sp = Sp + 24;
           goto ubvGD;
       ubvGD: // global
           call _sbubQ() args: 0, res: 0, upd: 0;
     }
 },
 _cbvBh() //  [R1]
         { info_tbl: [(cbvBh,
                       label: block_cbvBh_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvBh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvF7; else goto cbvF6;
       cbvF7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvF6: // global
           _sbuby::P64 = P64[Sp + 64];
           _sbudD::P64 = P64[R1 + 7];
           _sbudE::P64 = P64[R1 + 15];
           _sbudH::P64 = P64[_sbuby::P64 + 8];
           I64[Hp - 16] = sat_sbudP_info;
           P64[Hp] = _sbudH::P64;
           call MO_WriteBarrier();
           P64[_sbuby::P64 + 8] = Hp - 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbuby::P64);
           I64[Sp - 8] = block_cbvBG_info;
           R1 = _sbudH::P64;
           P64[Sp] = _sbudE::P64;
           P64[Sp + 56] = _sbudD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvGE; else goto cbvBH;
       ubvGE: // global
           call _cbvBG(R1) args: 0, res: 0, upd: 0;
       cbvBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvBG() //  [R1]
         { info_tbl: [(cbvBG,
                       label: block_cbvBG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvBG: // global
           _sbudY::I64 = I64[R1 + 39];
           if (_sbudY::I64 != 0) goto cbvFa; else goto cbvFF;
       cbvFa: // global
           I64[Sp - 32] = block_cbvBN_info;
           _sbudT::P64 = P64[R1 + 7];
           _sbudU::P64 = P64[R1 + 15];
           _sbudS::I64 = I64[R1 + 23];
           R1 = P64[Sp + 96];
           P64[Sp - 24] = _sbudT::P64;
           P64[Sp - 16] = _sbudU::P64;
           I64[Sp - 8] = _sbudY::I64;
           I64[Sp] = _sbudS::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubvGF; else goto cbvBO;
       ubvGF: // global
           call _cbvBN(R1) args: 0, res: 0, upd: 0;
       cbvBO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvFF: // global
           _sbubv::P64 = P64[Sp + 48];
           _sbudE::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbubv::P64 + 8] = _sbudE::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbubv::P64);
           Sp = Sp + 16;
           call _sbubQ() args: 0, res: 0, upd: 0;
     }
 },
 _cbvBN() //  [R1]
         { info_tbl: [(cbvBN,
                       label: block_cbvBN_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvBN: // global
           if (R1 & 7 == 1) goto cbvFc; else goto cbvFu;
       cbvFc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbvFf; else goto cbvFe;
       cbvFf: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvFe: // global
           I64[Hp - 24] = sat_sbue8_info;
           P64[Hp - 8] = P64[Sp + 40];
           I64[Hp] = I64[Sp + 24];
           _sbubv::P64 = P64[Sp + 80];
           call MO_WriteBarrier();
           P64[_sbubv::P64 + 8] = Hp - 24;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbubv::P64);
           Sp = Sp + 48;
           call _sbubQ() args: 0, res: 0, upd: 0;
       cbvFu: // global
           I64[Sp] = block_cbvFi_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubvGH; else goto cbvFj;
       ubvGH: // global
           call _cbvFi(R1) args: 0, res: 0, upd: 0;
       cbvFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvFi() //  [R1]
         { info_tbl: [(cbvFi,
                       label: block_cbvFi_info
                       rep:StackRep [False, False, True, True, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvFi: // global
           I64[Sp - 8] = block_cbvFn_info;
           R2 = P64[Sp + 96];
           _sbuec::P64 = P64[R1 + 7];
           _sbued::P64 = P64[R1 + 15];
           R1 = P64[R1 + 39];
           P64[Sp] = _sbued::P64;
           P64[Sp + 96] = _sbuec::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvFn() //  [R1]
         { info_tbl: [(cbvFn,
                       label: block_cbvFn_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvFn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbvFy; else goto cbvFx;
       cbvFy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvFx: // global
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = I64[Sp + 40];
           I64[Hp - 16] = I64[Sp + 32];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           _sbudE::P64 = P64[Sp + 48];
           I64[Sp + 48] = block_cbvFq_info;
           R5 = Hp - 47;
           R4 = _sbudE::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 104];
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wstreamEncode_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvFq() //  [R1]
         { info_tbl: [(cbvFq,
                       label: block_cbvFq_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvFq: // global
           I64[Sp] = block_cbvFs_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubvGX; else goto cbvFA;
       ubvGX: // global
           call _cbvFs(R1) args: 0, res: 0, upd: 0;
       cbvFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvFs() //  [R1]
         { info_tbl: [(cbvFs,
                       label: block_cbvFs_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvFs: // global
           _sbubv::P64 = P64[Sp + 40];
           _sbuep::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_sbubv::P64 + 8] = _sbuep::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbubv::P64);
           Sp = Sp + 8;
           call _sbubQ() args: 0, res: 0, upd: 0;
     }
 },
 _sbubQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbubQ: // global
           I64[Sp - 8] = block_cbvCm_info;
           R1 = P64[Sp + 80];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvGZ; else goto cbvDY;
       ubvGZ: // global
           call _cbvCm(R1) args: 0, res: 0, upd: 0;
       cbvDY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvCm() //  [R1]
         { info_tbl: [(cbvCm,
                       label: block_cbvCm_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvCm: // global
           if (R1 & 7 == 1) goto cbvE5; else goto cbvEu;
       cbvE5: // global
           I64[Sp] = block_cbvE2_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubvGK; else goto cbvE6;
       ubvGK: // global
           call _cbvE2(R1) args: 0, res: 0, upd: 0;
       cbvE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvEu: // global
           I64[Sp] = block_cbvEs_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubvGL; else goto cbvEv;
       ubvGL: // global
           call _cbvEs(R1) args: 0, res: 0, upd: 0;
       cbvEv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvE2() //  [R1]
         { info_tbl: [(cbvE2,
                       label: block_cbvE2_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvE2: // global
           if (R1 & 7 == 1) goto ubvGr; else goto cbvEm;
       ubvGr: // global
           Sp = Sp + 8;
           call _sbubS() args: 0, res: 0, upd: 0;
       cbvEm: // global
           I64[Sp] = block_cbvEf_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubvGQ; else goto cbvEg;
       ubvGQ: // global
           call _cbvEf(R1) args: 0, res: 0, upd: 0;
       cbvEg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvEf() //  [R1]
         { info_tbl: [(cbvEf,
                       label: block_cbvEf_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvEf: // global
           I64[Sp] = block_cbvEk_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvEk() //  []
         { info_tbl: [(cbvEk,
                       label: block_cbvEk_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvEk: // global
           Sp = Sp + 8;
           call _sbubS() args: 0, res: 0, upd: 0;
     }
 },
 _cbvEs() //  [R1]
         { info_tbl: [(cbvEs,
                       label: block_cbvEs_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvEs: // global
           I64[Sp] = block_cbvEz_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvEz() //  []
         { info_tbl: [(cbvEz,
                       label: block_cbvEz_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvEz: // global
           I64[Sp] = block_cbvEB_info;
           R1 = P64[Sp + 80];
           if (R1 & 7 != 0) goto ubvGT; else goto cbvEE;
       ubvGT: // global
           call _cbvEB(R1) args: 0, res: 0, upd: 0;
       cbvEE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvEB() //  [R1]
         { info_tbl: [(cbvEB,
                       label: block_cbvEB_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvEB: // global
           if (R1 & 7 == 1) goto ubvGp; else goto cbvEU;
       ubvGp: // global
           Sp = Sp + 8;
           call _sbubS() args: 0, res: 0, upd: 0;
       cbvEU: // global
           I64[Sp] = block_cbvEN_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubvGU; else goto cbvEO;
       ubvGU: // global
           call _cbvEN(R1) args: 0, res: 0, upd: 0;
       cbvEO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvEN() //  [R1]
         { info_tbl: [(cbvEN,
                       label: block_cbvEN_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvEN: // global
           I64[Sp] = block_cbvES_info;
           R1 = P64[R1 + 23];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvES() //  []
         { info_tbl: [(cbvES,
                       label: block_cbvES_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvES: // global
           Sp = Sp + 8;
           call _sbubS() args: 0, res: 0, upd: 0;
     }
 },
 _sbubS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbubS: // global
           I64[Sp - 8] = block_cbvCr_info;
           R1 = P64[Sp + 120];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvH0; else goto cbvCt;
       ubvH0: // global
           call _cbvCr(R1) args: 0, res: 0, upd: 0;
       cbvCt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvCr() //  [R1]
         { info_tbl: [(cbvCr,
                       label: block_cbvCr_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, True, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvCr: // global
           I64[Sp] = block_cbvCz_info;
           _sbubW::P64 = P64[R1 + 15];
           _sbubX::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp + 88] = _sbubX::P64;
           P64[Sp + 128] = _sbubW::P64;
           if (R1 & 7 != 0) goto ubvGM; else goto cbvDz;
       ubvGM: // global
           call _cbvCz(R1) args: 0, res: 0, upd: 0;
       cbvDz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvCz() //  [R1]
         { info_tbl: [(cbvCz,
                       label: block_cbvCz_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvCz: // global
           _sbubW::P64 = P64[Sp + 128];
           _cbvGc::P64 = R1 & 7;
           if (_cbvGc::P64 != 3) goto ubvGg; else goto cbvDK;
       ubvGg: // global
           if (_cbvGc::P64 != 6) goto cbvDF; else goto cbvDT;
       cbvDF: // global
           P64[Sp + 128] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call _sbubY() args: 0, res: 0, upd: 0;
       cbvDT: // global
           I64[Sp] = block_cbvDR_info;
           R1 = _sbubW::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbvDK: // global
           I64[Sp] = block_cbvDI_info;
           R1 = _sbubW::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvDR() //  [R1]
         { info_tbl: [(cbvDR,
                       label: block_cbvDR_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvDR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbvDX; else goto cbvDW;
       cbvDX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvDW: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 128] = Hp - 6;
           Sp = Sp + 8;
           call _sbubY() args: 0, res: 0, upd: 0;
     }
 },
 _cbvDI() //  [R1]
         { info_tbl: [(cbvDI,
                       label: block_cbvDI_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, True, False, False, False, False, False, True,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvDI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbvDO; else goto cbvDN;
       cbvDO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvDN: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           P64[Sp + 128] = Hp - 6;
           Sp = Sp + 8;
           call _sbubY() args: 0, res: 0, upd: 0;
     }
 },
 _sbubY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbubY: // global
           I64[Sp - 8] = block_cbvCE_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvH1; else goto cbvCG;
       ubvH1: // global
           call _cbvCE(R1) args: 0, res: 0, upd: 0;
       cbvCG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvCE() //  [R1]
         { info_tbl: [(cbvCE,
                       label: block_cbvCE_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvCE: // global
           _sbubX::P64 = P64[Sp + 88];
           _cbvGf::P64 = R1 & 7;
           if (_cbvGf::P64 < 5) goto ubvGh; else goto ubvGi;
       ubvGh: // global
           if (_cbvGf::P64 < 4) goto cbvCP; else goto cbvD2;
       cbvCP: // global
           I64[Sp] = block_cbvCK_info;
           _sbuc1::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbuc1::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       cbvD2: // global
           I64[Sp] = block_cbvCV_info;
           R1 = _sbubX::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ubvGi: // global
           if (_cbvGf::P64 < 6) goto cbvDg; else goto cbvDu;
       cbvDg: // global
           I64[Sp] = block_cbvD9_info;
           R1 = _sbubX::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       cbvDu: // global
           I64[Sp] = block_cbvDn_info;
           R1 = _sbubX::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvCK() //  [R1]
         { info_tbl: [(cbvCK,
                       label: block_cbvCK_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvCK: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbvCS; else goto cbvCR;
       cbvCS: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvCR: // global
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 88];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvCV() //  [R1]
         { info_tbl: [(cbvCV,
                       label: block_cbvCV_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvCV: // global
           I64[Sp] = block_cbvCX_info;
           _sbucb::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbucb::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvCX() //  [R1]
         { info_tbl: [(cbvCX,
                       label: block_cbvCX_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvCX: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbvD6; else goto cbvD5;
       cbvD6: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvD5: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.WriteHandle_closure+4;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvD9() //  [R1]
         { info_tbl: [(cbvD9,
                       label: block_cbvD9_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvD9: // global
           I64[Sp] = block_cbvDb_info;
           _sbucm::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbucm::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvDb() //  [R1]
         { info_tbl: [(cbvDb,
                       label: block_cbvDb_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvDb: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbvDk; else goto cbvDj;
       cbvDk: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvDj: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.AppendHandle_closure+5;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvDn() //  [R1]
         { info_tbl: [(cbvDn,
                       label: block_cbvDn_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, True, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvDn: // global
           I64[Sp] = block_cbvDp_info;
           _sbucx::P64 = R1;
           R1 = lvl18_rbnX0_closure;
           P64[Sp + 88] = _sbucx::P64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvDp() //  [R1]
         { info_tbl: [(cbvDp,
                       label: block_cbvDp_info
                       rep:StackRep [False, False, False, True, False, False, True, False,
                                     False, True, False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvDp: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cbvDy; else goto cbvDx;
       cbvDy: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvDx: // global
           I64[Hp - 144] = GHC.Base.Just_con_info;
           P64[Hp - 136] = P64[Sp + 88];
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = P64[Sp + 120];
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = P64[Sp + 16];
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = GHC.IO.Handle.Types.ReadWriteHandle_closure+6;
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = P64[Sp + 48];
           P64[Hp - 64] = R1;
           P64[Hp - 56] = P64[Sp + 64];
           P64[Hp - 48] = P64[Sp + 72];
           P64[Hp - 40] = Hp - 142;
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 127;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetEncoding1_entry() //  [R2, R3]
         { info_tbl: [(cbvH2,
                       label: GHC.IO.Handle.hSetEncoding1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvH2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbvH6; else goto cbvH5;
       cbvH6: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetEncoding1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbvH5: // global
           I64[Hp - 32] = GHC.Base.Just_con_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbuev_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 30;
           R4 = Hp - 14;
           R3 = R2;
           R2 = lvl16_rbnWY_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.706979675 UTC

[section ""data" . GHC.IO.Handle.hSetEncoding_closure" {
     GHC.IO.Handle.hSetEncoding_closure:
         const GHC.IO.Handle.hSetEncoding_info;
         const 0;
 },
 GHC.IO.Handle.hSetEncoding_entry() //  [R2, R3]
         { info_tbl: [(cbvMb,
                       label: GHC.IO.Handle.hSetEncoding_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvMb: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetEncoding1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.710339467 UTC

[section ""cstring" . GHC.IO.Handle.hSetBuffering3_bytes" {
     GHC.IO.Handle.hSetBuffering3_bytes:
         I8[] [104,83,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.712261894 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering2_closure" {
     GHC.IO.Handle.hSetBuffering2_closure:
         const GHC.IO.Handle.hSetBuffering2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetBuffering2_entry() //  [R1]
         { info_tbl: [(cbvMp,
                       label: GHC.IO.Handle.hSetBuffering2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvMp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvMq; else goto cbvMr;
       cbvMq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvMr: // global
           (_cbvMm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbvMm::I64 == 0) goto cbvMo; else goto cbvMn;
       cbvMo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbvMn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvMm::I64;
           R2 = GHC.IO.Handle.hSetBuffering3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.7208902 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering1_closure" {
     GHC.IO.Handle.hSetBuffering1_closure:
         const GHC.IO.Handle.hSetBuffering1_info;
         const 0;
 },
 sat_sbufG_entry() //  [R1, R2]
         { info_tbl: [(cbvMM,
                       label: sat_sbufG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvMM: // global
           if ((Sp + -176) < SpLim) (likely: False) goto cbvMN; else goto cbvMO;
       cbvMN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvMO: // global
           I64[Sp - 16] = block_cbvMJ_info;
           _sbuex::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbuex::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubvRg; else goto cbvMK;
       ubvRg: // global
           call _cbvMJ(R1) args: 0, res: 0, upd: 0;
       cbvMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvMJ() //  [R1]
         { info_tbl: [(cbvMJ,
                       label: block_cbvMJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvMJ: // global
           I64[Sp - 128] = block_cbvMR_info;
           _sbueB::P64 = R1;
           _sbueC::P64 = P64[R1 + 7];
           _sbueD::P64 = P64[R1 + 15];
           _sbueE::P64 = P64[R1 + 23];
           _sbueF::P64 = P64[R1 + 31];
           _sbueH::P64 = P64[R1 + 47];
           _sbueI::P64 = P64[R1 + 55];
           _sbueJ::P64 = P64[R1 + 63];
           _sbueK::P64 = P64[R1 + 71];
           _sbueL::P64 = P64[R1 + 79];
           _sbueM::P64 = P64[R1 + 87];
           _sbueN::P64 = P64[R1 + 95];
           _sbueO::P64 = P64[R1 + 103];
           _sbueP::P64 = P64[R1 + 111];
           _sbueQ::P64 = P64[R1 + 119];
           _sbueR::P64 = P64[R1 + 127];
           R1 = P64[R1 + 39];
           P64[Sp - 120] = _sbueC::P64;
           P64[Sp - 112] = _sbueD::P64;
           P64[Sp - 104] = _sbueE::P64;
           P64[Sp - 96] = _sbueF::P64;
           P64[Sp - 88] = _sbueH::P64;
           P64[Sp - 80] = _sbueI::P64;
           P64[Sp - 72] = _sbueJ::P64;
           P64[Sp - 64] = _sbueK::P64;
           P64[Sp - 56] = _sbueL::P64;
           P64[Sp - 48] = _sbueM::P64;
           P64[Sp - 40] = _sbueN::P64;
           P64[Sp - 32] = _sbueO::P64;
           P64[Sp - 24] = _sbueP::P64;
           P64[Sp - 16] = _sbueQ::P64;
           P64[Sp - 8] = _sbueR::P64;
           P64[Sp] = _sbueB::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto ubvRf; else goto cbvMT;
       ubvRf: // global
           call _cbvMR(R1) args: 0, res: 0, upd: 0;
       cbvMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvMR() //  [R1]
         { info_tbl: [(cbvMR,
                       label: block_cbvMR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvMR: // global
           if (R1 & 7 == 1) goto cbvQM; else goto cbvP2;
       cbvQM: // global
           Sp = Sp + 144;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbvP2: // global
           I64[Sp - 8] = block_cbvMZ_info;
           _sbueS::P64 = R1;
           R1 = P64[Sp + 136];
           P64[Sp] = _sbueS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvRh; else goto cbvP3;
       ubvRh: // global
           call _cbvMZ(R1) args: 0, res: 0, upd: 0;
       cbvP3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvMZ() //  [R1]
         { info_tbl: [(cbvMZ,
                       label: block_cbvMZ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvMZ: // global
           _sbueI::P64 = P64[Sp + 56];
           _cbvQO::P64 = R1 & 7;
           if (_cbvQO::P64 < 3) goto ubvR0; else goto cbvPG;
       ubvR0: // global
           if (_cbvQO::P64 < 2) goto cbvPa; else goto cbvPq;
       cbvPa: // global
           I64[Sp] = block_cbvP7_info;
           R1 = _sbueI::P64;
           if (R1 & 7 != 0) goto ubvRi; else goto cbvPb;
       ubvRi: // global
           call _cbvP7(R1) args: 0, res: 0, upd: 0;
       cbvPb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvPq: // global
           I64[Sp] = block_cbvPo_info;
           R1 = _sbueI::P64;
           if (R1 & 7 != 0) goto ubvRj; else goto cbvPr;
       ubvRj: // global
           call _cbvPo(R1) args: 0, res: 0, upd: 0;
       cbvPr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvPG: // global
           I64[Sp] = block_cbvPE_info;
           _sbufs::P64 = P64[R1 + 5];
           R1 = _sbueI::P64;
           P64[Sp + 56] = _sbufs::P64;
           if (R1 & 7 != 0) goto ubvRk; else goto cbvPH;
       ubvRk: // global
           call _cbvPE(R1) args: 0, res: 0, upd: 0;
       cbvPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvP7() //  [R1]
         { info_tbl: [(cbvP7,
                       label: block_cbvP7_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvP7: // global
           if (R1 & 7 == 1) goto ubvR2; else goto ubvR3;
       ubvR2: // global
           Sp = Sp + 136;
           call _cbvQI() args: 0, res: 0, upd: 0;
       ubvR3: // global
           Sp = Sp + 8;
           call _sbueT() args: 0, res: 0, upd: 0;
     }
 },
 _cbvPo() //  [R1]
         { info_tbl: [(cbvPo,
                       label: block_cbvPo_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvPo: // global
           if (R1 & 7 == 2) goto ubvR4; else goto ubvR5;
       ubvR4: // global
           Sp = Sp + 136;
           call _cbvQI() args: 0, res: 0, upd: 0;
       ubvR5: // global
           Sp = Sp + 8;
           call _sbueT() args: 0, res: 0, upd: 0;
     }
 },
 _cbvPE() //  [R1]
         { info_tbl: [(cbvPE,
                       label: block_cbvPE_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvPE: // global
           if (R1 & 7 == 3) goto cbvPS; else goto ubvR6;
       cbvPS: // global
           I64[Sp] = block_cbvPQ_info;
           _sbufu::P64 = P64[R1 + 5];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _sbufu::P64;
           if (R1 & 7 != 0) goto ubvRx; else goto cbvPT;
       ubvRx: // global
           call _cbvPQ(R1) args: 0, res: 0, upd: 0;
       cbvPT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubvR6: // global
           Sp = Sp + 8;
           call _sbueT() args: 0, res: 0, upd: 0;
     }
 },
 _cbvPQ() //  [R1]
         { info_tbl: [(cbvPQ,
                       label: block_cbvPQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvPQ: // global
           _sbufu::P64 = P64[Sp + 56];
           if (R1 & 7 == 1) goto cbvQ0; else goto cbvQg;
       cbvQ0: // global
           I64[Sp] = block_cbvPX_info;
           R1 = _sbufu::P64;
           if (R1 & 7 != 0) goto ubvRz; else goto cbvQ1;
       ubvRz: // global
           call _cbvPX(R1) args: 0, res: 0, upd: 0;
       cbvQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvQg: // global
           I64[Sp] = block_cbvQe_info;
           _sbufy::P64 = P64[R1 + 6];
           R1 = _sbufu::P64;
           P64[Sp + 56] = _sbufy::P64;
           if (R1 & 7 != 0) goto ubvRA; else goto cbvQh;
       ubvRA: // global
           call _cbvQe(R1) args: 0, res: 0, upd: 0;
       cbvQh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvPX() //  [R1]
         { info_tbl: [(cbvPX,
                       label: block_cbvPX_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvPX: // global
           if (R1 & 7 == 1) goto ubvRa; else goto ubvRb;
       ubvRa: // global
           Sp = Sp + 136;
           call _cbvQI() args: 0, res: 0, upd: 0;
       ubvRb: // global
           Sp = Sp + 8;
           call _sbueT() args: 0, res: 0, upd: 0;
     }
 },
 _cbvQe() //  [R1]
         { info_tbl: [(cbvQe,
                       label: block_cbvQe_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvQe: // global
           if (R1 & 7 == 1) goto ubvR7; else goto cbvQx;
       ubvR7: // global
           Sp = Sp + 8;
           call _sbueT() args: 0, res: 0, upd: 0;
       cbvQx: // global
           I64[Sp] = block_cbvQq_info;
           _sbufA::P64 = P64[R1 + 6];
           R1 = P64[Sp + 56];
           P64[Sp + 56] = _sbufA::P64;
           if (R1 & 7 != 0) goto ubvRD; else goto cbvQr;
       ubvRD: // global
           call _cbvQq(R1) args: 0, res: 0, upd: 0;
       cbvQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvQq() //  [R1]
         { info_tbl: [(cbvQq,
                       label: block_cbvQq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvQq: // global
           I64[Sp] = block_cbvQv_info;
           _sbufC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp + 56] = _sbufC::I64;
           if (R1 & 7 != 0) goto ubvRF; else goto cbvQz;
       ubvRF: // global
           call _cbvQv(R1) args: 0, res: 0, upd: 0;
       cbvQz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvQv() //  [R1]
         { info_tbl: [(cbvQv,
                       label: block_cbvQv_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvQv: // global
           if (I64[Sp + 56] == I64[R1 + 7]) goto ubvR8; else goto ubvR9;
       ubvR8: // global
           Sp = Sp + 136;
           call _cbvQI() args: 0, res: 0, upd: 0;
       ubvR9: // global
           Sp = Sp + 8;
           call _sbueT() args: 0, res: 0, upd: 0;
     }
 },
 _cbvQI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvQI: // global
           R1 = P64[Sp];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _sbueT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbueT: // global
           I64[Sp - 8] = block_cbvN6_info;
           R1 = P64[Sp + 136];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvRI; else goto cbvOt;
       ubvRI: // global
           call _cbvN6(R1) args: 0, res: 0, upd: 0;
       cbvOt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvN6() //  [R1]
         { info_tbl: [(cbvN6,
                       label: block_cbvN6_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvN6: // global
           if (R1 & 7 == 3) goto cbvOE; else goto ubvRc;
       cbvOE: // global
           I64[Sp] = block_cbvOC_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto ubvRl; else goto cbvOF;
       ubvRl: // global
           call _cbvOC(R1) args: 0, res: 0, upd: 0;
       cbvOF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubvRc: // global
           Sp = Sp + 8;
           call _sbueU() args: 0, res: 0, upd: 0;
     }
 },
 _cbvOC() //  [R1]
         { info_tbl: [(cbvOC,
                       label: block_cbvOC_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvOC: // global
           if (R1 & 7 == 1) goto ubvRd; else goto cbvOQ;
       ubvRd: // global
           Sp = Sp + 8;
           call _sbueU() args: 0, res: 0, upd: 0;
       cbvOQ: // global
           I64[Sp] = block_cbvOO_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubvRq; else goto cbvOR;
       ubvRq: // global
           call _cbvOO(R1) args: 0, res: 0, upd: 0;
       cbvOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvOO() //  [R1]
         { info_tbl: [(cbvOO,
                       label: block_cbvOO_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvOO: // global
           _sbufm::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sbufm::I64, 0)) goto ubvRe; else goto cbvP0;
       ubvRe: // global
           Sp = Sp + 8;
           call _sbueU() args: 0, res: 0, upd: 0;
       cbvP0: // global
           R2 = _sbufm::I64;
           Sp = Sp + 152;
           call GHC.IO.Handle.Internals.$wioe_bufsiz_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _sbueU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbueU: // global
           I64[Sp - 8] = block_cbvNb_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pv_info;
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 24;
           call GHC.IO.Device.isTerminal_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbvNb() //  [R1]
         { info_tbl: [(cbvNb,
                       label: block_cbvNb_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvNb: // global
           I64[Sp] = block_cbvNd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubvRn; else goto cbvNg;
       ubvRn: // global
           call _cbvNd(R1) args: 0, res: 0, upd: 0;
       cbvNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvNd() //  [R1]
         { info_tbl: [(cbvNd,
                       label: block_cbvNd_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvNd: // global
           _sbueS::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbvNp; else goto cbvO7;
       cbvNp: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbvNs; else goto cbvNr;
       cbvNs: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvNr: // global
           _sbuex::P64 = P64[Sp + 144];
           _sbueC::P64 = P64[Sp + 16];
           _sbueD::P64 = P64[Sp + 24];
           _sbueE::P64 = P64[Sp + 32];
           _sbueF::P64 = P64[Sp + 40];
           _sbueH::P64 = P64[Sp + 48];
           _sbueJ::P64 = P64[Sp + 64];
           _sbueK::P64 = P64[Sp + 72];
           _sbueL::P64 = P64[Sp + 80];
           _sbueM::P64 = P64[Sp + 88];
           _sbueN::P64 = P64[Sp + 96];
           _sbueO::P64 = P64[Sp + 104];
           _sbueP::P64 = P64[Sp + 112];
           _sbueQ::P64 = P64[Sp + 120];
           _sbueR::P64 = P64[Sp + 128];
           call MO_WriteBarrier();
           P64[_sbueL::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbueL::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbueC::P64;
           P64[Hp - 112] = _sbueD::P64;
           P64[Hp - 104] = _sbueE::P64;
           P64[Hp - 96] = _sbueF::P64;
           P64[Hp - 88] = _sbueS::P64;
           P64[Hp - 80] = _sbueH::P64;
           P64[Hp - 72] = _sbuex::P64;
           P64[Hp - 64] = _sbueJ::P64;
           P64[Hp - 56] = _sbueK::P64;
           P64[Hp - 48] = _sbueL::P64;
           P64[Hp - 40] = _sbueM::P64;
           P64[Hp - 32] = _sbueN::P64;
           P64[Hp - 24] = _sbueO::P64;
           P64[Hp - 16] = _sbueP::P64;
           P64[Hp - 8] = _sbueQ::P64;
           P64[Hp] = _sbueR::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbvO7: // global
           I64[Sp] = block_cbvNx_info;
           R1 = _sbueS::P64;
           if (R1 & 7 != 0) goto ubvRo; else goto cbvO8;
       ubvRo: // global
           call _cbvNx(R1) args: 0, res: 0, upd: 0;
       cbvO8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvNx() //  [R1]
         { info_tbl: [(cbvNx,
                       label: block_cbvNx_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvNx: // global
           _sbuex::P64 = P64[Sp + 144];
           _cbvQY::P64 = R1 & 7;
           if (_cbvQY::P64 == 3) goto sbuf2; else goto ubvR1;
       ubvR1: // global
           if (_cbvQY::P64 == 6) goto sbuf2; else goto cbvOh;
       sbuf2: // global
           I64[Sp] = block_cbvNC_info;
           R1 = _sbuex::P64;
           if (R1 & 7 != 0) goto ubvRp; else goto cbvNE;
       ubvRp: // global
           call _cbvNC(R1) args: 0, res: 0, upd: 0;
       cbvNE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvOh: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbvOk; else goto cbvOj;
       cbvOk: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvOj: // global
           _sbueC::P64 = P64[Sp + 16];
           _sbueD::P64 = P64[Sp + 24];
           _sbueE::P64 = P64[Sp + 32];
           _sbueF::P64 = P64[Sp + 40];
           _sbueH::P64 = P64[Sp + 48];
           _sbueJ::P64 = P64[Sp + 64];
           _sbueK::P64 = P64[Sp + 72];
           _sbueL::P64 = P64[Sp + 80];
           _sbueM::P64 = P64[Sp + 88];
           _sbueN::P64 = P64[Sp + 96];
           _sbueO::P64 = P64[Sp + 104];
           _sbueP::P64 = P64[Sp + 112];
           _sbueQ::P64 = P64[Sp + 120];
           _sbueR::P64 = P64[Sp + 128];
           call MO_WriteBarrier();
           P64[_sbueL::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbueL::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbueC::P64;
           P64[Hp - 112] = _sbueD::P64;
           P64[Hp - 104] = _sbueE::P64;
           P64[Hp - 96] = _sbueF::P64;
           P64[Hp - 88] = R1;
           P64[Hp - 80] = _sbueH::P64;
           P64[Hp - 72] = _sbuex::P64;
           P64[Hp - 64] = _sbueJ::P64;
           P64[Hp - 56] = _sbueK::P64;
           P64[Hp - 48] = _sbueL::P64;
           P64[Hp - 40] = _sbueM::P64;
           P64[Hp - 32] = _sbueN::P64;
           P64[Hp - 24] = _sbueO::P64;
           P64[Hp - 16] = _sbueP::P64;
           P64[Hp - 8] = _sbueQ::P64;
           P64[Hp] = _sbueR::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvNC() //  [R1]
         { info_tbl: [(cbvNC,
                       label: block_cbvNC_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvNC: // global
           _sbueC::P64 = P64[Sp + 16];
           _sbueF::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto cbvO3; else goto cbvNQ;
       cbvO3: // global
           I64[Sp] = block_cbvNW_info;
           R2 = _sbueC::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sbueF::P64;
           P64[Sp - 8] = GHC.Types.True_closure+2;
           Sp = Sp - 24;
           call GHC.IO.Device.setRaw_entry(R2) args: 32, res: 8, upd: 8;
       cbvNQ: // global
           I64[Sp] = block_cbvNI_info;
           R2 = _sbueC::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _sbueF::P64;
           P64[Sp - 8] = GHC.Types.False_closure+1;
           P64[Sp + 144] = R1;
           Sp = Sp - 24;
           call GHC.IO.Device.setRaw_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbvNW() //  [R1]
         { info_tbl: [(cbvNW,
                       label: block_cbvNW_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvNW: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbvO6; else goto cbvO5;
       cbvO6: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvO5: // global
           _sbueC::P64 = P64[Sp + 16];
           _sbueD::P64 = P64[Sp + 24];
           _sbueE::P64 = P64[Sp + 32];
           _sbueF::P64 = P64[Sp + 40];
           _sbueH::P64 = P64[Sp + 48];
           _sbueJ::P64 = P64[Sp + 64];
           _sbueK::P64 = P64[Sp + 72];
           _sbueL::P64 = P64[Sp + 80];
           _sbueM::P64 = P64[Sp + 88];
           _sbueN::P64 = P64[Sp + 96];
           _sbueO::P64 = P64[Sp + 104];
           _sbueP::P64 = P64[Sp + 112];
           _sbueQ::P64 = P64[Sp + 120];
           _sbueR::P64 = P64[Sp + 128];
           _sbueS::P64 = P64[Sp + 8];
           call MO_WriteBarrier();
           P64[_sbueL::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbueL::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbueC::P64;
           P64[Hp - 112] = _sbueD::P64;
           P64[Hp - 104] = _sbueE::P64;
           P64[Hp - 96] = _sbueF::P64;
           P64[Hp - 88] = _sbueS::P64;
           P64[Hp - 80] = _sbueH::P64;
           P64[Hp - 72] = GHC.IO.Handle.Types.NoBuffering_closure+1;
           P64[Hp - 64] = _sbueJ::P64;
           P64[Hp - 56] = _sbueK::P64;
           P64[Hp - 48] = _sbueL::P64;
           P64[Hp - 40] = _sbueM::P64;
           P64[Hp - 32] = _sbueN::P64;
           P64[Hp - 24] = _sbueO::P64;
           P64[Hp - 16] = _sbueP::P64;
           P64[Hp - 8] = _sbueQ::P64;
           P64[Hp] = _sbueR::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvNI() //  [R1]
         { info_tbl: [(cbvNI,
                       label: block_cbvNI_info
                       rep:StackRep [False, False, False, False, False, False, True,
                                     False, False, False, False, False, False, False, False, False,
                                     True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvNI: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cbvNT; else goto cbvNS;
       cbvNT: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvNS: // global
           _sbueC::P64 = P64[Sp + 16];
           _sbueD::P64 = P64[Sp + 24];
           _sbueE::P64 = P64[Sp + 32];
           _sbueF::P64 = P64[Sp + 40];
           _sbueH::P64 = P64[Sp + 48];
           _sbueJ::P64 = P64[Sp + 64];
           _sbueK::P64 = P64[Sp + 72];
           _sbueL::P64 = P64[Sp + 80];
           _sbueM::P64 = P64[Sp + 88];
           _sbueN::P64 = P64[Sp + 96];
           _sbueO::P64 = P64[Sp + 104];
           _sbueP::P64 = P64[Sp + 112];
           _sbueQ::P64 = P64[Sp + 120];
           _sbueR::P64 = P64[Sp + 128];
           _sbueS::P64 = P64[Sp + 8];
           _sbuf3::P64 = P64[Sp + 144];
           call MO_WriteBarrier();
           P64[_sbueL::P64 + 8] = GHC.IO.Handle.Types.BufferListNil_closure+1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbueL::P64);
           I64[Hp - 128] = GHC.IO.Handle.Types.Handle___con_info;
           P64[Hp - 120] = _sbueC::P64;
           P64[Hp - 112] = _sbueD::P64;
           P64[Hp - 104] = _sbueE::P64;
           P64[Hp - 96] = _sbueF::P64;
           P64[Hp - 88] = _sbueS::P64;
           P64[Hp - 80] = _sbueH::P64;
           P64[Hp - 72] = _sbuf3::P64;
           P64[Hp - 64] = _sbueJ::P64;
           P64[Hp - 56] = _sbueK::P64;
           P64[Hp - 48] = _sbueL::P64;
           P64[Hp - 40] = _sbueM::P64;
           P64[Hp - 32] = _sbueN::P64;
           P64[Hp - 24] = _sbueO::P64;
           P64[Hp - 16] = _sbueP::P64;
           P64[Hp - 8] = _sbueQ::P64;
           P64[Hp] = _sbueR::P64;
           R1 = Hp - 127;
           Sp = Sp + 152;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubvRO_srtd" {
     ubvRO_srtd:
         const SbuCr_srt+256;
         const 34;
         const 16106127361;
 },
 GHC.IO.Handle.hSetBuffering1_entry() //  [R2, R3]
         { info_tbl: [(cbvRJ,
                       label: GHC.IO.Handle.hSetBuffering1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvRJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbvRN; else goto cbvRM;
       cbvRN: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetBuffering1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbvRM: // global
           I64[Hp - 8] = sat_sbufG_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = R2;
           R2 = GHC.IO.Handle.hSetBuffering2_closure;
           call GHC.IO.Handle.Internals.withAllHandles__1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.777823009 UTC

[section ""data" . GHC.IO.Handle.hSetBuffering_closure" {
     GHC.IO.Handle.hSetBuffering_closure:
         const GHC.IO.Handle.hSetBuffering_info;
         const 0;
 },
 GHC.IO.Handle.hSetBuffering_entry() //  [R2, R3]
         { info_tbl: [(cbvUC,
                       label: GHC.IO.Handle.hSetBuffering_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvUC: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetBuffering1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.781088433 UTC

[section ""cstring" . GHC.IO.Handle.hIsEOF4_bytes" {
     GHC.IO.Handle.hIsEOF4_bytes:
         I8[] [104,73,115,69,79,70]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.783243939 UTC

[section ""data" . GHC.IO.Handle.hIsEOF3_closure" {
     GHC.IO.Handle.hIsEOF3_closure:
         const GHC.IO.Handle.hIsEOF3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsEOF3_entry() //  [R1]
         { info_tbl: [(cbvUQ,
                       label: GHC.IO.Handle.hIsEOF3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvUQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvUR; else goto cbvUS;
       cbvUR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvUS: // global
           (_cbvUN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbvUN::I64 == 0) goto cbvUP; else goto cbvUO;
       cbvUP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbvUO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvUN::I64;
           R2 = GHC.IO.Handle.hIsEOF4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.789461602 UTC

[section ""data" . GHC.IO.Handle.hIsEOF2_closure" {
     GHC.IO.Handle.hIsEOF2_closure:
         const GHC.IO.Handle.hIsEOF2_info;
 },
 GHC.IO.Handle.hIsEOF2_entry() //  [R2]
         { info_tbl: [(cbvV8,
                       label: GHC.IO.Handle.hIsEOF2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvV8: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbvVc; else goto cbvVd;
       cbvVc: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsEOF2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvVd: // global
           I64[Sp - 8] = block_cbvV5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubvW4; else goto cbvV6;
       ubvW4: // global
           call _cbvV5(R1) args: 0, res: 0, upd: 0;
       cbvV6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvV5() //  [R1]
         { info_tbl: [(cbvV5,
                       label: block_cbvV5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvV5: // global
           _sbug2::P64 = P64[P64[R1 + 71] + 8];
           I64[Sp - 24] = block_cbvVb_info;
           _sbufL::P64 = P64[R1 + 15];
           _sbufN::P64 = P64[R1 + 31];
           _sbufP::P64 = P64[R1 + 47];
           R1 = _sbug2::P64;
           P64[Sp - 16] = _sbufN::P64;
           P64[Sp - 8] = _sbufP::P64;
           P64[Sp] = _sbufL::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubvW3; else goto cbvVf;
       ubvW3: // global
           call _cbvVb(R1) args: 0, res: 0, upd: 0;
       cbvVf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvVb() //  [R1]
         { info_tbl: [(cbvVb,
                       label: block_cbvVb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvVb: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbvVr; else goto ubvW1;
       cbvVr: // global
           _sbugd::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = block_cbvVq_info;
           R1 = _sbugd::P64;
           if (R1 & 7 != 0) goto ubvW5; else goto cbvVs;
       ubvW5: // global
           call _cbvVq(R1) args: 0, res: 0, upd: 0;
       cbvVs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubvW1: // global
           Sp = Sp + 32;
           call _cbvVA() args: 0, res: 0, upd: 0;
     }
 },
 _cbvVq() //  [R1]
         { info_tbl: [(cbvVq,
                       label: block_cbvVq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvVq: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbvVL; else goto ubvW2;
       cbvVL: // global
           _sbufN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbvVD_info;
           R2 = P64[Sp + 24];
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sbufN::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.fillReadBuffer_entry(R2) args: 32, res: 8, upd: 8;
       ubvW2: // global
           Sp = Sp + 32;
           call _cbvVA() args: 0, res: 0, upd: 0;
     }
 },
 _cbvVD() //  [R1]
         { info_tbl: [(cbvVD,
                       label: block_cbvVD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvVD: // global
           I64[Sp] = block_cbvVF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubvW8; else goto cbvVG;
       ubvW8: // global
           call _cbvVF(R1) args: 0, res: 0, upd: 0;
       cbvVG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvVF() //  [R1]
         { info_tbl: [(cbvVF,
                       label: block_cbvVF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvVF: // global
           I64[Sp] = block_cbvVK_info;
           _sbugr::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 16] = _sbugr::P64;
           if (R1 & 7 != 0) goto ubvW9; else goto cbvVO;
       ubvW9: // global
           call _cbvVK(R1) args: 0, res: 0, upd: 0;
       cbvVO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvVK() //  [R1]
         { info_tbl: [(cbvVK,
                       label: block_cbvVK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvVK: // global
           if (I64[R1 + 7] == 0) goto cbvVW; else goto cbvVV;
       cbvVW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbvVV: // global
           _sbufP::P64 = P64[Sp + 8];
           _sbugr::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbufP::P64 + 8] = _sbugr::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbufP::P64);
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvVA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvVA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.80725573 UTC

[section ""data" . GHC.IO.Handle.hIsEOF1_closure" {
     GHC.IO.Handle.hIsEOF1_closure:
         const GHC.IO.Handle.hIsEOF1_info;
         const 0;
 },
 GHC.IO.Handle.hIsEOF1_entry() //  [R2]
         { info_tbl: [(cbvX0,
                       label: GHC.IO.Handle.hIsEOF1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvX0: // global
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.811318324 UTC

[section ""data" . GHC.IO.Handle.hIsEOF_closure" {
     GHC.IO.Handle.hIsEOF_closure:
         const GHC.IO.Handle.hIsEOF_info;
         const 0;
 },
 GHC.IO.Handle.hIsEOF_entry() //  [R2]
         { info_tbl: [(cbvXb,
                       label: GHC.IO.Handle.hIsEOF_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvXb: // global
           R2 = R2;
           call GHC.IO.Handle.hIsEOF1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.8158112 UTC

[section ""data" . GHC.IO.Handle.isEOF1_closure" {
     GHC.IO.Handle.isEOF1_closure:
         const GHC.IO.Handle.isEOF1_info;
         const 0;
 },
 GHC.IO.Handle.isEOF1_entry() //  []
         { info_tbl: [(cbvXm,
                       label: GHC.IO.Handle.isEOF1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvXm: // global
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.819337417 UTC

[section ""data" . GHC.IO.Handle.isEOF_closure" {
     GHC.IO.Handle.isEOF_closure:
         const GHC.IO.Handle.isEOF_info;
         const 0;
 },
 GHC.IO.Handle.isEOF_entry() //  []
         { info_tbl: [(cbvXx,
                       label: GHC.IO.Handle.isEOF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvXx: // global
           call GHC.IO.Handle.isEOF1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.822841036 UTC

[section ""cstring" . lvl19_rbnX1_bytes" {
     lvl19_rbnX1_bytes:
         I8[] [104,83,101,116,70,105,108,101,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.82478956 UTC

[section ""data" . lvl20_rbnX2_closure" {
     lvl20_rbnX2_closure:
         const lvl20_rbnX2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl20_rbnX2_entry() //  [R1]
         { info_tbl: [(cbvXL,
                       label: lvl20_rbnX2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvXL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvXM; else goto cbvXN;
       cbvXM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvXN: // global
           (_cbvXI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbvXI::I64 == 0) goto cbvXK; else goto cbvXJ;
       cbvXK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbvXJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvXI::I64;
           R2 = lvl19_rbnX1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.832088808 UTC

[section ""data" . GHC.IO.Handle.hSetFileSize1_closure" {
     GHC.IO.Handle.hSetFileSize1_closure:
         const GHC.IO.Handle.hSetFileSize1_info;
         const 0;
 },
 act_sbugA_entry() //  [R1, R2]
         { info_tbl: [(cbvY8,
                       label: act_sbugA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvY8: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbvY9; else goto cbvYa;
       cbvY9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvYa: // global
           I64[Sp - 16] = block_cbvY5_info;
           _sbugy::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbugy::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubvZi; else goto cbvY6;
       ubvZi: // global
           call _cbvY5(R1) args: 0, res: 0, upd: 0;
       cbvY6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvY5() //  [R1]
         { info_tbl: [(cbvY5,
                       label: block_cbvY5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvY5: // global
           I64[Sp - 32] = block_cbvYd_info;
           _sbugE::P64 = P64[R1 + 7];
           _sbugF::P64 = P64[R1 + 15];
           _sbugH::P64 = P64[R1 + 31];
           _sbugJ::P64 = P64[R1 + 47];
           R1 = P64[R1 + 39];
           P64[Sp - 24] = _sbugF::P64;
           P64[Sp - 16] = _sbugH::P64;
           P64[Sp - 8] = _sbugJ::P64;
           P64[Sp] = _sbugE::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubvZh; else goto cbvYf;
       ubvZh: // global
           call _cbvYd(R1) args: 0, res: 0, upd: 0;
       cbvYf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvYd() //  [R1]
         { info_tbl: [(cbvYd,
                       label: block_cbvYd_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvYd: // global
           _cbvZe::P64 = R1 & 7;
           if (_cbvZe::P64 != 1) goto ubvZg; else goto cbvZ9;
       ubvZg: // global
           if (_cbvZe::P64 != 2) goto cbvYm; else goto cbvZd;
       cbvYm: // global
           _sbugX::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbvYj_info;
           R1 = _sbugX::P64;
           if (R1 & 7 != 0) goto ubvZj; else goto cbvYn;
       ubvZj: // global
           call _cbvYj(R1) args: 0, res: 0, upd: 0;
       cbvYn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbvZd: // global
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbvZ9: // global
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbvYj() //  [R1]
         { info_tbl: [(cbvYj,
                       label: block_cbvYj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvYj: // global
           I64[Sp] = block_cbvYr_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubvZk; else goto cbvYt;
       ubvZk: // global
           call _cbvYr(R1) args: 0, res: 0, upd: 0;
       cbvYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvYr() //  [R1]
         { info_tbl: [(cbvYr,
                       label: block_cbvYr_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvYr: // global
           if (R1 & 7 == 1) goto cbvYA; else goto cbvYH;
       cbvYA: // global
           _sbugy::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbvYx_info;
           R2 = P64[Sp + 32];
           _sbugH::P64 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_ppv_info;
           P64[Sp + 24] = _sbugH::P64;
           P64[Sp + 32] = _sbugy::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
       cbvYH: // global
           _sbuhb::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbvYF_info;
           R1 = _sbuhb::P64;
           if (R1 & 7 != 0) goto ubvZl; else goto cbvYI;
       ubvZl: // global
           call _cbvYF(R1) args: 0, res: 0, upd: 0;
       cbvYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvYx() //  []
         { info_tbl: [(cbvYx,
                       label: block_cbvYx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvYx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvYF() //  [R1]
         { info_tbl: [(cbvYF,
                       label: block_cbvYF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvYF: // global
           _sbugH::P64 = P64[Sp + 16];
           if (I64[R1 + 39] == I64[R1 + 47]) goto cbvZ3; else goto cbvYX;
       cbvZ3: // global
           _sbugy::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cbvZ2_info;
           R2 = P64[Sp + 32];
           I64[Sp + 16] = stg_ap_ppv_info;
           P64[Sp + 24] = _sbugH::P64;
           P64[Sp + 32] = _sbugy::P64;
           Sp = Sp + 16;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
       cbvYX: // global
           _sbugF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbvYQ_info;
           R2 = _sbugF::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = _sbugH::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbvZ2() //  []
         { info_tbl: [(cbvZ2,
                       label: block_cbvZ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvZ2: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbvYQ() //  [R1]
         { info_tbl: [(cbvYQ,
                       label: block_cbvYQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvYQ: // global
           _sbugy::P64 = P64[Sp + 32];
           _sbugE::P64 = P64[Sp + 24];
           _sbugH::P64 = P64[Sp + 8];
           _sbugJ::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbugJ::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbugJ::P64);
           I64[Sp + 32] = block_cbvYV_info;
           R2 = _sbugE::P64;
           I64[Sp + 8] = stg_ap_ppv_info;
           P64[Sp + 16] = _sbugH::P64;
           P64[Sp + 24] = _sbugy::P64;
           Sp = Sp + 8;
           call GHC.IO.Device.setSize_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbvYV() //  []
         { info_tbl: [(cbvYV,
                       label: block_cbvYV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvYV: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbuhI_entry() //  [R1, R2]
         { info_tbl: [(cbvZG,
                       label: sat_sbuhI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvZG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbvZH; else goto cbvZI;
       cbvZH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbvZI: // global
           I64[Sp - 16] = block_cbvZD_info;
           _sbuhC::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbuhC::P64;
           Sp = Sp - 16;
           call act_sbugA_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvZD() //  [R1]
         { info_tbl: [(cbvZD,
                       label: block_cbvZD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvZD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbvZL; else goto cbvZK;
       cbvZL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbvZK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbuhA_entry() //  [R1]
         { info_tbl: [(cbvZR,
                       label: io_sbuhA_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvZR: // global
           _sbuhA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbvZV; else goto cbvZW;
       cbvZW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbvZY; else goto cbvZX;
       cbvZY: // global
           HpAlloc = 16;
           goto cbvZV;
       cbvZV: // global
           R1 = _sbuhA::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbvZX: // global
           _sbugA::P64 = P64[_sbuhA::P64 + 7];
           _sbuhu::P64 = P64[_sbuhA::P64 + 15];
           _sbuhw::P64 = P64[_sbuhA::P64 + 23];
           I64[Hp - 8] = sat_sbuhI_info;
           P64[Hp] = _sbugA::P64;
           I64[Sp - 16] = block_cbvZM_info;
           R5 = _sbuhw::P64;
           R4 = Hp - 6;
           R3 = _sbuhu::P64;
           R2 = lvl20_rbnX2_closure;
           P64[Sp - 8] = _sbuhw::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbvZM() //  [R1]
         { info_tbl: [(cbvZM,
                       label: block_cbvZM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvZM: // global
           I64[Sp] = block_cbvZO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubw03; else goto cbvZP;
       ubw03: // global
           call _cbvZO(R1) args: 0, res: 0, upd: 0;
       cbvZP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvZO() //  [R1]
         { info_tbl: [(cbvZO,
                       label: block_cbvZO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvZO: // global
           I64[Sp] = block_cbvZU_info;
           R2 = P64[R1 + 7];
           _sbuhO::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbuhO::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvZU() //  []
         { info_tbl: [(cbvZU,
                       label: block_cbvZU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvZU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbui5_entry() //  [R1, R2]
         { info_tbl: [(cbw0l,
                       label: sat_sbui5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw0l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbw0m; else goto cbw0n;
       cbw0m: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbw0n: // global
           I64[Sp - 16] = block_cbw0i_info;
           _sbuhZ::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbuhZ::P64;
           Sp = Sp - 16;
           call act_sbugA_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw0i() //  [R1]
         { info_tbl: [(cbw0i,
                       label: block_cbw0i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw0i: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbw0q; else goto cbw0p;
       cbw0q: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbw0p: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbuhX_entry() //  [R1]
         { info_tbl: [(cbw0w,
                       label: io_sbuhX_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw0w: // global
           _sbuhX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbw0A; else goto cbw0B;
       cbw0B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbw0D; else goto cbw0C;
       cbw0D: // global
           HpAlloc = 16;
           goto cbw0A;
       cbw0A: // global
           R1 = _sbuhX::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbw0C: // global
           _sbugA::P64 = P64[_sbuhX::P64 + 7];
           _sbuhu::P64 = P64[_sbuhX::P64 + 15];
           _sbuhS::P64 = P64[_sbuhX::P64 + 23];
           I64[Hp - 8] = sat_sbui5_info;
           P64[Hp] = _sbugA::P64;
           I64[Sp - 16] = block_cbw0r_info;
           R5 = _sbuhS::P64;
           R4 = Hp - 6;
           R3 = _sbuhu::P64;
           R2 = lvl20_rbnX2_closure;
           P64[Sp - 8] = _sbuhS::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbw0r() //  [R1]
         { info_tbl: [(cbw0r,
                       label: block_cbw0r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw0r: // global
           I64[Sp] = block_cbw0t_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubw0I; else goto cbw0u;
       ubw0I: // global
           call _cbw0t(R1) args: 0, res: 0, upd: 0;
       cbw0u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw0t() //  [R1]
         { info_tbl: [(cbw0t,
                       label: block_cbw0t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw0t: // global
           I64[Sp] = block_cbw0z_info;
           R2 = P64[R1 + 7];
           _sbuib::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbuib::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw0z() //  []
         { info_tbl: [(cbw0z,
                       label: block_cbw0z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw0z: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hSetFileSize1_entry() //  [R2, R3]
         { info_tbl: [(cbw0N,
                       label: GHC.IO.Handle.hSetFileSize1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw0N: // global
           _sbugy::P64 = R3;
           _sbugx::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbw0O; else goto cbw0P;
       cbw0P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbw0R; else goto cbw0Q;
       cbw0R: // global
           HpAlloc = 16;
           goto cbw0O;
       cbw0O: // global
           R3 = _sbugy::P64;
           R2 = _sbugx::P64;
           R1 = GHC.IO.Handle.hSetFileSize1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbw0Q: // global
           I64[Hp - 8] = act_sbugA_info;
           P64[Hp] = _sbugy::P64;
           I64[Sp - 16] = block_cbvZm_info;
           R1 = _sbugx::P64;
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubw18; else goto cbvZn;
       ubw18: // global
           call _cbvZm(R1) args: 0, res: 0, upd: 0;
       cbvZn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbvZm() //  [R1]
         { info_tbl: [(cbvZm,
                       label: block_cbvZm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvZm: // global
           if (R1 & 7 == 1) goto cbw0K; else goto cbw0L;
       cbw0K: // global
           I64[Sp - 16] = block_cbvZr_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbw0L: // global
           I64[Sp - 16] = block_cbw06_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbvZr() //  [R1]
         { info_tbl: [(cbvZr,
                       label: block_cbvZr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbvZr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbw0V; else goto cbw0U;
       cbw0V: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbw0U: // global
           I64[Hp - 24] = io_sbuhA_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbvZt::P64 = Hp - 23;
           if (R1 == 0) goto cbw0Z; else goto cbw0Y;
       cbw0Z: // global
           R1 = _cbvZt::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbw0Y: // global
           R1 = _cbvZt::P64;
           Sp = Sp + 32;
           call io_sbuhA_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbw06() //  [R1]
         { info_tbl: [(cbw06,
                       label: block_cbw06_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw06: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbw13; else goto cbw12;
       cbw13: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbw12: // global
           I64[Hp - 24] = io_sbuhX_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbw08::P64 = Hp - 23;
           if (R1 == 0) goto cbw17; else goto cbw16;
       cbw17: // global
           R1 = _cbw08::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbw16: // global
           R1 = _cbw08::P64;
           Sp = Sp + 32;
           call io_sbuhX_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.88508232 UTC

[section ""data" . GHC.IO.Handle.hSetFileSize_closure" {
     GHC.IO.Handle.hSetFileSize_closure:
         const GHC.IO.Handle.hSetFileSize_info;
         const 0;
 },
 GHC.IO.Handle.hSetFileSize_entry() //  [R2, R3]
         { info_tbl: [(cbw3H,
                       label: GHC.IO.Handle.hSetFileSize_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw3H: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetFileSize1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.888310885 UTC

[section ""cstring" . GHC.IO.Handle.hFileSize9_bytes" {
     GHC.IO.Handle.hFileSize9_bytes:
         I8[] [104,70,105,108,101,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.890130646 UTC

[section ""data" . GHC.IO.Handle.hFileSize8_closure" {
     GHC.IO.Handle.hFileSize8_closure:
         const GHC.IO.Handle.hFileSize8_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize8_entry() //  [R1]
         { info_tbl: [(cbw3V,
                       label: GHC.IO.Handle.hFileSize8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw3V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbw3W; else goto cbw3X;
       cbw3W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbw3X: // global
           (_cbw3S::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbw3S::I64 == 0) goto cbw3U; else goto cbw3T;
       cbw3U: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbw3T: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbw3S::I64;
           R2 = GHC.IO.Handle.hFileSize9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.894976458 UTC

[section ""cstring" . GHC.IO.Handle.hFileSize7_bytes" {
     GHC.IO.Handle.hFileSize7_bytes:
         I8[] [110,111,116,32,97,32,114,101,103,117,108,97,114,32,102,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.896787418 UTC

[section ""data" . GHC.IO.Handle.hFileSize6_closure" {
     GHC.IO.Handle.hFileSize6_closure:
         const GHC.IO.Handle.hFileSize6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize6_entry() //  [R1]
         { info_tbl: [(cbw4d,
                       label: GHC.IO.Handle.hFileSize6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw4d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbw4e; else goto cbw4f;
       cbw4e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbw4f: // global
           (_cbw4a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbw4a::I64 == 0) goto cbw4c; else goto cbw4b;
       cbw4c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbw4b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbw4a::I64;
           R2 = GHC.IO.Handle.hFileSize7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.900529779 UTC

[section ""data" . GHC.IO.Handle.hFileSize5_closure" {
     GHC.IO.Handle.hFileSize5_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InappropriateType_closure+1;
         const GHC.IO.Handle.hFileSize8_closure;
         const GHC.IO.Handle.hFileSize6_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.902612814 UTC

[section ""data" . GHC.IO.Handle.hFileSize4_closure" {
     GHC.IO.Handle.hFileSize4_closure:
         const GHC.IO.Handle.hFileSize4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize4_entry() //  [R1]
         { info_tbl: [(cbw4v,
                       label: GHC.IO.Handle.hFileSize4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw4v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbw4w; else goto cbw4x;
       cbw4w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbw4x: // global
           (_cbw4s::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbw4s::I64 == 0) goto cbw4u; else goto cbw4t;
       cbw4u: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbw4t: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbw4s::I64;
           R2 = GHC.IO.Handle.hFileSize5_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.906500631 UTC

[section ""data" . sat_sbuie_closure" {
     sat_sbuie_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.908172032 UTC

[section ""data" . sat_sbuif_closure" {
     sat_sbuif_closure:
         const :_con_info;
         const sat_sbuie_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.910473109 UTC

[section ""data" . GHC.IO.Handle.hFileSize10_closure" {
     GHC.IO.Handle.hFileSize10_closure:
         const GHC.IO.Handle.hFileSize10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hFileSize10_entry() //  [R1]
         { info_tbl: [(cbw4O,
                       label: GHC.IO.Handle.hFileSize10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw4O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbw4P; else goto cbw4Q;
       cbw4P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbw4Q: // global
           (_cbw4L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbw4L::I64 == 0) goto cbw4N; else goto cbw4M;
       cbw4N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbw4M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbw4L::I64;
           R3 = sat_sbuif_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.915568238 UTC

[section ""data" . GHC.IO.Handle.hFileSize3_closure" {
     GHC.IO.Handle.hFileSize3_closure:
         const GHC.IO.Handle.hFileSize3_info;
         const 0;
 },
 section ""relreadonly" . ubw6B_srtd" {
     ubw6B_srtd:
         const SbuCr_srt+328;
         const 38;
         const 240522362881;
 },
 GHC.IO.Handle.hFileSize3_entry() //  [R2]
         { info_tbl: [(cbw57,
                       label: GHC.IO.Handle.hFileSize3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw57: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbw58; else goto cbw59;
       cbw58: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbw59: // global
           I64[Sp - 8] = block_cbw54_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubw6u; else goto cbw55;
       ubw6u: // global
           call _cbw54(R1) args: 0, res: 0, upd: 0;
       cbw55: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubw6C_srtd" {
     ubw6C_srtd:
         const SbuCr_srt+328;
         const 38;
         const 206162624513;
 },
 _cbw54() //  [R1]
         { info_tbl: [(cbw54,
                       label: block_cbw54_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw54: // global
           I64[Sp - 32] = block_cbw5c_info;
           _sbuij::P64 = P64[R1 + 7];
           _sbuik::P64 = P64[R1 + 15];
           _sbuim::P64 = P64[R1 + 31];
           _sbuio::P64 = P64[R1 + 47];
           R1 = P64[R1 + 39];
           P64[Sp - 24] = _sbuik::P64;
           P64[Sp - 16] = _sbuim::P64;
           P64[Sp - 8] = _sbuio::P64;
           P64[Sp] = _sbuij::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubw6t; else goto cbw5e;
       ubw6t: // global
           call _cbw5c(R1) args: 0, res: 0, upd: 0;
       cbw5e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubw6D_srtd" {
     ubw6D_srtd:
         const SbuCr_srt+328;
         const 38;
         const 206162624513;
 },
 _cbw5c() //  [R1]
         { info_tbl: [(cbw5c,
                       label: block_cbw5c_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw5c: // global
           _cbw6k::P64 = R1 & 7;
           if (_cbw6k::P64 != 1) goto ubw6p; else goto cbw6f;
       ubw6p: // global
           if (_cbw6k::P64 != 2) goto cbw5l; else goto cbw6j;
       cbw5l: // global
           _sbuiC::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbw5i_info;
           R1 = _sbuiC::P64;
           if (R1 & 7 != 0) goto ubw6v; else goto cbw5m;
       ubw6v: // global
           call _cbw5i(R1) args: 0, res: 0, upd: 0;
       cbw5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbw6j: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbw6f: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbw5i() //  [R1]
         { info_tbl: [(cbw5i,
                       label: block_cbw5i_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw5i: // global
           I64[Sp] = block_cbw5s_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto ubw6w; else goto cbw5M;
       ubw6w: // global
           call _cbw5s(R1) args: 0, res: 0, upd: 0;
       cbw5M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw5s() //  [R1]
         { info_tbl: [(cbw5s,
                       label: block_cbw5s_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw5s: // global
           if (R1 & 7 == 1) goto ubw6q; else goto cbw5X;
       ubw6q: // global
           Sp = Sp + 16;
           call _sbuiK() args: 0, res: 0, upd: 0;
       cbw5X: // global
           _sbuiT::P64 = P64[P64[Sp + 24] + 8];
           I64[Sp] = block_cbw5V_info;
           R1 = _sbuiT::P64;
           if (R1 & 7 != 0) goto ubw6x; else goto cbw5Y;
       ubw6x: // global
           call _cbw5V(R1) args: 0, res: 0, upd: 0;
       cbw5Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw5V() //  [R1]
         { info_tbl: [(cbw5V,
                       label: block_cbw5V_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw5V: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto ubw6r; else goto cbw68;
       ubw6r: // global
           Sp = Sp + 16;
           call _sbuiK() args: 0, res: 0, upd: 0;
       cbw68: // global
           _sbuik::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbw66_info;
           R2 = _sbuik::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.BufferedIO.flushWriteBuffer_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbw66() //  [R1]
         { info_tbl: [(cbw66,
                       label: block_cbw66_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw66: // global
           _sbuio::P64 = P64[Sp + 16];
           call MO_WriteBarrier();
           P64[_sbuio::P64 + 8] = R1;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sbuio::P64);
           Sp = Sp + 8;
           call _sbuiK() args: 0, res: 0, upd: 0;
     }
 },
 _sbuiK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbuiK: // global
           _sbuij::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbw5x_info;
           R2 = _sbuij::P64;
           _sbuim::P64 = P64[Sp];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbuim::P64;
           call GHC.IO.Device.getSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbw5x() //  [R1]
         { info_tbl: [(cbw5x,
                       label: block_cbw5x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw5x: // global
           I64[Sp - 8] = block_cbw5z_info;
           R3 = GHC.IO.Handle.hFileSize10_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbw5z() //  [R1]
         { info_tbl: [(cbw5z,
                       label: block_cbw5z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw5z: // global
           if (R1 == 1) goto cbw5L; else goto cbw5H;
       cbw5L: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbw5H: // global
           R1 = GHC.IO.Handle.hFileSize4_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.939644964 UTC

[section ""data" . GHC.IO.Handle.hFileSize2_closure" {
     GHC.IO.Handle.hFileSize2_closure:
         const GHC.IO.Handle.hFileSize2_info;
         const 0;
 },
 GHC.IO.Handle.hFileSize2_entry() //  [R2]
         { info_tbl: [(cbw7H,
                       label: GHC.IO.Handle.hFileSize2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw7H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbw7I; else goto cbw7J;
       cbw7I: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbw7J: // global
           I64[Sp - 16] = block_cbw7E_info;
           _sbuj6::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbuj6::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hFileSize3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbw7E() //  [R1]
         { info_tbl: [(cbw7E,
                       label: block_cbw7E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw7E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbw7M; else goto cbw7L;
       cbw7M: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbw7L: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.946829017 UTC

[section ""data" . GHC.IO.Handle.hFileSize1_closure" {
     GHC.IO.Handle.hFileSize1_closure:
         const GHC.IO.Handle.hFileSize1_info;
         const 0;
 },
 io_sbujk_entry() //  [R1]
         { info_tbl: [(cbw8k,
                       label: io_sbujk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbw8o; else goto cbw8p;
       cbw8o: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbw8p: // global
           I64[Sp - 16] = block_cbw8f_info;
           _sbujg::P64 = P64[R1 + 15];
           R5 = _sbujg::P64;
           R4 = GHC.IO.Handle.hFileSize2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFileSize8_closure;
           P64[Sp - 8] = _sbujg::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbw8f() //  [R1]
         { info_tbl: [(cbw8f,
                       label: block_cbw8f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8f: // global
           I64[Sp] = block_cbw8h_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubw8u; else goto cbw8i;
       ubw8u: // global
           call _cbw8h(R1) args: 0, res: 0, upd: 0;
       cbw8i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw8h() //  [R1]
         { info_tbl: [(cbw8h,
                       label: block_cbw8h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8h: // global
           I64[Sp] = block_cbw8n_info;
           R2 = P64[R1 + 7];
           _sbujr::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbujr::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw8n() //  []
         { info_tbl: [(cbw8n,
                       label: block_cbw8n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8n: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbujA_entry() //  [R1]
         { info_tbl: [(cbw8J,
                       label: io_sbujA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbw8N; else goto cbw8O;
       cbw8N: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbw8O: // global
           I64[Sp - 16] = block_cbw8E_info;
           _sbujv::P64 = P64[R1 + 15];
           R5 = _sbujv::P64;
           R4 = GHC.IO.Handle.hFileSize2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hFileSize8_closure;
           P64[Sp - 8] = _sbujv::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbw8E() //  [R1]
         { info_tbl: [(cbw8E,
                       label: block_cbw8E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8E: // global
           I64[Sp] = block_cbw8G_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubw8T; else goto cbw8H;
       ubw8T: // global
           call _cbw8G(R1) args: 0, res: 0, upd: 0;
       cbw8H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw8G() //  [R1]
         { info_tbl: [(cbw8G,
                       label: block_cbw8G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8G: // global
           I64[Sp] = block_cbw8M_info;
           R2 = P64[R1 + 7];
           _sbujH::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbujH::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw8M() //  []
         { info_tbl: [(cbw8M,
                       label: block_cbw8M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8M: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hFileSize1_entry() //  [R2]
         { info_tbl: [(cbw8Y,
                       label: GHC.IO.Handle.hFileSize1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8Y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbw8Z; else goto cbw90;
       cbw8Z: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hFileSize1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbw90: // global
           I64[Sp - 8] = block_cbw83_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubw9h; else goto cbw84;
       ubw9h: // global
           call _cbw83(R1) args: 0, res: 0, upd: 0;
       cbw84: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbw83() //  [R1]
         { info_tbl: [(cbw83,
                       label: block_cbw83_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw83: // global
           if (R1 & 7 == 1) goto cbw8V; else goto cbw8W;
       cbw8V: // global
           I64[Sp - 16] = block_cbw88_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbw8W: // global
           I64[Sp - 16] = block_cbw8x_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbw88() //  [R1]
         { info_tbl: [(cbw88,
                       label: block_cbw88_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw88: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbw94; else goto cbw93;
       cbw94: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbw93: // global
           I64[Hp - 16] = io_sbujk_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbw8a::P64 = Hp - 15;
           if (R1 == 0) goto cbw98; else goto cbw97;
       cbw98: // global
           R1 = _cbw8a::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbw97: // global
           R1 = _cbw8a::P64;
           Sp = Sp + 24;
           call io_sbujk_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbw8x() //  [R1]
         { info_tbl: [(cbw8x,
                       label: block_cbw8x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbw8x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbw9c; else goto cbw9b;
       cbw9c: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbw9b: // global
           I64[Hp - 16] = io_sbujA_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbw8z::P64 = Hp - 15;
           if (R1 == 0) goto cbw9g; else goto cbw9f;
       cbw9g: // global
           R1 = _cbw8z::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbw9f: // global
           R1 = _cbw8z::P64;
           Sp = Sp + 24;
           call io_sbujA_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.971262087 UTC

[section ""data" . GHC.IO.Handle.hFileSize_closure" {
     GHC.IO.Handle.hFileSize_closure:
         const GHC.IO.Handle.hFileSize_info;
         const 0;
 },
 GHC.IO.Handle.hFileSize_entry() //  [R2]
         { info_tbl: [(cbwao,
                       label: GHC.IO.Handle.hFileSize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwao: // global
           R2 = R2;
           call GHC.IO.Handle.hFileSize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.975203974 UTC

[section ""data" . lvl21_rbnX3_closure" {
     lvl21_rbnX3_closure:
         const GHC.Base.Just_con_info;
         const GHC.IO.Handle.Internals.handleFinalizer1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:28.982342746 UTC

[section ""data" . GHC.IO.Handle.hDuplicateTo1_closure" {
     GHC.IO.Handle.hDuplicateTo1_closure:
         const GHC.IO.Handle.hDuplicateTo1_info;
         const 0;
 },
 sat_sbuk4_entry() //  [R1, R2]
         { info_tbl: [(cbwaZ,
                       label: sat_sbuk4_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwaZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwb0; else goto cbwb1;
       cbwb0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwb1: // global
           I64[Sp - 16] = block_cbwaW_info;
           R6 = R2;
           R5 = P64[R1 + 22];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 6];
           _sbujY::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = lvl21_rbnX3_closure+2;
           P64[Sp - 8] = _sbujY::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbwaW() //  [R1]
         { info_tbl: [(cbwaW,
                       label: block_cbwaW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwaW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwb4; else goto cbwb3;
       cbwb4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwb3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwcR_srtd" {
     ubwcR_srtd:
         const SbuCr_srt+176;
         const 64;
         const 17293822569102704641;
 },
 sat_sbuk5_entry() //  [R1, R2]
         { info_tbl: [(cbwb5,
                       label: sat_sbuk5_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwb5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbwb6; else goto cbwb7;
       cbwb6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwb7: // global
           I64[Sp - 40] = block_cbwaP_info;
           _sbujT::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 14];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _sbujT::P64;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwcS_srtd" {
     ubwcS_srtd:
         const SbuCr_srt+176;
         const 64;
         const 12682136550675316737;
 },
 _cbwaP() //  [R1]
         { info_tbl: [(cbwaP,
                       label: block_cbwaP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwaP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbwba; else goto cbwb9;
       cbwba: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwb9: // global
           I64[Hp - 24] = sat_sbuk4_info;
           _sbujN::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sbujN::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 32];
           R5 = Hp - 22;
           R4 = P64[Sp + 24];
           R3 = _sbujN::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbukt_entry() //  [R1, R2]
         { info_tbl: [(cbwby,
                       label: sat_sbukt_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwby: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwbz; else goto cbwbA;
       cbwbz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwbA: // global
           I64[Sp - 16] = block_cbwbv_info;
           R6 = R2;
           R5 = P64[R1 + 22];
           R4 = GHC.Base.Nothing_closure+1;
           R3 = P64[R1 + 6];
           _sbukn::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = lvl21_rbnX3_closure+2;
           P64[Sp - 8] = _sbukn::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbwbv() //  [R1]
         { info_tbl: [(cbwbv,
                       label: block_cbwbv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwbv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwbD; else goto cbwbC;
       cbwbD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwbC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwcT_srtd" {
     ubwcT_srtd:
         const SbuCr_srt+176;
         const 64;
         const 17293822569102704641;
 },
 sat_sbuku_entry() //  [R1, R2]
         { info_tbl: [(cbwbE,
                       label: sat_sbuku_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwbE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbwbF; else goto cbwbG;
       cbwbF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwbG: // global
           I64[Sp - 40] = block_cbwbo_info;
           _sbuki::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 14];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _sbuki::P64;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwcU_srtd" {
     ubwcU_srtd:
         const SbuCr_srt+176;
         const 64;
         const 12682136550675316737;
 },
 _cbwbo() //  [R1]
         { info_tbl: [(cbwbo,
                       label: block_cbwbo_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwbo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbwbJ; else goto cbwbI;
       cbwbJ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwbI: // global
           I64[Hp - 24] = sat_sbukt_info;
           _sbujN::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sbujN::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 32];
           R5 = Hp - 22;
           R4 = P64[Sp + 24];
           R3 = _sbujN::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbukL_entry() //  [R1, R2]
         { info_tbl: [(cbwc3,
                       label: sat_sbukL_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwc3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwc4; else goto cbwc5;
       cbwc4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwc5: // global
           I64[Sp - 16] = block_cbwc0_info;
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 6];
           _sbukF::P64 = R2;
           R2 = P64[R1 + 14];
           P64[Sp - 24] = GHC.Base.Nothing_closure+1;
           P64[Sp - 8] = _sbukF::P64;
           Sp = Sp - 24;
           call dupHandleTo_rbnWN_entry(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbwc0() //  [R1]
         { info_tbl: [(cbwc0,
                       label: block_cbwc0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwc0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwc8; else goto cbwc7;
       cbwc8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwc7: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwcV_srtd" {
     ubwcV_srtd:
         const SbuCr_srt+176;
         const 64;
         const 16140901064495857665;
 },
 sat_sbukM_entry() //  [R1, R2]
         { info_tbl: [(cbwc9,
                       label: sat_sbukM_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwc9: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbwca; else goto cbwcb;
       cbwca: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwcb: // global
           I64[Sp - 48] = block_cbwbT_info;
           _sbukA::P64 = R2;
           R2 = R2;
           P64[Sp - 40] = P64[R1 + 6];
           P64[Sp - 32] = P64[R1 + 14];
           P64[Sp - 24] = P64[R1 + 22];
           P64[Sp - 16] = P64[R1 + 30];
           P64[Sp - 8] = _sbukA::P64;
           Sp = Sp - 48;
           call GHC.IO.Handle.Internals.hClose_help1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwcW_srtd" {
     ubwcW_srtd:
         const SbuCr_srt+176;
         const 64;
         const 11529215046068469761;
 },
 _cbwbT() //  [R1]
         { info_tbl: [(cbwbT,
                       label: block_cbwbT_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwbT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbwce; else goto cbwcd;
       cbwce: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwcd: // global
           I64[Hp - 32] = sat_sbukL_info;
           _sbujN::P64 = P64[Sp + 8];
           P64[Hp - 24] = _sbujN::P64;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R5 = Hp - 30;
           R4 = P64[Sp + 24];
           R3 = _sbujN::P64;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 48;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwcX_srtd" {
     ubwcX_srtd:
         const SbuCr_srt+176;
         const 66;
         const 17293822569102704645;
         const 3;
 },
 GHC.IO.Handle.hDuplicateTo1_entry() //  [R2, R3]
         { info_tbl: [(cbwcj,
                       label: GHC.IO.Handle.hDuplicateTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwcj: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbwck; else goto cbwcl;
       cbwck: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hDuplicateTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbwcl: // global
           I64[Sp - 16] = block_cbwaA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubwcQ; else goto cbwaB;
       ubwcQ: // global
           call _cbwaA(R1) args: 0, res: 0, upd: 0;
       cbwaB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwcY_srtd" {
     ubwcY_srtd:
         const SbuCr_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbwaA() //  [R1]
         { info_tbl: [(cbwaA,
                       label: block_cbwaA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwaA: // global
           _sbujL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbwcg; else goto cbwch;
       cbwcg: // global
           I64[Sp - 16] = block_cbwaF_info;
           _sbujN::P64 = R1;
           _sbujO::P64 = P64[R1 + 7];
           _sbujP::P64 = P64[R1 + 15];
           R1 = _sbujL::P64;
           P64[Sp - 8] = _sbujP::P64;
           P64[Sp] = _sbujO::P64;
           P64[Sp + 8] = _sbujN::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubwcM; else goto cbwaG;
       ubwcM: // global
           call _cbwaF(R1) args: 0, res: 0, upd: 0;
       cbwaG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cbwch: // global
           I64[Sp - 24] = block_cbwbd_info;
           _sbujN::P64 = R1;
           _sbuk9::P64 = P64[R1 + 6];
           _sbuka::P64 = P64[R1 + 14];
           _sbukb::P64 = P64[R1 + 22];
           R1 = _sbujL::P64;
           P64[Sp - 16] = _sbuka::P64;
           P64[Sp - 8] = _sbukb::P64;
           P64[Sp] = _sbuk9::P64;
           P64[Sp + 8] = _sbujN::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubwcN; else goto cbwbe;
       ubwcN: // global
           call _cbwbd(R1) args: 0, res: 0, upd: 0;
       cbwbe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwcZ_srtd" {
     ubwcZ_srtd:
         const SbuCr_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbwaF() //  [R1]
         { info_tbl: [(cbwaF,
                       label: block_cbwaF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwaF: // global
           if (R1 & 7 == 1) goto cbwco; else goto ubwcL;
       cbwco: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbwcr; else goto cbwcq;
       cbwcr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwcq: // global
           _sbujS::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sbuk5_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R5 = Hp - 22;
           R4 = _sbujS::P64;
           R3 = R1;
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
       ubwcL: // global
           Sp = Sp + 24;
           call _cbwcA() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . ubwd0_srtd" {
     ubwd0_srtd:
         const SbuCr_srt+176;
         const 65;
         const 17293822569102704645;
         const 1;
 },
 _cbwbd() //  [R1]
         { info_tbl: [(cbwbd,
                       label: block_cbwbd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwbd: // global
           if (R1 & 7 == 1) goto ubwcK; else goto cbwcB;
       ubwcK: // global
           Sp = Sp + 32;
           call _cbwcA() args: 0, res: 0, upd: 0;
       cbwcB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbwcE; else goto cbwcD;
       cbwcE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwcD: // global
           _sbukg::P64 = P64[R1 + 14];
           _sbukh::P64 = P64[R1 + 22];
           I64[Hp - 24] = sat_sbuku_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 16];
           I64[Sp - 16] = block_cbwbK_info;
           R5 = Hp - 22;
           R4 = _sbukh::P64;
           R3 = R1;
           R2 = lvl1_rbnWC_closure;
           P64[Sp - 8] = _sbukg::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwcA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwcA: // global
           R2 = P64[Sp];
           Sp = Sp + 8;
           call ioe_dupHandlesNotCompatible_rbnWF_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwd1_srtd" {
     ubwd1_srtd:
         const SbuCr_srt+176;
         const 65;
         const 16140901064495857665;
         const 1;
 },
 _cbwbK() //  [R1]
         { info_tbl: [(cbwbK,
                       label: block_cbwbK_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwbK: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbwcH; else goto cbwcG;
       cbwcH: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwcG: // global
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = P64[Sp + 32];
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = sat_sbukM_info;
           P64[Hp - 24] = P64[Sp + 48];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 46;
           R5 = Hp - 30;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = lvl1_rbnWC_closure;
           Sp = Sp + 56;
           call GHC.IO.Handle.Internals.$wwithHandle__'_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.033507858 UTC

[section ""data" . GHC.IO.Handle.hDuplicateTo_closure" {
     GHC.IO.Handle.hDuplicateTo_closure:
         const GHC.IO.Handle.hDuplicateTo_info;
         const 0;
 },
 GHC.IO.Handle.hDuplicateTo_entry() //  [R2, R3]
         { info_tbl: [(cbwfp,
                       label: GHC.IO.Handle.hDuplicateTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwfp: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hDuplicateTo1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.036668407 UTC

[section ""cstring" . lvl22_rbnX4_bytes" {
     lvl22_rbnX4_bytes:
         I8[] [104,68,117,112,108,105,99,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.038773247 UTC

[section ""data" . lvl23_rbnX5_closure" {
     lvl23_rbnX5_closure:
         const lvl23_rbnX5_info;
         const 0;
         const 0;
         const 0;
 },
 lvl23_rbnX5_entry() //  [R1]
         { info_tbl: [(cbwfD,
                       label: lvl23_rbnX5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwfD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwfE; else goto cbwfF;
       cbwfE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwfF: // global
           (_cbwfA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwfA::I64 == 0) goto cbwfC; else goto cbwfB;
       cbwfC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwfB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwfA::I64;
           R2 = lvl22_rbnX4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.04259904 UTC

[section ""cstring" . lvl24_rbnX6_bytes" {
     lvl24_rbnX6_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,54,50,54,58,51,45,51,51]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.044373196 UTC

[section ""data" . lvl25_rbnX7_closure" {
     lvl25_rbnX7_closure:
         const lvl25_rbnX7_info;
         const 0;
 },
 lvl25_rbnX7_entry() //  []
         { info_tbl: [(cbwfV,
                       label: lvl25_rbnX7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwfV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbwfW; else goto cbwfX;
       cbwfW: // global
           R1 = lvl25_rbnX7_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwfX: // global
           I64[Sp - 8] = block_cbwfT_info;
           R2 = lvl24_rbnX6_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwfT() //  [R1]
         { info_tbl: [(cbwfT,
                       label: block_cbwfT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwfT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.049043629 UTC

[section ""cstring" . lvl26_rbnX8_bytes" {
     lvl26_rbnX8_bytes:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,71,72,67,47,73,79,47,72,97,110,100,108,101,46,104,115,58,54,50,51,58,51,45,51,53]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.051398914 UTC

[section ""data" . lvl27_rbnX9_closure" {
     lvl27_rbnX9_closure:
         const lvl27_rbnX9_info;
         const 0;
 },
 lvl27_rbnX9_entry() //  []
         { info_tbl: [(cbwgh,
                       label: lvl27_rbnX9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwgh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbwgi; else goto cbwgj;
       cbwgi: // global
           R1 = lvl27_rbnX9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwgj: // global
           I64[Sp - 8] = block_cbwgf_info;
           R2 = lvl26_rbnX8_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwgf() //  [R1]
         { info_tbl: [(cbwgf,
                       label: block_cbwgf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwgf: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.059530928 UTC

[section ""data" . GHC.IO.Handle.hDuplicate1_closure" {
     GHC.IO.Handle.hDuplicate1_closure:
         const GHC.IO.Handle.hDuplicate1_info;
         const 0;
 },
 section ""relreadonly" . ubwjd_srtd" {
     ubwjd_srtd:
         const SbuCr_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 sat_sbulp_entry() //  [R1, R2]
         { info_tbl: [(cbwgN,
                       label: sat_sbulp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwgN: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbwgX; else goto cbwgY;
       cbwgX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwgY: // global
           I64[Sp - 16] = block_cbwgK_info;
           _sbukU::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbukU::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubwh5; else goto cbwgL;
       ubwh5: // global
           call _cbwgK(R1) args: 0, res: 0, upd: 0;
       cbwgL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwje_srtd" {
     ubwje_srtd:
         const SbuCr_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 _cbwgK() //  [R1]
         { info_tbl: [(cbwgK,
                       label: block_cbwgK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwgK: // global
           I64[Sp - 40] = block_cbwgQ_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwjf_srtd" {
     ubwjf_srtd:
         const SbuCr_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbwgQ() //  []
         { info_tbl: [(cbwgQ,
                       label: block_cbwgQ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwgQ: // global
           I64[Sp] = block_cbwgS_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 16;
           call GHC.IO.Device.dup_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwjg_srtd" {
     ubwjg_srtd:
         const SbuCr_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbwgS() //  [R1]
         { info_tbl: [(cbwgS,
                       label: block_cbwgS_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwgS: // global
           I64[Sp + 32] = block_cbwgU_info;
           R6 = P64[Sp + 48];
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = lvl21_rbnX3_closure+2;
           Sp = Sp + 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbwgU() //  [R1]
         { info_tbl: [(cbwgU,
                       label: block_cbwgU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwgU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwh4; else goto cbwh3;
       cbwh4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwh3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwjh_srtd" {
     ubwjh_srtd:
         const SbuCr_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 sat_sbulW_entry() //  [R1, R2]
         { info_tbl: [(cbwhg,
                       label: sat_sbulW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhg: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cbwhq; else goto cbwhr;
       cbwhq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwhr: // global
           I64[Sp - 16] = block_cbwhd_info;
           _sbulq::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbulq::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubwhy; else goto cbwhe;
       ubwhy: // global
           call _cbwhd(R1) args: 0, res: 0, upd: 0;
       cbwhe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwji_srtd" {
     ubwji_srtd:
         const SbuCr_srt+96;
         const 71;
         const 32769;
         const 64;
 },
 _cbwhd() //  [R1]
         { info_tbl: [(cbwhd,
                       label: block_cbwhd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhd: // global
           I64[Sp - 40] = block_cbwhj_info;
           R2 = R1;
           P64[Sp - 32] = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 15];
           P64[Sp - 16] = P64[R1 + 23];
           P64[Sp - 8] = P64[R1 + 31];
           P64[Sp] = R1;
           Sp = Sp - 40;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwjj_srtd" {
     ubwjj_srtd:
         const SbuCr_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbwhj() //  []
         { info_tbl: [(cbwhj,
                       label: block_cbwhj_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhj: // global
           I64[Sp] = block_cbwhl_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_pv_info;
           P64[Sp - 8] = P64[Sp + 32];
           Sp = Sp - 16;
           call GHC.IO.Device.dup_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwjk_srtd" {
     ubwjk_srtd:
         const SbuCr_srt+216;
         const 56;
         const 36028797018963969;
 },
 _cbwhl() //  [R1]
         { info_tbl: [(cbwhl,
                       label: block_cbwhl_info
                       rep:StackRep [False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhl: // global
           I64[Sp + 32] = block_cbwhn_info;
           R6 = P64[Sp + 48];
           R5 = R1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 16] = P64[Sp + 40];
           P64[Sp + 24] = lvl21_rbnX3_closure+2;
           Sp = Sp + 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbwhn() //  [R1]
         { info_tbl: [(cbwhn,
                       label: block_cbwhn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwhx; else goto cbwhw;
       cbwhx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwhw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbumO_entry() //  [R1, R2]
         { info_tbl: [(cbwi2,
                       label: sat_sbumO_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwi2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbwi8; else goto cbwi9;
       cbwi8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwi9: // global
           I64[Sp - 32] = block_cbwhZ_info;
           _sbulq::P64 = P64[R1 + 6];
           _sbum4::P64 = P64[R1 + 14];
           _sbum7::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 24] = _sbulq::P64;
           P64[Sp - 16] = _sbum4::P64;
           P64[Sp - 8] = _sbum7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubwie; else goto cbwi0;
       ubwie: // global
           call _cbwhZ(R1) args: 0, res: 0, upd: 0;
       cbwi0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwhZ() //  [R1]
         { info_tbl: [(cbwhZ,
                       label: block_cbwhZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhZ: // global
           _sbum4::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbwi5_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _sbum4::P64;
           P64[Sp] = P64[Sp + 24];
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call dupHandle__rbnWK_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbwi5() //  [R1]
         { info_tbl: [(cbwi5,
                       label: block_cbwi5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwi5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwid; else goto cbwic;
       cbwid: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwic: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwjl_srtd" {
     ubwjl_srtd:
         const SbuCr_srt+96;
         const 81;
         const 1;
         const 98816;
 },
 sat_sbumT_entry() //  [R1, R2]
         { info_tbl: [(cbwif,
                       label: sat_sbumT_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwif: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbwij; else goto cbwik;
       cbwij: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwik: // global
           I64[Sp - 40] = block_cbwhN_info;
           _sbukT::P64 = P64[R1 + 6];
           _sbulq::P64 = P64[R1 + 14];
           _sbum2::P64 = P64[R1 + 22];
           _sbum4::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 32] = _sbukT::P64;
           P64[Sp - 24] = _sbulq::P64;
           P64[Sp - 16] = _sbum2::P64;
           P64[Sp - 8] = _sbum4::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubwis; else goto cbwhO;
       ubwis: // global
           call _cbwhN(R1) args: 0, res: 0, upd: 0;
       cbwhO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwjm_srtd" {
     ubwjm_srtd:
         const SbuCr_srt+96;
         const 81;
         const 1;
         const 98816;
 },
 _cbwhN() //  [R1]
         { info_tbl: [(cbwhN,
                       label: block_cbwhN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhN: // global
           I64[Sp - 8] = block_cbwhS_info;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.flushBuffer1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwhS() //  [R1]
         { info_tbl: [(cbwhS,
                       label: block_cbwhS_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbwio; else goto cbwin;
       cbwio: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwin: // global
           I64[Hp - 24] = sat_sbumO_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_cbwig_info;
           R5 = Hp - 22;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 16];
           R2 = lvl7_rbnWP_closure;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwig() //  [R1]
         { info_tbl: [(cbwig,
                       label: block_cbwig_info
                       rep:StackRep [False, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwig: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwir; else goto cbwiq;
       cbwir: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwiq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwjn_srtd" {
     ubwjn_srtd:
         const SbuCr_srt+96;
         const 83;
         const 1;
         const 512576;
 },
 GHC.IO.Handle.hDuplicate1_entry() //  [R2]
         { info_tbl: [(cbwix,
                       label: GHC.IO.Handle.hDuplicate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwix: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbwiy; else goto cbwiz;
       cbwiy: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hDuplicate1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwiz: // global
           I64[Sp - 8] = block_cbwgA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwjb; else goto cbwgB;
       ubwjb: // global
           call _cbwgA(R1) args: 0, res: 0, upd: 0;
       cbwgB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwjo_srtd" {
     ubwjo_srtd:
         const SbuCr_srt+96;
         const 83;
         const 1;
         const 381504;
 },
 _cbwgA() //  [R1]
         { info_tbl: [(cbwgA,
                       label: block_cbwgA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwgA: // global
           if (R1 & 7 == 1) goto cbwiu; else goto cbwiv;
       cbwiu: // global
           Hp = Hp + 16;
           _sbukT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbwiF; else goto cbwiB;
       cbwiB: // global
           _sbukU::P64 = P64[_sbukT::P64 + 7];
           _sbukV::P64 = P64[_sbukT::P64 + 15];
           I64[Hp - 8] = sat_sbulp_info;
           P64[Hp] = _sbukU::P64;
           R5 = Hp - 6;
           R4 = _sbukV::P64;
           R3 = _sbukT::P64;
           R2 = lvl23_rbnX5_closure;
           Sp = Sp + 8;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
       cbwiv: // global
           Hp = Hp + 16;
           _sbukT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbwiF; else goto cbwiE;
       cbwiF: // global
           HpAlloc = 16;
           R1 = _sbukT::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwiE: // global
           _sbulq::P64 = P64[_sbukT::P64 + 6];
           _sbulr::P64 = P64[_sbukT::P64 + 14];
           _sbuls::P64 = P64[_sbukT::P64 + 22];
           I64[Hp - 8] = sat_sbulW_info;
           P64[Hp] = _sbulq::P64;
           I64[Sp - 24] = block_cbwhz_info;
           R5 = Hp - 6;
           R4 = _sbuls::P64;
           R3 = _sbukT::P64;
           R2 = lvl23_rbnX5_closure;
           P64[Sp - 16] = _sbulq::P64;
           P64[Sp - 8] = _sbulr::P64;
           P64[Sp] = _sbukT::P64;
           Sp = Sp - 24;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwjp_srtd" {
     ubwjp_srtd:
         const SbuCr_srt+96;
         const 83;
         const 1;
         const 381440;
 },
 _cbwhz() //  [R1]
         { info_tbl: [(cbwhz,
                       label: block_cbwhz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhz: // global
           I64[Sp] = block_cbwhB_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwja; else goto cbwhC;
       ubwja: // global
           call _cbwhB(R1) args: 0, res: 0, upd: 0;
       cbwhC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwjq_srtd" {
     ubwjq_srtd:
         const SbuCr_srt+96;
         const 83;
         const 1;
         const 381440;
 },
 _cbwhB() //  [R1]
         { info_tbl: [(cbwhB,
                       label: block_cbwhB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwhB: // global
           if (R1 & 7 == 1) goto cbwiL; else goto cbwj7;
       cbwiL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbwiO; else goto cbwiN;
       cbwiO: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwiN: // global
           _sbum2::P64 = P64[R1 + 15];
           I64[Hp - 64] = GHC.MVar.MVar_con_info;
           P64[Hp - 56] = _sbum2::P64;
           I64[Hp - 48] = GHC.Base.Just_con_info;
           P64[Hp - 40] = Hp - 63;
           I64[Hp - 32] = sat_sbumT_info;
           _sbukT::P64 = P64[Sp + 24];
           P64[Hp - 24] = _sbukT::P64;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sbum2::P64;
           P64[Hp] = Hp - 46;
           I64[Sp] = block_cbwiH_info;
           R5 = Hp - 30;
           R4 = P64[Sp + 16];
           R3 = _sbukT::P64;
           R2 = lvl23_rbnX5_closure;
           P64[Sp + 24] = _sbum2::P64;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
       cbwj7: // global
           Sp = Sp + 32;
           call lvl27_rbnX9_entry() args: 8, res: 0, upd: 8;
     }
 },
 _cbwiH() //  [R1]
         { info_tbl: [(cbwiH,
                       label: block_cbwiH_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwiH: // global
           I64[Sp] = block_cbwiJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwjc; else goto cbwiQ;
       ubwjc: // global
           call _cbwiJ(R1) args: 0, res: 0, upd: 0;
       cbwiQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwiJ() //  [R1]
         { info_tbl: [(cbwiJ,
                       label: block_cbwiJ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwiJ: // global
           if (R1 & 7 == 1) goto cbwiW; else goto cbwj3;
       cbwiW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbwiZ; else goto cbwiY;
       cbwiZ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwiY: // global
           _sbumZ::P64 = P64[R1 + 15];
           I64[Hp - 24] = GHC.IO.Handle.Types.DuplexHandle_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sbumZ::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 22;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbwj3: // global
           Sp = Sp + 32;
           call lvl25_rbnX7_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.115084268 UTC

[section ""data" . GHC.IO.Handle.hDuplicate_closure" {
     GHC.IO.Handle.hDuplicate_closure:
         const GHC.IO.Handle.hDuplicate_info;
         const 0;
 },
 GHC.IO.Handle.hDuplicate_entry() //  [R2]
         { info_tbl: [(cbwmg,
                       label: GHC.IO.Handle.hDuplicate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwmg: // global
           R2 = R2;
           call GHC.IO.Handle.hDuplicate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.118224522 UTC

[section ""cstring" . GHC.IO.Handle.hGetEcho4_bytes" {
     GHC.IO.Handle.hGetEcho4_bytes:
         I8[] [104,71,101,116,69,99,104,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.120083875 UTC

[section ""data" . GHC.IO.Handle.hGetEcho3_closure" {
     GHC.IO.Handle.hGetEcho3_closure:
         const GHC.IO.Handle.hGetEcho3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetEcho3_entry() //  [R1]
         { info_tbl: [(cbwmu,
                       label: GHC.IO.Handle.hGetEcho3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwmu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwmv; else goto cbwmw;
       cbwmv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwmw: // global
           (_cbwmr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwmr::I64 == 0) goto cbwmt; else goto cbwms;
       cbwmt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwms: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwmr::I64;
           R2 = GHC.IO.Handle.hGetEcho4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.124542879 UTC

[section ""data" . GHC.IO.Handle.hGetEcho2_closure" {
     GHC.IO.Handle.hGetEcho2_closure:
         const GHC.IO.Handle.hGetEcho2_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho2_entry() //  [R2]
         { info_tbl: [(cbwmM,
                       label: GHC.IO.Handle.hGetEcho2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwmM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbwmN; else goto cbwmO;
       cbwmN: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwmO: // global
           I64[Sp - 8] = block_cbwmJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwnc; else goto cbwmK;
       ubwnc: // global
           call _cbwmJ(R1) args: 0, res: 0, upd: 0;
       cbwmK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwmJ() //  [R1]
         { info_tbl: [(cbwmJ,
                       label: block_cbwmJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwmJ: // global
           I64[Sp - 24] = block_cbwmR_info;
           _sbun9::P64 = R1;
           _sbuna::P64 = P64[R1 + 7];
           _sbund::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbuna::P64;
           P64[Sp - 8] = _sbund::P64;
           P64[Sp] = _sbun9::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubwnb; else goto cbwmT;
       ubwnb: // global
           call _cbwmR(R1) args: 0, res: 0, upd: 0;
       cbwmT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwmR() //  [R1]
         { info_tbl: [(cbwmR,
                       label: block_cbwmR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwmR: // global
           if (R1 & 7 == 1) goto cbwn9; else goto cbwn2;
       cbwn9: // global
           Sp = Sp + 32;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbwn2: // global
           _sbund::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbwmX_info;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pv_info;
           P64[Sp + 8] = _sbund::P64;
           call GHC.IO.Device.getEcho_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cbwmX() //  [R1]
         { info_tbl: [(cbwmX,
                       label: block_cbwmX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwmX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwn5; else goto cbwn4;
       cbwn5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwn4: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.136125128 UTC

[section ""data" . GHC.IO.Handle.hGetEcho1_closure" {
     GHC.IO.Handle.hGetEcho1_closure:
         const GHC.IO.Handle.hGetEcho1_info;
         const 0;
 },
 section ""relreadonly" . ubwpc_srtd" {
     ubwpc_srtd:
         const SbuCr_srt+456;
         const 41;
         const 1374389534721;
 },
 io_sbunI_entry() //  [R1]
         { info_tbl: [(cbwo5,
                       label: io_sbunI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwo5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwo9; else goto cbwoa;
       cbwo9: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwoa: // global
           I64[Sp - 16] = block_cbwo0_info;
           _sbunE::P64 = P64[R1 + 15];
           R5 = _sbunE::P64;
           R4 = GHC.IO.Handle.hGetEcho2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho3_closure;
           P64[Sp - 8] = _sbunE::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwo0() //  [R1]
         { info_tbl: [(cbwo0,
                       label: block_cbwo0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwo0: // global
           I64[Sp] = block_cbwo2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwof; else goto cbwo3;
       ubwof: // global
           call _cbwo2(R1) args: 0, res: 0, upd: 0;
       cbwo3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwo2() //  [R1]
         { info_tbl: [(cbwo2,
                       label: block_cbwo2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwo2: // global
           I64[Sp] = block_cbwo8_info;
           R2 = P64[R1 + 7];
           _sbunP::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbunP::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwo8() //  []
         { info_tbl: [(cbwo8,
                       label: block_cbwo8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwo8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwpd_srtd" {
     ubwpd_srtd:
         const SbuCr_srt+456;
         const 41;
         const 1374389534721;
 },
 io_sbunY_entry() //  [R1]
         { info_tbl: [(cbwou,
                       label: io_sbunY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwou: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwoy; else goto cbwoz;
       cbwoy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwoz: // global
           I64[Sp - 16] = block_cbwop_info;
           _sbunT::P64 = P64[R1 + 15];
           R5 = _sbunT::P64;
           R4 = GHC.IO.Handle.hGetEcho2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetEcho3_closure;
           P64[Sp - 8] = _sbunT::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwop() //  [R1]
         { info_tbl: [(cbwop,
                       label: block_cbwop_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwop: // global
           I64[Sp] = block_cbwor_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwoE; else goto cbwos;
       ubwoE: // global
           call _cbwor(R1) args: 0, res: 0, upd: 0;
       cbwos: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwor() //  [R1]
         { info_tbl: [(cbwor,
                       label: block_cbwor_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwor: // global
           I64[Sp] = block_cbwox_info;
           R2 = P64[R1 + 7];
           _sbuo5::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbuo5::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwox() //  []
         { info_tbl: [(cbwox,
                       label: block_cbwox_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwox: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwpe_srtd" {
     ubwpe_srtd:
         const SbuCr_srt+160;
         const 79;
         const 137438953473;
         const 26624;
 },
 GHC.IO.Handle.hGetEcho1_entry() //  [R2]
         { info_tbl: [(cbwoJ,
                       label: GHC.IO.Handle.hGetEcho1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwoJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwoK; else goto cbwoL;
       cbwoK: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetEcho1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwoL: // global
           I64[Sp - 16] = block_cbwnG_info;
           _sbunw::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbunw::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwpf_srtd" {
     ubwpf_srtd:
         const SbuCr_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbwnG() //  [R1]
         { info_tbl: [(cbwnG,
                       label: block_cbwnG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwnG: // global
           I64[Sp] = block_cbwnI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwpa; else goto cbwnJ;
       ubwpa: // global
           call _cbwnI(R1) args: 0, res: 0, upd: 0;
       cbwnJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwpg_srtd" {
     ubwpg_srtd:
         const SbuCr_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbwnI() //  [R1]
         { info_tbl: [(cbwnI,
                       label: block_cbwnI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwnI: // global
           if (R1 & 7 == 1) goto cbwoG; else goto cbwoH;
       cbwoG: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbwoH: // global
           _sbunw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbwnO_info;
           R1 = _sbunw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubwpb; else goto cbwnP;
       ubwpb: // global
           call _cbwnO(R1) args: 0, res: 0, upd: 0;
       cbwnP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwph_srtd" {
     ubwph_srtd:
         const SbuCr_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbwnO() //  [R1]
         { info_tbl: [(cbwnO,
                       label: block_cbwnO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwnO: // global
           if (R1 & 7 == 1) goto cbwoS; else goto cbwp1;
       cbwoS: // global
           I64[Sp - 16] = block_cbwnT_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbwp1: // global
           I64[Sp - 16] = block_cbwoi_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwpi_srtd" {
     ubwpi_srtd:
         const SbuCr_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbwnT() //  [R1]
         { info_tbl: [(cbwnT,
                       label: block_cbwnT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwnT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwoV; else goto cbwoU;
       cbwoV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwoU: // global
           I64[Hp - 16] = io_sbunI_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwnV::P64 = Hp - 15;
           if (R1 == 0) goto cbwoZ; else goto cbwoY;
       cbwoZ: // global
           R1 = _cbwnV::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwoY: // global
           R1 = _cbwnV::P64;
           Sp = Sp + 24;
           call io_sbunI_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwpj_srtd" {
     ubwpj_srtd:
         const SbuCr_srt+456;
         const 41;
         const 1374389534721;
 },
 _cbwoi() //  [R1]
         { info_tbl: [(cbwoi,
                       label: block_cbwoi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwoi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwp4; else goto cbwp3;
       cbwp4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwp3: // global
           I64[Hp - 16] = io_sbunY_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwok::P64 = Hp - 15;
           if (R1 == 0) goto cbwp8; else goto cbwp7;
       cbwp8: // global
           R1 = _cbwok::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwp7: // global
           R1 = _cbwok::P64;
           Sp = Sp + 24;
           call io_sbunY_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.168652163 UTC

[section ""data" . GHC.IO.Handle.hGetEcho_closure" {
     GHC.IO.Handle.hGetEcho_closure:
         const GHC.IO.Handle.hGetEcho_info;
         const 0;
 },
 GHC.IO.Handle.hGetEcho_entry() //  [R2]
         { info_tbl: [(cbwqL,
                       label: GHC.IO.Handle.hGetEcho_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwqL: // global
           R2 = R2;
           call GHC.IO.Handle.hGetEcho1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.171906248 UTC

[section ""cstring" . GHC.IO.Handle.hSetEcho3_bytes" {
     GHC.IO.Handle.hSetEcho3_bytes:
         I8[] [104,83,101,116,69,99,104,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.173716428 UTC

[section ""data" . GHC.IO.Handle.hSetEcho2_closure" {
     GHC.IO.Handle.hSetEcho2_closure:
         const GHC.IO.Handle.hSetEcho2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hSetEcho2_entry() //  [R1]
         { info_tbl: [(cbwqZ,
                       label: GHC.IO.Handle.hSetEcho2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwqZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwr0; else goto cbwr1;
       cbwr0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwr1: // global
           (_cbwqW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwqW::I64 == 0) goto cbwqY; else goto cbwqX;
       cbwqY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwqX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwqW::I64;
           R2 = GHC.IO.Handle.hSetEcho3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.180393187 UTC

[section ""data" . GHC.IO.Handle.hSetEcho1_closure" {
     GHC.IO.Handle.hSetEcho1_closure:
         const GHC.IO.Handle.hSetEcho1_info;
         const 0;
 },
 sat_sbuoM_entry() //  [R1, R2]
         { info_tbl: [(cbwrG,
                       label: sat_sbuoM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwrG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbwrH; else goto cbwrI;
       cbwrH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwrI: // global
           I64[Sp - 16] = block_cbwrD_info;
           _sbuo9::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbuo9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubws6; else goto cbwrE;
       ubws6: // global
           call _cbwrD(R1) args: 0, res: 0, upd: 0;
       cbwrE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwrD() //  [R1]
         { info_tbl: [(cbwrD,
                       label: block_cbwrD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwrD: // global
           I64[Sp - 24] = block_cbwrL_info;
           _sbuop::P64 = R1;
           _sbuoq::P64 = P64[R1 + 7];
           _sbuot::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbuoq::P64;
           P64[Sp - 8] = _sbuot::P64;
           P64[Sp] = _sbuop::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubws5; else goto cbwrN;
       ubws5: // global
           call _cbwrL(R1) args: 0, res: 0, upd: 0;
       cbwrN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwrL() //  [R1]
         { info_tbl: [(cbwrL,
                       label: block_cbwrL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwrL: // global
           if (R1 & 7 == 1) goto cbws3; else goto cbwrW;
       cbws3: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbwrW: // global
           _sbuot::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbwrR_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sbuot::P64;
           P64[Sp + 8] = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.IO.Device.setEcho_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbwrR() //  [R1]
         { info_tbl: [(cbwrR,
                       label: block_cbwrR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwrR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwrZ; else goto cbwrY;
       cbwrZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwrY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwtW_srtd" {
     ubwtW_srtd:
         const SbuCr_srt+456;
         const 43;
         const 4947802324993;
 },
 io_sbuol_entry() //  [R1]
         { info_tbl: [(cbwsc,
                       label: io_sbuol_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwsc: // global
           _sbuol::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbwsg; else goto cbwsh;
       cbwsh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbwsj; else goto cbwsi;
       cbwsj: // global
           HpAlloc = 16;
           goto cbwsg;
       cbwsg: // global
           R1 = _sbuol::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwsi: // global
           _sbuo9::P64 = P64[_sbuol::P64 + 7];
           _sbuof::P64 = P64[_sbuol::P64 + 15];
           _sbuoh::P64 = P64[_sbuol::P64 + 23];
           I64[Hp - 8] = sat_sbuoM_info;
           P64[Hp] = _sbuo9::P64;
           I64[Sp - 16] = block_cbws7_info;
           R5 = _sbuoh::P64;
           R4 = Hp - 6;
           R3 = _sbuof::P64;
           R2 = GHC.IO.Handle.hSetEcho2_closure;
           P64[Sp - 8] = _sbuoh::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbws7() //  [R1]
         { info_tbl: [(cbws7,
                       label: block_cbws7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbws7: // global
           I64[Sp] = block_cbws9_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwso; else goto cbwsa;
       ubwso: // global
           call _cbws9(R1) args: 0, res: 0, upd: 0;
       cbwsa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbws9() //  [R1]
         { info_tbl: [(cbws9,
                       label: block_cbws9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbws9: // global
           I64[Sp] = block_cbwsf_info;
           R2 = P64[R1 + 7];
           _sbuoS::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbuoS::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwsf() //  []
         { info_tbl: [(cbwsf,
                       label: block_cbwsf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwsf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbups_entry() //  [R1, R2]
         { info_tbl: [(cbwsG,
                       label: sat_sbups_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwsG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbwsH; else goto cbwsI;
       cbwsH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwsI: // global
           I64[Sp - 16] = block_cbwsD_info;
           _sbuo9::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sbuo9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubwt6; else goto cbwsE;
       ubwt6: // global
           call _cbwsD(R1) args: 0, res: 0, upd: 0;
       cbwsE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwsD() //  [R1]
         { info_tbl: [(cbwsD,
                       label: block_cbwsD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwsD: // global
           I64[Sp - 24] = block_cbwsL_info;
           _sbup5::P64 = R1;
           _sbup6::P64 = P64[R1 + 7];
           _sbup9::P64 = P64[R1 + 31];
           R1 = P64[R1 + 39];
           P64[Sp - 16] = _sbup6::P64;
           P64[Sp - 8] = _sbup9::P64;
           P64[Sp] = _sbup5::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubwt5; else goto cbwsN;
       ubwt5: // global
           call _cbwsL(R1) args: 0, res: 0, upd: 0;
       cbwsN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwsL() //  [R1]
         { info_tbl: [(cbwsL,
                       label: block_cbwsL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwsL: // global
           if (R1 & 7 == 1) goto cbwt3; else goto cbwsW;
       cbwt3: // global
           Sp = Sp + 40;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbwsW: // global
           _sbup9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cbwsR_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _sbup9::P64;
           P64[Sp + 8] = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.IO.Device.setEcho_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbwsR() //  [R1]
         { info_tbl: [(cbwsR,
                       label: block_cbwsR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwsR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwsZ; else goto cbwsY;
       cbwsZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwsY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwtX_srtd" {
     ubwtX_srtd:
         const SbuCr_srt+456;
         const 43;
         const 4947802324993;
 },
 io_sbup1_entry() //  [R1]
         { info_tbl: [(cbwtc,
                       label: io_sbup1_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwtc: // global
           _sbup1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbwtg; else goto cbwth;
       cbwth: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbwtj; else goto cbwti;
       cbwtj: // global
           HpAlloc = 16;
           goto cbwtg;
       cbwtg: // global
           R1 = _sbup1::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwti: // global
           _sbuo9::P64 = P64[_sbup1::P64 + 7];
           _sbuof::P64 = P64[_sbup1::P64 + 15];
           _sbuoW::P64 = P64[_sbup1::P64 + 23];
           I64[Hp - 8] = sat_sbups_info;
           P64[Hp] = _sbuo9::P64;
           I64[Sp - 16] = block_cbwt7_info;
           R5 = _sbuoW::P64;
           R4 = Hp - 6;
           R3 = _sbuof::P64;
           R2 = GHC.IO.Handle.hSetEcho2_closure;
           P64[Sp - 8] = _sbuoW::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwt7() //  [R1]
         { info_tbl: [(cbwt7,
                       label: block_cbwt7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwt7: // global
           I64[Sp] = block_cbwt9_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwto; else goto cbwta;
       ubwto: // global
           call _cbwt9(R1) args: 0, res: 0, upd: 0;
       cbwta: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwt9() //  [R1]
         { info_tbl: [(cbwt9,
                       label: block_cbwt9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwt9: // global
           I64[Sp] = block_cbwtf_info;
           R2 = P64[R1 + 7];
           _sbupy::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbupy::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwtf() //  []
         { info_tbl: [(cbwtf,
                       label: block_cbwtf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwtf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwtY_srtd" {
     ubwtY_srtd:
         const SbuCr_srt+160;
         const 81;
         const 137438953473;
         const 102400;
 },
 GHC.IO.Handle.hSetEcho1_entry() //  [R2, R3]
         { info_tbl: [(cbwtt,
                       label: GHC.IO.Handle.hSetEcho1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwtt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbwtu; else goto cbwtv;
       cbwtu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.hSetEcho1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbwtv: // global
           I64[Sp - 24] = block_cbwre_info;
           _sbuo8::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _sbuo8::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.IO.Handle.hGetEcho5_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwtZ_srtd" {
     ubwtZ_srtd:
         const SbuCr_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbwre() //  [R1]
         { info_tbl: [(cbwre,
                       label: block_cbwre_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwre: // global
           I64[Sp] = block_cbwrg_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwtU; else goto cbwrh;
       ubwtU: // global
           call _cbwrg(R1) args: 0, res: 0, upd: 0;
       cbwrh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwu0_srtd" {
     ubwu0_srtd:
         const SbuCr_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbwrg() //  [R1]
         { info_tbl: [(cbwrg,
                       label: block_cbwrg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwrg: // global
           if (R1 & 7 == 1) goto cbwtq; else goto cbwtr;
       cbwtq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbwtr: // global
           _sbuo8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbwrm_info;
           R1 = _sbuo8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubwtV; else goto cbwrn;
       ubwtV: // global
           call _cbwrm(R1) args: 0, res: 0, upd: 0;
       cbwrn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwu1_srtd" {
     ubwu1_srtd:
         const SbuCr_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbwrm() //  [R1]
         { info_tbl: [(cbwrm,
                       label: block_cbwrm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwrm: // global
           if (R1 & 7 == 1) goto cbwtC; else goto cbwtL;
       cbwtC: // global
           I64[Sp - 16] = block_cbwrr_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbwtL: // global
           I64[Sp - 16] = block_cbwsr_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwu2_srtd" {
     ubwu2_srtd:
         const SbuCr_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbwrr() //  [R1]
         { info_tbl: [(cbwrr,
                       label: block_cbwrr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwrr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbwtF; else goto cbwtE;
       cbwtF: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwtE: // global
           I64[Hp - 24] = io_sbuol_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwrt::P64 = Hp - 23;
           if (R1 == 0) goto cbwtJ; else goto cbwtI;
       cbwtJ: // global
           R1 = _cbwrt::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwtI: // global
           R1 = _cbwrt::P64;
           Sp = Sp + 32;
           call io_sbuol_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwu3_srtd" {
     ubwu3_srtd:
         const SbuCr_srt+456;
         const 43;
         const 4947802324993;
 },
 _cbwsr() //  [R1]
         { info_tbl: [(cbwsr,
                       label: block_cbwsr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwsr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbwtO; else goto cbwtN;
       cbwtO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwtN: // global
           I64[Hp - 24] = io_sbup1_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwst::P64 = Hp - 23;
           if (R1 == 0) goto cbwtS; else goto cbwtR;
       cbwtS: // global
           R1 = _cbwst::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwtR: // global
           R1 = _cbwst::P64;
           Sp = Sp + 32;
           call io_sbup1_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.231465253 UTC

[section ""data" . GHC.IO.Handle.hSetEcho_closure" {
     GHC.IO.Handle.hSetEcho_closure:
         const GHC.IO.Handle.hSetEcho_info;
         const 0;
 },
 GHC.IO.Handle.hSetEcho_entry() //  [R2, R3]
         { info_tbl: [(cbwwn,
                       label: GHC.IO.Handle.hSetEcho_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwwn: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.Handle.hSetEcho1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.235098645 UTC

[section ""cstring" . GHC.IO.Handle.hGetBuffering3_bytes" {
     GHC.IO.Handle.hGetBuffering3_bytes:
         I8[] [104,71,101,116,66,117,102,102,101,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.236925757 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering_fun_closure" {
     GHC.IO.Handle.hGetBuffering_fun_closure:
         const GHC.IO.Handle.hGetBuffering_fun_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering_fun_entry() //  [R1]
         { info_tbl: [(cbwwB,
                       label: GHC.IO.Handle.hGetBuffering_fun_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwwB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwwC; else goto cbwwD;
       cbwwC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwwD: // global
           (_cbwwy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwwy::I64 == 0) goto cbwwA; else goto cbwwz;
       cbwwA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwwz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwwy::I64;
           R2 = GHC.IO.Handle.hGetBuffering3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.242356099 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering2_closure" {
     GHC.IO.Handle.hGetBuffering2_closure:
         const GHC.IO.Handle.hGetBuffering2_info;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering2_entry() //  [R2]
         { info_tbl: [(cbwwT,
                       label: GHC.IO.Handle.hGetBuffering2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwwT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwwU; else goto cbwwV;
       cbwwU: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetBuffering2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwwV: // global
           I64[Sp - 8] = block_cbwwQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwxg; else goto cbwwR;
       ubwxg: // global
           call _cbwwQ(R1) args: 0, res: 0, upd: 0;
       cbwwR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwwQ() //  [R1]
         { info_tbl: [(cbwwQ,
                       label: block_cbwwQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwwQ: // global
           I64[Sp - 16] = block_cbwwY_info;
           _sbupD::P64 = R1;
           _sbupK::P64 = P64[R1 + 55];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _sbupK::P64;
           P64[Sp] = _sbupD::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubwxf; else goto cbwx0;
       ubwxf: // global
           call _cbwwY(R1) args: 0, res: 0, upd: 0;
       cbwx0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwwY() //  [R1]
         { info_tbl: [(cbwwY,
                       label: block_cbwwY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwwY: // global
           if (R1 & 7 == 1) goto cbwxd; else goto cbwx6;
       cbwxd: // global
           Sp = Sp + 24;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       cbwx6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwx9; else goto cbwx8;
       cbwx9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwx8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.250757065 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering1_closure" {
     GHC.IO.Handle.hGetBuffering1_closure:
         const GHC.IO.Handle.hGetBuffering1_info;
         const 0;
 },
 section ""relreadonly" . ubwyV_srtd" {
     ubwyV_srtd:
         const SbuCr_srt+456;
         const 46;
         const 52776558133249;
 },
 io_sbuq5_entry() //  [R1]
         { info_tbl: [(cbwxX,
                       label: io_sbuq5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwxX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwy1; else goto cbwy2;
       cbwy1: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwy2: // global
           I64[Sp - 16] = block_cbwxS_info;
           _sbuq1::P64 = P64[R1 + 15];
           R5 = _sbuq1::P64;
           R4 = GHC.IO.Handle.hGetBuffering2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetBuffering_fun_closure;
           P64[Sp - 8] = _sbuq1::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwxS() //  [R1]
         { info_tbl: [(cbwxS,
                       label: block_cbwxS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwxS: // global
           I64[Sp] = block_cbwxU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwy7; else goto cbwxV;
       ubwy7: // global
           call _cbwxU(R1) args: 0, res: 0, upd: 0;
       cbwxV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwxU() //  [R1]
         { info_tbl: [(cbwxU,
                       label: block_cbwxU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwxU: // global
           I64[Sp] = block_cbwy0_info;
           R2 = P64[R1 + 7];
           _sbuqc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbuqc::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwy0() //  []
         { info_tbl: [(cbwy0,
                       label: block_cbwy0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwy0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwyW_srtd" {
     ubwyW_srtd:
         const SbuCr_srt+456;
         const 46;
         const 52776558133249;
 },
 io_sbuql_entry() //  [R1]
         { info_tbl: [(cbwym,
                       label: io_sbuql_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwym: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwyq; else goto cbwyr;
       cbwyq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwyr: // global
           I64[Sp - 16] = block_cbwyh_info;
           _sbuqg::P64 = P64[R1 + 15];
           R5 = _sbuqg::P64;
           R4 = GHC.IO.Handle.hGetBuffering2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hGetBuffering_fun_closure;
           P64[Sp - 8] = _sbuqg::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwyh() //  [R1]
         { info_tbl: [(cbwyh,
                       label: block_cbwyh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwyh: // global
           I64[Sp] = block_cbwyj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwyw; else goto cbwyk;
       ubwyw: // global
           call _cbwyj(R1) args: 0, res: 0, upd: 0;
       cbwyk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwyj() //  [R1]
         { info_tbl: [(cbwyj,
                       label: block_cbwyj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwyj: // global
           I64[Sp] = block_cbwyp_info;
           R2 = P64[R1 + 7];
           _sbuqs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbuqs::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwyp() //  []
         { info_tbl: [(cbwyp,
                       label: block_cbwyp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwyp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwyX_srtd" {
     ubwyX_srtd:
         const SbuCr_srt+456;
         const 47;
         const 123145302310913;
 },
 GHC.IO.Handle.hGetBuffering1_entry() //  [R2]
         { info_tbl: [(cbwyB,
                       label: GHC.IO.Handle.hGetBuffering1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwyB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwyC; else goto cbwyD;
       cbwyC: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetBuffering1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwyD: // global
           I64[Sp - 8] = block_cbwxG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwyU; else goto cbwxH;
       ubwyU: // global
           call _cbwxG(R1) args: 0, res: 0, upd: 0;
       cbwxH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwyY_srtd" {
     ubwyY_srtd:
         const SbuCr_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbwxG() //  [R1]
         { info_tbl: [(cbwxG,
                       label: block_cbwxG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwxG: // global
           if (R1 & 7 == 1) goto cbwyy; else goto cbwyz;
       cbwyy: // global
           I64[Sp - 16] = block_cbwxL_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbwyz: // global
           I64[Sp - 16] = block_cbwya_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwyZ_srtd" {
     ubwyZ_srtd:
         const SbuCr_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbwxL() //  [R1]
         { info_tbl: [(cbwxL,
                       label: block_cbwxL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwxL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwyH; else goto cbwyG;
       cbwyH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwyG: // global
           I64[Hp - 16] = io_sbuq5_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwxN::P64 = Hp - 15;
           if (R1 == 0) goto cbwyL; else goto cbwyK;
       cbwyL: // global
           R1 = _cbwxN::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwyK: // global
           R1 = _cbwxN::P64;
           Sp = Sp + 24;
           call io_sbuq5_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwz0_srtd" {
     ubwz0_srtd:
         const SbuCr_srt+456;
         const 46;
         const 52776558133249;
 },
 _cbwya() //  [R1]
         { info_tbl: [(cbwya,
                       label: block_cbwya_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwya: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwyP; else goto cbwyO;
       cbwyP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwyO: // global
           I64[Hp - 16] = io_sbuql_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwyc::P64 = Hp - 15;
           if (R1 == 0) goto cbwyT; else goto cbwyS;
       cbwyT: // global
           R1 = _cbwyc::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwyS: // global
           R1 = _cbwyc::P64;
           Sp = Sp + 24;
           call io_sbuql_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.278821089 UTC

[section ""data" . GHC.IO.Handle.hGetBuffering_closure" {
     GHC.IO.Handle.hGetBuffering_closure:
         const GHC.IO.Handle.hGetBuffering_info;
         const 0;
 },
 GHC.IO.Handle.hGetBuffering_entry() //  [R2]
         { info_tbl: [(cbwAd,
                       label: GHC.IO.Handle.hGetBuffering_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwAd: // global
           R2 = R2;
           call GHC.IO.Handle.hGetBuffering1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.282100772 UTC

[section ""cstring" . GHC.IO.Handle.hIsWritable4_bytes" {
     GHC.IO.Handle.hIsWritable4_bytes:
         I8[] [104,73,115,87,114,105,116,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.283882981 UTC

[section ""data" . GHC.IO.Handle.hIsWritable3_closure" {
     GHC.IO.Handle.hIsWritable3_closure:
         const GHC.IO.Handle.hIsWritable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsWritable3_entry() //  [R1]
         { info_tbl: [(cbwAr,
                       label: GHC.IO.Handle.hIsWritable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwAr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwAs; else goto cbwAt;
       cbwAs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwAt: // global
           (_cbwAo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwAo::I64 == 0) goto cbwAq; else goto cbwAp;
       cbwAq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwAp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwAo::I64;
           R2 = GHC.IO.Handle.hIsWritable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.28855282 UTC

[section ""data" . GHC.IO.Handle.hIsWritable2_closure" {
     GHC.IO.Handle.hIsWritable2_closure:
         const GHC.IO.Handle.hIsWritable2_info;
         const 0;
 },
 sat_sbuqQ_entry() //  [R1]
         { info_tbl: [(cbwB3,
                       label: sat_sbuqQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwB3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwB4; else goto cbwB5;
       cbwB4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwB5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbwAU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubwBj; else goto cbwAV;
       ubwBj: // global
           call _cbwAU(R1) args: 0, res: 0, upd: 0;
       cbwAV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbwAU() //  [R1]
         { info_tbl: [(cbwAU,
                       label: block_cbwAU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwAU: // global
           _cbwB2::P64 = R1 & 7;
           if (_cbwB2::P64 < 4) goto cbwAY; else goto ubwBi;
       cbwAY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ubwBi: // global
           if (_cbwB2::P64 != 5) goto cbwB1; else goto cbwB1;
       cbwB1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubwBG_srtd" {
     ubwBG_srtd:
         const SbuCr_srt+328;
         const 64;
         const 9259400833873739777;
 },
 GHC.IO.Handle.hIsWritable2_entry() //  [R2]
         { info_tbl: [(cbwBk,
                       label: GHC.IO.Handle.hIsWritable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwBk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwBl; else goto cbwBm;
       cbwBl: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsWritable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwBm: // global
           I64[Sp - 8] = block_cbwAG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwBF; else goto cbwAH;
       ubwBF: // global
           call _cbwAG(R1) args: 0, res: 0, upd: 0;
       cbwAH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwBH_srtd" {
     ubwBH_srtd:
         const SbuCr_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbwAG() //  [R1]
         { info_tbl: [(cbwAG,
                       label: block_cbwAG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwAG: // global
           I64[Sp - 8] = block_cbwAL_info;
           _sbuqx::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbuqx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwBE; else goto cbwAM;
       ubwBE: // global
           call _cbwAL(R1) args: 0, res: 0, upd: 0;
       cbwAM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwBI_srtd" {
     ubwBI_srtd:
         const SbuCr_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbwAL() //  [R1]
         { info_tbl: [(cbwAL,
                       label: block_cbwAL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwAL: // global
           _cbwBC::P64 = R1 & 7;
           if (_cbwBC::P64 == 1) goto cbwBx; else goto ubwBD;
       cbwBx: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       ubwBD: // global
           if (_cbwBC::P64 == 2) goto cbwBB; else goto cbwBq;
       cbwBB: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbwBq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbwBt; else goto cbwBs;
       cbwBt: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwBs: // global
           I64[Hp - 40] = sat_sbuqQ_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.303593471 UTC

[section ""data" . GHC.IO.Handle.hIsWritable1_closure" {
     GHC.IO.Handle.hIsWritable1_closure:
         const GHC.IO.Handle.hIsWritable1_info;
         const 0;
 },
 section ""relreadonly" . ubwDb_srtd" {
     ubwDb_srtd:
         const SbuCr_srt+456;
         const 49;
         const 422212465065985;
 },
 io_sbur2_entry() //  [R1]
         { info_tbl: [(cbwCH,
                       label: io_sbur2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwCH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwCL; else goto cbwCM;
       cbwCL: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwCM: // global
           I64[Sp - 16] = block_cbwCC_info;
           _sbuqY::P64 = P64[R1 + 15];
           R5 = _sbuqY::P64;
           R4 = GHC.IO.Handle.hIsWritable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsWritable3_closure;
           P64[Sp - 8] = _sbuqY::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwCC() //  [R1]
         { info_tbl: [(cbwCC,
                       label: block_cbwCC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwCC: // global
           I64[Sp] = block_cbwCE_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwCR; else goto cbwCF;
       ubwCR: // global
           call _cbwCE(R1) args: 0, res: 0, upd: 0;
       cbwCF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwCE() //  [R1]
         { info_tbl: [(cbwCE,
                       label: block_cbwCE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwCE: // global
           I64[Sp] = block_cbwCK_info;
           R2 = P64[R1 + 7];
           _sbur9::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbur9::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwCK() //  []
         { info_tbl: [(cbwCK,
                       label: block_cbwCK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwCK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwDc_srtd" {
     ubwDc_srtd:
         const SbuCr_srt+456;
         const 50;
         const 985162418487297;
 },
 GHC.IO.Handle.hIsWritable1_entry() //  [R2]
         { info_tbl: [(cbwCW,
                       label: GHC.IO.Handle.hIsWritable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwCW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwCX; else goto cbwCY;
       cbwCX: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsWritable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwCY: // global
           I64[Sp - 8] = block_cbwCq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwDa; else goto cbwCr;
       ubwDa: // global
           call _cbwCq(R1) args: 0, res: 0, upd: 0;
       cbwCr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwDd_srtd" {
     ubwDd_srtd:
         const SbuCr_srt+456;
         const 49;
         const 422212465065985;
 },
 _cbwCq() //  [R1]
         { info_tbl: [(cbwCq,
                       label: block_cbwCq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwCq: // global
           if (R1 & 7 == 1) goto cbwCT; else goto cbwCU;
       cbwCT: // global
           I64[Sp - 16] = block_cbwCv_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbwCU: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwDe_srtd" {
     ubwDe_srtd:
         const SbuCr_srt+456;
         const 49;
         const 422212465065985;
 },
 _cbwCv() //  [R1]
         { info_tbl: [(cbwCv,
                       label: block_cbwCv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwCv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwD2; else goto cbwD1;
       cbwD2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwD1: // global
           I64[Hp - 16] = io_sbur2_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwCx::P64 = Hp - 15;
           if (R1 == 0) goto cbwD6; else goto cbwD5;
       cbwD6: // global
           R1 = _cbwCx::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwD5: // global
           R1 = _cbwCx::P64;
           Sp = Sp + 24;
           call io_sbur2_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.321654365 UTC

[section ""data" . GHC.IO.Handle.hIsWritable_closure" {
     GHC.IO.Handle.hIsWritable_closure:
         const GHC.IO.Handle.hIsWritable_info;
         const 0;
 },
 GHC.IO.Handle.hIsWritable_entry() //  [R2]
         { info_tbl: [(cbwE1,
                       label: GHC.IO.Handle.hIsWritable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwE1: // global
           R2 = R2;
           call GHC.IO.Handle.hIsWritable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.324752058 UTC

[section ""cstring" . GHC.IO.Handle.hIsReadable4_bytes" {
     GHC.IO.Handle.hIsReadable4_bytes:
         I8[] [104,73,115,82,101,97,100,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.326654561 UTC

[section ""data" . GHC.IO.Handle.hIsReadable3_closure" {
     GHC.IO.Handle.hIsReadable3_closure:
         const GHC.IO.Handle.hIsReadable3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsReadable3_entry() //  [R1]
         { info_tbl: [(cbwEf,
                       label: GHC.IO.Handle.hIsReadable3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwEf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwEg; else goto cbwEh;
       cbwEg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwEh: // global
           (_cbwEc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwEc::I64 == 0) goto cbwEe; else goto cbwEd;
       cbwEe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwEd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwEc::I64;
           R2 = GHC.IO.Handle.hIsReadable4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.331294008 UTC

[section ""data" . GHC.IO.Handle.hIsReadable2_closure" {
     GHC.IO.Handle.hIsReadable2_closure:
         const GHC.IO.Handle.hIsReadable2_info;
         const 0;
 },
 sat_sburA_entry() //  [R1]
         { info_tbl: [(cbwEQ,
                       label: sat_sburA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwEQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwER; else goto cbwES;
       cbwER: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwES: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbwEI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubwF3; else goto cbwEJ;
       ubwF3: // global
           call _cbwEI(R1) args: 0, res: 0, upd: 0;
       cbwEJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbwEI() //  [R1]
         { info_tbl: [(cbwEI,
                       label: block_cbwEI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwEI: // global
           _cbwEP::P64 = R1 & 7;
           if (_cbwEP::P64 == 3) goto cbwEO; else goto ubwF2;
       ubwF2: // global
           if (_cbwEP::P64 == 6) goto cbwEO; else goto cbwEM;
       cbwEO: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbwEM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ubwFq_srtd" {
     ubwFq_srtd:
         const SbuCr_srt+328;
         const 67;
         const 36028797018963969;
         const 4;
 },
 GHC.IO.Handle.hIsReadable2_entry() //  [R2]
         { info_tbl: [(cbwF4,
                       label: GHC.IO.Handle.hIsReadable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwF4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwF5; else goto cbwF6;
       cbwF5: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsReadable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwF6: // global
           I64[Sp - 8] = block_cbwEu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwFp; else goto cbwEv;
       ubwFp: // global
           call _cbwEu(R1) args: 0, res: 0, upd: 0;
       cbwEv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwFr_srtd" {
     ubwFr_srtd:
         const SbuCr_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbwEu() //  [R1]
         { info_tbl: [(cbwEu,
                       label: block_cbwEu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwEu: // global
           I64[Sp - 8] = block_cbwEz_info;
           _sburh::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sburh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwFo; else goto cbwEA;
       ubwFo: // global
           call _cbwEz(R1) args: 0, res: 0, upd: 0;
       cbwEA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwFs_srtd" {
     ubwFs_srtd:
         const SbuCr_srt+328;
         const 56;
         const 36028797018963969;
 },
 _cbwEz() //  [R1]
         { info_tbl: [(cbwEz,
                       label: block_cbwEz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwEz: // global
           _cbwFm::P64 = R1 & 7;
           if (_cbwFm::P64 == 1) goto cbwFh; else goto ubwFn;
       cbwFh: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_closedHandle1_entry() args: 8, res: 0, upd: 8;
       ubwFn: // global
           if (_cbwFm::P64 == 2) goto cbwFl; else goto cbwFa;
       cbwFl: // global
           Sp = Sp + 16;
           call GHC.IO.Handle.Internals.ioe_semiclosedHandle1_entry() args: 8, res: 0, upd: 8;
       cbwFa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbwFd; else goto cbwFc;
       cbwFd: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwFc: // global
           I64[Hp - 40] = sat_sburA_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.346014079 UTC

[section ""data" . GHC.IO.Handle.hIsReadable1_closure" {
     GHC.IO.Handle.hIsReadable1_closure:
         const GHC.IO.Handle.hIsReadable1_info;
         const 0;
 },
 section ""relreadonly" . ubwGV_srtd" {
     ubwGV_srtd:
         const SbuCr_srt+456;
         const 52;
         const 3377699720527873;
 },
 io_sburM_entry() //  [R1]
         { info_tbl: [(cbwGr,
                       label: io_sburM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwGr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwGv; else goto cbwGw;
       cbwGv: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwGw: // global
           I64[Sp - 16] = block_cbwGm_info;
           _sburI::P64 = P64[R1 + 15];
           R5 = _sburI::P64;
           R4 = GHC.IO.Handle.hIsReadable2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsReadable3_closure;
           P64[Sp - 8] = _sburI::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwGm() //  [R1]
         { info_tbl: [(cbwGm,
                       label: block_cbwGm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwGm: // global
           I64[Sp] = block_cbwGo_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwGB; else goto cbwGp;
       ubwGB: // global
           call _cbwGo(R1) args: 0, res: 0, upd: 0;
       cbwGp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwGo() //  [R1]
         { info_tbl: [(cbwGo,
                       label: block_cbwGo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwGo: // global
           I64[Sp] = block_cbwGu_info;
           R2 = P64[R1 + 7];
           _sburT::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sburT::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwGu() //  []
         { info_tbl: [(cbwGu,
                       label: block_cbwGu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwGu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwGW_srtd" {
     ubwGW_srtd:
         const SbuCr_srt+456;
         const 53;
         const 7881299347898369;
 },
 GHC.IO.Handle.hIsReadable1_entry() //  [R2]
         { info_tbl: [(cbwGG,
                       label: GHC.IO.Handle.hIsReadable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwGG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwGH; else goto cbwGI;
       cbwGH: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsReadable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwGI: // global
           I64[Sp - 8] = block_cbwGa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwGU; else goto cbwGb;
       ubwGU: // global
           call _cbwGa(R1) args: 0, res: 0, upd: 0;
       cbwGb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwGX_srtd" {
     ubwGX_srtd:
         const SbuCr_srt+456;
         const 52;
         const 3377699720527873;
 },
 _cbwGa() //  [R1]
         { info_tbl: [(cbwGa,
                       label: block_cbwGa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwGa: // global
           if (R1 & 7 == 1) goto cbwGD; else goto cbwGE;
       cbwGD: // global
           I64[Sp - 16] = block_cbwGf_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbwGE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwGY_srtd" {
     ubwGY_srtd:
         const SbuCr_srt+456;
         const 52;
         const 3377699720527873;
 },
 _cbwGf() //  [R1]
         { info_tbl: [(cbwGf,
                       label: block_cbwGf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwGf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwGM; else goto cbwGL;
       cbwGM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwGL: // global
           I64[Hp - 16] = io_sburM_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwGh::P64 = Hp - 15;
           if (R1 == 0) goto cbwGQ; else goto cbwGP;
       cbwGQ: // global
           R1 = _cbwGh::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwGP: // global
           R1 = _cbwGh::P64;
           Sp = Sp + 24;
           call io_sburM_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.363749318 UTC

[section ""data" . GHC.IO.Handle.hIsReadable_closure" {
     GHC.IO.Handle.hIsReadable_closure:
         const GHC.IO.Handle.hIsReadable_info;
         const 0;
 },
 GHC.IO.Handle.hIsReadable_entry() //  [R2]
         { info_tbl: [(cbwHL,
                       label: GHC.IO.Handle.hIsReadable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwHL: // global
           R2 = R2;
           call GHC.IO.Handle.hIsReadable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.367023811 UTC

[section ""cstring" . GHC.IO.Handle.hIsClosed4_bytes" {
     GHC.IO.Handle.hIsClosed4_bytes:
         I8[] [104,73,115,67,108,111,115,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.368813592 UTC

[section ""data" . GHC.IO.Handle.hIsClosed3_closure" {
     GHC.IO.Handle.hIsClosed3_closure:
         const GHC.IO.Handle.hIsClosed3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsClosed3_entry() //  [R1]
         { info_tbl: [(cbwHZ,
                       label: GHC.IO.Handle.hIsClosed3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwHZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwI0; else goto cbwI1;
       cbwI0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwI1: // global
           (_cbwHW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwHW::I64 == 0) goto cbwHY; else goto cbwHX;
       cbwHY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwHX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwHW::I64;
           R2 = GHC.IO.Handle.hIsClosed4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.373231234 UTC

[section ""data" . GHC.IO.Handle.hIsClosed2_closure" {
     GHC.IO.Handle.hIsClosed2_closure:
         const GHC.IO.Handle.hIsClosed2_info;
 },
 GHC.IO.Handle.hIsClosed2_entry() //  [R2]
         { info_tbl: [(cbwIh,
                       label: GHC.IO.Handle.hIsClosed2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwIh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwIi; else goto cbwIj;
       cbwIi: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsClosed2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwIj: // global
           I64[Sp - 8] = block_cbwIe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwIH; else goto cbwIf;
       ubwIH: // global
           call _cbwIe(R1) args: 0, res: 0, upd: 0;
       cbwIf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwIe() //  [R1]
         { info_tbl: [(cbwIe,
                       label: block_cbwIe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwIe: // global
           I64[Sp - 8] = block_cbwIm_info;
           _sbus1::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbus1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwIG; else goto cbwIo;
       ubwIG: // global
           call _cbwIm(R1) args: 0, res: 0, upd: 0;
       cbwIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwIm() //  [R1]
         { info_tbl: [(cbwIm,
                       label: block_cbwIm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwIm: // global
           _sbus1::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbwIB; else goto cbwIu;
       cbwIB: // global
           Hp = Hp + 24;
           _sbusi::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbwIE; else goto cbwID;
       cbwID: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbus1::P64;
           P64[Hp] = GHC.Types.True_closure+2;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbwIu: // global
           Hp = Hp + 24;
           _sbusi::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbwIE; else goto cbwIw;
       cbwIE: // global
           HpAlloc = 24;
           R1 = _sbusi::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwIw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbus1::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.382455563 UTC

[section ""data" . GHC.IO.Handle.hIsClosed1_closure" {
     GHC.IO.Handle.hIsClosed1_closure:
         const GHC.IO.Handle.hIsClosed1_info;
         const 0;
 },
 io_sbust_entry() //  [R1]
         { info_tbl: [(cbwJs,
                       label: io_sbust_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwJw; else goto cbwJx;
       cbwJw: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwJx: // global
           I64[Sp - 16] = block_cbwJn_info;
           _sbusp::P64 = P64[R1 + 15];
           R5 = _sbusp::P64;
           R4 = GHC.IO.Handle.hIsClosed2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsClosed3_closure;
           P64[Sp - 8] = _sbusp::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwJn() //  [R1]
         { info_tbl: [(cbwJn,
                       label: block_cbwJn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJn: // global
           I64[Sp] = block_cbwJp_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwJC; else goto cbwJq;
       ubwJC: // global
           call _cbwJp(R1) args: 0, res: 0, upd: 0;
       cbwJq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwJp() //  [R1]
         { info_tbl: [(cbwJp,
                       label: block_cbwJp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJp: // global
           I64[Sp] = block_cbwJv_info;
           R2 = P64[R1 + 7];
           _sbusA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbusA::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwJv() //  []
         { info_tbl: [(cbwJv,
                       label: block_cbwJv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbusJ_entry() //  [R1]
         { info_tbl: [(cbwJR,
                       label: io_sbusJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwJV; else goto cbwJW;
       cbwJV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwJW: // global
           I64[Sp - 16] = block_cbwJM_info;
           _sbusE::P64 = P64[R1 + 15];
           R5 = _sbusE::P64;
           R4 = GHC.IO.Handle.hIsClosed2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsClosed3_closure;
           P64[Sp - 8] = _sbusE::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwJM() //  [R1]
         { info_tbl: [(cbwJM,
                       label: block_cbwJM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJM: // global
           I64[Sp] = block_cbwJO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwK1; else goto cbwJP;
       ubwK1: // global
           call _cbwJO(R1) args: 0, res: 0, upd: 0;
       cbwJP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwJO() //  [R1]
         { info_tbl: [(cbwJO,
                       label: block_cbwJO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJO: // global
           I64[Sp] = block_cbwJU_info;
           R2 = P64[R1 + 7];
           _sbusQ::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbusQ::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwJU() //  []
         { info_tbl: [(cbwJU,
                       label: block_cbwJU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsClosed1_entry() //  [R2]
         { info_tbl: [(cbwK6,
                       label: GHC.IO.Handle.hIsClosed1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwK6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwK7; else goto cbwK8;
       cbwK7: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsClosed1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwK8: // global
           I64[Sp - 8] = block_cbwJb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwKp; else goto cbwJc;
       ubwKp: // global
           call _cbwJb(R1) args: 0, res: 0, upd: 0;
       cbwJc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwJb() //  [R1]
         { info_tbl: [(cbwJb,
                       label: block_cbwJb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJb: // global
           if (R1 & 7 == 1) goto cbwK3; else goto cbwK4;
       cbwK3: // global
           I64[Sp - 16] = block_cbwJg_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbwK4: // global
           I64[Sp - 16] = block_cbwJF_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbwJg() //  [R1]
         { info_tbl: [(cbwJg,
                       label: block_cbwJg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwKc; else goto cbwKb;
       cbwKc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwKb: // global
           I64[Hp - 16] = io_sbust_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwJi::P64 = Hp - 15;
           if (R1 == 0) goto cbwKg; else goto cbwKf;
       cbwKg: // global
           R1 = _cbwJi::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwKf: // global
           R1 = _cbwJi::P64;
           Sp = Sp + 24;
           call io_sbust_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbwJF() //  [R1]
         { info_tbl: [(cbwJF,
                       label: block_cbwJF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwJF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwKk; else goto cbwKj;
       cbwKk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwKj: // global
           I64[Hp - 16] = io_sbusJ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwJH::P64 = Hp - 15;
           if (R1 == 0) goto cbwKo; else goto cbwKn;
       cbwKo: // global
           R1 = _cbwJH::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwKn: // global
           R1 = _cbwJH::P64;
           Sp = Sp + 24;
           call io_sbusJ_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.406698003 UTC

[section ""data" . GHC.IO.Handle.hIsClosed_closure" {
     GHC.IO.Handle.hIsClosed_closure:
         const GHC.IO.Handle.hIsClosed_info;
         const 0;
 },
 GHC.IO.Handle.hIsClosed_entry() //  [R2]
         { info_tbl: [(cbwLw,
                       label: GHC.IO.Handle.hIsClosed_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwLw: // global
           R2 = R2;
           call GHC.IO.Handle.hIsClosed1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.409978421 UTC

[section ""cstring" . GHC.IO.Handle.hIsOpen4_bytes" {
     GHC.IO.Handle.hIsOpen4_bytes:
         I8[] [104,73,115,79,112,101,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.411807918 UTC

[section ""data" . GHC.IO.Handle.hIsOpen3_closure" {
     GHC.IO.Handle.hIsOpen3_closure:
         const GHC.IO.Handle.hIsOpen3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hIsOpen3_entry() //  [R1]
         { info_tbl: [(cbwLK,
                       label: GHC.IO.Handle.hIsOpen3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwLK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwLL; else goto cbwLM;
       cbwLL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwLM: // global
           (_cbwLH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwLH::I64 == 0) goto cbwLJ; else goto cbwLI;
       cbwLJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwLI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwLH::I64;
           R2 = GHC.IO.Handle.hIsOpen4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.416293298 UTC

[section ""data" . GHC.IO.Handle.hIsOpen2_closure" {
     GHC.IO.Handle.hIsOpen2_closure:
         const GHC.IO.Handle.hIsOpen2_info;
 },
 GHC.IO.Handle.hIsOpen2_entry() //  [R2]
         { info_tbl: [(cbwM2,
                       label: GHC.IO.Handle.hIsOpen2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwM2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwM3; else goto cbwM4;
       cbwM3: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsOpen2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwM4: // global
           I64[Sp - 8] = block_cbwLZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwMA; else goto cbwM0;
       ubwMA: // global
           call _cbwLZ(R1) args: 0, res: 0, upd: 0;
       cbwM0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwLZ() //  [R1]
         { info_tbl: [(cbwLZ,
                       label: block_cbwLZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwLZ: // global
           I64[Sp - 8] = block_cbwM7_info;
           _sbusV::P64 = R1;
           R1 = P64[R1 + 39];
           P64[Sp] = _sbusV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwMz; else goto cbwM9;
       ubwMz: // global
           call _cbwM7(R1) args: 0, res: 0, upd: 0;
       cbwM9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwM7() //  [R1]
         { info_tbl: [(cbwM7,
                       label: block_cbwM7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwM7: // global
           _sbusV::P64 = P64[Sp + 8];
           _cbwMx::P64 = R1 & 7;
           if (_cbwMx::P64 == 1) goto cbwMm; else goto ubwMy;
       cbwMm: // global
           Hp = Hp + 24;
           _sbutc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbwMw; else goto cbwMo;
       cbwMo: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbusV::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ubwMy: // global
           if (_cbwMx::P64 == 2) goto cbwMt; else goto cbwMf;
       cbwMt: // global
           Hp = Hp + 24;
           _sbutc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbwMw; else goto cbwMv;
       cbwMv: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbusV::P64;
           P64[Hp] = GHC.Types.False_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbwMf: // global
           Hp = Hp + 24;
           _sbutc::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbwMw; else goto cbwMh;
       cbwMw: // global
           HpAlloc = 24;
           R1 = _sbutc::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwMh: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbusV::P64;
           P64[Hp] = GHC.Types.True_closure+2;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.426770765 UTC

[section ""data" . GHC.IO.Handle.hIsOpen1_closure" {
     GHC.IO.Handle.hIsOpen1_closure:
         const GHC.IO.Handle.hIsOpen1_info;
         const 0;
 },
 io_sbuto_entry() //  [R1]
         { info_tbl: [(cbwNo,
                       label: io_sbuto_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwNs; else goto cbwNt;
       cbwNs: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwNt: // global
           I64[Sp - 16] = block_cbwNj_info;
           _sbutk::P64 = P64[R1 + 15];
           R5 = _sbutk::P64;
           R4 = GHC.IO.Handle.hIsOpen2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsOpen3_closure;
           P64[Sp - 8] = _sbutk::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwNj() //  [R1]
         { info_tbl: [(cbwNj,
                       label: block_cbwNj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNj: // global
           I64[Sp] = block_cbwNl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwNy; else goto cbwNm;
       ubwNy: // global
           call _cbwNl(R1) args: 0, res: 0, upd: 0;
       cbwNm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwNl() //  [R1]
         { info_tbl: [(cbwNl,
                       label: block_cbwNl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNl: // global
           I64[Sp] = block_cbwNr_info;
           R2 = P64[R1 + 7];
           _sbutv::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbutv::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwNr() //  []
         { info_tbl: [(cbwNr,
                       label: block_cbwNr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbutE_entry() //  [R1]
         { info_tbl: [(cbwNN,
                       label: io_sbutE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwNR; else goto cbwNS;
       cbwNR: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbwNS: // global
           I64[Sp - 16] = block_cbwNI_info;
           _sbutz::P64 = P64[R1 + 15];
           R5 = _sbutz::P64;
           R4 = GHC.IO.Handle.hIsOpen2_closure+2;
           R3 = P64[R1 + 7];
           R2 = GHC.IO.Handle.hIsOpen3_closure;
           P64[Sp - 8] = _sbutz::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwNI() //  [R1]
         { info_tbl: [(cbwNI,
                       label: block_cbwNI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNI: // global
           I64[Sp] = block_cbwNK_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwNX; else goto cbwNL;
       ubwNX: // global
           call _cbwNK(R1) args: 0, res: 0, upd: 0;
       cbwNL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwNK() //  [R1]
         { info_tbl: [(cbwNK,
                       label: block_cbwNK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNK: // global
           I64[Sp] = block_cbwNQ_info;
           R2 = P64[R1 + 7];
           _sbutL::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbutL::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwNQ() //  []
         { info_tbl: [(cbwNQ,
                       label: block_cbwNQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hIsOpen1_entry() //  [R2]
         { info_tbl: [(cbwO2,
                       label: GHC.IO.Handle.hIsOpen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwO2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbwO3; else goto cbwO4;
       cbwO3: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hIsOpen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwO4: // global
           I64[Sp - 8] = block_cbwN7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwOl; else goto cbwN8;
       ubwOl: // global
           call _cbwN7(R1) args: 0, res: 0, upd: 0;
       cbwN8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwN7() //  [R1]
         { info_tbl: [(cbwN7,
                       label: block_cbwN7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwN7: // global
           if (R1 & 7 == 1) goto cbwNZ; else goto cbwO0;
       cbwNZ: // global
           I64[Sp - 16] = block_cbwNc_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbwO0: // global
           I64[Sp - 16] = block_cbwNB_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbwNc() //  [R1]
         { info_tbl: [(cbwNc,
                       label: block_cbwNc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwO8; else goto cbwO7;
       cbwO8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwO7: // global
           I64[Hp - 16] = io_sbuto_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwNe::P64 = Hp - 15;
           if (R1 == 0) goto cbwOc; else goto cbwOb;
       cbwOc: // global
           R1 = _cbwNe::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwOb: // global
           R1 = _cbwNe::P64;
           Sp = Sp + 24;
           call io_sbuto_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbwNB() //  [R1]
         { info_tbl: [(cbwNB,
                       label: block_cbwNB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwNB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwOg; else goto cbwOf;
       cbwOg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbwOf: // global
           I64[Hp - 16] = io_sbutE_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbwND::P64 = Hp - 15;
           if (R1 == 0) goto cbwOk; else goto cbwOj;
       cbwOk: // global
           R1 = _cbwND::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbwOj: // global
           R1 = _cbwND::P64;
           Sp = Sp + 24;
           call io_sbutE_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.449968289 UTC

[section ""data" . GHC.IO.Handle.hIsOpen_closure" {
     GHC.IO.Handle.hIsOpen_closure:
         const GHC.IO.Handle.hIsOpen_info;
         const 0;
 },
 GHC.IO.Handle.hIsOpen_entry() //  [R2]
         { info_tbl: [(cbwPs,
                       label: GHC.IO.Handle.hIsOpen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwPs: // global
           R2 = R2;
           call GHC.IO.Handle.hIsOpen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.453460085 UTC

[section ""data" . GHC.IO.Handle.hGetPosn1_closure" {
     GHC.IO.Handle.hGetPosn1_closure:
         const GHC.IO.Handle.hGetPosn1_info;
         const 0;
 },
 GHC.IO.Handle.hGetPosn1_entry() //  [R2]
         { info_tbl: [(cbwPG,
                       label: GHC.IO.Handle.hGetPosn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwPG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwPH; else goto cbwPI;
       cbwPH: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hGetPosn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwPI: // global
           I64[Sp - 16] = block_cbwPD_info;
           R4 = GHC.IO.Handle.hGetPosn2_closure+2;
           R3 = R2;
           _sbutO::P64 = R2;
           R2 = GHC.IO.Handle.hGetPosn3_closure;
           P64[Sp - 8] = _sbutO::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantSeekableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwPD() //  [R1]
         { info_tbl: [(cbwPD,
                       label: block_cbwPD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwPD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwPL; else goto cbwPK;
       cbwPL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwPK: // global
           I64[Hp - 16] = GHC.IO.Handle.HandlePosn_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.459183508 UTC

[section ""data" . GHC.IO.Handle.hGetPosn_closure" {
     GHC.IO.Handle.hGetPosn_closure:
         const GHC.IO.Handle.hGetPosn_info;
         const 0;
 },
 GHC.IO.Handle.hGetPosn_entry() //  [R2]
         { info_tbl: [(cbwQ2,
                       label: GHC.IO.Handle.hGetPosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwQ2: // global
           R2 = R2;
           call GHC.IO.Handle.hGetPosn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.462898134 UTC

[section ""cstring" . GHC.IO.Handle.hClose3_bytes" {
     GHC.IO.Handle.hClose3_bytes:
         I8[] [104,67,108,111,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.464730662 UTC

[section ""data" . GHC.IO.Handle.hClose2_closure" {
     GHC.IO.Handle.hClose2_closure:
         const GHC.IO.Handle.hClose2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.Handle.hClose2_entry() //  [R1]
         { info_tbl: [(cbwQg,
                       label: GHC.IO.Handle.hClose2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwQg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwQh; else goto cbwQi;
       cbwQh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwQi: // global
           (_cbwQd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwQd::I64 == 0) goto cbwQf; else goto cbwQe;
       cbwQf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwQe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwQd::I64;
           R2 = GHC.IO.Handle.hClose3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.469572776 UTC

[section ""data" . GHC.IO.Handle.$wlvl_closure" {
     GHC.IO.Handle.$wlvl_closure:
         const GHC.IO.Handle.$wlvl_info;
         const 0;
 },
 sat_sbuu9_entry() //  [R1]
         { info_tbl: [(cbwQK,
                       label: sat_sbuu9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwQK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbwQL; else goto cbwQM;
       cbwQL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwQM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbwQD_info;
           _sbutU::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbutU::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubwRd; else goto cbwQE;
       ubwRd: // global
           call _cbwQD(R1) args: 0, res: 0, upd: 0;
       cbwQE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbwQD() //  [R1]
         { info_tbl: [(cbwQD,
                       label: block_cbwQD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwQD: // global
           if (R1 & 7 == 1) goto cbwQH; else goto cbwQI;
       cbwQH: // global
           _sbutU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbwQP_info;
           R1 = _sbutU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubwRc; else goto cbwQR;
       ubwRc: // global
           call _cbwQP(R1) args: 0, res: 0, upd: 0;
       cbwQR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbwQI: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _cbwQP() //  [R1]
         { info_tbl: [(cbwQP,
                       label: block_cbwQP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwQP: // global
           if (R1 & 7 == 1) goto cbwQX; else goto cbwR4;
       cbwQX: // global
           Hp = Hp + 16;
           _sbuu2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbwR7; else goto cbwQZ;
       cbwQZ: // global
           _sbuu3::P64 = P64[_sbuu2::P64 + 7];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbuu3::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbwR4: // global
           Hp = Hp + 16;
           _sbuu2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbwR7; else goto cbwR6;
       cbwR7: // global
           HpAlloc = 16;
           R1 = _sbuu2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbwR6: // global
           _sbuu5::P64 = P64[_sbuu2::P64 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbuu5::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbuub_entry() //  [R1]
         { info_tbl: [(cbwRg,
                       label: sat_sbuub_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwRg: // global
           _sbuub::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbwRh; else goto cbwRi;
       cbwRi: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cbwRk; else goto cbwRj;
       cbwRk: // global
           HpAlloc = 104;
           goto cbwRh;
       cbwRh: // global
           R1 = _sbuub::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwRj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbuub::P64;
           _sbutU::P64 = P64[_sbuub::P64 + 16];
           _sbutV::P64 = P64[_sbuub::P64 + 24];
           _sbutW::P64 = P64[_sbuub::P64 + 32];
           _sbutX::P64 = P64[_sbuub::P64 + 40];
           _sbutY::P64 = P64[_sbuub::P64 + 48];
           I64[Hp - 96] = sat_sbuu9_info;
           P64[Hp - 80] = _sbutU::P64;
           P64[Hp - 72] = _sbutY::P64;
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _sbutU::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = Hp - 62;
           P64[Hp - 32] = _sbutV::P64;
           P64[Hp - 24] = GHC.IO.Handle.hClose2_closure;
           P64[Hp - 16] = _sbutW::P64;
           P64[Hp - 8] = _sbutX::P64;
           P64[Hp] = Hp - 96;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.Handle.$wlvl_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbwRl,
                       label: GHC.IO.Handle.$wlvl_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwRl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbwRp; else goto cbwRo;
       cbwRp: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.$wlvl_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbwRo: // global
           I64[Hp - 48] = sat_sbuub_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.483922374 UTC

[section ""data" . GHC.IO.Handle.hClose1_closure" {
     GHC.IO.Handle.hClose1_closure:
         const GHC.IO.Handle.hClose1_info;
         const 0;
 },
 section ""relreadonly" . ubwU3_srtd" {
     ubwU3_srtd:
         const SbuCr_srt+240;
         const 94;
         const 54043195528445953;
         const 973078528;
 },
 GHC.IO.Handle.hClose1_entry() //  [R2]
         { info_tbl: [(cbwSg,
                       label: GHC.IO.Handle.hClose1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwSg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbwSh; else goto cbwSi;
       cbwSh: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hClose1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbwSi: // global
           I64[Sp - 8] = block_cbwS9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubwTX; else goto cbwSa;
       ubwTX: // global
           call _cbwS9(R1) args: 0, res: 0, upd: 0;
       cbwSa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwU4_srtd" {
     ubwU4_srtd:
         const SbuCr_srt+240;
         const 93;
         const 54043195528445953;
         const 436207616;
 },
 _cbwS9() //  [R1]
         { info_tbl: [(cbwS9,
                       label: block_cbwS9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwS9: // global
           if (R1 & 7 == 1) goto cbwSd; else goto cbwSe;
       cbwSd: // global
           I64[Sp - 8] = block_cbwSl_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[R1 + 15];
           R3 = R1;
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
       cbwSe: // global
           I64[Sp - 16] = block_cbwT4_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[R1 + 14];
           R3 = R1;
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwU5_srtd" {
     ubwU5_srtd:
         const SbuCr_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbwSl() //  [R1]
         { info_tbl: [(cbwSl,
                       label: block_cbwSl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwSl: // global
           I64[Sp] = block_cbwSn_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubwTY; else goto cbwSq;
       ubwTY: // global
           call _cbwSn(R1) args: 0, res: 0, upd: 0;
       cbwSq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwU6_srtd" {
     ubwU6_srtd:
         const SbuCr_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbwSn() //  [R1]
         { info_tbl: [(cbwSn,
                       label: block_cbwSn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwSn: // global
           if (R1 & 7 == 1) goto ubwTW; else goto cbwSG;
       ubwTW: // global
           Sp = Sp + 16;
           call _cbwTl() args: 0, res: 0, upd: 0;
       cbwSG: // global
           I64[Sp] = block_cbwSz_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubwTZ; else goto cbwSA;
       ubwTZ: // global
           call _cbwSz(R1) args: 0, res: 0, upd: 0;
       cbwSA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwU7_srtd" {
     ubwU7_srtd:
         const SbuCr_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbwSz() //  [R1]
         { info_tbl: [(cbwSz,
                       label: block_cbwSz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwSz: // global
           I64[Sp - 16] = block_cbwSE_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwU8_srtd" {
     ubwU8_srtd:
         const SbuCr_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbwSE() //  [R1]
         { info_tbl: [(cbwSE,
                       label: block_cbwSE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwSE: // global
           I64[Sp] = block_cbwSL_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwSL() //  [R1]
         { info_tbl: [(cbwSL,
                       label: block_cbwSL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwSL: // global
           if (R1 & 7 == 1) goto cbwSS; else goto cbwSX;
       cbwSS: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbwSX: // global
           I64[Sp + 16] = block_cbwSV_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwSV() //  [R1]
         { info_tbl: [(cbwSV,
                       label: block_cbwSV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwSV: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 39];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$wlvl_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwU9_srtd" {
     ubwU9_srtd:
         const SbuCr_srt+240;
         const 93;
         const 54043195528445953;
         const 436207616;
 },
 _cbwT4() //  [R1]
         { info_tbl: [(cbwT4,
                       label: block_cbwT4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwT4: // global
           I64[Sp] = block_cbwT6_info;
           R5 = GHC.IO.Handle.Internals.hClose_help1_closure+2;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = GHC.IO.Handle.hClose2_closure;
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.Internals.$wwithHandle'_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwUa_srtd" {
     ubwUa_srtd:
         const SbuCr_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbwT6() //  [R1]
         { info_tbl: [(cbwT6,
                       label: block_cbwT6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwT6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbwTf; else goto cbwTe;
       cbwTf: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbwTe: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 38;
           I64[Sp + 8] = block_cbwTa_info;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call Data.Maybe.catMaybes1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwUb_srtd" {
     ubwUb_srtd:
         const SbuCr_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbwTa() //  [R1]
         { info_tbl: [(cbwTa,
                       label: block_cbwTa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwTa: // global
           if (R1 & 7 == 1) goto ubwTV; else goto cbwTv;
       ubwTV: // global
           Sp = Sp + 16;
           call _cbwTl() args: 0, res: 0, upd: 0;
       cbwTv: // global
           I64[Sp] = block_cbwTo_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto ubwU1; else goto cbwTp;
       ubwU1: // global
           call _cbwTo(R1) args: 0, res: 0, upd: 0;
       cbwTp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwTl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwTl: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubwUc_srtd" {
     ubwUc_srtd:
         const SbuCr_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbwTo() //  [R1]
         { info_tbl: [(cbwTo,
                       label: block_cbwTo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwTo: // global
           I64[Sp - 16] = block_cbwTt_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . ubwUd_srtd" {
     ubwUd_srtd:
         const SbuCr_srt+240;
         const 93;
         const 1;
         const 402653184;
 },
 _cbwTt() //  [R1]
         { info_tbl: [(cbwTt,
                       label: block_cbwTt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwTt: // global
           I64[Sp] = block_cbwTA_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbwTA() //  [R1]
         { info_tbl: [(cbwTA,
                       label: block_cbwTA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwTA: // global
           if (R1 & 7 == 1) goto cbwTH; else goto cbwTM;
       cbwTH: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbwTM: // global
           I64[Sp + 16] = block_cbwTK_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbwTK() //  [R1]
         { info_tbl: [(cbwTK,
                       label: block_cbwTK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwTK: // global
           R6 = P64[R1 + 47];
           R5 = P64[R1 + 39];
           R4 = P64[R1 + 31];
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.Handle.$wlvl_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.520303516 UTC

[section ""data" . GHC.IO.Handle.hClose_closure" {
     GHC.IO.Handle.hClose_closure:
         const GHC.IO.Handle.hClose_info;
         const 0;
 },
 GHC.IO.Handle.hClose_entry() //  [R2]
         { info_tbl: [(cbwVW,
                       label: GHC.IO.Handle.hClose_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwVW: // global
           R2 = R2;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.523772192 UTC

[section ""data" . lvl28_rbnXa_closure" {
     lvl28_rbnXa_closure:
         const GHC.Types.C#_con_info;
         const 123;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.525414544 UTC

[section ""data" . lvl29_rbnXb_closure" {
     lvl29_rbnXb_closure:
         const GHC.Types.C#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.526902486 UTC

[section ""cstring" . lvl30_rbnXc_bytes" {
     lvl30_rbnXc_bytes:
         I8[] [100,117,112,108,101,120,32,40,114,101,97,100,45,119,114,105,116,101,41]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.528804214 UTC

[section ""data" . lvl31_rbnXd_closure" {
     lvl31_rbnXd_closure:
         const lvl31_rbnXd_info;
         const 0;
         const 0;
         const 0;
 },
 lvl31_rbnXd_entry() //  [R1]
         { info_tbl: [(cbwWc,
                       label: lvl31_rbnXd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwWc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwWd; else goto cbwWe;
       cbwWd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwWe: // global
           (_cbwW9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwW9::I64 == 0) goto cbwWb; else goto cbwWa;
       cbwWb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwWa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwW9::I64;
           R2 = lvl30_rbnXc_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.533440947 UTC

[section ""cstring" . lvl32_rbnXe_bytes" {
     lvl32_rbnXe_bytes:
         I8[] [110,111,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.535198668 UTC

[section ""data" . lvl33_rbnXf_closure" {
     lvl33_rbnXf_closure:
         const lvl33_rbnXf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl33_rbnXf_entry() //  [R1]
         { info_tbl: [(cbwWu,
                       label: lvl33_rbnXf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwWu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwWv; else goto cbwWw;
       cbwWv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwWw: // global
           (_cbwWr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwWr::I64 == 0) goto cbwWt; else goto cbwWs;
       cbwWt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwWs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwWr::I64;
           R2 = lvl32_rbnXe_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.539546359 UTC

[section ""cstring" . lvl34_rbnXg_bytes" {
     lvl34_rbnXg_bytes:
         I8[] [108,105,110,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.541438324 UTC

[section ""data" . lvl35_rbnXh_closure" {
     lvl35_rbnXh_closure:
         const lvl35_rbnXh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl35_rbnXh_entry() //  [R1]
         { info_tbl: [(cbwWM,
                       label: lvl35_rbnXh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwWM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwWN; else goto cbwWO;
       cbwWN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwWO: // global
           (_cbwWJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwWJ::I64 == 0) goto cbwWL; else goto cbwWK;
       cbwWL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwWK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwWJ::I64;
           R2 = lvl34_rbnXg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.545060603 UTC

[section ""cstring" . lvl36_rbnXi_bytes" {
     lvl36_rbnXi_bytes:
         I8[] [115,104,111,119,72,97,110,100,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.546918614 UTC

[section ""data" . lvl37_rbnXj_closure" {
     lvl37_rbnXj_closure:
         const lvl37_rbnXj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl37_rbnXj_entry() //  [R1]
         { info_tbl: [(cbwX4,
                       label: lvl37_rbnXj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwX4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwX5; else goto cbwX6;
       cbwX5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwX6: // global
           (_cbwX1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwX1::I64 == 0) goto cbwX3; else goto cbwX2;
       cbwX3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwX2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwX1::I64;
           R2 = lvl36_rbnXi_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.550626136 UTC

[section ""cstring" . lvl38_rbnXk_bytes" {
     lvl38_rbnXk_bytes:
         I8[] [108,111,99,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.552224237 UTC

[section ""cstring" . lvl39_rbnXl_bytes" {
     lvl39_rbnXl_bytes:
         I8[] [116,121,112,101,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.554256 UTC

[section ""cstring" . lvl40_rbnXm_bytes" {
     lvl40_rbnXm_bytes:
         I8[] [98,117,102,102,101,114,105,110,103,61]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.555784138 UTC

[section ""cstring" . lvl41_rbnXn_bytes" {
     lvl41_rbnXn_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.557648409 UTC

[section ""data" . lvl42_rbnXo_closure" {
     lvl42_rbnXo_closure:
         const lvl42_rbnXo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rbnXo_entry() //  [R1]
         { info_tbl: [(cbwXp,
                       label: lvl42_rbnXo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwXp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwXq; else goto cbwXr;
       cbwXq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwXr: // global
           (_cbwXm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwXm::I64 == 0) goto cbwXo; else goto cbwXn;
       cbwXo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwXn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwXm::I64;
           R2 = lvl41_rbnXn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.562398925 UTC

[section ""data" . lvl43_rbnXp_closure" {
     lvl43_rbnXp_closure:
         const lvl43_rbnXp_info;
         const 0;
         const 0;
         const 0;
 },
 lvl43_rbnXp_entry() //  [R1]
         { info_tbl: [(cbwXG,
                       label: lvl43_rbnXp_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwXG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwXH; else goto cbwXI;
       cbwXH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwXI: // global
           (_cbwXD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwXD::I64 == 0) goto cbwXF; else goto cbwXE;
       cbwXF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwXE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwXD::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = lvl33_rbnXf_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.566400735 UTC

[section ""data" . lvl44_rbnXq_closure" {
     lvl44_rbnXq_closure:
         const lvl44_rbnXq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rbnXq_entry() //  [R1]
         { info_tbl: [(cbwXX,
                       label: lvl44_rbnXq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwXX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwXY; else goto cbwXZ;
       cbwXY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwXZ: // global
           (_cbwXU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwXU::I64 == 0) goto cbwXW; else goto cbwXV;
       cbwXW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwXV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwXU::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = lvl35_rbnXh_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.570582428 UTC

[section ""cstring" . lvl45_rbnXr_bytes" {
     lvl45_rbnXr_bytes:
         I8[] [98,108,111,99,107,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.572151651 UTC

[section ""data" . lvl46_rbnXs_closure" {
     lvl46_rbnXs_closure:
         const :_con_info;
         const GHC.Show.$fShow(,)2_closure;
         const lvl42_rbnXo_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.574144412 UTC

[section ""data" . lvl47_rbnXt_closure" {
     lvl47_rbnXt_closure:
         const lvl47_rbnXt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl47_rbnXt_entry() //  [R1]
         { info_tbl: [(cbwYg,
                       label: lvl47_rbnXt_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbwYh; else goto cbwYi;
       cbwYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwYi: // global
           (_cbwYd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbwYd::I64 == 0) goto cbwYf; else goto cbwYe;
       cbwYf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbwYe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwYd::I64;
           R3 = lvl42_rbnXo_closure;
           R2 = GHC.IO.Handle.Types.$fShowHandleType11_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.584242007 UTC

[section ""data" . GHC.IO.Handle.hShow2_closure" {
     GHC.IO.Handle.hShow2_closure:
         const GHC.IO.Handle.hShow2_info;
         const 0;
 },
 sat_sbuvF_entry() //  [R1]
         { info_tbl: [(cbwZw,
                       label: sat_sbuvF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwZw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbwZC; else goto cbwZD;
       cbwZC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwZD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbwZo_info;
           P64[Sp - 24] = P64[R1 + 16];
           Sp = Sp - 32;
           call stg_noDuplicate#() args: 8, res: 8, upd: 24;
     }
 },
 _cbwZo() //  []
         { info_tbl: [(cbwZo,
                       label: block_cbwZo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwZo: // global
           _sbuvu::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp + 8] = block_cbwZt_info;
           R1 = _sbuvu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubwZK; else goto cbwZu;
       ubwZK: // global
           call _cbwZt(R1) args: 0, res: 0, upd: 0;
       cbwZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbwZt() //  [R1]
         { info_tbl: [(cbwZt,
                       label: block_cbwZt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwZt: // global
           I64[Sp] = block_cbwZz_info;
           R4 = lvl46_rbnXs_closure+2;
           R3 = I64[R1 + 31];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbwZz() //  [R1, R2]
         { info_tbl: [(cbwZz,
                       label: block_cbwZz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwZz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbwZJ; else goto cbwZI;
       cbwZJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbwZI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbuvN_entry() //  [R1]
         { info_tbl: [(cbwZU,
                       label: sat_sbuvN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwZU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbx00; else goto cbx01;
       cbx00: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbx01: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbwZR_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubx06; else goto cbwZS;
       ubx06: // global
           call _cbwZR(R1) args: 0, res: 0, upd: 0;
       cbwZS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbwZR() //  [R1]
         { info_tbl: [(cbwZR,
                       label: block_cbwZR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwZR: // global
           I64[Sp] = block_cbwZX_info;
           R4 = lvl46_rbnXs_closure+2;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbwZX() //  [R1, R2]
         { info_tbl: [(cbwZX,
                       label: block_cbwZX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwZX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbx05; else goto cbx04;
       cbx05: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbx04: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbuvP_entry() //  [R1]
         { info_tbl: [(cbx0c,
                       label: sat_sbuvP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx0c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbx0d; else goto cbx0e;
       cbx0d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbx0e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbwZ8_info;
           _sbuve::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbuve::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubx0y; else goto cbwZ9;
       ubx0y: // global
           call _cbwZ8(R1) args: 0, res: 0, upd: 0;
       cbwZ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbwZ8() //  [R1]
         { info_tbl: [(cbwZ8,
                       label: block_cbwZ8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwZ8: // global
           _cbx0b::P64 = R1 & 7;
           if (_cbx0b::P64 < 3) goto ubx0w; else goto cbx0a;
       ubx0w: // global
           if (_cbx0b::P64 < 2) goto cbx08; else goto cbx09;
       cbx08: // global
           R1 = lvl43_rbnXp_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbx09: // global
           R1 = lvl44_rbnXq_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbx0a: // global
           I64[Sp] = block_cbwZf_info;
           R1 = P64[R1 + 5];
           if (R1 & 7 != 0) goto ubx0x; else goto cbwZg;
       ubx0x: // global
           call _cbwZf(R1) args: 0, res: 0, upd: 0;
       cbwZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbwZf() //  [R1]
         { info_tbl: [(cbwZf,
                       label: block_cbwZf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwZf: // global
           if (R1 & 7 == 1) goto cbx0m; else goto cbx0r;
       cbx0m: // global
           Hp = Hp + 48;
           _sbuvq::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbx0u; else goto cbx0o;
       cbx0o: // global
           I64[Hp - 40] = sat_sbuvF_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = lvl45_rbnXr_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cbx0r: // global
           Hp = Hp + 48;
           _sbuvq::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbx0u; else goto cbx0t;
       cbx0u: // global
           HpAlloc = 48;
           R1 = _sbuvq::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbx0t: // global
           _sbuvH::P64 = P64[_sbuvq::P64 + 6];
           I64[Hp - 40] = sat_sbuvN_info;
           P64[Hp - 24] = _sbuvH::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = lvl45_rbnXr_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 karg_sbuvn_entry() //  [R1]
         { info_tbl: [(cbx0z,
                       label: karg_sbuvn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx0z: // global
           _sbuvn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbx0A; else goto cbx0B;
       cbx0B: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbx0D; else goto cbx0C;
       cbx0D: // global
           HpAlloc = 32;
           goto cbx0A;
       cbx0A: // global
           R1 = _sbuvn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbx0C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbuvn::P64;
           _sbuvc::P64 = P64[_sbuvn::P64 + 16];
           _sbuve::P64 = P64[_sbuvn::P64 + 24];
           I64[Hp - 24] = sat_sbuvP_info;
           P64[Hp - 8] = _sbuvc::P64;
           P64[Hp] = _sbuve::P64;
           R3 = Hp - 24;
           R2 = lvl40_rbnXm_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbuvY_entry() //  [R1]
         { info_tbl: [(cbx0L,
                       label: sat_sbuvY_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx0L: // global
           _sbuvY::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cbx0M; else goto cbx0N;
       cbx0N: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbx0P; else goto cbx0O;
       cbx0P: // global
           HpAlloc = 32;
           goto cbx0M;
       cbx0M: // global
           R1 = _sbuvY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbx0O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbuvY::P64;
           _sbuuZ::P64 = P64[_sbuvY::P64 + 16];
           _sbuvc::P64 = P64[_sbuvY::P64 + 24];
           _sbuve::P64 = P64[_sbuvY::P64 + 32];
           _sbuvm::P64 = P64[_sbuvY::P64 + 40];
           I64[Hp - 24] = karg_sbuvn_info;
           P64[Hp - 8] = _sbuvc::P64;
           P64[Hp] = _sbuve::P64;
           I64[Sp - 40] = block_cbx0E_info;
           R1 = _sbuuZ::P64;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = _sbuvm::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubx1H; else goto cbx0F;
       ubx1H: // global
           call _cbx0E(R1) args: 0, res: 0, upd: 0;
       cbx0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbx0E() //  [R1]
         { info_tbl: [(cbx0E,
                       label: block_cbx0E_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx0E: // global
           if (R1 & 7 == 1) goto cbx0I; else goto cbx0J;
       cbx0I: // global
           I64[Sp] = block_cbx0S_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto ubx1G; else goto cbx0U;
       ubx1G: // global
           call _cbx0S(R1) args: 0, res: 0, upd: 0;
       cbx0U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
       cbx0J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbx1B; else goto cbx1A;
       cbx1B: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbx1A: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 14;
           R2 = lvl31_rbnXd_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 _cbx0S() //  [R1]
         { info_tbl: [(cbx0S,
                       label: block_cbx0S_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx0S: // global
           _cbwZ0::P64 = P64[Sp + 8];
           _cbx1C::P64 = R1 & 7;
           if (_cbx1C::P64 < 5) goto ubx1D; else goto ubx1F;
       ubx1D: // global
           if (_cbx1C::P64 < 4) goto ubx1E; else goto cbx1e;
       ubx1E: // global
           if (_cbx1C::P64 < 3) goto cbx10; else goto cbx17;
       cbx10: // global
           Hp = Hp + 24;
           _sbuvR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbx1v; else goto cbx12;
       cbx12: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbwZ0::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType9_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbx17: // global
           Hp = Hp + 24;
           _sbuvR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbx1v; else goto cbx19;
       cbx19: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbwZ0::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType7_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbx1e: // global
           Hp = Hp + 24;
           _sbuvR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbx1v; else goto cbx1g;
       cbx1g: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbwZ0::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType5_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       ubx1F: // global
           if (_cbx1C::P64 < 6) goto cbx1l; else goto cbx1s;
       cbx1l: // global
           Hp = Hp + 24;
           _sbuvR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbx1v; else goto cbx1n;
       cbx1n: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbwZ0::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType3_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbx1s: // global
           Hp = Hp + 24;
           _sbuvR::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbx1v; else goto cbx1u;
       cbx1v: // global
           HpAlloc = 24;
           R1 = _sbuvR::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbx1u: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = _cbwZ0::P64;
           R3 = Hp - 14;
           R2 = GHC.IO.Handle.Types.$fShowHandleType1_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbuvZ_entry() //  [R1]
         { info_tbl: [(cbx1I,
                       label: sat_sbuvZ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx1I: // global
           _sbuvZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbx1J; else goto cbx1K;
       cbx1K: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbx1M; else goto cbx1L;
       cbx1M: // global
           HpAlloc = 48;
           goto cbx1J;
       cbx1J: // global
           R1 = _sbuvZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbx1L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbuvZ::P64;
           _sbuuZ::P64 = P64[_sbuvZ::P64 + 16];
           _sbuvc::P64 = P64[_sbuvZ::P64 + 24];
           _sbuve::P64 = P64[_sbuvZ::P64 + 32];
           _sbuvm::P64 = P64[_sbuvZ::P64 + 40];
           I64[Hp - 40] = sat_sbuvY_info;
           P64[Hp - 24] = _sbuuZ::P64;
           P64[Hp - 16] = _sbuvc::P64;
           P64[Hp - 8] = _sbuve::P64;
           P64[Hp] = _sbuvm::P64;
           R3 = Hp - 40;
           R2 = lvl39_rbnXl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbuw1_entry() //  [R1]
         { info_tbl: [(cbx1O,
                       label: sat_sbuw1_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx1O: // global
           _sbuw1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbx1P; else goto cbx1Q;
       cbx1Q: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbx1S; else goto cbx1R;
       cbx1S: // global
           HpAlloc = 72;
           goto cbx1P;
       cbx1P: // global
           R1 = _sbuw1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbx1R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbuw1::P64;
           _sbuuY::P64 = P64[_sbuw1::P64 + 16];
           _sbuuZ::P64 = P64[_sbuw1::P64 + 24];
           _sbuvc::P64 = P64[_sbuw1::P64 + 32];
           _sbuve::P64 = P64[_sbuw1::P64 + 40];
           _sbuvm::P64 = P64[_sbuw1::P64 + 48];
           I64[Hp - 64] = sat_sbuvZ_info;
           P64[Hp - 48] = _sbuuZ::P64;
           P64[Hp - 40] = _sbuvc::P64;
           P64[Hp - 32] = _sbuve::P64;
           P64[Hp - 24] = _sbuvm::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl29_rbnXb_closure+1;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _sbuuY::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbuw2_entry() //  [R1]
         { info_tbl: [(cbx1T,
                       label: sat_sbuw2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx1T: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbx1U; else goto cbx1V;
       cbx1U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbx1V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbwYE_info;
           _sbuuY::P64 = P64[R1 + 16];
           _sbuuZ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbuuY::P64;
           P64[Sp - 24] = _sbuuZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubx28; else goto cbwYF;
       ubx28: // global
           call _cbwYE(R1) args: 0, res: 0, upd: 0;
       cbwYF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbwYE() //  [R1]
         { info_tbl: [(cbwYE,
                       label: block_cbwYE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwYE: // global
           I64[Sp - 16] = block_cbwYJ_info;
           _sbuvc::P64 = P64[R1 + 55];
           _sbuve::P64 = P64[R1 + 71];
           R1 = P64[R1 + 39];
           P64[Sp - 8] = _sbuve::P64;
           P64[Sp] = _sbuvc::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubx27; else goto cbwYK;
       ubx27: // global
           call _cbwYJ(R1) args: 0, res: 0, upd: 0;
       cbwYK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbwYJ() //  [R1]
         { info_tbl: [(cbwYJ,
                       label: block_cbwYJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbwYJ: // global
           if (R1 & 7 == 1) goto cbx25; else goto cbx1Y;
       cbx25: // global
           R1 = lvl47_rbnXt_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbx1Y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbx21; else goto cbx20;
       cbx21: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbx20: // global
           I64[Hp - 48] = sat_sbuw1_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R3 = Hp - 48;
           R2 = lvl38_rbnXk_bytes;
           Sp = Sp + 40;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 act_sbuv2_entry() //  [R1, R2]
         { info_tbl: [(cbx2a,
                       label: act_sbuv2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2a: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbx2e; else goto cbx2d;
       cbx2e: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbx2d: // global
           _sbuuY::P64 = P64[R1 + 6];
           _sbuuZ::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sbuw2_info;
           P64[Hp - 40] = _sbuuY::P64;
           P64[Hp - 32] = _sbuuZ::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl28_rbnXa_closure+1;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbuwi_entry() //  [R1, R2]
         { info_tbl: [(cbx2z,
                       label: sat_sbuwi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbx2A; else goto cbx2B;
       cbx2A: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbx2B: // global
           I64[Sp - 16] = block_cbx2w_info;
           _sbuwc::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbuwc::P64;
           Sp = Sp - 16;
           call act_sbuv2_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbx2w() //  [R1]
         { info_tbl: [(cbx2w,
                       label: block_cbx2w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbx2E; else goto cbx2D;
       cbx2E: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbx2D: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbuwa_entry() //  [R1]
         { info_tbl: [(cbx2K,
                       label: io_sbuwa_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2K: // global
           _sbuwa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbx2O; else goto cbx2P;
       cbx2P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbx2R; else goto cbx2Q;
       cbx2R: // global
           HpAlloc = 16;
           goto cbx2O;
       cbx2O: // global
           R1 = _sbuwa::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbx2Q: // global
           _sbuv2::P64 = P64[_sbuwa::P64 + 7];
           _sbuw4::P64 = P64[_sbuwa::P64 + 15];
           _sbuw6::P64 = P64[_sbuwa::P64 + 23];
           I64[Hp - 8] = sat_sbuwi_info;
           P64[Hp] = _sbuv2::P64;
           I64[Sp - 16] = block_cbx2F_info;
           R5 = _sbuw6::P64;
           R4 = Hp - 6;
           R3 = _sbuw4::P64;
           R2 = lvl37_rbnXj_closure;
           P64[Sp - 8] = _sbuw6::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbx2F() //  [R1]
         { info_tbl: [(cbx2F,
                       label: block_cbx2F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2F: // global
           I64[Sp] = block_cbx2H_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubx2W; else goto cbx2I;
       ubx2W: // global
           call _cbx2H(R1) args: 0, res: 0, upd: 0;
       cbx2I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbx2H() //  [R1]
         { info_tbl: [(cbx2H,
                       label: block_cbx2H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2H: // global
           I64[Sp] = block_cbx2N_info;
           R2 = P64[R1 + 7];
           _sbuwo::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbuwo::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbx2N() //  []
         { info_tbl: [(cbx2N,
                       label: block_cbx2N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2N: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbuwF_entry() //  [R1, R2]
         { info_tbl: [(cbx3e,
                       label: sat_sbuwF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx3e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbx3f; else goto cbx3g;
       cbx3f: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbx3g: // global
           I64[Sp - 16] = block_cbx3b_info;
           _sbuwz::P64 = R2;
           R2 = R2;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sbuwz::P64;
           Sp = Sp - 16;
           call act_sbuv2_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbx3b() //  [R1]
         { info_tbl: [(cbx3b,
                       label: block_cbx3b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx3b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbx3j; else goto cbx3i;
       cbx3j: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbx3i: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sbuwx_entry() //  [R1]
         { info_tbl: [(cbx3p,
                       label: io_sbuwx_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx3p: // global
           _sbuwx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbx3t; else goto cbx3u;
       cbx3u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbx3w; else goto cbx3v;
       cbx3w: // global
           HpAlloc = 16;
           goto cbx3t;
       cbx3t: // global
           R1 = _sbuwx::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbx3v: // global
           _sbuv2::P64 = P64[_sbuwx::P64 + 7];
           _sbuw4::P64 = P64[_sbuwx::P64 + 15];
           _sbuws::P64 = P64[_sbuwx::P64 + 23];
           I64[Hp - 8] = sat_sbuwF_info;
           P64[Hp] = _sbuv2::P64;
           I64[Sp - 16] = block_cbx3k_info;
           R5 = _sbuws::P64;
           R4 = Hp - 6;
           R3 = _sbuw4::P64;
           R2 = lvl37_rbnXj_closure;
           P64[Sp - 8] = _sbuws::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.$wdo_operation_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbx3k() //  [R1]
         { info_tbl: [(cbx3k,
                       label: block_cbx3k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx3k: // global
           I64[Sp] = block_cbx3m_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubx3B; else goto cbx3n;
       ubx3B: // global
           call _cbx3m(R1) args: 0, res: 0, upd: 0;
       cbx3n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbx3m() //  [R1]
         { info_tbl: [(cbx3m,
                       label: block_cbx3m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx3m: // global
           I64[Sp] = block_cbx3s_info;
           R2 = P64[R1 + 7];
           _sbuwL::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbuwL::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbx3s() //  []
         { info_tbl: [(cbx3s,
                       label: block_cbx3s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx3s: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.Handle.hShow2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbx3G,
                       label: GHC.IO.Handle.hShow2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx3G: // global
           _sbuv0::P64 = R4;
           _sbuuZ::P64 = R3;
           _sbuuY::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbx3H; else goto cbx3I;
       cbx3I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbx3K; else goto cbx3J;
       cbx3K: // global
           HpAlloc = 24;
           goto cbx3H;
       cbx3H: // global
           R4 = _sbuv0::P64;
           R3 = _sbuuZ::P64;
           R2 = _sbuuY::P64;
           R1 = GHC.IO.Handle.hShow2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbx3J: // global
           I64[Hp - 16] = act_sbuv2_info;
           P64[Hp - 8] = _sbuuY::P64;
           P64[Hp] = _sbuuZ::P64;
           I64[Sp - 16] = block_cbx2f_info;
           R1 = _sbuv0::P64;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubx41; else goto cbx2g;
       ubx41: // global
           call _cbx2f(R1) args: 0, res: 0, upd: 0;
       cbx2g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbx2f() //  [R1]
         { info_tbl: [(cbx2f,
                       label: block_cbx2f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2f: // global
           if (R1 & 7 == 1) goto cbx3D; else goto cbx3E;
       cbx3D: // global
           I64[Sp - 16] = block_cbx2k_info;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
       cbx3E: // global
           I64[Sp - 16] = block_cbx2Z_info;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbx2k() //  [R1]
         { info_tbl: [(cbx2k,
                       label: block_cbx2k_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2k: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbx3O; else goto cbx3N;
       cbx3O: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbx3N: // global
           I64[Hp - 24] = io_sbuwa_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbx2m::P64 = Hp - 23;
           if (R1 == 0) goto cbx3S; else goto cbx3R;
       cbx3S: // global
           R1 = _cbx2m::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbx3R: // global
           R1 = _cbx2m::P64;
           Sp = Sp + 32;
           call io_sbuwa_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbx2Z() //  [R1]
         { info_tbl: [(cbx2Z,
                       label: block_cbx2Z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx2Z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbx3W; else goto cbx3V;
       cbx3W: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbx3V: // global
           I64[Hp - 24] = io_sbuwx_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           _cbx31::P64 = Hp - 23;
           if (R1 == 0) goto cbx40; else goto cbx3Z;
       cbx40: // global
           R1 = _cbx31::P64;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       cbx3Z: // global
           R1 = _cbx31::P64;
           Sp = Sp + 32;
           call io_sbuwx_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.664559945 UTC

[section ""data" . GHC.IO.Handle.hShow1_closure" {
     GHC.IO.Handle.hShow1_closure:
         const GHC.IO.Handle.hShow1_info;
         const 0;
 },
 GHC.IO.Handle.hShow1_entry() //  [R2]
         { info_tbl: [(cbx89,
                       label: GHC.IO.Handle.hShow1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx89: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbx8a; else goto cbx8b;
       cbx8a: // global
           R2 = R2;
           R1 = GHC.IO.Handle.hShow1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbx8b: // global
           I64[Sp - 8] = block_cbx82_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubx8i; else goto cbx83;
       ubx8i: // global
           call _cbx82(R1) args: 0, res: 0, upd: 0;
       cbx83: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbx82() //  [R1]
         { info_tbl: [(cbx82,
                       label: block_cbx82_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx82: // global
           if (R1 & 7 == 1) goto cbx86; else goto cbx87;
       cbx86: // global
           R4 = R1;
           R3 = GHC.Types.False_closure+1;
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.IO.Handle.hShow2_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
       cbx87: // global
           R4 = R1;
           R3 = GHC.Types.True_closure+2;
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.IO.Handle.hShow2_entry(R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.670604429 UTC

[section ""data" . GHC.IO.Handle.hShow_closure" {
     GHC.IO.Handle.hShow_closure:
         const GHC.IO.Handle.hShow_info;
         const 0;
 },
 GHC.IO.Handle.hShow_entry() //  [R2]
         { info_tbl: [(cbx8B,
                       label: GHC.IO.Handle.hShow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx8B: // global
           R2 = R2;
           call GHC.IO.Handle.hShow1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.673950559 UTC

[section ""data" . GHC.IO.Handle.HandlePosn_closure" {
     GHC.IO.Handle.HandlePosn_closure:
         const GHC.IO.Handle.HandlePosn_info;
 },
 GHC.IO.Handle.HandlePosn_entry() //  [R2, R3]
         { info_tbl: [(cbx8N,
                       label: GHC.IO.Handle.HandlePosn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx8N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbx8R; else goto cbx8Q;
       cbx8R: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.Handle.HandlePosn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbx8Q: // global
           I64[Hp - 16] = GHC.IO.Handle.HandlePosn_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.677926531 UTC

[GHC.IO.Handle.HandlePosn_con_entry() //  [R1]
         { info_tbl: [(cbx8Y,
                       label: GHC.IO.Handle.HandlePosn_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,72,97,110,100,108,101,46,72,97,110,100,108,101,80,111,115,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbx8Y: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:29.680948424 UTC

[section ""relreadonly" . SbuCr_srt" {
     SbuCr_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.IO.Handle.$w$cshowsPrec_closure;
         const GHC.IO.Handle.$fShowHandlePosn_$cshowsPrec_closure;
         const GHC.IO.Handle.$fShowHandlePosn_$cshow_closure;
         const GHC.IO.Handle.$fShowHandlePosn1_closure;
         const GHC.IO.Handle.Internals.hLookAhead_1_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.hLookAhead2_closure;
         const GHC.IO.Handle.hLookAhead1_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.hFlush2_closure;
         const GHC.IO.Handle.hFlush1_closure;
         const GHC.IO.Handle.Internals.flushBuffer1_closure;
         const GHC.IO.Handle.hFlushAll2_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hFlushAll3_closure;
         const GHC.IO.Handle.hFlushAll1_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hGetEcho6_closure;
         const GHC.IO.Handle.hGetEcho_fun_closure;
         const GHC.IO.Handle.hGetEcho5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl1_rbnWC_closure;
         const lvl3_rbnWE_closure;
         const ioe_dupHandlesNotCompatible_rbnWF_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.Handle.Internals.mkDuplexHandle5_closure;
         const dupHandle__rbnWK_closure;
         const GHC.IO.failIO1_closure;
         const lvl5_rbnWM_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const dupHandleTo_rbnWN_closure;
         const GHC.IO.Handle.Internals.withAllHandles__1_closure;
         const GHC.IO.Handle.$whSetNewlineMode_closure;
         const GHC.IO.Handle.hSetNewlineMode2_closure;
         const GHC.IO.Handle.hSetNewlineMode1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.Handle.Internals.flushCharBuffer2_closure;
         const lvl11_rbnWT_closure;
         const GHC.IO.Handle.hSetBinaryMode1_closure;
         const lvl9_rbnWR_closure;
         const GHC.IO.Handle.Internals.ioe_semiclosedHandle1_closure;
         const GHC.IO.Handle.hIsSeekable2_closure;
         const GHC.IO.Handle.hIsSeekable3_closure;
         const GHC.IO.Handle.hIsSeekable1_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.IO.Handle.hGetPosn2_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.hGetPosn3_closure;
         const GHC.IO.Handle.hTell1_closure;
         const lvl14_rbnWW_closure;
         const GHC.IO.Handle.Internals.flushBuffer2_closure;
         const GHC.IO.Handle.hSeek1_closure;
         const lvl13_rbnWV_closure;
         const GHC.IO.Handle.hSetPosn1_closure;
         const GHC.IO.Handle.hGetEncoding3_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hGetEncoding1_closure;
         const lvl18_rbnX0_closure;
         const GHC.IO.Handle.hSetEncoding1_closure;
         const lvl16_rbnWY_closure;
         const GHC.IO.Handle.Internals.$wioe_bufsiz_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hSetBuffering1_closure;
         const GHC.IO.Handle.hSetBuffering2_closure;
         const GHC.IO.Handle.hIsEOF3_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.hIsEOF1_closure;
         const GHC.IO.Handle.FD.stdin_closure;
         const GHC.IO.Handle.isEOF1_closure;
         const lvl20_rbnX2_closure;
         const GHC.IO.Handle.hSetFileSize1_closure;
         const GHC.IO.Handle.hFileSize5_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const sat_sbuif_closure;
         const GHC.IO.Handle.hFileSize3_closure;
         const GHC.IO.Handle.hFileSize4_closure;
         const GHC.IO.Handle.hFileSize10_closure;
         const GHC.IO.Handle.hFileSize2_closure;
         const GHC.IO.Handle.hFileSize8_closure;
         const GHC.IO.Handle.hFileSize1_closure;
         const lvl21_rbnX3_closure;
         const dupHandleTo_rbnWN_closure;
         const GHC.IO.Handle.Internals.hClose_help1_closure;
         const GHC.IO.Handle.Internals.$wwithHandle'_closure;
         const GHC.IO.Handle.Internals.$wwithHandle__'_closure;
         const GHC.IO.Handle.hDuplicateTo1_closure;
         const lvl25_rbnX7_closure;
         const GHC.IO.failIO1_closure;
         const lvl27_rbnX9_closure;
         const dupHandle__rbnWK_closure;
         const lvl7_rbnWP_closure;
         const GHC.IO.Handle.hDuplicate1_closure;
         const lvl23_rbnX5_closure;
         const GHC.IO.Handle.hGetEcho2_closure;
         const GHC.IO.Handle.Internals.ioe_closedHandle1_closure;
         const GHC.IO.Handle.hGetEcho3_closure;
         const GHC.IO.Handle.hGetEcho1_closure;
         const GHC.IO.Handle.hSetEcho2_closure;
         const GHC.IO.Handle.hSetEcho1_closure;
         const GHC.IO.Handle.hGetBuffering2_closure;
         const GHC.IO.Handle.hGetBuffering_fun_closure;
         const GHC.IO.Handle.hGetBuffering1_closure;
         const GHC.IO.Handle.hIsWritable2_closure;
         const GHC.IO.Handle.hIsWritable3_closure;
         const GHC.IO.Handle.hIsWritable1_closure;
         const GHC.IO.Handle.hIsReadable2_closure;
         const GHC.IO.Handle.hIsReadable3_closure;
         const GHC.IO.Handle.hIsReadable1_closure;
         const GHC.IO.Handle.hIsClosed3_closure;
         const GHC.IO.Handle.Internals.$wdo_operation_closure;
         const GHC.IO.Handle.hIsClosed1_closure;
         const GHC.IO.Handle.hIsOpen3_closure;
         const GHC.IO.Handle.hIsOpen1_closure;
         const GHC.IO.Handle.hGetPosn1_closure;
         const GHC.IO.Handle.hGetPosn3_closure;
         const GHC.IO.Handle.Internals.wantSeekableHandle1_closure;
         const GHC.IO.Handle.hGetPosn2_closure;
         const GHC.IO.Handle.hClose2_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.IO.Handle.$wlvl_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.IO.Handle.hClose1_closure;
         const lvl33_rbnXf_closure;
         const lvl42_rbnXo_closure;
         const lvl35_rbnXh_closure;
         const GHC.IO.Handle.Types.$fShowHandleType11_closure;
         const lvl46_rbnXs_closure;
         const lvl43_rbnXp_closure;
         const lvl44_rbnXq_closure;
         const GHC.IO.Handle.Types.$fShowHandleType1_closure;
         const GHC.IO.Handle.Types.$fShowHandleType3_closure;
         const GHC.IO.Handle.Types.$fShowHandleType5_closure;
         const GHC.IO.Handle.Types.$fShowHandleType7_closure;
         const GHC.IO.Handle.Types.$fShowHandleType9_closure;
         const lvl31_rbnXd_closure;
         const lvl47_rbnXt_closure;
         const lvl37_rbnXj_closure;
         const GHC.IO.Handle.hShow2_closure;
         const GHC.IO.Handle.hShow1_closure;
 }]

